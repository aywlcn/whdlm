; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	D:\qijianban\laok\服务端\游戏组件\老K子游戏\红中麻将\服务器组件\GameLogic.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_cbCardDataArray@CGameLogic@@1QBEB		; CGameLogic::m_cbCardDataArray
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	__pAtlLocaleNameToIndexTable
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?CLSID_ImageOle@@3U_GUID@@A			; CLSID_ImageOle
PUBLIC	?IID_IImageOle@@3U_GUID@@A			; IID_IImageOle
PUBLIC	?IID_IRichEditOleCallback2@@3U_GUID@@A		; IID_IRichEditOleCallback2
PUBLIC	?CLSID_WinFormsControl@@3U_GUID@@B		; CLSID_WinFormsControl
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	__pIncludeInitManaged
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	_LIBID_ShockwaveFlashObjects
PUBLIC	_IID_IShockwaveFlash
PUBLIC	_DIID__IShockwaveFlashEvents
PUBLIC	_CLSID_ShockwaveFlash
PUBLIC	?szInvalidDateTime@ATL@@3QB_WB			; ATL::szInvalidDateTime
PUBLIC	_IID_IFlashFactory
PUBLIC	_IID_IDispatchEx
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QB_WB		; ATL::szInvalidDateTimeSpan
PUBLIC	_IID_IFlashObjectInterface
PUBLIC	_CLSID_FlashObjectInterface
PUBLIC	_LIBID_ATLLib
PUBLIC	_CLSID_Registrar
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	_IID_IRegistrar
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	__pAtlLcidToLocaleNameTable
PUBLIC	?_AfxInitManaged@@YAHXZ				; _AfxInitManaged
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?m_bInit@CChiHuRight@@0_NA			; CChiHuRight::m_bInit
PUBLIC	?m_dwRightMask@CChiHuRight@@0PAKA		; CChiHuRight::m_dwRightMask
_BSS	SEGMENT
?GenericSansSerifFontFamily@Gdiplus@@3PAVFontFamily@1@A DD 01H DUP (?) ; Gdiplus::GenericSansSerifFontFamily
?GenericSerifFontFamily@Gdiplus@@3PAVFontFamily@1@A DD 01H DUP (?) ; Gdiplus::GenericSerifFontFamily
?GenericMonospaceFontFamily@Gdiplus@@3PAVFontFamily@1@A DD 01H DUP (?) ; Gdiplus::GenericMonospaceFontFamily
?GenericSansSerifFontFamilyBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericSansSerifFontFamilyBuffer
?GenericSerifFontFamilyBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericSerifFontFamilyBuffer
?GenericMonospaceFontFamilyBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericMonospaceFontFamilyBuffer
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
_BSS	SEGMENT
?GenericTypographicStringFormatBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericTypographicStringFormatBuffer
?GenericDefaultStringFormatBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericDefaultStringFormatBuffer
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
_BSS	SEGMENT
?m_bInit@CChiHuRight@@0_NA DB 01H DUP (?)		; CChiHuRight::m_bInit
	ALIGN	4

?m_dwRightMask@CChiHuRight@@0PAKA DD 01H DUP (?)	; CChiHuRight::m_dwRightMask
_BSS	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT __pAtlLcidToLocaleNameTable
CONST	SEGMENT
__pAtlLcidToLocaleNameTable DD 01H
	DD	FLAT:$SG61324
	DD	02H
	DD	FLAT:$SG61325
	DD	03H
	DD	FLAT:$SG61326
	DD	04H
	DD	FLAT:$SG61327
	DD	05H
	DD	FLAT:$SG61328
	DD	06H
	DD	FLAT:$SG61329
	DD	07H
	DD	FLAT:$SG61330
	DD	08H
	DD	FLAT:$SG61331
	DD	09H
	DD	FLAT:$SG61332
	DD	0aH
	DD	FLAT:$SG61333
	DD	0bH
	DD	FLAT:$SG61334
	DD	0cH
	DD	FLAT:$SG61335
	DD	0dH
	DD	FLAT:$SG61336
	DD	0eH
	DD	FLAT:$SG61337
	DD	0fH
	DD	FLAT:$SG61338
	DD	010H
	DD	FLAT:$SG61339
	DD	011H
	DD	FLAT:$SG61340
	DD	012H
	DD	FLAT:$SG61341
	DD	013H
	DD	FLAT:$SG61342
	DD	014H
	DD	FLAT:$SG61343
	DD	015H
	DD	FLAT:$SG61344
	DD	016H
	DD	FLAT:$SG61345
	DD	018H
	DD	FLAT:$SG61346
	DD	019H
	DD	FLAT:$SG61347
	DD	01aH
	DD	FLAT:$SG61348
	DD	01bH
	DD	FLAT:$SG61349
	DD	01cH
	DD	FLAT:$SG61350
	DD	01dH
	DD	FLAT:$SG61351
	DD	01eH
	DD	FLAT:$SG61352
	DD	01fH
	DD	FLAT:$SG61353
	DD	020H
	DD	FLAT:$SG61354
	DD	021H
	DD	FLAT:$SG61355
	DD	022H
	DD	FLAT:$SG61356
	DD	023H
	DD	FLAT:$SG61357
	DD	024H
	DD	FLAT:$SG61358
	DD	025H
	DD	FLAT:$SG61359
	DD	026H
	DD	FLAT:$SG61360
	DD	027H
	DD	FLAT:$SG61361
	DD	029H
	DD	FLAT:$SG61362
	DD	02aH
	DD	FLAT:$SG61363
	DD	02bH
	DD	FLAT:$SG61364
	DD	02cH
	DD	FLAT:$SG61365
	DD	02dH
	DD	FLAT:$SG61366
	DD	02fH
	DD	FLAT:$SG61367
	DD	036H
	DD	FLAT:$SG61368
	DD	037H
	DD	FLAT:$SG61369
	DD	038H
	DD	FLAT:$SG61370
	DD	039H
	DD	FLAT:$SG61371
	DD	03eH
	DD	FLAT:$SG61372
	DD	03fH
	DD	FLAT:$SG61373
	DD	040H
	DD	FLAT:$SG61374
	DD	041H
	DD	FLAT:$SG61375
	DD	043H
	DD	FLAT:$SG61376
	DD	044H
	DD	FLAT:$SG61377
	DD	046H
	DD	FLAT:$SG61378
	DD	047H
	DD	FLAT:$SG61379
	DD	049H
	DD	FLAT:$SG61380
	DD	04aH
	DD	FLAT:$SG61381
	DD	04bH
	DD	FLAT:$SG61382
	DD	04eH
	DD	FLAT:$SG61383
	DD	04fH
	DD	FLAT:$SG61384
	DD	050H
	DD	FLAT:$SG61385
	DD	056H
	DD	FLAT:$SG61386
	DD	057H
	DD	FLAT:$SG61387
	DD	05aH
	DD	FLAT:$SG61388
	DD	065H
	DD	FLAT:$SG61389
	DD	07fH
	DD	FLAT:$SG61390
	DD	0401H
	DD	FLAT:$SG61391
	DD	0402H
	DD	FLAT:$SG61392
	DD	0403H
	DD	FLAT:$SG61393
	DD	0404H
	DD	FLAT:$SG61394
	DD	0405H
	DD	FLAT:$SG61395
	DD	0406H
	DD	FLAT:$SG61396
	DD	0407H
	DD	FLAT:$SG61397
	DD	0408H
	DD	FLAT:$SG61398
	DD	0409H
	DD	FLAT:$SG61399
	DD	040bH
	DD	FLAT:$SG61400
	DD	040cH
	DD	FLAT:$SG61401
	DD	040dH
	DD	FLAT:$SG61402
	DD	040eH
	DD	FLAT:$SG61403
	DD	040fH
	DD	FLAT:$SG61404
	DD	0410H
	DD	FLAT:$SG61405
	DD	0411H
	DD	FLAT:$SG61406
	DD	0412H
	DD	FLAT:$SG61407
	DD	0413H
	DD	FLAT:$SG61408
	DD	0414H
	DD	FLAT:$SG61409
	DD	0415H
	DD	FLAT:$SG61410
	DD	0416H
	DD	FLAT:$SG61411
	DD	0418H
	DD	FLAT:$SG61412
	DD	0419H
	DD	FLAT:$SG61413
	DD	041aH
	DD	FLAT:$SG61414
	DD	041bH
	DD	FLAT:$SG61415
	DD	041cH
	DD	FLAT:$SG61416
	DD	041dH
	DD	FLAT:$SG61417
	DD	041eH
	DD	FLAT:$SG61418
	DD	041fH
	DD	FLAT:$SG61419
	DD	0420H
	DD	FLAT:$SG61420
	DD	0421H
	DD	FLAT:$SG61421
	DD	0422H
	DD	FLAT:$SG61422
	DD	0423H
	DD	FLAT:$SG61423
	DD	0424H
	DD	FLAT:$SG61424
	DD	0425H
	DD	FLAT:$SG61425
	DD	0426H
	DD	FLAT:$SG61426
	DD	0427H
	DD	FLAT:$SG61427
	DD	0429H
	DD	FLAT:$SG61428
	DD	042aH
	DD	FLAT:$SG61429
	DD	042bH
	DD	FLAT:$SG61430
	DD	042cH
	DD	FLAT:$SG61431
	DD	042dH
	DD	FLAT:$SG61432
	DD	042fH
	DD	FLAT:$SG61433
	DD	0432H
	DD	FLAT:$SG61434
	DD	0434H
	DD	FLAT:$SG61435
	DD	0435H
	DD	FLAT:$SG61436
	DD	0436H
	DD	FLAT:$SG61437
	DD	0437H
	DD	FLAT:$SG61438
	DD	0438H
	DD	FLAT:$SG61439
	DD	0439H
	DD	FLAT:$SG61440
	DD	043aH
	DD	FLAT:$SG61441
	DD	043bH
	DD	FLAT:$SG61442
	DD	043eH
	DD	FLAT:$SG61443
	DD	043fH
	DD	FLAT:$SG61444
	DD	0440H
	DD	FLAT:$SG61445
	DD	0441H
	DD	FLAT:$SG61446
	DD	0443H
	DD	FLAT:$SG61447
	DD	0444H
	DD	FLAT:$SG61448
	DD	0445H
	DD	FLAT:$SG61449
	DD	0446H
	DD	FLAT:$SG61450
	DD	0447H
	DD	FLAT:$SG61451
	DD	0449H
	DD	FLAT:$SG61452
	DD	044aH
	DD	FLAT:$SG61453
	DD	044bH
	DD	FLAT:$SG61454
	DD	044cH
	DD	FLAT:$SG61455
	DD	044eH
	DD	FLAT:$SG61456
	DD	044fH
	DD	FLAT:$SG61457
	DD	0450H
	DD	FLAT:$SG61458
	DD	0452H
	DD	FLAT:$SG61459
	DD	0456H
	DD	FLAT:$SG61460
	DD	0457H
	DD	FLAT:$SG61461
	DD	045aH
	DD	FLAT:$SG61462
	DD	0465H
	DD	FLAT:$SG61463
	DD	046bH
	DD	FLAT:$SG61464
	DD	046cH
	DD	FLAT:$SG61465
	DD	0481H
	DD	FLAT:$SG61466
	DD	0801H
	DD	FLAT:$SG61467
	DD	0804H
	DD	FLAT:$SG61468
	DD	0807H
	DD	FLAT:$SG61469
	DD	0809H
	DD	FLAT:$SG61470
	DD	080aH
	DD	FLAT:$SG61471
	DD	080cH
	DD	FLAT:$SG61472
	DD	0810H
	DD	FLAT:$SG61473
	DD	0813H
	DD	FLAT:$SG61474
	DD	0814H
	DD	FLAT:$SG61475
	DD	0816H
	DD	FLAT:$SG61476
	DD	081aH
	DD	FLAT:$SG61477
	DD	081dH
	DD	FLAT:$SG61478
	DD	082cH
	DD	FLAT:$SG61479
	DD	083bH
	DD	FLAT:$SG61480
	DD	083eH
	DD	FLAT:$SG61481
	DD	0843H
	DD	FLAT:$SG61482
	DD	086bH
	DD	FLAT:$SG61483
	DD	0c01H
	DD	FLAT:$SG61484
	DD	0c04H
	DD	FLAT:$SG61485
	DD	0c07H
	DD	FLAT:$SG61486
	DD	0c09H
	DD	FLAT:$SG61487
	DD	0c0aH
	DD	FLAT:$SG61488
	DD	0c0cH
	DD	FLAT:$SG61489
	DD	0c1aH
	DD	FLAT:$SG61490
	DD	0c3bH
	DD	FLAT:$SG61491
	DD	0c6bH
	DD	FLAT:$SG61492
	DD	01001H
	DD	FLAT:$SG61493
	DD	01004H
	DD	FLAT:$SG61494
	DD	01007H
	DD	FLAT:$SG61495
	DD	01009H
	DD	FLAT:$SG61496
	DD	0100aH
	DD	FLAT:$SG61497
	DD	0100cH
	DD	FLAT:$SG61498
	DD	0101aH
	DD	FLAT:$SG61499
	DD	0103bH
	DD	FLAT:$SG61500
	DD	01401H
	DD	FLAT:$SG61501
	DD	01404H
	DD	FLAT:$SG61502
	DD	01407H
	DD	FLAT:$SG61503
	DD	01409H
	DD	FLAT:$SG61504
	DD	0140aH
	DD	FLAT:$SG61505
	DD	0140cH
	DD	FLAT:$SG61506
	DD	0141aH
	DD	FLAT:$SG61507
	DD	0143bH
	DD	FLAT:$SG61508
	DD	01801H
	DD	FLAT:$SG61509
	DD	01809H
	DD	FLAT:$SG61510
	DD	0180aH
	DD	FLAT:$SG61511
	DD	0180cH
	DD	FLAT:$SG61512
	DD	0181aH
	DD	FLAT:$SG61513
	DD	0183bH
	DD	FLAT:$SG61514
	DD	01c01H
	DD	FLAT:$SG61515
	DD	01c09H
	DD	FLAT:$SG61516
	DD	01c0aH
	DD	FLAT:$SG61517
	DD	01c1aH
	DD	FLAT:$SG61518
	DD	01c3bH
	DD	FLAT:$SG61519
	DD	02001H
	DD	FLAT:$SG61520
	DD	02009H
	DD	FLAT:$SG61521
	DD	0200aH
	DD	FLAT:$SG61522
	DD	0203bH
	DD	FLAT:$SG61523
	DD	02401H
	DD	FLAT:$SG61524
	DD	02409H
	DD	FLAT:$SG61525
	DD	0240aH
	DD	FLAT:$SG61526
	DD	0243bH
	DD	FLAT:$SG61527
	DD	02801H
	DD	FLAT:$SG61528
	DD	02809H
	DD	FLAT:$SG61529
	DD	0280aH
	DD	FLAT:$SG61530
	DD	02c01H
	DD	FLAT:$SG61531
	DD	02c09H
	DD	FLAT:$SG61532
	DD	02c0aH
	DD	FLAT:$SG61533
	DD	03001H
	DD	FLAT:$SG61534
	DD	03009H
	DD	FLAT:$SG61535
	DD	0300aH
	DD	FLAT:$SG61536
	DD	03401H
	DD	FLAT:$SG61537
	DD	03409H
	DD	FLAT:$SG61538
	DD	0340aH
	DD	FLAT:$SG61539
	DD	03801H
	DD	FLAT:$SG61540
	DD	0380aH
	DD	FLAT:$SG61541
	DD	03c01H
	DD	FLAT:$SG61542
	DD	03c0aH
	DD	FLAT:$SG61543
	DD	04001H
	DD	FLAT:$SG61544
	DD	0400aH
	DD	FLAT:$SG61545
	DD	0440aH
	DD	FLAT:$SG61546
	DD	0480aH
	DD	FLAT:$SG61547
	DD	04c0aH
	DD	FLAT:$SG61548
	DD	0500aH
	DD	FLAT:$SG61549
	DD	07c04H
	DD	FLAT:$SG61550
	DD	07c1aH
	DD	FLAT:$SG61551
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_FlashObjectInterface
CONST	SEGMENT
_CLSID_FlashObjectInterface DD 0d27cdb71H
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _IID_IFlashObjectInterface
CONST	SEGMENT
_IID_IFlashObjectInterface DD 0d27cdb72H
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QB_WB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QB_WB DD FLAT:$SG82626	; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT _IID_IDispatchEx
CONST	SEGMENT
_IID_IDispatchEx DD 0a6ef9860H
	DW	0c720H
	DW	011d0H
	DB	093H
	DB	037H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	0dH
	DB	0caH
	DB	0a9H
CONST	ENDS
;	COMDAT _IID_IFlashFactory
CONST	SEGMENT
_IID_IFlashFactory DD 0d27cdb70H
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QB_WB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QB_WB DD FLAT:$SG82624		; ATL::szInvalidDateTime
CONST	ENDS
;	COMDAT _CLSID_ShockwaveFlash
CONST	SEGMENT
_CLSID_ShockwaveFlash DD 0d27cdb6eH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _DIID__IShockwaveFlashEvents
CONST	SEGMENT
_DIID__IShockwaveFlashEvents DD 0d27cdb6dH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _IID_IShockwaveFlash
CONST	SEGMENT
_IID_IShockwaveFlash DD 0d27cdb6cH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _LIBID_ShockwaveFlashObjects
CONST	SEGMENT
_LIBID_ShockwaveFlashObjects DD 0d27cdb6bH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT __pIncludeInitManaged
_DATA	SEGMENT
__pIncludeInitManaged DD FLAT:?_AfxInitManaged@@YAHXZ
_DATA	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
_DATA	SEGMENT
?PADDING@@3PAEA DB 080H					; PADDING
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
;	COMDAT ?CLSID_WinFormsControl@@3U_GUID@@B
CONST	SEGMENT
?CLSID_WinFormsControl@@3U_GUID@@B DD 0b7e7a666H	; CLSID_WinFormsControl
	DW	0d623H
	DW	0457fH
	DB	0a3H
	DB	0aH
	DB	06aH
	DB	049H
	DB	0a3H
	DB	0e5H
	DB	0b4H
	DB	070H
CONST	ENDS
;	COMDAT ?IID_IRichEditOleCallback2@@3U_GUID@@A
_DATA	SEGMENT
?IID_IRichEditOleCallback2@@3U_GUID@@A DD 089fc1386H	; IID_IRichEditOleCallback2
	DW	091e5H
	DW	0415fH
	DB	0adH
	DB	08fH
	DB	04H
	DB	041H
	DB	05cH
	DB	015H
	DB	0f8H
	DB	0f5H
_DATA	ENDS
;	COMDAT ?IID_IImageOle@@3U_GUID@@A
_DATA	SEGMENT
?IID_IImageOle@@3U_GUID@@A DD 0e41fe3bbH		; IID_IImageOle
	DW	07218H
	DW	0423dH
	DB	095H
	DB	02eH
	DB	096H
	DB	0e5H
	DB	056H
	DB	0aeH
	DB	0e3H
	DB	0fH
_DATA	ENDS
;	COMDAT ?CLSID_ImageOle@@3U_GUID@@A
_DATA	SEGMENT
?CLSID_ImageOle@@3U_GUID@@A DD 0c5b3a481H		; CLSID_ImageOle
	DW	021e3H
	DW	04cabH
	DB	08aH
	DB	0bdH
	DB	03cH
	DB	06aH
	DB	085H
	DB	089H
	DB	02aH
	DB	0d2H
_DATA	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:$SG109682			; ATL::szDelete
CONST	ENDS
;	COMDAT __pAtlLocaleNameToIndexTable
CONST	SEGMENT
__pAtlLocaleNameToIndexTable DD FLAT:$SG61553
	DD	042H
	DD	FLAT:$SG61554
	DD	02cH
	DD	FLAT:$SG61555
	DD	071H
	DD	FLAT:$SG61556
	DD	00H
	DD	FLAT:$SG61557
	DD	0d8H
	DD	FLAT:$SG61558
	DD	0daH
	DD	FLAT:$SG61559
	DD	0b1H
	DD	FLAT:$SG61560
	DD	0a0H
	DD	FLAT:$SG61561
	DD	08fH
	DD	FLAT:$SG61562
	DD	0cfH
	DD	FLAT:$SG61563
	DD	0d5H
	DD	FLAT:$SG61564
	DD	0d2H
	DD	FLAT:$SG61565
	DD	0a9H
	DD	FLAT:$SG61566
	DD	0b9H
	DD	FLAT:$SG61567
	DD	0c4H
	DD	FLAT:$SG61568
	DD	0dcH
	DD	FLAT:$SG61569
	DD	043H
	DD	FLAT:$SG61570
	DD	0ccH
	DD	FLAT:$SG61571
	DD	0bfH
	DD	FLAT:$SG61572
	DD	0c8H
	DD	FLAT:$SG61573
	DD	029H
	DD	FLAT:$SG61574
	DD	09bH
	DD	FLAT:$SG61575
	DD	06bH
	DD	FLAT:$SG61576
	DD	021H
	DD	FLAT:$SG61577
	DD	063H
	DD	FLAT:$SG61578
	DD	01H
	DD	FLAT:$SG61579
	DD	044H
	DD	FLAT:$SG61580
	DD	07dH
	DD	FLAT:$SG61581
	DD	0b7H
	DD	FLAT:$SG61582
	DD	02H
	DD	FLAT:$SG61583
	DD	045H
	DD	FLAT:$SG61584
	DD	04H
	DD	FLAT:$SG61585
	DD	047H
	DD	FLAT:$SG61586
	DD	087H
	DD	FLAT:$SG61587
	DD	05H
	DD	FLAT:$SG61588
	DD	048H
	DD	FLAT:$SG61589
	DD	06H
	DD	FLAT:$SG61590
	DD	0a2H
	DD	FLAT:$SG61591
	DD	091H
	DD	FLAT:$SG61592
	DD	049H
	DD	FLAT:$SG61593
	DD	0b3H
	DD	FLAT:$SG61594
	DD	0abH
	DD	FLAT:$SG61595
	DD	041H
	DD	FLAT:$SG61596
	DD	08bH
	DD	FLAT:$SG61597
	DD	07H
	DD	FLAT:$SG61598
	DD	04aH
	DD	FLAT:$SG61599
	DD	08H
	DD	FLAT:$SG61600
	DD	0a3H
	DD	FLAT:$SG61601
	DD	0cdH
	DD	FLAT:$SG61602
	DD	0acH
	DD	FLAT:$SG61603
	DD	0c9H
	DD	FLAT:$SG61604
	DD	092H
	DD	FLAT:$SG61605
	DD	0baH
	DD	FLAT:$SG61606
	DD	0c5H
	DD	FLAT:$SG61607
	DD	0b4H
	DD	FLAT:$SG61608
	DD	0d6H
	DD	FLAT:$SG61609
	DD	0d0H
	DD	FLAT:$SG61610
	DD	04bH
	DD	FLAT:$SG61611
	DD	0c0H
	DD	FLAT:$SG61612
	DD	0d3H
	DD	FLAT:$SG61613
	DD	09H
	DD	FLAT:$SG61614
	DD	0d1H
	DD	FLAT:$SG61615
	DD	0ddH
	DD	FLAT:$SG61616
	DD	0d7H
	DD	FLAT:$SG61617
	DD	0caH
	DD	FLAT:$SG61618
	DD	0b5H
	DD	FLAT:$SG61619
	DD	0c1H
	DD	FLAT:$SG61620
	DD	0d4H
	DD	FLAT:$SG61621
	DD	0a4H
	DD	FLAT:$SG61622
	DD	0adH
	DD	FLAT:$SG61623
	DD	0dfH
	DD	FLAT:$SG61624
	DD	093H
	DD	FLAT:$SG61625
	DD	0e0H
	DD	FLAT:$SG61626
	DD	0bbH
	DD	FLAT:$SG61627
	DD	0ceH
	DD	FLAT:$SG61628
	DD	0e1H
	DD	FLAT:$SG61629
	DD	0dbH
	DD	FLAT:$SG61630
	DD	0deH
	DD	FLAT:$SG61631
	DD	0d9H
	DD	FLAT:$SG61632
	DD	0c6H
	DD	FLAT:$SG61633
	DD	023H
	DD	FLAT:$SG61634
	DD	065H
	DD	FLAT:$SG61635
	DD	02aH
	DD	FLAT:$SG61636
	DD	06cH
	DD	FLAT:$SG61637
	DD	026H
	DD	FLAT:$SG61638
	DD	068H
	DD	FLAT:$SG61639
	DD	0aH
	DD	FLAT:$SG61640
	DD	04cH
	DD	FLAT:$SG61641
	DD	02eH
	DD	FLAT:$SG61642
	DD	073H
	DD	FLAT:$SG61643
	DD	0bH
	DD	FLAT:$SG61644
	DD	094H
	DD	FLAT:$SG61645
	DD	0a5H
	DD	FLAT:$SG61646
	DD	0aeH
	DD	FLAT:$SG61647
	DD	04dH
	DD	FLAT:$SG61648
	DD	0b6H
	DD	FLAT:$SG61649
	DD	0bcH
	DD	FLAT:$SG61650
	DD	03eH
	DD	FLAT:$SG61651
	DD	088H
	DD	FLAT:$SG61652
	DD	037H
	DD	FLAT:$SG61653
	DD	07fH
	DD	FLAT:$SG61654
	DD	0cH
	DD	FLAT:$SG61655
	DD	04eH
	DD	FLAT:$SG61656
	DD	02fH
	DD	FLAT:$SG61657
	DD	074H
	DD	FLAT:$SG61658
	DD	018H
	DD	FLAT:$SG61659
	DD	0afH
	DD	FLAT:$SG61660
	DD	05aH
	DD	FLAT:$SG61661
	DD	0dH
	DD	FLAT:$SG61662
	DD	04fH
	DD	FLAT:$SG61663
	DD	028H
	DD	FLAT:$SG61664
	DD	06aH
	DD	FLAT:$SG61665
	DD	01fH
	DD	FLAT:$SG61666
	DD	061H
	DD	FLAT:$SG61667
	DD	0eH
	DD	FLAT:$SG61668
	DD	050H
	DD	FLAT:$SG61669
	DD	0fH
	DD	FLAT:$SG61670
	DD	095H
	DD	FLAT:$SG61671
	DD	051H
	DD	FLAT:$SG61672
	DD	010H
	DD	FLAT:$SG61673
	DD	052H
	DD	FLAT:$SG61674
	DD	02dH
	DD	FLAT:$SG61675
	DD	072H
	DD	FLAT:$SG61676
	DD	031H
	DD	FLAT:$SG61677
	DD	078H
	DD	FLAT:$SG61678
	DD	03aH
	DD	FLAT:$SG61679
	DD	082H
	DD	FLAT:$SG61680
	DD	011H
	DD	FLAT:$SG61681
	DD	03fH
	DD	FLAT:$SG61682
	DD	089H
	DD	FLAT:$SG61683
	DD	053H
	DD	FLAT:$SG61684
	DD	032H
	DD	FLAT:$SG61685
	DD	079H
	DD	FLAT:$SG61686
	DD	025H
	DD	FLAT:$SG61687
	DD	067H
	DD	FLAT:$SG61688
	DD	024H
	DD	FLAT:$SG61689
	DD	066H
	DD	FLAT:$SG61690
	DD	08eH
	DD	FLAT:$SG61691
	DD	02bH
	DD	FLAT:$SG61692
	DD	06dH
	DD	FLAT:$SG61693
	DD	083H
	DD	FLAT:$SG61694
	DD	03dH
	DD	FLAT:$SG61695
	DD	086H
	DD	FLAT:$SG61696
	DD	03bH
	DD	FLAT:$SG61697
	DD	084H
	DD	FLAT:$SG61698
	DD	030H
	DD	FLAT:$SG61699
	DD	09dH
	DD	FLAT:$SG61700
	DD	077H
	DD	FLAT:$SG61701
	DD	075H
	DD	FLAT:$SG61702
	DD	055H
	DD	FLAT:$SG61703
	DD	012H
	DD	FLAT:$SG61704
	DD	096H
	DD	FLAT:$SG61705
	DD	054H
	DD	FLAT:$SG61706
	DD	097H
	DD	FLAT:$SG61707
	DD	013H
	DD	FLAT:$SG61708
	DD	08dH
	DD	FLAT:$SG61709
	DD	036H
	DD	FLAT:$SG61710
	DD	07eH
	DD	FLAT:$SG61711
	DD	014H
	DD	FLAT:$SG61712
	DD	056H
	DD	FLAT:$SG61713
	DD	015H
	DD	FLAT:$SG61714
	DD	057H
	DD	FLAT:$SG61715
	DD	098H
	DD	FLAT:$SG61716
	DD	08cH
	DD	FLAT:$SG61717
	DD	09fH
	DD	FLAT:$SG61718
	DD	0a8H
	DD	FLAT:$SG61719
	DD	016H
	DD	FLAT:$SG61720
	DD	058H
	DD	FLAT:$SG61721
	DD	017H
	DD	FLAT:$SG61722
	DD	059H
	DD	FLAT:$SG61723
	DD	03cH
	DD	FLAT:$SG61724
	DD	085H
	DD	FLAT:$SG61725
	DD	0a7H
	DD	FLAT:$SG61726
	DD	076H
	DD	FLAT:$SG61727
	DD	09cH
	DD	FLAT:$SG61728
	DD	019H
	DD	FLAT:$SG61729
	DD	05bH
	DD	FLAT:$SG61730
	DD	022H
	DD	FLAT:$SG61731
	DD	064H
	DD	FLAT:$SG61732
	DD	0beH
	DD	FLAT:$SG61733
	DD	0c3H
	DD	FLAT:$SG61734
	DD	0b0H
	DD	FLAT:$SG61735
	DD	0b8H
	DD	FLAT:$SG61736
	DD	0cbH
	DD	FLAT:$SG61737
	DD	0c7H
	DD	FLAT:$SG61738
	DD	01aH
	DD	FLAT:$SG61739
	DD	05cH
	DD	FLAT:$SG61740
	DD	0e3H
	DD	FLAT:$SG61741
	DD	0c2H
	DD	FLAT:$SG61742
	DD	0bdH
	DD	FLAT:$SG61743
	DD	0a6H
	DD	FLAT:$SG61744
	DD	099H
	DD	FLAT:$SG61745
	DD	01bH
	DD	FLAT:$SG61746
	DD	09aH
	DD	FLAT:$SG61747
	DD	05dH
	DD	FLAT:$SG61748
	DD	033H
	DD	FLAT:$SG61749
	DD	07aH
	DD	FLAT:$SG61750
	DD	040H
	DD	FLAT:$SG61751
	DD	08aH
	DD	FLAT:$SG61752
	DD	038H
	DD	FLAT:$SG61753
	DD	080H
	DD	FLAT:$SG61754
	DD	039H
	DD	FLAT:$SG61755
	DD	081H
	DD	FLAT:$SG61756
	DD	01cH
	DD	FLAT:$SG61757
	DD	05eH
	DD	FLAT:$SG61758
	DD	06eH
	DD	FLAT:$SG61759
	DD	01dH
	DD	FLAT:$SG61760
	DD	05fH
	DD	FLAT:$SG61761
	DD	035H
	DD	FLAT:$SG61762
	DD	07cH
	DD	FLAT:$SG61763
	DD	020H
	DD	FLAT:$SG61764
	DD	062H
	DD	FLAT:$SG61765
	DD	01eH
	DD	FLAT:$SG61766
	DD	060H
	DD	FLAT:$SG61767
	DD	034H
	DD	FLAT:$SG61768
	DD	09eH
	DD	FLAT:$SG61769
	DD	07bH
	DD	FLAT:$SG61770
	DD	027H
	DD	FLAT:$SG61771
	DD	069H
	DD	FLAT:$SG61772
	DD	06fH
	DD	FLAT:$SG61773
	DD	03H
	DD	FLAT:$SG61774
	DD	0e2H
	DD	FLAT:$SG61775
	DD	090H
	DD	FLAT:$SG61776
	DD	0a1H
	DD	FLAT:$SG61777
	DD	0b2H
	DD	FLAT:$SG61778
	DD	0aaH
	DD	FLAT:$SG61779
	DD	046H
	DD	FLAT:$SG61780
	DD	070H
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:$SG109680		; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:$SG109678		; ATL::szForceRemove
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:$SG109676		; ATL::szValToken
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:$SG109674		; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:$SG109672		; ATL::szDwordVal
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:$SG109670		; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:$SG109668		; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
CONST	SEGMENT
$SG61440 DB	'h', 00H, 'i', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61441 DB	'm', 00H, 't', 00H, '-', 00H, 'M', 00H, 'T', 00H, 00H, 00H
$SG61442 DB	's', 00H, 'e', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H
$SG61443 DB	'm', 00H, 's', 00H, '-', 00H, 'M', 00H, 'Y', 00H, 00H, 00H
?m_cbCardDataArray@CGameLogic@@1QBEB DB 01H		; CGameLogic::m_cbCardDataArray
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	035H
	DB	035H
	DB	035H
	DB	035H
$SG61444 DB	'k', 00H, 'k', 00H, '-', 00H, 'K', 00H, 'Z', 00H, 00H, 00H
$SG61445 DB	'k', 00H, 'y', 00H, '-', 00H, 'K', 00H, 'G', 00H, 00H, 00H
$SG61446 DB	's', 00H, 'w', 00H, '-', 00H, 'K', 00H, 'E', 00H, 00H, 00H
$SG61447 DB	'u', 00H, 'z', 00H, '-', 00H, 'U', 00H, 'Z', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61448 DB	't', 00H, 't', 00H, '-', 00H, 'R', 00H, 'U', 00H, 00H, 00H
$SG61449 DB	'b', 00H, 'n', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61450 DB	'p', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61451 DB	'g', 00H, 'u', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61452 DB	't', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61453 DB	't', 00H, 'e', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61454 DB	'k', 00H, 'n', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61455 DB	'm', 00H, 'l', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
?IID_IDataBase@@3U_GUID@@B DD 07fbbbffaH		; IID_IDataBase
	DW	0edf4H
	DW	043d2H
	DB	08aH
	DB	0b7H
	DB	028H
	DB	087H
	DB	03bH
	DB	0d0H
	DB	0f5H
	DB	03fH
$SG61456 DB	'm', 00H, 'r', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61457 DB	's', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61458 DB	'm', 00H, 'n', 00H, '-', 00H, 'M', 00H, 'N', 00H, 00H, 00H
$SG61459 DB	'c', 00H, 'y', 00H, '-', 00H, 'G', 00H, 'B', 00H, 00H, 00H
$SG61460 DB	'g', 00H, 'l', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61461 DB	'k', 00H, 'o', 00H, 'k', 00H, '-', 00H, 'I', 00H, 'N', 00H
	DB	00H, 00H
	ORG $+2
$SG61462 DB	's', 00H, 'y', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'Y', 00H
	DB	00H, 00H
	ORG $+2
$SG61463 DB	'd', 00H, 'i', 00H, 'v', 00H, '-', 00H, 'M', 00H, 'V', 00H
	DB	00H, 00H
	ORG $+2
$SG61464 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'B', 00H, 'O', 00H
	DB	00H, 00H
	ORG $+2
$SG61465 DB	'n', 00H, 's', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61466 DB	'm', 00H, 'i', 00H, '-', 00H, 'N', 00H, 'Z', 00H, 00H, 00H
$SG61467 DB	'a', 00H, 'r', 00H, '-', 00H, 'I', 00H, 'Q', 00H, 00H, 00H
$SG61468 DB	'z', 00H, 'h', 00H, '-', 00H, 'C', 00H, 'N', 00H, 00H, 00H
$SG61469 DB	'd', 00H, 'e', 00H, '-', 00H, 'C', 00H, 'H', 00H, 00H, 00H
$SG61470 DB	'e', 00H, 'n', 00H, '-', 00H, 'G', 00H, 'B', 00H, 00H, 00H
$SG61471 DB	'e', 00H, 's', 00H, '-', 00H, 'M', 00H, 'X', 00H, 00H, 00H
$SG61472 DB	'f', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'E', 00H, 00H, 00H
$SG61473 DB	'i', 00H, 't', 00H, '-', 00H, 'C', 00H, 'H', 00H, 00H, 00H
$SG61474 DB	'n', 00H, 'l', 00H, '-', 00H, 'B', 00H, 'E', 00H, 00H, 00H
$SG61475 DB	'n', 00H, 'n', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H
$SG61476 DB	'p', 00H, 't', 00H, '-', 00H, 'P', 00H, 'T', 00H, 00H, 00H
$SG61477 DB	's', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'P', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61478 DB	's', 00H, 'v', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H
$SG61479 DB	'a', 00H, 'z', 00H, '-', 00H, 'A', 00H, 'Z', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61480 DB	's', 00H, 'e', 00H, '-', 00H, 'S', 00H, 'E', 00H, 00H, 00H
$SG61481 DB	'm', 00H, 's', 00H, '-', 00H, 'B', 00H, 'N', 00H, 00H, 00H
$SG61482 DB	'u', 00H, 'z', 00H, '-', 00H, 'U', 00H, 'Z', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61483 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'E', 00H, 'C', 00H
	DB	00H, 00H
	ORG $+2
$SG60459 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61484 DB	'a', 00H, 'r', 00H, '-', 00H, 'E', 00H, 'G', 00H, 00H, 00H
$SG61485 DB	'z', 00H, 'h', 00H, '-', 00H, 'H', 00H, 'K', 00H, 00H, 00H
$SG61486 DB	'd', 00H, 'e', 00H, '-', 00H, 'A', 00H, 'T', 00H, 00H, 00H
$SG61487 DB	'e', 00H, 'n', 00H, '-', 00H, 'A', 00H, 'U', 00H, 00H, 00H
$SG61488 DB	'e', 00H, 's', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61489 DB	'f', 00H, 'r', 00H, '-', 00H, 'C', 00H, 'A', 00H, 00H, 00H
$SG61490 DB	's', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'P', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
?IID_IPlatformResource@@3U_GUID@@B DD 0bcd7ff05H	; IID_IPlatformResource
	DW	0a79H
	DW	04482H
	DB	09bH
	DB	0a6H
	DB	079H
	DB	0dfH
	DB	04bH
	DB	0d9H
	DB	080H
	DB	016H
$SG61491 DB	's', 00H, 'e', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H
$SG61492 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'P', 00H, 'E', 00H
	DB	00H, 00H
	ORG $+2
$SG61493 DB	'a', 00H, 'r', 00H, '-', 00H, 'L', 00H, 'Y', 00H, 00H, 00H
$SG61494 DB	'z', 00H, 'h', 00H, '-', 00H, 'S', 00H, 'G', 00H, 00H, 00H
$SG61495 DB	'd', 00H, 'e', 00H, '-', 00H, 'L', 00H, 'U', 00H, 00H, 00H
$SG61496 DB	'e', 00H, 'n', 00H, '-', 00H, 'C', 00H, 'A', 00H, 00H, 00H
$SG61497 DB	'e', 00H, 's', 00H, '-', 00H, 'G', 00H, 'T', 00H, 00H, 00H
$SG61498 DB	'f', 00H, 'r', 00H, '-', 00H, 'C', 00H, 'H', 00H, 00H, 00H
$SG61499 DB	'h', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, 00H, 00H
$SG61500 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 'N', 00H, 'O', 00H
	DB	00H, 00H
	ORG $+2
$SG61501 DB	'a', 00H, 'r', 00H, '-', 00H, 'D', 00H, 'Z', 00H, 00H, 00H
$SG61502 DB	'z', 00H, 'h', 00H, '-', 00H, 'M', 00H, 'O', 00H, 00H, 00H
$SG61503 DB	'd', 00H, 'e', 00H, '-', 00H, 'L', 00H, 'I', 00H, 00H, 00H
$SG61504 DB	'e', 00H, 'n', 00H, '-', 00H, 'N', 00H, 'Z', 00H, 00H, 00H
$SG61505 DB	'e', 00H, 's', 00H, '-', 00H, 'C', 00H, 'R', 00H, 00H, 00H
$SG61506 DB	'f', 00H, 'r', 00H, '-', 00H, 'L', 00H, 'U', 00H, 00H, 00H
$SG61507 DB	'b', 00H, 's', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61508 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 'S', 00H, 'E', 00H
	DB	00H, 00H
	ORG $+2
$SG61509 DB	'a', 00H, 'r', 00H, '-', 00H, 'M', 00H, 'A', 00H, 00H, 00H
$SG61510 DB	'e', 00H, 'n', 00H, '-', 00H, 'I', 00H, 'E', 00H, 00H, 00H
$SG61511 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'A', 00H, 00H, 00H
?IID_IDataBaseEngine@@3U_GUID@@B DD 03c56956dH		; IID_IDataBaseEngine
	DW	01690H
	DW	04c22H
	DB	088H
	DB	034H
	DB	09eH
	DB	0b9H
	DB	0d0H
	DB	093H
	DB	066H
	DB	04cH
$SG61512 DB	'f', 00H, 'r', 00H, '-', 00H, 'M', 00H, 'C', 00H, 00H, 00H
$SG61513 DB	's', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61514 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 'N', 00H, 'O', 00H
	DB	00H, 00H
	ORG $+2
$SG61515 DB	'a', 00H, 'r', 00H, '-', 00H, 'T', 00H, 'N', 00H, 00H, 00H
$SG61516 DB	'e', 00H, 'n', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61517 DB	'e', 00H, 's', 00H, '-', 00H, 'D', 00H, 'O', 00H, 00H, 00H
$SG61518 DB	's', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61519 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 'S', 00H, 'E', 00H
	DB	00H, 00H
	ORG $+2
$SG61520 DB	'a', 00H, 'r', 00H, '-', 00H, 'O', 00H, 'M', 00H, 00H, 00H
$SG61521 DB	'e', 00H, 'n', 00H, '-', 00H, 'J', 00H, 'M', 00H, 00H, 00H
$SG61522 DB	'e', 00H, 's', 00H, '-', 00H, 'V', 00H, 'E', 00H, 00H, 00H
$SG61523 DB	's', 00H, 'm', 00H, 's', 00H, '-', 00H, 'F', 00H, 'I', 00H
	DB	00H, 00H
	ORG $+2
$SG61524 DB	'a', 00H, 'r', 00H, '-', 00H, 'Y', 00H, 'E', 00H, 00H, 00H
$SG61525 DB	'e', 00H, 'n', 00H, '-', 00H, 'C', 00H, 'B', 00H, 00H, 00H
$SG61526 DB	'e', 00H, 's', 00H, '-', 00H, 'C', 00H, 'O', 00H, 00H, 00H
$SG61527 DB	's', 00H, 'm', 00H, 'n', 00H, '-', 00H, 'F', 00H, 'I', 00H
	DB	00H, 00H
	ORG $+2
$SG61528 DB	'a', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'Y', 00H, 00H, 00H
$SG61529 DB	'e', 00H, 'n', 00H, '-', 00H, 'B', 00H, 'Z', 00H, 00H, 00H
$SG61530 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'E', 00H, 00H, 00H
$SG60506 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG61531 DB	'a', 00H, 'r', 00H, '-', 00H, 'J', 00H, 'O', 00H, 00H, 00H
$SG61532 DB	'e', 00H, 'n', 00H, '-', 00H, 'T', 00H, 'T', 00H, 00H, 00H
$SG61533 DB	'e', 00H, 's', 00H, '-', 00H, 'A', 00H, 'R', 00H, 00H, 00H
$SG61534 DB	'a', 00H, 'r', 00H, '-', 00H, 'L', 00H, 'B', 00H, 00H, 00H
$SG61535 DB	'e', 00H, 'n', 00H, '-', 00H, 'Z', 00H, 'W', 00H, 00H, 00H
$SG61536 DB	'e', 00H, 's', 00H, '-', 00H, 'E', 00H, 'C', 00H, 00H, 00H
$SG61537 DB	'a', 00H, 'r', 00H, '-', 00H, 'K', 00H, 'W', 00H, 00H, 00H
$SG61538 DB	'e', 00H, 'n', 00H, '-', 00H, 'P', 00H, 'H', 00H, 00H, 00H
$SG61539 DB	'e', 00H, 's', 00H, '-', 00H, 'C', 00H, 'L', 00H, 00H, 00H
$SG109668 DB	'S', 00H, 00H, 00H
$SG61540 DB	'a', 00H, 'r', 00H, '-', 00H, 'A', 00H, 'E', 00H, 00H, 00H
$SG61541 DB	'e', 00H, 's', 00H, '-', 00H, 'U', 00H, 'Y', 00H, 00H, 00H
$SG109670 DB	'M', 00H, 00H, 00H
$SG61542 DB	'a', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'H', 00H, 00H, 00H
$SG61543 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'Y', 00H, 00H, 00H
$SG109672 DB	'D', 00H, 00H, 00H
$SG61544 DB	'a', 00H, 'r', 00H, '-', 00H, 'Q', 00H, 'A', 00H, 00H, 00H
$SG61545 DB	'e', 00H, 's', 00H, '-', 00H, 'B', 00H, 'O', 00H, 00H, 00H
$SG109674 DB	'B', 00H, 00H, 00H
$SG61546 DB	'e', 00H, 's', 00H, '-', 00H, 'S', 00H, 'V', 00H, 00H, 00H
$SG61547 DB	'e', 00H, 's', 00H, '-', 00H, 'H', 00H, 'N', 00H, 00H, 00H
$SG109676 DB	'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG61548 DB	'e', 00H, 's', 00H, '-', 00H, 'N', 00H, 'I', 00H, 00H, 00H
$SG61549 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'R', 00H, 00H, 00H
$SG109678 DB	'F', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG61550 DB	'z', 00H, 'h', 00H, '-', 00H, 'C', 00H, 'H', 00H, 'T', 00H
	DB	00H, 00H
	ORG $+2
$SG61551 DB	's', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG109680 DB	'N', 00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'v', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61553 DB	00H, 00H
	ORG $+2
$SG109682 DB	'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG61554 DB	'a', 00H, 'f', 00H, 00H, 00H
	ORG $+2
$SG61555 DB	'a', 00H, 'f', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61556 DB	'a', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61557 DB	'a', 00H, 'r', 00H, '-', 00H, 'a', 00H, 'e', 00H, 00H, 00H
$SG61558 DB	'a', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'h', 00H, 00H, 00H
$SG61559 DB	'a', 00H, 'r', 00H, '-', 00H, 'd', 00H, 'z', 00H, 00H, 00H
$SG61560 DB	'a', 00H, 'r', 00H, '-', 00H, 'e', 00H, 'g', 00H, 00H, 00H
$SG61561 DB	'a', 00H, 'r', 00H, '-', 00H, 'i', 00H, 'q', 00H, 00H, 00H
$SG61562 DB	'a', 00H, 'r', 00H, '-', 00H, 'j', 00H, 'o', 00H, 00H, 00H
$SG61563 DB	'a', 00H, 'r', 00H, '-', 00H, 'k', 00H, 'w', 00H, 00H, 00H
$SG61564 DB	'a', 00H, 'r', 00H, '-', 00H, 'l', 00H, 'b', 00H, 00H, 00H
$SG61565 DB	'a', 00H, 'r', 00H, '-', 00H, 'l', 00H, 'y', 00H, 00H, 00H
$SG61566 DB	'a', 00H, 'r', 00H, '-', 00H, 'm', 00H, 'a', 00H, 00H, 00H
$SG61567 DB	'a', 00H, 'r', 00H, '-', 00H, 'o', 00H, 'm', 00H, 00H, 00H
$SG61568 DB	'a', 00H, 'r', 00H, '-', 00H, 'q', 00H, 'a', 00H, 00H, 00H
$SG61569 DB	'a', 00H, 'r', 00H, '-', 00H, 's', 00H, 'a', 00H, 00H, 00H
$SG61570 DB	'a', 00H, 'r', 00H, '-', 00H, 's', 00H, 'y', 00H, 00H, 00H
$SG61571 DB	'a', 00H, 'r', 00H, '-', 00H, 't', 00H, 'n', 00H, 00H, 00H
$SG61572 DB	'a', 00H, 'r', 00H, '-', 00H, 'y', 00H, 'e', 00H, 00H, 00H
$SG61573 DB	'a', 00H, 'z', 00H, 00H, 00H
	ORG $+2
$SG61574 DB	'a', 00H, 'z', 00H, '-', 00H, 'a', 00H, 'z', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61575 DB	'a', 00H, 'z', 00H, '-', 00H, 'a', 00H, 'z', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61576 DB	'b', 00H, 'e', 00H, 00H, 00H
	ORG $+2
?IID_IUDPNetworkEngine@@3U_GUID@@B DD 0bbbd895aH	; IID_IUDPNetworkEngine
	DW	0a97H
	DW	04faeH
	DB	08eH
	DB	038H
	DB	010H
	DB	076H
	DB	0a7H
	DB	0c7H
	DB	04dH
	DB	07fH
$SG61577 DB	'b', 00H, 'e', 00H, '-', 00H, 'b', 00H, 'y', 00H, 00H, 00H
$SG60553 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG61578 DB	'b', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG61579 DB	'b', 00H, 'g', 00H, '-', 00H, 'b', 00H, 'g', 00H, 00H, 00H
$SG61580 DB	'b', 00H, 'n', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61581 DB	'b', 00H, 's', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61582 DB	'c', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61583 DB	'c', 00H, 'a', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61584 DB	'c', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61585 DB	'c', 00H, 's', 00H, '-', 00H, 'c', 00H, 'z', 00H, 00H, 00H
$SG61586 DB	'c', 00H, 'y', 00H, '-', 00H, 'g', 00H, 'b', 00H, 00H, 00H
$SG61587 DB	'd', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61588 DB	'd', 00H, 'a', 00H, '-', 00H, 'd', 00H, 'k', 00H, 00H, 00H
$SG61589 DB	'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61590 DB	'd', 00H, 'e', 00H, '-', 00H, 'a', 00H, 't', 00H, 00H, 00H
$SG61591 DB	'd', 00H, 'e', 00H, '-', 00H, 'c', 00H, 'h', 00H, 00H, 00H
$SG61592 DB	'd', 00H, 'e', 00H, '-', 00H, 'd', 00H, 'e', 00H, 00H, 00H
$SG61593 DB	'd', 00H, 'e', 00H, '-', 00H, 'l', 00H, 'i', 00H, 00H, 00H
$SG61594 DB	'd', 00H, 'e', 00H, '-', 00H, 'l', 00H, 'u', 00H, 00H, 00H
$SG61595 DB	'd', 00H, 'i', 00H, 'v', 00H, 00H, 00H
$SG61596 DB	'd', 00H, 'i', 00H, 'v', 00H, '-', 00H, 'm', 00H, 'v', 00H
	DB	00H, 00H
	ORG $+2
$SG61597 DB	'e', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61598 DB	'e', 00H, 'l', 00H, '-', 00H, 'g', 00H, 'r', 00H, 00H, 00H
$SG61599 DB	'e', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61600 DB	'e', 00H, 'n', 00H, '-', 00H, 'a', 00H, 'u', 00H, 00H, 00H
$SG61601 DB	'e', 00H, 'n', 00H, '-', 00H, 'b', 00H, 'z', 00H, 00H, 00H
$SG61602 DB	'e', 00H, 'n', 00H, '-', 00H, 'c', 00H, 'a', 00H, 00H, 00H
$SG61603 DB	'e', 00H, 'n', 00H, '-', 00H, 'c', 00H, 'b', 00H, 00H, 00H
$SG61604 DB	'e', 00H, 'n', 00H, '-', 00H, 'g', 00H, 'b', 00H, 00H, 00H
$SG61605 DB	'e', 00H, 'n', 00H, '-', 00H, 'i', 00H, 'e', 00H, 00H, 00H
$SG61606 DB	'e', 00H, 'n', 00H, '-', 00H, 'j', 00H, 'm', 00H, 00H, 00H
$SG61607 DB	'e', 00H, 'n', 00H, '-', 00H, 'n', 00H, 'z', 00H, 00H, 00H
$SG61608 DB	'e', 00H, 'n', 00H, '-', 00H, 'p', 00H, 'h', 00H, 00H, 00H
$SG61609 DB	'e', 00H, 'n', 00H, '-', 00H, 't', 00H, 't', 00H, 00H, 00H
$SG61610 DB	'e', 00H, 'n', 00H, '-', 00H, 'u', 00H, 's', 00H, 00H, 00H
$SG61611 DB	'e', 00H, 'n', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
?IID_ITCPNetworkEngine@@3U_GUID@@B DD 09aa6931fH	; IID_ITCPNetworkEngine
	DW	0417fH
	DW	043a7H
	DB	086H
	DB	0abH
	DB	056H
	DB	010H
	DB	0e4H
	DB	034H
	DB	01cH
	DB	017H
$SG61612 DB	'e', 00H, 'n', 00H, '-', 00H, 'z', 00H, 'w', 00H, 00H, 00H
$SG61613 DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61614 DB	'e', 00H, 's', 00H, '-', 00H, 'a', 00H, 'r', 00H, 00H, 00H
$SG61615 DB	'e', 00H, 's', 00H, '-', 00H, 'b', 00H, 'o', 00H, 00H, 00H
$SG61616 DB	'e', 00H, 's', 00H, '-', 00H, 'c', 00H, 'l', 00H, 00H, 00H
$SG61617 DB	'e', 00H, 's', 00H, '-', 00H, 'c', 00H, 'o', 00H, 00H, 00H
$SG61618 DB	'e', 00H, 's', 00H, '-', 00H, 'c', 00H, 'r', 00H, 00H, 00H
$SG61619 DB	'e', 00H, 's', 00H, '-', 00H, 'd', 00H, 'o', 00H, 00H, 00H
$SG61620 DB	'e', 00H, 's', 00H, '-', 00H, 'e', 00H, 'c', 00H, 00H, 00H
$SG61621 DB	'e', 00H, 's', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61622 DB	'e', 00H, 's', 00H, '-', 00H, 'g', 00H, 't', 00H, 00H, 00H
$SG61623 DB	'e', 00H, 's', 00H, '-', 00H, 'h', 00H, 'n', 00H, 00H, 00H
$SG61624 DB	'e', 00H, 's', 00H, '-', 00H, 'm', 00H, 'x', 00H, 00H, 00H
$SG60600 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e'
	DB	00H, 00H, 00H
$SG61625 DB	'e', 00H, 's', 00H, '-', 00H, 'n', 00H, 'i', 00H, 00H, 00H
$SG61626 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'a', 00H, 00H, 00H
$SG61627 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'e', 00H, 00H, 00H
$SG61628 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'r', 00H, 00H, 00H
$SG61629 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'y', 00H, 00H, 00H
$SG61630 DB	'e', 00H, 's', 00H, '-', 00H, 's', 00H, 'v', 00H, 00H, 00H
$SG61631 DB	'e', 00H, 's', 00H, '-', 00H, 'u', 00H, 'y', 00H, 00H, 00H
$SG61632 DB	'e', 00H, 's', 00H, '-', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG61633 DB	'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61634 DB	'e', 00H, 't', 00H, '-', 00H, 'e', 00H, 'e', 00H, 00H, 00H
$SG61635 DB	'e', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61636 DB	'e', 00H, 'u', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61637 DB	'f', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61638 DB	'f', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'r', 00H, 00H, 00H
$SG61639 DB	'f', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61640 DB	'f', 00H, 'i', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H
$SG61641 DB	'f', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61642 DB	'f', 00H, 'o', 00H, '-', 00H, 'f', 00H, 'o', 00H, 00H, 00H
$SG61643 DB	'f', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61644 DB	'f', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'e', 00H, 00H, 00H
$SG61645 DB	'f', 00H, 'r', 00H, '-', 00H, 'c', 00H, 'a', 00H, 00H, 00H
$SG61646 DB	'f', 00H, 'r', 00H, '-', 00H, 'c', 00H, 'h', 00H, 00H, 00H
$SG61647 DB	'f', 00H, 'r', 00H, '-', 00H, 'f', 00H, 'r', 00H, 00H, 00H
$SG61648 DB	'f', 00H, 'r', 00H, '-', 00H, 'l', 00H, 'u', 00H, 00H, 00H
$SG61649 DB	'f', 00H, 'r', 00H, '-', 00H, 'm', 00H, 'c', 00H, 00H, 00H
$SG61650 DB	'g', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61651 DB	'g', 00H, 'l', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61652 DB	'g', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61653 DB	'g', 00H, 'u', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61654 DB	'h', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61655 DB	'h', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'l', 00H, 00H, 00H
$SG61656 DB	'h', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61657 DB	'h', 00H, 'i', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
?IID_ITCPSocketService@@3U_GUID@@B DD 0f8a5c14H		; IID_ITCPSocketService
	DW	0ab92H
	DW	0467cH
	DB	0b6H
	DB	07bH
	DB	06dH
	DB	08aH
	DB	0cfH
	DB	064H
	DB	052H
	DB	0d7H
$SG61658 DB	'h', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61659 DB	'h', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, 00H, 00H
$SG61660 DB	'h', 00H, 'r', 00H, '-', 00H, 'h', 00H, 'r', 00H, 00H, 00H
$SG61661 DB	'h', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61662 DB	'h', 00H, 'u', 00H, '-', 00H, 'h', 00H, 'u', 00H, 00H, 00H
$SG61663 DB	'h', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61664 DB	'h', 00H, 'y', 00H, '-', 00H, 'a', 00H, 'm', 00H, 00H, 00H
$SG61665 DB	'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG61666 DB	'i', 00H, 'd', 00H, '-', 00H, 'i', 00H, 'd', 00H, 00H, 00H
$SG61667 DB	'i', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61668 DB	'i', 00H, 's', 00H, '-', 00H, 'i', 00H, 's', 00H, 00H, 00H
$SG61669 DB	'i', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61670 DB	'i', 00H, 't', 00H, '-', 00H, 'c', 00H, 'h', 00H, 00H, 00H
$SG61671 DB	'i', 00H, 't', 00H, '-', 00H, 'i', 00H, 't', 00H, 00H, 00H
$SG60647 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'l', 00H, 00H, 00H
$SG61672 DB	'j', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61673 DB	'j', 00H, 'a', 00H, '-', 00H, 'j', 00H, 'p', 00H, 00H, 00H
$SG61674 DB	'k', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61675 DB	'k', 00H, 'a', 00H, '-', 00H, 'g', 00H, 'e', 00H, 00H, 00H
$SG61676 DB	'k', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61677 DB	'k', 00H, 'k', 00H, '-', 00H, 'k', 00H, 'z', 00H, 00H, 00H
$SG61678 DB	'k', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61679 DB	'k', 00H, 'n', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61680 DB	'k', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61681 DB	'k', 00H, 'o', 00H, 'k', 00H, 00H, 00H
$SG61682 DB	'k', 00H, 'o', 00H, 'k', 00H, '-', 00H, 'i', 00H, 'n', 00H
	DB	00H, 00H
	ORG $+2
$SG61683 DB	'k', 00H, 'o', 00H, '-', 00H, 'k', 00H, 'r', 00H, 00H, 00H
$SG61684 DB	'k', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61685 DB	'k', 00H, 'y', 00H, '-', 00H, 'k', 00H, 'g', 00H, 00H, 00H
$SG61686 DB	'l', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61687 DB	'l', 00H, 't', 00H, '-', 00H, 'l', 00H, 't', 00H, 00H, 00H
$SG61688 DB	'l', 00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG61689 DB	'l', 00H, 'v', 00H, '-', 00H, 'l', 00H, 'v', 00H, 00H, 00H
$SG61690 DB	'm', 00H, 'i', 00H, '-', 00H, 'n', 00H, 'z', 00H, 00H, 00H
?IID_IWEBSocketService@@3U_GUID@@B DD 05502d590H	; IID_IWEBSocketService
	DW	0c446H
	DW	0440dH
	DB	0a1H
	DB	095H
	DB	03eH
	DB	0daH
	DB	011H
	DB	0f8H
	DB	0dH
	DB	064H
$SG61691 DB	'm', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61692 DB	'm', 00H, 'k', 00H, '-', 00H, 'm', 00H, 'k', 00H, 00H, 00H
$SG61693 DB	'm', 00H, 'l', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61694 DB	'm', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61695 DB	'm', 00H, 'n', 00H, '-', 00H, 'm', 00H, 'n', 00H, 00H, 00H
$SG61696 DB	'm', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61697 DB	'm', 00H, 'r', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61698 DB	'm', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61699 DB	'm', 00H, 's', 00H, '-', 00H, 'b', 00H, 'n', 00H, 00H, 00H
$SG61700 DB	'm', 00H, 's', 00H, '-', 00H, 'm', 00H, 'y', 00H, 00H, 00H
$SG61701 DB	'm', 00H, 't', 00H, '-', 00H, 'm', 00H, 't', 00H, 00H, 00H
$SG61702 DB	'n', 00H, 'b', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H
$SG61703 DB	'n', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61704 DB	'n', 00H, 'l', 00H, '-', 00H, 'b', 00H, 'e', 00H, 00H, 00H
$SG61705 DB	'n', 00H, 'l', 00H, '-', 00H, 'n', 00H, 'l', 00H, 00H, 00H
$SG61706 DB	'n', 00H, 'n', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H
$SG61707 DB	'n', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61708 DB	'n', 00H, 's', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61709 DB	'p', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61710 DB	'p', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61711 DB	'p', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61712 DB	'p', 00H, 'l', 00H, '-', 00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG61713 DB	'p', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61714 DB	'p', 00H, 't', 00H, '-', 00H, 'b', 00H, 'r', 00H, 00H, 00H
$SG61715 DB	'p', 00H, 't', 00H, '-', 00H, 'p', 00H, 't', 00H, 00H, 00H
$SG61716 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'b', 00H, 'o', 00H
	DB	00H, 00H
	ORG $+2
?IID_ITimerEngine@@3U_GUID@@B DD 0c90cfc81H		; IID_ITimerEngine
	DW	0ee01H
	DW	04654H
	DB	08cH
	DB	09aH
	DB	058H
	DB	0a9H
	DB	04bH
	DB	078H
	DB	076H
	DB	0b6H
$SG61717 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'e', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG61718 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'p', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG60694 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG61719 DB	'r', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61720 DB	'r', 00H, 'o', 00H, '-', 00H, 'r', 00H, 'o', 00H, 00H, 00H
$SG61721 DB	'r', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61722 DB	'r', 00H, 'u', 00H, '-', 00H, 'r', 00H, 'u', 00H, 00H, 00H
$SG61723 DB	's', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61724 DB	's', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61725 DB	's', 00H, 'e', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H
$SG61726 DB	's', 00H, 'e', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H
$SG61727 DB	's', 00H, 'e', 00H, '-', 00H, 's', 00H, 'e', 00H, 00H, 00H
$SG61728 DB	's', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61729 DB	's', 00H, 'k', 00H, '-', 00H, 's', 00H, 'k', 00H, 00H, 00H
$SG61730 DB	's', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61731 DB	's', 00H, 'l', 00H, '-', 00H, 's', 00H, 'i', 00H, 00H, 00H
$SG61732 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 'n', 00H, 'o', 00H
	DB	00H, 00H
	ORG $+2
$SG61733 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 's', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG61734 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 'n', 00H, 'o', 00H
	DB	00H, 00H
	ORG $+2
$SG61735 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 's', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG61736 DB	's', 00H, 'm', 00H, 'n', 00H, '-', 00H, 'f', 00H, 'i', 00H
	DB	00H, 00H
	ORG $+2
$SG61737 DB	's', 00H, 'm', 00H, 's', 00H, '-', 00H, 'f', 00H, 'i', 00H
	DB	00H, 00H
	ORG $+2
$SG61738 DB	's', 00H, 'q', 00H, 00H, 00H
	ORG $+2
$SG61739 DB	's', 00H, 'q', 00H, '-', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG61740 DB	's', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61741 DB	's', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61742 DB	's', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61743 DB	's', 00H, 'r', 00H, '-', 00H, 's', 00H, 'p', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61744 DB	's', 00H, 'r', 00H, '-', 00H, 's', 00H, 'p', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61745 DB	's', 00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG61746 DB	's', 00H, 'v', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H
$SG61747 DB	's', 00H, 'v', 00H, '-', 00H, 's', 00H, 'e', 00H, 00H, 00H
$SG61748 DB	's', 00H, 'w', 00H, 00H, 00H
	ORG $+2
$SG61749 DB	's', 00H, 'w', 00H, '-', 00H, 'k', 00H, 'e', 00H, 00H, 00H
$SG61750 DB	's', 00H, 'y', 00H, 'r', 00H, 00H, 00H
$SG61751 DB	's', 00H, 'y', 00H, 'r', 00H, '-', 00H, 's', 00H, 'y', 00H
	DB	00H, 00H
	ORG $+2
$SG61752 DB	't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61753 DB	't', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61754 DB	't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61755 DB	't', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61756 DB	't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG61757 DB	't', 00H, 'h', 00H, '-', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG61758 DB	't', 00H, 'n', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61759 DB	't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61760 DB	't', 00H, 'r', 00H, '-', 00H, 't', 00H, 'r', 00H, 00H, 00H
$SG61761 DB	't', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61762 DB	't', 00H, 't', 00H, '-', 00H, 'r', 00H, 'u', 00H, 00H, 00H
$SG61763 DB	'u', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61764 DB	'u', 00H, 'k', 00H, '-', 00H, 'u', 00H, 'a', 00H, 00H, 00H
$SG61765 DB	'u', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG60741 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H
$SG61766 DB	'u', 00H, 'r', 00H, '-', 00H, 'p', 00H, 'k', 00H, 00H, 00H
$SG61767 DB	'u', 00H, 'z', 00H, 00H, 00H
	ORG $+2
$SG61768 DB	'u', 00H, 'z', 00H, '-', 00H, 'u', 00H, 'z', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61769 DB	'u', 00H, 'z', 00H, '-', 00H, 'u', 00H, 'z', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61770 DB	'v', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG60746 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG61771 DB	'v', 00H, 'i', 00H, '-', 00H, 'v', 00H, 'n', 00H, 00H, 00H
$SG61772 DB	'x', 00H, 'h', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61773 DB	'z', 00H, 'h', 00H, '-', 00H, 'c', 00H, 'h', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG61774 DB	'z', 00H, 'h', 00H, '-', 00H, 'c', 00H, 'h', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG61775 DB	'z', 00H, 'h', 00H, '-', 00H, 'c', 00H, 'n', 00H, 00H, 00H
$SG61776 DB	'z', 00H, 'h', 00H, '-', 00H, 'h', 00H, 'k', 00H, 00H, 00H
$SG61777 DB	'z', 00H, 'h', 00H, '-', 00H, 'm', 00H, 'o', 00H, 00H, 00H
$SG61778 DB	'z', 00H, 'h', 00H, '-', 00H, 's', 00H, 'g', 00H, 00H, 00H
$SG61779 DB	'z', 00H, 'h', 00H, '-', 00H, 't', 00H, 'w', 00H, 00H, 00H
$SG61780 DB	'z', 00H, 'u', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG60793 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
?IID_IAttemperEngine@@3U_GUID@@B DD 04d5d2424H		; IID_IAttemperEngine
	DW	040fdH
	DW	04747H
	DB	086H
	DB	0d8H
	DB	08fH
	DB	0caH
	DB	06bH
	DB	096H
	DB	0eaH
	DB	0bH
$SG60840 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+2
$SG60887 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I'
	DB	00H, 00H, 00H
$SG59871 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG59942 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H
$SG59989 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H
	ORG $+2
$SG60036 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H
?IID_IFaceItemControl@@3U_GUID@@B DD 0fc9067a9H		; IID_IFaceItemControl
	DW	0162eH
	DW	04e13H
	DB	0b0H
	DB	01H
	DB	0f7H
	DB	057H
	DB	09eH
	DB	0a4H
	DB	060H
	DB	06bH
$SG60083 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG82624 DB	'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'T'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG82626 DB	'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'T'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 'S', 00H, 'p', 00H, 'a', 00H
	DB	'n', 00H, 00H, 00H
	ORG $+2
?IID_IFaceSelectControl@@3U_GUID@@B DD 08514020bH	; IID_IFaceSelectControl
	DW	082a2H
	DW	042d9H
	DB	090H
	DB	019H
	DB	032H
	DB	0a4H
	DB	0eaH
	DB	0ceH
	DB	09fH
	DB	075H
$SG60130 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
?IID_ICustomFaceManager@@3U_GUID@@B DD 0bcd7ff05H	; IID_ICustomFaceManager
	DW	0a79H
	DW	04482H
	DB	09bH
	DB	0a6H
	DB	079H
	DB	0dfH
	DB	04bH
	DB	0d9H
	DB	080H
	DB	016H
$SG60177 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r'
	DB	00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG110357 DB	'A', 00H, 'p', 00H, 'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG110358 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG110359 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG110360 DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110361 DB	'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG110362 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110363 DB	'M', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110364 DB	'S', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG110365 DB	'S', 00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG110366 DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	00H, 00H
	ORG $+2
$SG110367 DB	'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110368 DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H
	DB	'b', 00H, 00H, 00H
$SG60224 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 00H, 00H
?IID_ITCPSocket@@3U_GUID@@B DD 0a870d592H		; IID_ITCPSocket
	DW	0447aH
	DW	040bdH
	DB	0aeH
	DB	04eH
	DB	05eH
	DB	064H
	DB	0deH
	DB	0ceH
	DB	022H
	DB	0edH
?IID_IPlazaUserManager@@3U_GUID@@B DD 0a2992ab9H	; IID_IPlazaUserManager
	DW	02fddH
	DW	04f9fH
	DB	0bbH
	DB	0acH
	DB	0cfH
	DB	08bH
	DB	060H
	DB	070H
	DB	080H
	DB	0cdH
$SG60271 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
?IID_IAndroidUserItemSink@@3U_GUID@@B DD 0967632cH	; IID_IAndroidUserItemSink
	DW	093daH
	DW	04f7fH
	DB	098H
	DB	0e4H
	DB	06fH
	DB	09fH
	DB	0f2H
	DB	0caH
	DB	07bH
	DB	0c4H
?IID_IGameUserManager@@3U_GUID@@B DD 0b0e334b9H		; IID_IGameUserManager
	DW	0f693H
	DW	04c5fH
	DB	087H
	DB	0fH
	DB	066H
	DB	077H
	DB	0aH
	DB	0b9H
	DB	093H
	DB	0b2H
?IID_IUDPSocket@@3U_GUID@@B DD 011e344d0H		; IID_IUDPSocket
	DW	0ace1H
	DW	04a72H
	DB	0abH
	DB	0acH
	DB	06fH
	DB	031H
	DB	013H
	DB	0bfH
	DB	0c9H
	DB	023H
$SG61324 DB	'a', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61325 DB	'b', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG61326 DB	'c', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61327 DB	'z', 00H, 'h', 00H, '-', 00H, 'C', 00H, 'H', 00H, 'S', 00H
	DB	00H, 00H
	ORG $+2
$SG61328 DB	'c', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61329 DB	'd', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61330 DB	'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61331 DB	'e', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61332 DB	'e', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61333 DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61334 DB	'f', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61335 DB	'f', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61336 DB	'h', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61337 DB	'h', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61338 DB	'i', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61339 DB	'i', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61340 DB	'j', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61341 DB	'k', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61342 DB	'n', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG60318 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o'
	DB	00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61343 DB	'n', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61344 DB	'p', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61345 DB	'p', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61346 DB	'r', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61347 DB	'r', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61348 DB	'h', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61349 DB	's', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61350 DB	's', 00H, 'q', 00H, 00H, 00H
	ORG $+2
$SG61351 DB	's', 00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG61352 DB	't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG61353 DB	't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61354 DB	'u', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61355 DB	'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG61356 DB	'u', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61357 DB	'b', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61358 DB	's', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61359 DB	'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61360 DB	'l', 00H, 'v', 00H, 00H, 00H
	ORG $+2
?IID_IGameLevelParser@@3U_GUID@@B DD 012823198H		; IID_IGameLevelParser
	DW	027b6H
	DW	046c5H
	DB	09cH
	DB	02cH
	DB	09cH
	DB	037H
	DB	08H
	DB	058H
	DB	0bfH
	DB	0faH
$SG61361 DB	'l', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61362 DB	'f', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61363 DB	'v', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61364 DB	'h', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61365 DB	'a', 00H, 'z', 00H, 00H, 00H
	ORG $+2
$SG61366 DB	'e', 00H, 'u', 00H, 00H, 00H
	ORG $+2
?IID_ITraceServiceManager@@3U_GUID@@B DD 06d14efe6H	; IID_ITraceServiceManager
	DW	0892aH
	DW	04a48H
	DB	092H
	DB	0c9H
	DB	0dbH
	DB	0eaH
	DB	092H
	DB	0ddH
	DB	0d5H
	DB	013H
$SG61367 DB	'm', 00H, 'k', 00H, 00H, 00H
	ORG $+2
?IID_IGameServiceManager@@3U_GUID@@B DD 0a975ccebH	; IID_IGameServiceManager
	DW	0331H
	DW	04553H
	DB	0a1H
	DB	0e0H
	DB	0a7H
	DB	0c7H
	DB	07aH
	DB	07cH
	DB	04eH
	DB	0fdH
$SG61368 DB	'a', 00H, 'f', 00H, 00H, 00H
	ORG $+2
$SG61369 DB	'k', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61370 DB	'f', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61371 DB	'h', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61372 DB	'm', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61373 DB	'k', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61374 DB	'k', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61375 DB	's', 00H, 'w', 00H, 00H, 00H
	ORG $+2
$SG61376 DB	'u', 00H, 'z', 00H, 00H, 00H
	ORG $+2
?IID_IWHNetwork@@3U_GUID@@B DD 0e500997bH		; IID_IWHNetwork
	DW	0e45eH
	DW	0474eH
	DB	08aH
	DB	0d4H
	DB	0bcH
	DB	0f3H
	DB	04dH
	DB	089H
	DB	045H
	DB	041H
$SG61377 DB	't', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61378 DB	'p', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61379 DB	'g', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61380 DB	't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61381 DB	't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61382 DB	'k', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61383 DB	'm', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61384 DB	's', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61385 DB	'm', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61386 DB	'g', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61387 DB	'k', 00H, 'o', 00H, 'k', 00H, 00H, 00H
$SG61388 DB	's', 00H, 'y', 00H, 'r', 00H, 00H, 00H
$SG61389 DB	'd', 00H, 'i', 00H, 'v', 00H, 00H, 00H
$SG60365 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i'
	DB	00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61390 DB	00H, 00H
	ORG $+2
$SG61391 DB	'a', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'A', 00H, 00H, 00H
?IID_IUserOrderParser@@3U_GUID@@B DD 0eff89495H		; IID_IUserOrderParser
	DW	0e9daH
	DW	04ea3H
	DB	083H
	DB	064H
	DB	0aaH
	DB	0b2H
	DB	0afH
	DB	07fH
	DB	03H
	DB	0ceH
$SG61392 DB	'b', 00H, 'g', 00H, '-', 00H, 'B', 00H, 'G', 00H, 00H, 00H
$SG61393 DB	'c', 00H, 'a', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61394 DB	'z', 00H, 'h', 00H, '-', 00H, 'T', 00H, 'W', 00H, 00H, 00H
$SG61395 DB	'c', 00H, 's', 00H, '-', 00H, 'C', 00H, 'Z', 00H, 00H, 00H
$SG61396 DB	'd', 00H, 'a', 00H, '-', 00H, 'D', 00H, 'K', 00H, 00H, 00H
$SG61397 DB	'd', 00H, 'e', 00H, '-', 00H, 'D', 00H, 'E', 00H, 00H, 00H
$SG61398 DB	'e', 00H, 'l', 00H, '-', 00H, 'G', 00H, 'R', 00H, 00H, 00H
$SG61399 DB	'e', 00H, 'n', 00H, '-', 00H, 'U', 00H, 'S', 00H, 00H, 00H
$SG61400 DB	'f', 00H, 'i', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H
$SG61401 DB	'f', 00H, 'r', 00H, '-', 00H, 'F', 00H, 'R', 00H, 00H, 00H
$SG61402 DB	'h', 00H, 'e', 00H, '-', 00H, 'I', 00H, 'L', 00H, 00H, 00H
$SG61403 DB	'h', 00H, 'u', 00H, '-', 00H, 'H', 00H, 'U', 00H, 00H, 00H
$SG61404 DB	'i', 00H, 's', 00H, '-', 00H, 'I', 00H, 'S', 00H, 00H, 00H
$SG61405 DB	'i', 00H, 't', 00H, '-', 00H, 'I', 00H, 'T', 00H, 00H, 00H
$SG61406 DB	'j', 00H, 'a', 00H, '-', 00H, 'J', 00H, 'P', 00H, 00H, 00H
$SG61407 DB	'k', 00H, 'o', 00H, '-', 00H, 'K', 00H, 'R', 00H, 00H, 00H
$SG61408 DB	'n', 00H, 'l', 00H, '-', 00H, 'N', 00H, 'L', 00H, 00H, 00H
$SG61409 DB	'n', 00H, 'b', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H
?IID_IAsynchronismEngine@@3U_GUID@@B DD 0e03ad33dH	; IID_IAsynchronismEngine
	DW	0b285H
	DW	048eaH
	DB	086H
	DB	070H
	DB	0aH
	DB	095H
	DB	055H
	DB	092H
	DB	07H
	DB	0e1H
$SG61410 DB	'p', 00H, 'l', 00H, '-', 00H, 'P', 00H, 'L', 00H, 00H, 00H
$SG61411 DB	'p', 00H, 't', 00H, '-', 00H, 'B', 00H, 'R', 00H, 00H, 00H
$SG61412 DB	'r', 00H, 'o', 00H, '-', 00H, 'R', 00H, 'O', 00H, 00H, 00H
$SG61413 DB	'r', 00H, 'u', 00H, '-', 00H, 'R', 00H, 'U', 00H, 00H, 00H
$SG61414 DB	'h', 00H, 'r', 00H, '-', 00H, 'H', 00H, 'R', 00H, 00H, 00H
$SG61415 DB	's', 00H, 'k', 00H, '-', 00H, 'S', 00H, 'K', 00H, 00H, 00H
$SG61416 DB	's', 00H, 'q', 00H, '-', 00H, 'A', 00H, 'L', 00H, 00H, 00H
$SG61417 DB	's', 00H, 'v', 00H, '-', 00H, 'S', 00H, 'E', 00H, 00H, 00H
$SG61418 DB	't', 00H, 'h', 00H, '-', 00H, 'T', 00H, 'H', 00H, 00H, 00H
$SG61419 DB	't', 00H, 'r', 00H, '-', 00H, 'T', 00H, 'R', 00H, 00H, 00H
$SG61420 DB	'u', 00H, 'r', 00H, '-', 00H, 'P', 00H, 'K', 00H, 00H, 00H
$SG61421 DB	'i', 00H, 'd', 00H, '-', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG61422 DB	'u', 00H, 'k', 00H, '-', 00H, 'U', 00H, 'A', 00H, 00H, 00H
$SG61423 DB	'b', 00H, 'e', 00H, '-', 00H, 'B', 00H, 'Y', 00H, 00H, 00H
$SG61424 DB	's', 00H, 'l', 00H, '-', 00H, 'S', 00H, 'I', 00H, 00H, 00H
$SG61425 DB	'e', 00H, 't', 00H, '-', 00H, 'E', 00H, 'E', 00H, 00H, 00H
$SG61426 DB	'l', 00H, 'v', 00H, '-', 00H, 'L', 00H, 'V', 00H, 00H, 00H
$SG61427 DB	'l', 00H, 't', 00H, '-', 00H, 'L', 00H, 'T', 00H, 00H, 00H
$SG61428 DB	'f', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'R', 00H, 00H, 00H
$SG61429 DB	'v', 00H, 'i', 00H, '-', 00H, 'V', 00H, 'N', 00H, 00H, 00H
$SG61430 DB	'h', 00H, 'y', 00H, '-', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG61431 DB	'a', 00H, 'z', 00H, '-', 00H, 'A', 00H, 'Z', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61432 DB	'e', 00H, 'u', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61433 DB	'm', 00H, 'k', 00H, '-', 00H, 'M', 00H, 'K', 00H, 00H, 00H
$SG61434 DB	't', 00H, 'n', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61435 DB	'x', 00H, 'h', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61436 DB	'z', 00H, 'u', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG60412 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm'
	DB	00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG61437 DB	'a', 00H, 'f', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61438 DB	'k', 00H, 'a', 00H, '-', 00H, 'G', 00H, 'E', 00H, 00H, 00H
$SG61439 DB	'f', 00H, 'o', 00H, '-', 00H, 'F', 00H, 'O', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	??$AtlMultiply@K@ATL@@YAJPAKKK@Z		; ATL::AtlMultiply<unsigned long>
PUBLIC	??$AtlAdd@K@ATL@@YAJPAKKK@Z			; ATL::AtlAdd<unsigned long>
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0CWin32Heap@ATL@@QAE@PAX@Z			; ATL::CWin32Heap::CWin32Heap
PUBLIC	??1CWin32Heap@ATL@@UAE@XZ			; ATL::CWin32Heap::~CWin32Heap
PUBLIC	?Allocate@CWin32Heap@ATL@@UAEPAXI@Z		; ATL::CWin32Heap::Allocate
PUBLIC	?Free@CWin32Heap@ATL@@UAEXPAX@Z			; ATL::CWin32Heap::Free
PUBLIC	?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z	; ATL::CWin32Heap::Reallocate
PUBLIC	?GetSize@CWin32Heap@ATL@@UAEIPAX@Z		; ATL::CWin32Heap::GetSize
PUBLIC	??_GCWin32Heap@ATL@@UAEPAXI@Z			; ATL::CWin32Heap::`scalar deleting destructor'
PUBLIC	??$AtlAdd@I@ATL@@YAJPAIII@Z			; ATL::AtlAdd<unsigned int>
PUBLIC	??$AtlAdd@H@ATL@@YAJPAHHH@Z			; ATL::AtlAdd<int>
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
PUBLIC	??0CNilStringData@ATL@@QAE@XZ			; ATL::CNilStringData::CNilStringData
PUBLIC	?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z ; ATL::CNilStringData::SetManager
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z	; ATL::CAtlStringMgr::CAtlStringMgr
PUBLIC	??1CAtlStringMgr@ATL@@UAE@XZ			; ATL::CAtlStringMgr::~CAtlStringMgr
PUBLIC	?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::CAtlStringMgr::GetInstance
PUBLIC	?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z ; ATL::CAtlStringMgr::Allocate
PUBLIC	?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z ; ATL::CAtlStringMgr::Free
PUBLIC	?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z ; ATL::CAtlStringMgr::Reallocate
PUBLIC	?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ ; ATL::CAtlStringMgr::GetNilString
PUBLIC	?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ ; ATL::CAtlStringMgr::Clone
PUBLIC	?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ	; ATL::CAtlStringMgr::StaticInitialize
PUBLIC	??_GCAtlStringMgr@ATL@@UAEPAXI@Z		; ATL::CAtlStringMgr::`scalar deleting destructor'
PUBLIC	??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap''
PUBLIC	??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr''
PUBLIC	??$AtlAlignUp@H@ATL@@YGHHK@Z			; ATL::AtlAlignUp<int>
PUBLIC	??0CDCCache@CImage@ATL@@QAE@XZ			; ATL::CImage::CDCCache::CDCCache
PUBLIC	??1CDCCache@CImage@ATL@@QAE@XZ			; ATL::CImage::CDCCache::~CDCCache
PUBLIC	??0CInitGDIPlus@CImage@ATL@@QAE@XZ		; ATL::CImage::CInitGDIPlus::CInitGDIPlus
PUBLIC	??1CInitGDIPlus@CImage@ATL@@QAE@XZ		; ATL::CImage::CInitGDIPlus::~CInitGDIPlus
PUBLIC	?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ	; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus
PUBLIC	?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ ; ATL::CImage::GetInitGDIPlusInstance
PUBLIC	?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ ; ATL::CImage::GetCDCCacheInstance
PUBLIC	?CImageStaticInitialize@CImage@ATL@@CA_NXZ	; ATL::CImage::CImageStaticInitialize
PUBLIC	??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus''
PUBLIC	??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache''
PUBLIC	??0CChiHuRight@@QAE@XZ				; CChiHuRight::CChiHuRight
PUBLIC	??4CChiHuRight@@QAEAAV0@K@Z			; CChiHuRight::operator=
PUBLIC	??_4CChiHuRight@@QAEAAV0@K@Z			; CChiHuRight::operator&=
PUBLIC	??_5CChiHuRight@@QAEAAV0@K@Z			; CChiHuRight::operator|=
PUBLIC	??ICChiHuRight@@QAE?AV0@K@Z			; CChiHuRight::operator&
PUBLIC	??ICChiHuRight@@QBE?AV0@K@Z			; CChiHuRight::operator&
PUBLIC	??UCChiHuRight@@QAE?AV0@K@Z			; CChiHuRight::operator|
PUBLIC	??UCChiHuRight@@QBE?AV0@K@Z			; CChiHuRight::operator|
PUBLIC	??8CChiHuRight@@QBE_NK@Z			; CChiHuRight::operator==
PUBLIC	??8CChiHuRight@@QBE_NV0@@Z			; CChiHuRight::operator==
PUBLIC	??9CChiHuRight@@QBE_NK@Z			; CChiHuRight::operator!=
PUBLIC	??9CChiHuRight@@QBE_NV0@@Z			; CChiHuRight::operator!=
PUBLIC	?IsEmpty@CChiHuRight@@QAE_NXZ			; CChiHuRight::IsEmpty
PUBLIC	?SetEmpty@CChiHuRight@@QAEXXZ			; CChiHuRight::SetEmpty
PUBLIC	?GetRightData@CChiHuRight@@QAEEQAKE@Z		; CChiHuRight::GetRightData
PUBLIC	?SetRightData@CChiHuRight@@QAE_NQBKE@Z		; CChiHuRight::SetRightData
PUBLIC	?IsValidRight@CChiHuRight@@AAE_NK@Z		; CChiHuRight::IsValidRight
PUBLIC	??0CGameLogic@@QAE@XZ				; CGameLogic::CGameLogic
PUBLIC	??1CGameLogic@@UAE@XZ				; CGameLogic::~CGameLogic
PUBLIC	?RandCardList@CGameLogic@@QAEXQAEE@Z		; CGameLogic::RandCardList
PUBLIC	?RandCardList@CGameLogic@@QAEXQAE0E@Z		; CGameLogic::RandCardList
PUBLIC	?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z		; CGameLogic::RemoveCard
PUBLIC	?RemoveCard@CGameLogic@@QAE_NQAEE@Z		; CGameLogic::RemoveCard
PUBLIC	?SortCardList@CGameLogic@@QAE_NQAEE@Z		; CGameLogic::SortCardList
PUBLIC	?RemoveCard@CGameLogic@@QAE_NQAEEQBEE@Z		; CGameLogic::RemoveCard
PUBLIC	?IsMagicCard@CGameLogic@@QAE_NE@Z		; CGameLogic::IsMagicCard
PUBLIC	?IsHuaCard@CGameLogic@@QAE_NE@Z			; CGameLogic::IsHuaCard
PUBLIC	?IsHuaCard@CGameLogic@@QAEEQAE@Z		; CGameLogic::IsHuaCard
PUBLIC	?GetUserActionRank@CGameLogic@@QAEEE@Z		; CGameLogic::GetUserActionRank
PUBLIC	?GetChiHuActionRank@CGameLogic@@QAEGABVCChiHuRight@@@Z ; CGameLogic::GetChiHuActionRank
PUBLIC	?GetChiHuTime@CGameLogic@@QAEGABVCChiHuRight@@@Z ; CGameLogic::GetChiHuTime
PUBLIC	?AutomatismOutCard@CGameLogic@@QAEEQBE0E@Z	; CGameLogic::AutomatismOutCard
PUBLIC	?EstimateEatCard@CGameLogic@@QAEEQBEE@Z		; CGameLogic::EstimateEatCard
PUBLIC	?EstimatePengCard@CGameLogic@@QAEEQBEE@Z	; CGameLogic::EstimatePengCard
PUBLIC	?EstimateGangCard@CGameLogic@@QAEEQBEE@Z	; CGameLogic::EstimateGangCard
PUBLIC	?AnalyseGangCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAUtagGangCardResult@@@Z ; CGameLogic::AnalyseGangCard
PUBLIC	?AnalyseGangCardEx@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAUtagGangCardResult@@@Z ; CGameLogic::AnalyseGangCardEx
PUBLIC	?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
PUBLIC	?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@E@Z ; CGameLogic::AnalyseTingCard
PUBLIC	?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAY0BM@E@Z ; CGameLogic::AnalyseTingCard
PUBLIC	?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z ; CGameLogic::AnalyseTingCard
PUBLIC	?GetHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAE@Z ; CGameLogic::GetHuCard
PUBLIC	?SwitchToCardData@CGameLogic@@QAEEE@Z		; CGameLogic::SwitchToCardData
PUBLIC	?SwitchToCardIndex@CGameLogic@@QAEEE@Z		; CGameLogic::SwitchToCardIndex
PUBLIC	?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z	; CGameLogic::SwitchToCardData
PUBLIC	?SwitchToCardIndex@CGameLogic@@QAEEQBEEQAE@Z	; CGameLogic::SwitchToCardIndex
PUBLIC	?IsValidCard@CGameLogic@@QAE_NE@Z		; CGameLogic::IsValidCard
PUBLIC	?GetCardCount@CGameLogic@@QAEEQBE@Z		; CGameLogic::GetCardCount
PUBLIC	?GetWeaveCard@CGameLogic@@QAEEEEQAE@Z		; CGameLogic::GetWeaveCard
PUBLIC	?AddKindItem@CGameLogic@@AAE_NAAUtagKindItem@@QAU2@AAEAA_N@Z ; CGameLogic::AddKindItem
PUBLIC	?AnalyseCard@CGameLogic@@AAE_NQBEQBUtagWeaveItem@@EAAV?$CWHArray@UtagAnalyseItem@@AAU1@@@@Z ; CGameLogic::AnalyseCard
PUBLIC	?IsPengPeng@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z ; CGameLogic::IsPengPeng
PUBLIC	?IsMaQi@CGameLogic@@IAE_NQBEEAAVCChiHuRight@@@Z	; CGameLogic::IsMaQi
PUBLIC	?IsShiSanLan@CGameLogic@@IAE_NQBEEAAVCChiHuRight@@@Z ; CGameLogic::IsShiSanLan
PUBLIC	?IsPingHu@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z ; CGameLogic::IsPingHu
PUBLIC	?IsJiHu@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z	; CGameLogic::IsJiHu
PUBLIC	?IsQingYiSe@CGameLogic@@IAE_NPBUtagAnalyseItem@@AA_N@Z ; CGameLogic::IsQingYiSe
PUBLIC	?IsHunYiSe@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z ; CGameLogic::IsHunYiSe
PUBLIC	??_GCGameLogic@@UAEPAXI@Z			; CGameLogic::`scalar deleting destructor'
PUBLIC	??$pow@HH@@YANHH@Z				; pow<int,int>
PUBLIC	??0?$CWHArray@UtagAnalyseItem@@AAU1@@@QAE@XZ	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::CWHArray<tagAnalyseItem,tagAnalyseItem &>
PUBLIC	??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>
PUBLIC	?GetCount@?$CWHArray@UtagAnalyseItem@@AAU1@@@QBEHXZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::GetCount
PUBLIC	?Add@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEHAAUtagAnalyseItem@@@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::Add
PUBLIC	?SetSize@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetSize
PUBLIC	?SetAtGrow@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXHAAUtagAnalyseItem@@@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetAtGrow
PUBLIC	?RemoveAll@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXXZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::RemoveAll
PUBLIC	?AllocMemory@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::AllocMemory
PUBLIC	??_G?$CWHArray@UtagAnalyseItem@@AAU1@@@UAEPAXI@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`scalar deleting destructor'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	??_7CWin32Heap@ATL@@6B@				; ATL::CWin32Heap::`vftable'
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?isInitialized@CAtlStringMgr@ATL@@0_NA		; ATL::CAtlStringMgr::isInitialized
PUBLIC	??_7CAtlStringMgr@ATL@@6B@			; ATL::CAtlStringMgr::`vftable'
PUBLIC	?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
PUBLIC	?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
PUBLIC	?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
PUBLIC	?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
PUBLIC	?isCImageStaticInitialized@CImage@ATL@@0_NA	; ATL::CImage::isCImageStaticInitialized
PUBLIC	?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
PUBLIC	?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
PUBLIC	?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
PUBLIC	?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
PUBLIC	??_7CGameLogic@@6B@				; CGameLogic::`vftable'
PUBLIC	??_7?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`vftable'
PUBLIC	??_R4CWin32Heap@ATL@@6B@			; ATL::CWin32Heap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCWin32Heap@ATL@@@8			; ATL::CWin32Heap `RTTI Type Descriptor'
PUBLIC	??_R3CWin32Heap@ATL@@8				; ATL::CWin32Heap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWin32Heap@ATL@@8				; ATL::CWin32Heap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CWin32Heap@ATL@@8			; ATL::CWin32Heap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IAtlMemMgr@ATL@@8			; ATL::IAtlMemMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIAtlMemMgr@ATL@@@8			; ATL::IAtlMemMgr `RTTI Type Descriptor'
PUBLIC	??_R3IAtlMemMgr@ATL@@8				; ATL::IAtlMemMgr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IAtlMemMgr@ATL@@8				; ATL::IAtlMemMgr::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IAtlStringMgr@ATL@@8		; ATL::IAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIAtlStringMgr@ATL@@@8			; ATL::IAtlStringMgr `RTTI Type Descriptor'
PUBLIC	??_R3IAtlStringMgr@ATL@@8			; ATL::IAtlStringMgr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IAtlStringMgr@ATL@@8			; ATL::IAtlStringMgr::`RTTI Base Class Array'
PUBLIC	??_R4CAtlStringMgr@ATL@@6B@			; ATL::CAtlStringMgr::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAtlStringMgr@ATL@@@8			; ATL::CAtlStringMgr `RTTI Type Descriptor'
PUBLIC	??_R3CAtlStringMgr@ATL@@8			; ATL::CAtlStringMgr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAtlStringMgr@ATL@@8			; ATL::CAtlStringMgr::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAtlStringMgr@ATL@@8		; ATL::CAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CWHArray@UtagAnalyseItem@@AAU1@@@@8	; CWHArray<tagAnalyseItem,tagAnalyseItem &> `RTTI Type Descriptor'
PUBLIC	??_R3?$CWHArray@UtagAnalyseItem@@AAU1@@@8	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CWHArray@UtagAnalyseItem@@AAU1@@@8	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CWHArray@UtagAnalyseItem@@AAU1@@@8 ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CGameLogic@@6B@				; CGameLogic::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGameLogic@@@8				; CGameLogic `RTTI Type Descriptor'
PUBLIC	??_R3CGameLogic@@8				; CGameLogic::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGameLogic@@8				; CGameLogic::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGameLogic@@8			; CGameLogic::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__HeapDestroy@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapReAlloc@16:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__HeapSize@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__rand:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	??_ECWin32Heap@ATL@@UAEPAXI@Z:PROC		; ATL::CWin32Heap::`vector deleting destructor'
EXTRN	_pow:PROC
EXTRN	??_ECAtlStringMgr@ATL@@UAEPAXI@Z:PROC		; ATL::CAtlStringMgr::`vector deleting destructor'
EXTRN	_GdiplusShutdown@4:PROC
EXTRN	??_ECGameLogic@@UAEPAXI@Z:PROC			; CGameLogic::`vector deleting destructor'
EXTRN	??_E?$CWHArray@UtagAnalyseItem@@AAU1@@@UAEPAXI@Z:PROC ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__dtoui3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___ImageBase:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_BSS	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 028H DUP (?)	; ATL::_AtlComModule
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?isInitialized@CAtlStringMgr@ATL@@0_NA
_BSS	SEGMENT
?isInitialized@CAtlStringMgr@ATL@@0_NA DB 01H DUP (?)	; ATL::CAtlStringMgr::isInitialized
_BSS	ENDS
;	COMDAT ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A
_BSS	SEGMENT
?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A DB 0cH DUP (?) ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A
_BSS	SEGMENT
?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A DB 01cH DUP (?) ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
_BSS	ENDS
;	COMDAT ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA
_BSS	SEGMENT
?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA DD 01H DUP (?) ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?isCImageStaticInitialized@CImage@ATL@@0_NA
_BSS	SEGMENT
?isCImageStaticInitialized@CImage@ATL@@0_NA DB 01H DUP (?) ; ATL::CImage::isCImageStaticInitialized
_BSS	ENDS
;	COMDAT ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A
_BSS	SEGMENT
?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A DB 024H DUP (?) ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A
_BSS	SEGMENT
?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A DB 010H DUP (?) ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceGeneral$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceGeneral@ATL@@YAXXZ ; ATL::atlTraceGeneral$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CGameLogic@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGameLogic@@8 DD FLAT:??_R0?AVCGameLogic@@@8 ; CGameLogic::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGameLogic@@8
rdata$r	ENDS
;	COMDAT ??_R2CGameLogic@@8
rdata$r	SEGMENT
??_R2CGameLogic@@8 DD FLAT:??_R1A@?0A@EA@CGameLogic@@8	; CGameLogic::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGameLogic@@8
rdata$r	SEGMENT
??_R3CGameLogic@@8 DD 00H				; CGameLogic::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGameLogic@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGameLogic@@@8
data$r	SEGMENT
??_R0?AVCGameLogic@@@8 DD FLAT:??_7type_info@@6B@	; CGameLogic `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGameLogic@@', 00H
data$r	ENDS
;	COMDAT ??_R4CGameLogic@@6B@
rdata$r	SEGMENT
??_R4CGameLogic@@6B@ DD 00H				; CGameLogic::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGameLogic@@@8
	DD	FLAT:??_R3CGameLogic@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CWHArray@UtagAnalyseItem@@AAU1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CWHArray@UtagAnalyseItem@@AAU1@@@8 DD FLAT:??_R0?AV?$CWHArray@UtagAnalyseItem@@AAU1@@@@8 ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CWHArray@UtagAnalyseItem@@AAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CWHArray@UtagAnalyseItem@@AAU1@@@8
rdata$r	SEGMENT
??_R2?$CWHArray@UtagAnalyseItem@@AAU1@@@8 DD FLAT:??_R1A@?0A@EA@?$CWHArray@UtagAnalyseItem@@AAU1@@@8 ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CWHArray@UtagAnalyseItem@@AAU1@@@8
rdata$r	SEGMENT
??_R3?$CWHArray@UtagAnalyseItem@@AAU1@@@8 DD 00H	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CWHArray@UtagAnalyseItem@@AAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CWHArray@UtagAnalyseItem@@AAU1@@@@8
data$r	SEGMENT
??_R0?AV?$CWHArray@UtagAnalyseItem@@AAU1@@@@8 DD FLAT:??_7type_info@@6B@ ; CWHArray<tagAnalyseItem,tagAnalyseItem &> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CWHArray@UtagAnalyseItem@@AAU1@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@
rdata$r	SEGMENT
??_R4?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@ DD 00H	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CWHArray@UtagAnalyseItem@@AAU1@@@@8
	DD	FLAT:??_R3?$CWHArray@UtagAnalyseItem@@AAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAtlStringMgr@ATL@@8 DD FLAT:??_R0?AVCAtlStringMgr@ATL@@@8 ; ATL::CAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2CAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R2CAtlStringMgr@ATL@@8 DD FLAT:??_R1A@?0A@EA@CAtlStringMgr@ATL@@8 ; ATL::CAtlStringMgr::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R3CAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R3CAtlStringMgr@ATL@@8 DD 00H			; ATL::CAtlStringMgr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAtlStringMgr@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlStringMgr@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlStringMgr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlStringMgr@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R4CAtlStringMgr@ATL@@6B@
rdata$r	SEGMENT
??_R4CAtlStringMgr@ATL@@6B@ DD 00H			; ATL::CAtlStringMgr::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAtlStringMgr@ATL@@@8
	DD	FLAT:??_R3CAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2IAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R2IAtlStringMgr@ATL@@8 DD FLAT:??_R1A@?0A@EA@IAtlStringMgr@ATL@@8 ; ATL::IAtlStringMgr::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R3IAtlStringMgr@ATL@@8 DD 00H			; ATL::IAtlStringMgr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlStringMgr@ATL@@@8
data$r	SEGMENT
??_R0?AUIAtlStringMgr@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::IAtlStringMgr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIAtlStringMgr@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAtlStringMgr@ATL@@8 DD FLAT:??_R0?AUIAtlStringMgr@ATL@@@8 ; ATL::IAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2IAtlMemMgr@ATL@@8
rdata$r	SEGMENT
??_R2IAtlMemMgr@ATL@@8 DD FLAT:??_R1A@?0A@EA@IAtlMemMgr@ATL@@8 ; ATL::IAtlMemMgr::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IAtlMemMgr@ATL@@8
rdata$r	SEGMENT
??_R3IAtlMemMgr@ATL@@8 DD 00H				; ATL::IAtlMemMgr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IAtlMemMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlMemMgr@ATL@@@8
data$r	SEGMENT
??_R0?AUIAtlMemMgr@ATL@@@8 DD FLAT:??_7type_info@@6B@	; ATL::IAtlMemMgr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIAtlMemMgr@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAtlMemMgr@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAtlMemMgr@ATL@@8 DD FLAT:??_R0?AUIAtlMemMgr@ATL@@@8 ; ATL::IAtlMemMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAtlMemMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CWin32Heap@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWin32Heap@ATL@@8 DD FLAT:??_R0?AVCWin32Heap@ATL@@@8 ; ATL::CWin32Heap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWin32Heap@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2CWin32Heap@ATL@@8
rdata$r	SEGMENT
??_R2CWin32Heap@ATL@@8 DD FLAT:??_R1A@?0A@EA@CWin32Heap@ATL@@8 ; ATL::CWin32Heap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IAtlMemMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R3CWin32Heap@ATL@@8
rdata$r	SEGMENT
??_R3CWin32Heap@ATL@@8 DD 00H				; ATL::CWin32Heap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CWin32Heap@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWin32Heap@ATL@@@8
data$r	SEGMENT
??_R0?AVCWin32Heap@ATL@@@8 DD FLAT:??_7type_info@@6B@	; ATL::CWin32Heap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWin32Heap@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R4CWin32Heap@ATL@@6B@
rdata$r	SEGMENT
??_R4CWin32Heap@ATL@@6B@ DD 00H				; ATL::CWin32Heap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCWin32Heap@ATL@@@8
	DD	FLAT:??_R3CWin32Heap@ATL@@8
rdata$r	ENDS
;	COMDAT ??_7?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@
CONST	SEGMENT
??_7?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@ DD FLAT:??_R4?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`vftable'
	DD	FLAT:??_E?$CWHArray@UtagAnalyseItem@@AAU1@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CGameLogic@@6B@
CONST	SEGMENT
??_7CGameLogic@@6B@ DD FLAT:??_R4CGameLogic@@6B@	; CGameLogic::`vftable'
	DD	FLAT:??_ECGameLogic@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT
??_7CAtlStringMgr@ATL@@6B@ DD FLAT:??_R4CAtlStringMgr@ATL@@6B@ ; ATL::CAtlStringMgr::`vftable'
	DD	FLAT:?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
	DD	FLAT:?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
	DD	FLAT:?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
	DD	FLAT:?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
	DD	FLAT:?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
	DD	FLAT:??_ECAtlStringMgr@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CWin32Heap@ATL@@6B@
CONST	SEGMENT
??_7CWin32Heap@ATL@@6B@ DD FLAT:??_R4CWin32Heap@ATL@@6B@ ; ATL::CWin32Heap::`vftable'
	DD	FLAT:?Allocate@CWin32Heap@ATL@@UAEPAXI@Z
	DD	FLAT:?Free@CWin32Heap@ATL@@UAEXPAX@Z
	DD	FLAT:?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z
	DD	FLAT:?GetSize@CWin32Heap@ATL@@UAEIPAX@Z
	DD	FLAT:??_ECWin32Heap@ATL@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z$0
__ehfuncinfo$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceCOM$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceCOM@ATL@@YAXXZ ; ATL::atlTraceCOM$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceQI$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceQI@ATL@@YAXXZ ; ATL::atlTraceQI$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceRegistrar$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceRegistrar@ATL@@YAXXZ ; ATL::atlTraceRegistrar$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceRefcount$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceRefcount@ATL@@YAXXZ ; ATL::atlTraceRefcount$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceWindowing$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceWindowing@ATL@@YAXXZ ; ATL::atlTraceWindowing$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceControls$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceControls@ATL@@YAXXZ ; ATL::atlTraceControls$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceHosting$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceHosting@ATL@@YAXXZ ; ATL::atlTraceHosting$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceDBClient$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceDBClient@ATL@@YAXXZ ; ATL::atlTraceDBClient$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceDBProvider$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceDBProvider@ATL@@YAXXZ ; ATL::atlTraceDBProvider$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceSnapin$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceSnapin@ATL@@YAXXZ ; ATL::atlTraceSnapin$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceNotImpl$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceNotImpl@ATL@@YAXXZ ; ATL::atlTraceNotImpl$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceAllocation$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceAllocation@ATL@@YAXXZ ; ATL::atlTraceAllocation$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceException$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceException@ATL@@YAXXZ ; ATL::atlTraceException$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceTime$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceTime@ATL@@YAXXZ ; ATL::atlTraceTime$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceCache$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceCache@ATL@@YAXXZ ; ATL::atlTraceCache$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceStencil$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceStencil@ATL@@YAXXZ ; ATL::atlTraceStencil$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceString$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceString@ATL@@YAXXZ ; ATL::atlTraceString$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceMap$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceMap@ATL@@YAXXZ ; ATL::atlTraceMap$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceUtil$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceUtil@ATL@@YAXXZ ; ATL::atlTraceUtil$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceSecurity$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceSecurity@ATL@@YAXXZ ; ATL::atlTraceSecurity$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceSync$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceSync@ATL@@YAXXZ ; ATL::atlTraceSync$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceISAPI$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceISAPI@ATL@@YAXXZ ; ATL::atlTraceISAPI$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??isInitialized$initializer$@CAtlStringMgr@ATL@@0P6AXXZA@@3P6AXXZA DD FLAT:??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ ; ??isInitialized$initializer$@CAtlStringMgr@ATL@@0P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??isCImageStaticInitialized$initializer$@CImage@ATL@@0P6AXXZA@@3P6AXXZA DD FLAT:??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ ; ??isCImageStaticInitialized$initializer$@CImage@ATL@@0P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CWHArray@UtagAnalyseItem@@AAU1@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CWHArray@UtagAnalyseItem@@AAU1@@@UAEPAXI@Z PROC	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CWHArray@UtagAnalyseItem@@AAU1@@@UAEPAXI@Z ENDP	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ?AllocMemory@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv73 = -20						; size = 4
tv72 = -16						; size = 4
_pNewData$3 = -12					; size = 4
_nGrowCount$4 = -8					; size = 4
_this$ = -4						; size = 4
_nNewCount$ = 8						; size = 4
?AllocMemory@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z PROC ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::AllocMemory, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 414  : 	//效验参数
; 415  : 	ASSERT(nNewCount>=0);
; 416  : 
; 417  : 	if (nNewCount>m_nMaxCount)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _nNewCount$[ebp]
  0000f	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00012	0f 8e d7 00 00
	00		 jle	 $LN1@AllocMemor

; 418  : 	{
; 419  : 		//计算数目
; 420  : 		INT_PTR nGrowCount=m_nGrowCount;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001e	89 45 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], eax

; 421  : 		if (nGrowCount==0)

  00021	83 7d f8 00	 cmp	 DWORD PTR _nGrowCount$4[ebp], 0
  00025	75 45		 jne	 SHORT $LN3@AllocMemor

; 422  : 		{
; 423  : 			nGrowCount=m_nElementCount/8;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002d	99		 cdq
  0002e	83 e2 07	 and	 edx, 7
  00031	03 c2		 add	 eax, edx
  00033	c1 f8 03	 sar	 eax, 3
  00036	89 45 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], eax

; 424  : 			nGrowCount=(nGrowCount<4)?4:((nGrowCount>1024)?1024:nGrowCount);

  00039	83 7d f8 04	 cmp	 DWORD PTR _nGrowCount$4[ebp], 4
  0003d	7d 09		 jge	 SHORT $LN7@AllocMemor
  0003f	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR tv73[ebp], 4
  00046	eb 1e		 jmp	 SHORT $LN8@AllocMemor
$LN7@AllocMemor:
  00048	81 7d f8 00 04
	00 00		 cmp	 DWORD PTR _nGrowCount$4[ebp], 1024 ; 00000400H
  0004f	7e 09		 jle	 SHORT $LN5@AllocMemor
  00051	c7 45 f0 00 04
	00 00		 mov	 DWORD PTR tv72[ebp], 1024 ; 00000400H
  00058	eb 06		 jmp	 SHORT $LN6@AllocMemor
$LN5@AllocMemor:
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _nGrowCount$4[ebp]
  0005d	89 55 f0	 mov	 DWORD PTR tv72[ebp], edx
$LN6@AllocMemor:
  00060	8b 45 f0	 mov	 eax, DWORD PTR tv72[ebp]
  00063	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$LN8@AllocMemor:
  00066	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00069	89 4d f8	 mov	 DWORD PTR _nGrowCount$4[ebp], ecx
$LN3@AllocMemor:

; 425  : 		}
; 426  : 		nNewCount+=nGrowCount;

  0006c	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  0006f	03 55 f8	 add	 edx, DWORD PTR _nGrowCount$4[ebp]
  00072	89 55 08	 mov	 DWORD PTR _nNewCount$[ebp], edx

; 427  : 
; 428  : 		//申请内存
; 429  : 		TYPE * pNewData=(TYPE *) new BYTE[nNewCount*sizeof(TYPE)];

  00075	6b 45 08 1a	 imul	 eax, DWORD PTR _nNewCount$[ebp], 26
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0007f	83 c4 04	 add	 esp, 4
  00082	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00085	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  00088	89 4d f4	 mov	 DWORD PTR _pNewData$3[ebp], ecx

; 430  : 		memcpy(pNewData,m_pData,m_nElementCount*sizeof(TYPE));

  0008b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008e	6b 42 10 1a	 imul	 eax, DWORD PTR [edx+16], 26
  00092	50		 push	 eax
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00099	52		 push	 edx
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _memcpy
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 		memset(pNewData+m_nElementCount,0,(nNewCount-m_nElementCount)*sizeof(TYPE));

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  000ac	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  000af	6b c2 1a	 imul	 eax, edx, 26
  000b2	50		 push	 eax
  000b3	6a 00		 push	 0
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	6b 51 10 1a	 imul	 edx, DWORD PTR [ecx+16], 26
  000bc	03 55 f4	 add	 edx, DWORD PTR _pNewData$3[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _memset
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		delete [] (BYTE *)m_pData;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ce	89 4d e4	 mov	 DWORD PTR $T1[ebp], ecx
  000d1	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000da	83 c4 04	 add	 esp, 4

; 433  : 
; 434  : 		//设置变量
; 435  : 		m_pData=pNewData;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR _pNewData$3[ebp]
  000e3	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 436  : 		m_nMaxCount=nNewCount;

  000e6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  000ec	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN1@AllocMemor:

; 437  : 	}
; 438  : 
; 439  : 	return;
; 440  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
?AllocMemory@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z ENDP ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::AllocMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ?RemoveAll@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXXZ PROC ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::RemoveAll, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	if (m_nElementCount>0)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	7e 42		 jle	 SHORT $LN1@RemoveAll

; 381  : 	{
; 382  : 		for (INT_PTR i=0;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@RemoveAll
$LN2@RemoveAll:
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0001e	83 c1 01	 add	 ecx, 1
  00021	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002d	7d 02		 jge	 SHORT $LN3@RemoveAll
  0002f	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN3@RemoveAll:

; 383  : 		memset(m_pData,0,m_nElementCount*sizeof(TYPE));

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	6b 51 10 1a	 imul	 edx, DWORD PTR [ecx+16], 26
  00038	52		 push	 edx
  00039	6a 00		 push	 0
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _memset
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 		m_nElementCount=0;

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
$LN1@RemoveAll:

; 385  : 	}
; 386  : 
; 387  : 	return;
; 388  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?RemoveAll@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXXZ ENDP ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ?SetAtGrow@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXHAAUtagAnalyseItem@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXHAAUtagAnalyseItem@@@Z PROC ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetAtGrow, COMDAT
; _this$ = ecx

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	//效验参数
; 289  : 	ASSERT(nIndex>=0);
; 290  : 	if (nIndex<0) AfxThrowInvalidArgException();

  00009	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000d	7d 05		 jge	 SHORT $LN2@SetAtGrow
  0000f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@SetAtGrow:

; 291  : 
; 292  : 	//设置元素
; 293  : 	if (nIndex>=m_nElementCount) SetSize(m_nElementCount+1);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0001a	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0001d	7c 12		 jl	 SHORT $LN3@SetAtGrow
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00025	83 c0 01	 add	 eax, 1
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?SetSize@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetSize
$LN3@SetAtGrow:

; 294  : 	m_pData[nIndex]=newElement;

  00031	6b 4d 08 1a	 imul	 ecx, DWORD PTR _nIndex$[ebp], 26
  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0003b	03 f9		 add	 edi, ecx
  0003d	b9 06 00 00 00	 mov	 ecx, 6
  00042	8b 75 0c	 mov	 esi, DWORD PTR _newElement$[ebp]
  00045	f3 a5		 rep movsd
  00047	66 a5		 movsw
$LN4@SetAtGrow:

; 295  : 
; 296  : 	return;
; 297  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
?SetAtGrow@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXHAAUtagAnalyseItem@@@Z ENDP ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ?SetSize@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_i$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
_nNewSize$ = 8						; size = 4
?SetSize@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z PROC ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetSize, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 	//效验参数
; 254  : 	ASSERT(nNewSize>=0);
; 255  : 	if (nNewSize<0)	AfxThrowInvalidArgException();

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0000d	7d 05		 jge	 SHORT $LN8@SetSize
  0000f	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN8@SetSize:

; 256  : 	
; 257  : 	//设置大小
; 258  : 	AllocMemory(nNewSize);

  00014	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::AllocMemory

; 259  : 	if (nNewSize>m_nElementCount)

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00026	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00029	7e 38		 jle	 SHORT $LN9@SetSize

; 260  : 	{
; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00031	89 4d f8	 mov	 DWORD PTR _i$3[ebp], ecx
  00034	eb 09		 jmp	 SHORT $LN4@SetSize
$LN2@SetSize:
  00036	8b 55 f8	 mov	 edx, DWORD PTR _i$3[ebp]
  00039	83 c2 01	 add	 edx, 1
  0003c	89 55 f8	 mov	 DWORD PTR _i$3[ebp], edx
$LN4@SetSize:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00042	3b 45 08	 cmp	 eax, DWORD PTR _nNewSize$[ebp]
  00045	7d 1a		 jge	 SHORT $LN3@SetSize
  00047	6b 4d f8 1a	 imul	 ecx, DWORD PTR _i$3[ebp], 26
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00051	51		 push	 ecx
  00052	6a 1a		 push	 26			; 0000001aH
  00054	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00059	83 c4 08	 add	 esp, 8
  0005c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0005f	eb d5		 jmp	 SHORT $LN2@SetSize
$LN3@SetSize:

; 262  : 	}
; 263  : 	else if (nNewSize<m_nElementCount)

  00061	eb 4b		 jmp	 SHORT $LN10@SetSize
$LN9@SetSize:
  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00069	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0006c	7d 40		 jge	 SHORT $LN10@SetSize

; 264  : 	{
; 265  : 		for (INT_PTR i=nNewSize;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  0006e	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00071	89 55 f4	 mov	 DWORD PTR _i$2[ebp], edx
  00074	eb 09		 jmp	 SHORT $LN7@SetSize
$LN5@SetSize:
  00076	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
$LN7@SetSize:
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 55 f4	 mov	 edx, DWORD PTR _i$2[ebp]
  00085	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00088	7d 02		 jge	 SHORT $LN6@SetSize
  0008a	eb ea		 jmp	 SHORT $LN5@SetSize
$LN6@SetSize:

; 266  : 		memset(m_pData+nNewSize,0,(m_nElementCount-nNewSize)*sizeof(TYPE));

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00092	2b 4d 08	 sub	 ecx, DWORD PTR _nNewSize$[ebp]
  00095	6b d1 1a	 imul	 edx, ecx, 26
  00098	52		 push	 edx
  00099	6a 00		 push	 0
  0009b	6b 45 08 1a	 imul	 eax, DWORD PTR _nNewSize$[ebp], 26
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _memset
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@SetSize:

; 267  : 	}
; 268  : 	m_nElementCount=nNewSize;

  000ae	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b1	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  000b4	89 42 10	 mov	 DWORD PTR [edx+16], eax
$LN12@SetSize:

; 269  : 
; 270  : 	return;
; 271  : }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
?SetSize@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXH@Z ENDP ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ?Add@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEHAAUtagAnalyseItem@@@Z
_TEXT	SEGMENT
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_newElement$ = 8					; size = 4
?Add@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEHAAUtagAnalyseItem@@@Z PROC ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::Add, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	INT_PTR nIndex=m_nElementCount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f8	 mov	 DWORD PTR _nIndex$[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  00012	8b 55 08	 mov	 edx, DWORD PTR _newElement$[ebp]
  00015	52		 push	 edx
  00016	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXHAAUtagAnalyseItem@@@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::SetAtGrow

; 108  : 	return nIndex;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]

; 109  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Add@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEHAAUtagAnalyseItem@@@Z ENDP ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ?GetCount@?$CWHArray@UtagAnalyseItem@@AAU1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCount@?$CWHArray@UtagAnalyseItem@@AAU1@@@QBEHXZ PROC ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::GetCount, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 	return m_nElementCount;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 100  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCount@?$CWHArray@UtagAnalyseItem@@AAU1@@@QBEHXZ ENDP ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::GetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ PROC	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@

; 144  : 	if (m_pData!=NULL)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	74 3e		 je	 SHORT $LN6@CWHArray

; 145  : 	{
; 146  : 		for (INT_PTR i=0;i<m_nElementCount;i++)	(m_pData+i)->~TYPE();

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@CWHArray
$LN2@CWHArray:
  00024	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _i$2[ebp], edx
$LN4@CWHArray:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00033	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00036	7d 02		 jge	 SHORT $LN3@CWHArray
  00038	eb ea		 jmp	 SHORT $LN2@CWHArray
$LN3@CWHArray:

; 147  : 		delete [] (BYTE *)m_pData;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00043	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4

; 148  : 		m_pData=NULL;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN6@CWHArray:

; 149  : 	}
; 150  : 
; 151  : 	return;
; 152  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ ENDP	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\array.h
;	COMDAT ??0?$CWHArray@UtagAnalyseItem@@AAU1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CWHArray@UtagAnalyseItem@@AAU1@@@QAE@XZ PROC	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::CWHArray<tagAnalyseItem,tagAnalyseItem &>, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@UtagAnalyseItem@@AAU1@@@6B@

; 132  : 	m_pData=NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 133  : 	m_nMaxCount=0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 134  : 	m_nGrowCount=0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 135  : 	m_nElementCount=0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 136  : 
; 137  : 	return;
; 138  : }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0?$CWHArray@UtagAnalyseItem@@AAU1@@@QAE@XZ ENDP	; CWHArray<tagAnalyseItem,tagAnalyseItem &>::CWHArray<tagAnalyseItem,tagAnalyseItem &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtgmath.h
;	COMDAT ??$pow@HH@@YANHH@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$pow@HH@@YANHH@Z PROC					; pow<int,int>, COMDAT

; 82   : 	{	// bring mixed types to a common type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   : 	typedef typename _STD _Common_float_type<_Ty1, _Ty2>::type type;
; 84   : 	return (_CSTD pow(type(_Left), type(_Right)));

  00003	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR __Right$[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00010	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR __Left$[ebp]
  00015	83 ec 08	 sub	 esp, 8
  00018	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0001d	e8 00 00 00 00	 call	 _pow
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 85   : 	}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$pow@HH@@YANHH@Z ENDP					; pow<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCGameLogic@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGameLogic@@UAEPAXI@Z PROC				; CGameLogic::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGameLogic@@UAE@XZ	; CGameLogic::~CGameLogic
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCGameLogic@@UAEPAXI@Z ENDP				; CGameLogic::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_cbColorCount$ = -8					; size = 4
_cbCardColor$ = -2					; size = 1
_i$1 = -1						; size = 1
_pAnalyseItem$ = 8					; size = 4
?IsHunYiSe@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z PROC	; CGameLogic::IsHunYiSe
; _this$ = ecx

; 1737 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1738 : 	//参数校验
; 1739 : 	if(pAnalyseItem==NULL) return false;

  00009	83 7d 08 00	 cmp	 DWORD PTR _pAnalyseItem$[ebp], 0
  0000d	75 07		 jne	 SHORT $LN5@IsHunYiSe
  0000f	32 c0		 xor	 al, al
  00011	e9 b7 00 00 00	 jmp	 $LN1@IsHunYiSe
$LN5@IsHunYiSe:

; 1740 : 
; 1741 : 	//变量定义
; 1742 : 	BYTE  cbCardColor=(pAnalyseItem->cbCardEye&MASK_COLOR)>>4;

  00016	8b 45 08	 mov	 eax, DWORD PTR _pAnalyseItem$[ebp]
  00019	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0001c	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00022	c1 f9 04	 sar	 ecx, 4
  00025	88 4d fe	 mov	 BYTE PTR _cbCardColor$[ebp], cl

; 1743 : 	ASSERT(cbCardColor >= 0 && cbCardColor <= 3);
; 1744 : 	BYTE cbColorCount[4] = {0};

  00028	c6 45 f8 00	 mov	 BYTE PTR _cbColorCount$[ebp], 0
  0002c	33 d2		 xor	 edx, edx
  0002e	66 89 55 f9	 mov	 WORD PTR _cbColorCount$[ebp+1], dx
  00032	88 55 fb	 mov	 BYTE PTR _cbColorCount$[ebp+3], dl

; 1745 : 	cbColorCount[cbCardColor] = 1;

  00035	0f b6 45 fe	 movzx	 eax, BYTE PTR _cbCardColor$[ebp]
  00039	c6 44 05 f8 01	 mov	 BYTE PTR _cbColorCount$[ebp+eax], 1

; 1746 : 	for(BYTE i=0;i<MAX_WEAVE;i++)

  0003e	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  00042	eb 09		 jmp	 SHORT $LN4@IsHunYiSe
$LN2@IsHunYiSe:
  00044	8a 4d ff	 mov	 cl, BYTE PTR _i$1[ebp]
  00047	80 c1 01	 add	 cl, 1
  0004a	88 4d ff	 mov	 BYTE PTR _i$1[ebp], cl
$LN4@IsHunYiSe:
  0004d	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  00051	83 fa 04	 cmp	 edx, 4
  00054	7d 30		 jge	 SHORT $LN3@IsHunYiSe

; 1747 : 	{
; 1748 : 		cbCardColor=((pAnalyseItem->cbCenterCard[i])&MASK_COLOR)>>4;

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _pAnalyseItem$[ebp]
  0005d	0f b6 54 01 06	 movzx	 edx, BYTE PTR [ecx+eax+6]
  00062	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  00068	c1 fa 04	 sar	 edx, 4
  0006b	88 55 fe	 mov	 BYTE PTR _cbCardColor$[ebp], dl

; 1749 : 		ASSERT(cbCardColor >= 0 && cbCardColor <= 3);
; 1750 : 		if(0 == cbColorCount[cbCardColor])

  0006e	0f b6 45 fe	 movzx	 eax, BYTE PTR _cbCardColor$[ebp]
  00072	0f b6 4c 05 f8	 movzx	 ecx, BYTE PTR _cbColorCount$[ebp+eax]
  00077	85 c9		 test	 ecx, ecx
  00079	75 09		 jne	 SHORT $LN6@IsHunYiSe

; 1751 : 		{
; 1752 : 			cbColorCount[cbCardColor] = 1;

  0007b	0f b6 55 fe	 movzx	 edx, BYTE PTR _cbCardColor$[ebp]
  0007f	c6 44 15 f8 01	 mov	 BYTE PTR _cbColorCount$[ebp+edx], 1
$LN6@IsHunYiSe:

; 1753 : 		}
; 1754 : 	}

  00084	eb be		 jmp	 SHORT $LN2@IsHunYiSe
$LN3@IsHunYiSe:

; 1755 : 
; 1756 : 	if(cbColorCount[0] + cbColorCount[1] + cbColorCount[2] == 1 && cbColorCount[3] == 1)

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	6b c8 00	 imul	 ecx, eax, 0
  0008e	0f b6 54 0d f8	 movzx	 edx, BYTE PTR _cbColorCount$[ebp+ecx]
  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	c1 e0 00	 shl	 eax, 0
  0009b	0f b6 4c 05 f8	 movzx	 ecx, BYTE PTR _cbColorCount$[ebp+eax]
  000a0	03 d1		 add	 edx, ecx
  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	d1 e0		 shl	 eax, 1
  000a9	0f b6 4c 05 f8	 movzx	 ecx, BYTE PTR _cbColorCount$[ebp+eax]
  000ae	03 d1		 add	 edx, ecx
  000b0	83 fa 01	 cmp	 edx, 1
  000b3	75 16		 jne	 SHORT $LN7@IsHunYiSe
  000b5	ba 01 00 00 00	 mov	 edx, 1
  000ba	6b c2 03	 imul	 eax, edx, 3
  000bd	0f b6 4c 05 f8	 movzx	 ecx, BYTE PTR _cbColorCount$[ebp+eax]
  000c2	83 f9 01	 cmp	 ecx, 1
  000c5	75 04		 jne	 SHORT $LN7@IsHunYiSe

; 1757 : 	{
; 1758 : 		return true;

  000c7	b0 01		 mov	 al, 1
  000c9	eb 02		 jmp	 SHORT $LN1@IsHunYiSe
$LN7@IsHunYiSe:

; 1759 : 	}
; 1760 : 
; 1761 : 	return false;

  000cb	32 c0		 xor	 al, al
$LN1@IsHunYiSe:

; 1762 : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 04 00	 ret	 4
?IsHunYiSe@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z ENDP	; CGameLogic::IsHunYiSe
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbCardColor$ = -2					; size = 1
_i$1 = -1						; size = 1
_pAnalyseItem$ = 8					; size = 4
_bQuanFan$ = 12						; size = 4
?IsQingYiSe@CGameLogic@@IAE_NPBUtagAnalyseItem@@AA_N@Z PROC ; CGameLogic::IsQingYiSe
; _this$ = ecx

; 1709 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1710 : 	//参数校验
; 1711 : 	if(pAnalyseItem==NULL) return false;

  00009	83 7d 08 00	 cmp	 DWORD PTR _pAnalyseItem$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN5@IsQingYiSe
  0000f	32 c0		 xor	 al, al
  00011	eb 5f		 jmp	 SHORT $LN1@IsQingYiSe
$LN5@IsQingYiSe:

; 1712 : 
; 1713 : 	//变量定义
; 1714 : 	BYTE  cbCardColor=pAnalyseItem->cbCardEye&MASK_COLOR;

  00013	8b 45 08	 mov	 eax, DWORD PTR _pAnalyseItem$[ebp]
  00016	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00019	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0001f	88 4d fe	 mov	 BYTE PTR _cbCardColor$[ebp], cl

; 1715 : 	for(BYTE i=0;i<MAX_WEAVE;i++)

  00022	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  00026	eb 09		 jmp	 SHORT $LN4@IsQingYiSe
$LN2@IsQingYiSe:
  00028	8a 55 ff	 mov	 dl, BYTE PTR _i$1[ebp]
  0002b	80 c2 01	 add	 dl, 1
  0002e	88 55 ff	 mov	 BYTE PTR _i$1[ebp], dl
$LN4@IsQingYiSe:
  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  00035	83 f8 04	 cmp	 eax, 4
  00038	7d 1f		 jge	 SHORT $LN3@IsQingYiSe

; 1716 : 	{
; 1717 : 		if((pAnalyseItem->cbCenterCard[i]&MASK_COLOR) != cbCardColor) 

  0003a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0003e	8b 55 08	 mov	 edx, DWORD PTR _pAnalyseItem$[ebp]
  00041	0f b6 44 0a 06	 movzx	 eax, BYTE PTR [edx+ecx+6]
  00046	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0004b	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbCardColor$[ebp]
  0004f	3b c1		 cmp	 eax, ecx
  00051	74 04		 je	 SHORT $LN6@IsQingYiSe

; 1718 : 		{
; 1719 : 			return false;

  00053	32 c0		 xor	 al, al
  00055	eb 1b		 jmp	 SHORT $LN1@IsQingYiSe
$LN6@IsQingYiSe:

; 1720 : 		}
; 1721 : 	}

  00057	eb cf		 jmp	 SHORT $LN2@IsQingYiSe
$LN3@IsQingYiSe:

; 1722 : 
; 1723 : 	if(0x30 == cbCardColor)

  00059	0f b6 55 fe	 movzx	 edx, BYTE PTR _cbCardColor$[ebp]
  0005d	83 fa 30	 cmp	 edx, 48			; 00000030H
  00060	75 08		 jne	 SHORT $LN7@IsQingYiSe

; 1724 : 	{
; 1725 : 		bQuanFan = true;

  00062	8b 45 0c	 mov	 eax, DWORD PTR _bQuanFan$[ebp]
  00065	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1726 : 	}
; 1727 : 	else 

  00068	eb 06		 jmp	 SHORT $LN8@IsQingYiSe
$LN7@IsQingYiSe:

; 1728 : 	{
; 1729 : 		bQuanFan = false;

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _bQuanFan$[ebp]
  0006d	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN8@IsQingYiSe:

; 1730 : 	}
; 1731 : 
; 1732 : 	return true;

  00070	b0 01		 mov	 al, 1
$LN1@IsQingYiSe:

; 1733 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
?IsQingYiSe@CGameLogic@@IAE_NPBUtagAnalyseItem@@AA_N@Z ENDP ; CGameLogic::IsQingYiSe
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv78 = -8						; size = 4
_bLian$ = -3						; size = 1
_bPeng$ = -2						; size = 1
_i$1 = -1						; size = 1
_pAnalyseItem$ = 8					; size = 4
?IsJiHu@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z PROC	; CGameLogic::IsJiHu
; _this$ = ecx

; 1683 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1684 : 	bool bPeng = false,bLian = false;

  00009	c6 45 fe 00	 mov	 BYTE PTR _bPeng$[ebp], 0
  0000d	c6 45 fd 00	 mov	 BYTE PTR _bLian$[ebp], 0

; 1685 : 	for(BYTE i = 0; i < CountArray(pAnalyseItem->cbWeaveKind); i++)

  00011	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  00015	eb 08		 jmp	 SHORT $LN4@IsJiHu
$LN2@IsJiHu:
  00017	8a 45 ff	 mov	 al, BYTE PTR _i$1[ebp]
  0001a	04 01		 add	 al, 1
  0001c	88 45 ff	 mov	 BYTE PTR _i$1[ebp], al
$LN4@IsJiHu:
  0001f	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00023	83 f9 04	 cmp	 ecx, 4
  00026	73 1d		 jae	 SHORT $LN3@IsJiHu

; 1686 : 	{
; 1687 : 		if(pAnalyseItem->cbWeaveKind[i]&(WIK_PENG|WIK_GANG))

  00028	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  0002c	8b 45 08	 mov	 eax, DWORD PTR _pAnalyseItem$[ebp]
  0002f	0f b6 4c 10 02	 movzx	 ecx, BYTE PTR [eax+edx+2]
  00034	83 e1 18	 and	 ecx, 24			; 00000018H
  00037	74 06		 je	 SHORT $LN5@IsJiHu

; 1688 : 			bPeng = true;

  00039	c6 45 fe 01	 mov	 BYTE PTR _bPeng$[ebp], 1
  0003d	eb 04		 jmp	 SHORT $LN6@IsJiHu
$LN5@IsJiHu:

; 1689 : 		else bLian = true;

  0003f	c6 45 fd 01	 mov	 BYTE PTR _bLian$[ebp], 1
$LN6@IsJiHu:

; 1690 : 	}

  00043	eb d2		 jmp	 SHORT $LN2@IsJiHu
$LN3@IsJiHu:

; 1691 : 
; 1692 : 	return bPeng&&bLian;

  00045	0f b6 55 fe	 movzx	 edx, BYTE PTR _bPeng$[ebp]
  00049	85 d2		 test	 edx, edx
  0004b	74 11		 je	 SHORT $LN8@IsJiHu
  0004d	0f b6 45 fd	 movzx	 eax, BYTE PTR _bLian$[ebp]
  00051	85 c0		 test	 eax, eax
  00053	74 09		 je	 SHORT $LN8@IsJiHu
  00055	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN9@IsJiHu
$LN8@IsJiHu:
  0005e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN9@IsJiHu:
  00065	8a 45 f8	 mov	 al, BYTE PTR tv78[ebp]

; 1693 : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?IsJiHu@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z ENDP	; CGameLogic::IsJiHu
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -1						; size = 1
_pAnalyseItem$ = 8					; size = 4
?IsPingHu@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z PROC	; CGameLogic::IsPingHu
; _this$ = ecx

; 1697 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1698 : 	//检查组合
; 1699 : 	for(BYTE i = 0; i < CountArray(pAnalyseItem->cbWeaveKind); i++)

  00009	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN4@IsPingHu
$LN2@IsPingHu:
  0000f	8a 45 ff	 mov	 al, BYTE PTR _i$1[ebp]
  00012	04 01		 add	 al, 1
  00014	88 45 ff	 mov	 BYTE PTR _i$1[ebp], al
$LN4@IsPingHu:
  00017	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0001b	83 f9 04	 cmp	 ecx, 4
  0001e	73 17		 jae	 SHORT $LN3@IsPingHu

; 1700 : 	{
; 1701 : 		if(pAnalyseItem->cbWeaveKind[i]&(WIK_PENG|WIK_GANG)) return false;

  00020	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  00024	8b 45 08	 mov	 eax, DWORD PTR _pAnalyseItem$[ebp]
  00027	0f b6 4c 10 02	 movzx	 ecx, BYTE PTR [eax+edx+2]
  0002c	83 e1 18	 and	 ecx, 24			; 00000018H
  0002f	74 04		 je	 SHORT $LN5@IsPingHu
  00031	32 c0		 xor	 al, al
  00033	eb 04		 jmp	 SHORT $LN1@IsPingHu
$LN5@IsPingHu:

; 1702 : 	}

  00035	eb d8		 jmp	 SHORT $LN2@IsPingHu
$LN3@IsPingHu:

; 1703 : 
; 1704 : 	return true;

  00037	b0 01		 mov	 al, 1
$LN1@IsPingHu:

; 1705 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?IsPingHu@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z ENDP	; CGameLogic::IsPingHu
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_index$1 = -20						; size = 4
_i$2 = -16						; size = 4
_i$3 = -12						; size = 4
_j$4 = -8						; size = 4
_i$5 = -4						; size = 4
_cbCardIndex$ = 8					; size = 4
_cbWeaveCount$ = 12					; size = 1
_ChiHuRight$ = 16					; size = 4
?IsShiSanLan@CGameLogic@@IAE_NQBEEAAVCChiHuRight@@@Z PROC ; CGameLogic::IsShiSanLan
; _this$ = ecx

; 1644 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1645 : 	//组合判断
; 1646 : 	if (cbWeaveCount!=0) return false;

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbWeaveCount$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN14@IsShiSanLa
  00011	32 c0		 xor	 al, al
  00013	e9 db 00 00 00	 jmp	 $LN1@IsShiSanLa
$LN14@IsShiSanLa:

; 1647 : 
; 1648 : 	for(int i=0;i<MAX_INDEX;i++)

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  0001f	eb 09		 jmp	 SHORT $LN4@IsShiSanLa
$LN2@IsShiSanLa:
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _i$5[ebp]
  00024	83 c1 01	 add	 ecx, 1
  00027	89 4d fc	 mov	 DWORD PTR _i$5[ebp], ecx
$LN4@IsShiSanLa:
  0002a	83 7d fc 22	 cmp	 DWORD PTR _i$5[ebp], 34	; 00000022H
  0002e	7d 17		 jge	 SHORT $LN3@IsShiSanLa

; 1649 : 	{
; 1650 : 		if(cbCardIndex[i]>=2)//不能有重复牌

  00030	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  00033	03 55 fc	 add	 edx, DWORD PTR _i$5[ebp]
  00036	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	7c 07		 jl	 SHORT $LN15@IsShiSanLa

; 1651 : 			return false;

  0003e	32 c0		 xor	 al, al
  00040	e9 ae 00 00 00	 jmp	 $LN1@IsShiSanLa
$LN15@IsShiSanLa:

; 1652 : 	}

  00045	eb da		 jmp	 SHORT $LN2@IsShiSanLa
$LN3@IsShiSanLa:

; 1653 : 
; 1654 : 	for(int j=0;j<3;j++)

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$4[ebp], 0
  0004e	eb 09		 jmp	 SHORT $LN7@IsShiSanLa
$LN5@IsShiSanLa:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _j$4[ebp]
  00053	83 c1 01	 add	 ecx, 1
  00056	89 4d f8	 mov	 DWORD PTR _j$4[ebp], ecx
$LN7@IsShiSanLa:
  00059	83 7d f8 03	 cmp	 DWORD PTR _j$4[ebp], 3
  0005d	7d 50		 jge	 SHORT $LN6@IsShiSanLa

; 1655 : 	{
; 1656 : 		for(int i=0;i<9-2;i++)

  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00066	eb 09		 jmp	 SHORT $LN10@IsShiSanLa
$LN8@IsShiSanLa:
  00068	8b 55 f4	 mov	 edx, DWORD PTR _i$3[ebp]
  0006b	83 c2 01	 add	 edx, 1
  0006e	89 55 f4	 mov	 DWORD PTR _i$3[ebp], edx
$LN10@IsShiSanLa:
  00071	83 7d f4 07	 cmp	 DWORD PTR _i$3[ebp], 7
  00075	7d 36		 jge	 SHORT $LN9@IsShiSanLa

; 1657 : 		{
; 1658 : 			int index = j*9+i;

  00077	6b 45 f8 09	 imul	 eax, DWORD PTR _j$4[ebp], 9
  0007b	03 45 f4	 add	 eax, DWORD PTR _i$3[ebp]
  0007e	89 45 ec	 mov	 DWORD PTR _index$1[ebp], eax

; 1659 : 			if(cbCardIndex[index]+cbCardIndex[index+1]+cbCardIndex[index+2]>1)

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00084	03 4d ec	 add	 ecx, DWORD PTR _index$1[ebp]
  00087	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0008a	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  0008d	03 45 ec	 add	 eax, DWORD PTR _index$1[ebp]
  00090	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00094	03 d1		 add	 edx, ecx
  00096	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00099	03 45 ec	 add	 eax, DWORD PTR _index$1[ebp]
  0009c	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000a0	03 d1		 add	 edx, ecx
  000a2	83 fa 01	 cmp	 edx, 1
  000a5	7e 04		 jle	 SHORT $LN16@IsShiSanLa

; 1660 : 			{
; 1661 : 				//if(cbCardIndex[index+1]>0 || cbCardIndex[index+2]>0)//间隔必须>=3
; 1662 : 					return false;

  000a7	32 c0		 xor	 al, al
  000a9	eb 48		 jmp	 SHORT $LN1@IsShiSanLa
$LN16@IsShiSanLa:

; 1663 : 			}
; 1664 : 		}

  000ab	eb bb		 jmp	 SHORT $LN8@IsShiSanLa
$LN9@IsShiSanLa:

; 1665 : 	}

  000ad	eb a1		 jmp	 SHORT $LN5@IsShiSanLa
$LN6@IsShiSanLa:

; 1666 : 
; 1667 : 	for(int i=27;i<MAX_INDEX;i++)//检查风牌

  000af	c7 45 f0 1b 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 27	; 0000001bH
  000b6	eb 09		 jmp	 SHORT $LN13@IsShiSanLa
$LN11@IsShiSanLa:
  000b8	8b 55 f0	 mov	 edx, DWORD PTR _i$2[ebp]
  000bb	83 c2 01	 add	 edx, 1
  000be	89 55 f0	 mov	 DWORD PTR _i$2[ebp], edx
$LN13@IsShiSanLa:
  000c1	83 7d f0 22	 cmp	 DWORD PTR _i$2[ebp], 34	; 00000022H
  000c5	7d 1d		 jge	 SHORT $LN12@IsShiSanLa

; 1668 : 	{
; 1669 : 		if(cbCardIndex[i]==0)//没有包含所有风牌，十三烂

  000c7	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  000ca	03 45 f0	 add	 eax, DWORD PTR _i$2[ebp]
  000cd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d0	85 c9		 test	 ecx, ecx
  000d2	75 0e		 jne	 SHORT $LN17@IsShiSanLa

; 1670 : 		{
; 1671 : 			ChiHuRight |= CHR_SHI_SAN_LAN;

  000d4	6a 40		 push	 64			; 00000040H
  000d6	8b 4d 10	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  000d9	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=

; 1672 : 			return true;

  000de	b0 01		 mov	 al, 1
  000e0	eb 11		 jmp	 SHORT $LN1@IsShiSanLa
$LN17@IsShiSanLa:

; 1673 : 		}
; 1674 : 	}

  000e2	eb d4		 jmp	 SHORT $LN11@IsShiSanLa
$LN12@IsShiSanLa:

; 1675 : 
; 1676 : 	//所有风牌都有，七星十三烂
; 1677 : 	ChiHuRight |= CHR_QX_SHI_SAN_LAN;

  000e4	68 80 00 00 00	 push	 128			; 00000080H
  000e9	8b 4d 10	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  000ec	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=

; 1678 : 	return true;

  000f1	b0 01		 mov	 al, 1
$LN1@IsShiSanLa:

; 1679 : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
?IsShiSanLan@CGameLogic@@IAE_NQBEEAAVCChiHuRight@@@Z ENDP ; CGameLogic::IsShiSanLan
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv75 = -12						; size = 4
_this$ = -8						; size = 4
_cbMagicCount$ = -3					; size = 1
_cbGang$ = -2						; size = 1
_i$1 = -1						; size = 1
_cbCardIndex$ = 8					; size = 4
_cbWeaveCount$ = 12					; size = 1
_ChiHuRight$ = 16					; size = 4
?IsMaQi@CGameLogic@@IAE_NQBEEAAVCChiHuRight@@@Z PROC	; CGameLogic::IsMaQi
; _this$ = ecx

; 1597 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1598 : 	if(cbWeaveCount!=0)

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbWeaveCount$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	74 07		 je	 SHORT $LN5@IsMaQi

; 1599 : 		return false;

  00011	32 c0		 xor	 al, al
  00013	e9 fe 00 00 00	 jmp	 $LN1@IsMaQi
$LN5@IsMaQi:

; 1600 : 
; 1601 : 	BYTE cbGang = 0;

  00018	c6 45 fe 00	 mov	 BYTE PTR _cbGang$[ebp], 0

; 1602 : 	BYTE cbMagicCount = m_cbMagicIndex != MAX_INDEX ? cbCardIndex[m_cbMagicIndex] : 0;

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00023	83 fa 22	 cmp	 edx, 34			; 00000022H
  00026	74 13		 je	 SHORT $LN15@IsMaQi
  00028	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  00032	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00036	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00039	eb 07		 jmp	 SHORT $LN16@IsMaQi
$LN15@IsMaQi:
  0003b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN16@IsMaQi:
  00042	8a 4d f4	 mov	 cl, BYTE PTR tv75[ebp]
  00045	88 4d fd	 mov	 BYTE PTR _cbMagicCount$[ebp], cl

; 1603 : 	//变量定义
; 1604 : 	for(BYTE i=0;i<MAX_INDEX;i++)

  00048	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  0004c	eb 09		 jmp	 SHORT $LN4@IsMaQi
$LN2@IsMaQi:
  0004e	8a 55 ff	 mov	 dl, BYTE PTR _i$1[ebp]
  00051	80 c2 01	 add	 dl, 1
  00054	88 55 ff	 mov	 BYTE PTR _i$1[ebp], dl
$LN4@IsMaQi:
  00057	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  0005b	83 f8 22	 cmp	 eax, 34			; 00000022H
  0005e	7d 74		 jge	 SHORT $LN3@IsMaQi

; 1605 : 	{
; 1606 : 		if(cbCardIndex[i] != 0 && i != m_cbMagicIndex)

  00060	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00064	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  00067	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0006b	85 c0		 test	 eax, eax
  0006d	74 60		 je	 SHORT $LN6@IsMaQi
  0006f	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00073	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00076	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0007a	3b c8		 cmp	 ecx, eax
  0007c	74 51		 je	 SHORT $LN6@IsMaQi

; 1607 : 		{			
; 1608 : 			if(cbCardIndex[i] % 2 == 1)

  0007e	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00082	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  00085	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00089	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0008e	79 05		 jns	 SHORT $LN17@IsMaQi
  00090	48		 dec	 eax
  00091	83 c8 fe	 or	 eax, -2			; fffffffeH
  00094	40		 inc	 eax
$LN17@IsMaQi:
  00095	83 f8 01	 cmp	 eax, 1
  00098	75 18		 jne	 SHORT $LN7@IsMaQi

; 1609 : 			{
; 1610 : 				if(cbMagicCount >= 1)

  0009a	0f b6 4d fd	 movzx	 ecx, BYTE PTR _cbMagicCount$[ebp]
  0009e	83 f9 01	 cmp	 ecx, 1
  000a1	7c 0b		 jl	 SHORT $LN8@IsMaQi

; 1611 : 				{
; 1612 : 					cbMagicCount--;

  000a3	8a 55 fd	 mov	 dl, BYTE PTR _cbMagicCount$[ebp]
  000a6	80 ea 01	 sub	 dl, 1
  000a9	88 55 fd	 mov	 BYTE PTR _cbMagicCount$[ebp], dl

; 1613 : 				}
; 1614 : 				else

  000ac	eb 04		 jmp	 SHORT $LN7@IsMaQi
$LN8@IsMaQi:

; 1615 : 				{
; 1616 : 					return false;//有非对子，跳出

  000ae	32 c0		 xor	 al, al
  000b0	eb 64		 jmp	 SHORT $LN1@IsMaQi
$LN7@IsMaQi:

; 1617 : 				}
; 1618 : 			}
; 1619 : 
; 1620 : 			cbGang+= cbCardIndex[i] / 4;

  000b2	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  000b9	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  000bd	99		 cdq
  000be	83 e2 03	 and	 edx, 3
  000c1	03 c2		 add	 eax, edx
  000c3	c1 f8 02	 sar	 eax, 2
  000c6	0f b6 55 fe	 movzx	 edx, BYTE PTR _cbGang$[ebp]
  000ca	03 d0		 add	 edx, eax
  000cc	88 55 fe	 mov	 BYTE PTR _cbGang$[ebp], dl
$LN6@IsMaQi:

; 1621 : 		}
; 1622 : 	}

  000cf	e9 7a ff ff ff	 jmp	 $LN2@IsMaQi
$LN3@IsMaQi:

; 1623 : 
; 1624 : 	if(cbGang >= 2)//手上有两个4张，王中王

  000d4	0f b6 45 fe	 movzx	 eax, BYTE PTR _cbGang$[ebp]
  000d8	83 f8 02	 cmp	 eax, 2
  000db	7c 10		 jl	 SHORT $LN10@IsMaQi

; 1625 : 	{
; 1626 : 		ChiHuRight |= CHR_MA_QI_WZW;

  000dd	6a 20		 push	 32			; 00000020H
  000df	8b 4d 10	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  000e2	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=

; 1627 : 		return true;

  000e7	b0 01		 mov	 al, 1
  000e9	eb 2b		 jmp	 SHORT $LN1@IsMaQi
  000eb	eb 27		 jmp	 SHORT $LN11@IsMaQi
$LN10@IsMaQi:

; 1628 : 	}
; 1629 : 	else if(cbGang == 1)//有一个4张，麻七王

  000ed	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbGang$[ebp]
  000f1	83 f9 01	 cmp	 ecx, 1
  000f4	75 10		 jne	 SHORT $LN12@IsMaQi

; 1630 : 	{
; 1631 : 		ChiHuRight |= CHR_MA_QI_WANG;

  000f6	6a 10		 push	 16			; 00000010H
  000f8	8b 4d 10	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  000fb	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=

; 1632 : 		return true;

  00100	b0 01		 mov	 al, 1
  00102	eb 12		 jmp	 SHORT $LN1@IsMaQi

; 1633 : 	}
; 1634 : 	else//麻七对

  00104	eb 0e		 jmp	 SHORT $LN11@IsMaQi
$LN12@IsMaQi:

; 1635 : 	{
; 1636 : 		ChiHuRight |=CHR_MA_QI_DUI;

  00106	6a 08		 push	 8
  00108	8b 4d 10	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  0010b	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=

; 1637 : 		return true;

  00110	b0 01		 mov	 al, 1
  00112	eb 02		 jmp	 SHORT $LN1@IsMaQi
$LN11@IsMaQi:

; 1638 : 	}
; 1639 : 
; 1640 : 	return false;

  00114	32 c0		 xor	 al, al
$LN1@IsMaQi:

; 1641 : }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 0c 00	 ret	 12			; 0000000cH
?IsMaQi@CGameLogic@@IAE_NQBEEAAVCChiHuRight@@@Z ENDP	; CGameLogic::IsMaQi
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -1						; size = 1
_pAnalyseItem$ = 8					; size = 4
?IsPengPeng@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z PROC	; CGameLogic::IsPengPeng
; _this$ = ecx

; 1586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1587 : 	for(BYTE i = 0; i < CountArray(pAnalyseItem->cbWeaveKind); i++)

  00009	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN4@IsPengPeng
$LN2@IsPengPeng:
  0000f	8a 45 ff	 mov	 al, BYTE PTR _i$1[ebp]
  00012	04 01		 add	 al, 1
  00014	88 45 ff	 mov	 BYTE PTR _i$1[ebp], al
$LN4@IsPengPeng:
  00017	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0001b	83 f9 04	 cmp	 ecx, 4
  0001e	73 17		 jae	 SHORT $LN3@IsPengPeng

; 1588 : 	{
; 1589 : 		if(pAnalyseItem->cbWeaveKind[i]&(WIK_LEFT|WIK_CENTER|WIK_RIGHT))

  00020	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  00024	8b 45 08	 mov	 eax, DWORD PTR _pAnalyseItem$[ebp]
  00027	0f b6 4c 10 02	 movzx	 ecx, BYTE PTR [eax+edx+2]
  0002c	83 e1 07	 and	 ecx, 7
  0002f	74 04		 je	 SHORT $LN5@IsPengPeng

; 1590 : 			return false;

  00031	32 c0		 xor	 al, al
  00033	eb 04		 jmp	 SHORT $LN1@IsPengPeng
$LN5@IsPengPeng:

; 1591 : 	}

  00035	eb d8		 jmp	 SHORT $LN2@IsPengPeng
$LN3@IsPengPeng:

; 1592 : 	return true;

  00037	b0 01		 mov	 al, 1
$LN1@IsPengPeng:

; 1593 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?IsPengPeng@CGameLogic@@IAE_NPBUtagAnalyseItem@@@Z ENDP	; CGameLogic::IsPengPeng
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv869 = -1408						; size = 4
tv467 = -1404						; size = 4
_cbValidIndex$1 = -1400					; size = 3
_nMagicCountTemp$2 = -1396				; size = 4
_i$3 = -1392						; size = 4
_cbNewIndex$4 = -1385					; size = 1
_cbIndex$5 = -1384					; size = 4
tv278 = -1380						; size = 1
tv202 = -1379						; size = 1
tv268 = -1378						; size = 1
tv273 = -1377						; size = 1
_bEnoughCard$6 = -1376					; size = 1
tv356 = -1375						; size = 1
tv351 = -1374						; size = 1
tv346 = -1373						; size = 1
tv334 = -1372						; size = 1
tv329 = -1371						; size = 1
tv324 = -1370						; size = 1
_cbCardIndex$7 = -1369					; size = 1
_cbIndex$8 = -1368					; size = 3
_nTempIndex$9 = -1364					; size = 4
_cbCenterCard$10 = -1360				; size = 1
_bMagicThree$ = -1359					; size = 1
_cbTempMagicCount$ = -1358				; size = 1
_bMagicEye$11 = -1357					; size = 1
_j$12 = -1356						; size = 1
_cbCardEye$13 = -1355					; size = 1
_i$14 = -1354						; size = 1
_i$15 = -1353						; size = 1
_cbCardCount$ = -1352					; size = 1
_cbKindItemCount$ = -1351				; size = 1
_i$16 = -1350						; size = 1
_i$17 = -1349						; size = 1
_i$18 = -1348						; size = 1
_cbMagicCardCount$ = -1347				; size = 1
_j$19 = -1346						; size = 1
_i$20 = -1345						; size = 1
_j$21 = -1344						; size = 1
_cbIndex$22 = -1343					; size = 1
_i$23 = -1342						; size = 1
_cbLessKindItem$ = -1341				; size = 1
_this$ = -1340						; size = 4
_i$24 = -1334						; size = 1
_i$25 = -1333						; size = 1
_AnalyseItem$26 = -1332					; size = 26
_AnalyseItem$27 = -1304					; size = 26
_TempKindItem$ = -1276					; size = 6
_KindItemTemp$28 = -1268				; size = 588
_KindItem$ = -680					; size = 588
_pKindItem$29 = -92					; size = 16
_cbCardIndexTemp$30 = -76				; size = 34
_cbMagicCardIndex$ = -40				; size = 34
__$ArrayPad$ = -4					; size = 4
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
_AnalyseItemArray$ = 20					; size = 4
?AnalyseCard@CGameLogic@@AAE_NQBEQBUtagWeaveItem@@EAAV?$CWHArray@UtagAnalyseItem@@AAU1@@@@Z PROC ; CGameLogic::AnalyseCard
; _this$ = ecx

; 1238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 05 00
	00		 sub	 esp, 1408		; 00000580H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	89 8d c4 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1239 : 	//计算数目
; 1240 : 	BYTE cbCardCount=GetCardCount(cbCardIndex);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  0001d	50		 push	 eax
  0001e	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  00029	88 85 b8 fa ff
	ff		 mov	 BYTE PTR _cbCardCount$[ebp], al

; 1241 : 
; 1242 : 	//效验数目
; 1243 : 	ASSERT((cbCardCount>=2)&&(cbCardCount<=MAX_COUNT)&&((cbCardCount-2)%3==0));
; 1244 : 	if ((cbCardCount<2)||(cbCardCount>MAX_COUNT)||((cbCardCount-2)%3!=0))

  0002f	0f b6 8d b8 fa
	ff ff		 movzx	 ecx, BYTE PTR _cbCardCount$[ebp]
  00036	83 f9 02	 cmp	 ecx, 2
  00039	7c 22		 jl	 SHORT $LN50@AnalyseCar
  0003b	0f b6 95 b8 fa
	ff ff		 movzx	 edx, BYTE PTR _cbCardCount$[ebp]
  00042	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  00045	7f 16		 jg	 SHORT $LN50@AnalyseCar
  00047	0f b6 85 b8 fa
	ff ff		 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  0004e	83 e8 02	 sub	 eax, 2
  00051	99		 cdq
  00052	b9 03 00 00 00	 mov	 ecx, 3
  00057	f7 f9		 idiv	 ecx
  00059	85 d2		 test	 edx, edx
  0005b	74 07		 je	 SHORT $LN49@AnalyseCar
$LN50@AnalyseCar:

; 1245 : 		return false;

  0005d	32 c0		 xor	 al, al
  0005f	e9 ed 10 00 00	 jmp	 $LN1@AnalyseCar
$LN49@AnalyseCar:

; 1246 : 
; 1247 : 	//变量定义
; 1248 : 	BYTE cbKindItemCount=0;

  00064	c6 85 b9 fa ff
	ff 00		 mov	 BYTE PTR _cbKindItemCount$[ebp], 0

; 1249 : 	tagKindItem KindItem[27*2+28+16];
; 1250 : 	ZeroMemory(KindItem,sizeof(KindItem));

  0006b	68 4c 02 00 00	 push	 588			; 0000024cH
  00070	6a 00		 push	 0
  00072	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR _KindItem$[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _memset
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1251 : 	tagKindItem TempKindItem;
; 1252 : 	ZeroMemory(&TempKindItem,sizeof(TempKindItem));

  00081	6a 06		 push	 6
  00083	6a 00		 push	 0
  00085	8d 85 04 fb ff
	ff		 lea	 eax, DWORD PTR _TempKindItem$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _memset
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1253 : 	bool bMagicThree=false;

  00094	c6 85 b1 fa ff
	ff 00		 mov	 BYTE PTR _bMagicThree$[ebp], 0

; 1254 : 
; 1255 : 	//需求判断
; 1256 : 	BYTE cbLessKindItem=(cbCardCount-2)/3;

  0009b	0f b6 85 b8 fa
	ff ff		 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  000a2	83 e8 02	 sub	 eax, 2
  000a5	99		 cdq
  000a6	b9 03 00 00 00	 mov	 ecx, 3
  000ab	f7 f9		 idiv	 ecx
  000ad	88 85 c3 fa ff
	ff		 mov	 BYTE PTR _cbLessKindItem$[ebp], al

; 1257 : 	ASSERT((cbLessKindItem+cbWeaveCount)==MAX_WEAVE);
; 1258 : 
; 1259 : 	//单吊判断
; 1260 : 	if (cbLessKindItem==0)

  000b3	0f b6 95 c3 fa
	ff ff		 movzx	 edx, BYTE PTR _cbLessKindItem$[ebp]
  000ba	85 d2		 test	 edx, edx
  000bc	0f 85 ed 01 00
	00		 jne	 $LN51@AnalyseCar

; 1261 : 	{
; 1262 : 		//效验参数
; 1263 : 		ASSERT((cbCardCount==2)&&(cbWeaveCount==MAX_WEAVE));
; 1264 : 
; 1265 : 		//牌眼判断
; 1266 : 		for (BYTE i=0;i<MAX_INDEX;i++)

  000c2	c6 85 c2 fa ff
	ff 00		 mov	 BYTE PTR _i$23[ebp], 0
  000c9	eb 0e		 jmp	 SHORT $LN4@AnalyseCar
$LN2@AnalyseCar:
  000cb	8a 85 c2 fa ff
	ff		 mov	 al, BYTE PTR _i$23[ebp]
  000d1	04 01		 add	 al, 1
  000d3	88 85 c2 fa ff
	ff		 mov	 BYTE PTR _i$23[ebp], al
$LN4@AnalyseCar:
  000d9	0f b6 8d c2 fa
	ff ff		 movzx	 ecx, BYTE PTR _i$23[ebp]
  000e0	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000e3	0f 8d bf 01 00
	00		 jge	 $LN3@AnalyseCar

; 1267 : 		{
; 1268 : 			if (cbCardIndex[i]==2 || (m_cbMagicIndex != MAX_INDEX && i != m_cbMagicIndex && cbCardIndex[m_cbMagicIndex]+cbCardIndex[i]==2))

  000e9	0f b6 95 c2 fa
	ff ff		 movzx	 edx, BYTE PTR _i$23[ebp]
  000f0	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  000f3	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  000f7	83 f9 02	 cmp	 ecx, 2
  000fa	74 56		 je	 SHORT $LN53@AnalyseCar
  000fc	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00102	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00106	83 f8 22	 cmp	 eax, 34			; 00000022H
  00109	0f 84 94 01 00
	00		 je	 $LN52@AnalyseCar
  0010f	0f b6 8d c2 fa
	ff ff		 movzx	 ecx, BYTE PTR _i$23[ebp]
  00116	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0011c	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00120	3b c8		 cmp	 ecx, eax
  00122	0f 84 7b 01 00
	00		 je	 $LN52@AnalyseCar
  00128	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00132	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00135	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00139	0f b6 95 c2 fa
	ff ff		 movzx	 edx, BYTE PTR _i$23[ebp]
  00140	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00143	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  00147	03 ca		 add	 ecx, edx
  00149	83 f9 02	 cmp	 ecx, 2
  0014c	0f 85 51 01 00
	00		 jne	 $LN52@AnalyseCar
$LN53@AnalyseCar:

; 1269 : 			{
; 1270 : 				//变量定义
; 1271 : 				tagAnalyseItem AnalyseItem;
; 1272 : 				ZeroMemory(&AnalyseItem,sizeof(AnalyseItem));

  00152	6a 1a		 push	 26			; 0000001aH
  00154	6a 00		 push	 0
  00156	8d 85 cc fa ff
	ff		 lea	 eax, DWORD PTR _AnalyseItem$26[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memset
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1273 : 
; 1274 : 				//设置结果
; 1275 : 				for (BYTE j=0;j<cbWeaveCount;j++)

  00165	c6 85 be fa ff
	ff 00		 mov	 BYTE PTR _j$19[ebp], 0
  0016c	eb 0f		 jmp	 SHORT $LN7@AnalyseCar
$LN5@AnalyseCar:
  0016e	8a 8d be fa ff
	ff		 mov	 cl, BYTE PTR _j$19[ebp]
  00174	80 c1 01	 add	 cl, 1
  00177	88 8d be fa ff
	ff		 mov	 BYTE PTR _j$19[ebp], cl
$LN7@AnalyseCar:
  0017d	0f b6 95 be fa
	ff ff		 movzx	 edx, BYTE PTR _j$19[ebp]
  00184	0f b6 45 10	 movzx	 eax, BYTE PTR _cbWeaveCount$[ebp]
  00188	3b d0		 cmp	 edx, eax
  0018a	7d 6d		 jge	 SHORT $LN6@AnalyseCar

; 1276 : 				{
; 1277 : 					AnalyseItem.cbWeaveKind[j]=WeaveItem[j].cbWeaveKind;

  0018c	0f b6 8d be fa
	ff ff		 movzx	 ecx, BYTE PTR _j$19[ebp]
  00193	6b d1 09	 imul	 edx, ecx, 9
  00196	0f b6 85 be fa
	ff ff		 movzx	 eax, BYTE PTR _j$19[ebp]
  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _WeaveItem$[ebp]
  001a0	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  001a3	88 94 05 ce fa
	ff ff		 mov	 BYTE PTR _AnalyseItem$26[ebp+eax+2], dl

; 1278 : 					AnalyseItem.cbCenterCard[j]=WeaveItem[j].cbCenterCard;

  001aa	0f b6 85 be fa
	ff ff		 movzx	 eax, BYTE PTR _j$19[ebp]
  001b1	6b c8 09	 imul	 ecx, eax, 9
  001b4	0f b6 95 be fa
	ff ff		 movzx	 edx, BYTE PTR _j$19[ebp]
  001bb	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  001be	8a 4c 08 01	 mov	 cl, BYTE PTR [eax+ecx+1]
  001c2	88 8c 15 d2 fa
	ff ff		 mov	 BYTE PTR _AnalyseItem$26[ebp+edx+6], cl

; 1279 : 					CopyMemory(AnalyseItem.cbCardData[j],WeaveItem[j].cbCardData,sizeof(WeaveItem[j].cbCardData));

  001c9	6a 04		 push	 4
  001cb	0f b6 95 be fa
	ff ff		 movzx	 edx, BYTE PTR _j$19[ebp]
  001d2	6b c2 09	 imul	 eax, edx, 9
  001d5	8b 4d 0c	 mov	 ecx, DWORD PTR _WeaveItem$[ebp]
  001d8	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  001dc	52		 push	 edx
  001dd	0f b6 85 be fa
	ff ff		 movzx	 eax, BYTE PTR _j$19[ebp]
  001e4	8d 8c 85 d6 fa
	ff ff		 lea	 ecx, DWORD PTR _AnalyseItem$26[ebp+eax*4+10]
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 _memcpy
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1280 : 				}

  001f4	e9 75 ff ff ff	 jmp	 $LN5@AnalyseCar
$LN6@AnalyseCar:

; 1281 : 				if(cbCardIndex[i] < 2 || i == m_cbMagicIndex)

  001f9	0f b6 95 c2 fa
	ff ff		 movzx	 edx, BYTE PTR _i$23[ebp]
  00200	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00203	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00207	83 f9 02	 cmp	 ecx, 2
  0020a	7c 15		 jl	 SHORT $LN56@AnalyseCar
  0020c	0f b6 95 c2 fa
	ff ff		 movzx	 edx, BYTE PTR _i$23[ebp]
  00213	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00219	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0021d	3b d1		 cmp	 edx, ecx
  0021f	75 09		 jne	 SHORT $LN54@AnalyseCar
$LN56@AnalyseCar:

; 1282 : 					AnalyseItem.bMagicEye = true;

  00221	c6 85 cd fa ff
	ff 01		 mov	 BYTE PTR _AnalyseItem$26[ebp+1], 1
  00228	eb 07		 jmp	 SHORT $LN55@AnalyseCar
$LN54@AnalyseCar:

; 1283 : 				else AnalyseItem.bMagicEye = false;

  0022a	c6 85 cd fa ff
	ff 00		 mov	 BYTE PTR _AnalyseItem$26[ebp+1], 0
$LN55@AnalyseCar:

; 1284 : 				AnalyseItem.cbCardEye=cbCardIndex[i]==0?SwitchToCardData(cbCardIndex[m_cbMagicIndex]):SwitchToCardData(i);

  00231	0f b6 95 c2 fa
	ff ff		 movzx	 edx, BYTE PTR _i$23[ebp]
  00238	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  0023b	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0023f	85 c9		 test	 ecx, ecx
  00241	75 25		 jne	 SHORT $LN96@AnalyseCar
  00243	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00249	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0024d	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00250	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00254	52		 push	 edx
  00255	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0025b	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00260	88 85 9d fa ff
	ff		 mov	 BYTE PTR tv202[ebp], al
  00266	eb 19		 jmp	 SHORT $LN97@AnalyseCar
$LN96@AnalyseCar:
  00268	0f b6 85 c2 fa
	ff ff		 movzx	 eax, BYTE PTR _i$23[ebp]
  0026f	50		 push	 eax
  00270	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00276	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0027b	88 85 9d fa ff
	ff		 mov	 BYTE PTR tv202[ebp], al
$LN97@AnalyseCar:
  00281	8a 8d 9d fa ff
	ff		 mov	 cl, BYTE PTR tv202[ebp]
  00287	88 8d cc fa ff
	ff		 mov	 BYTE PTR _AnalyseItem$26[ebp], cl

; 1285 : 
; 1286 : 				//插入结果
; 1287 : 				AnalyseItemArray.Add(AnalyseItem);

  0028d	8d 95 cc fa ff
	ff		 lea	 edx, DWORD PTR _AnalyseItem$26[ebp]
  00293	52		 push	 edx
  00294	8b 4d 14	 mov	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  00297	e8 00 00 00 00	 call	 ?Add@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEHAAUtagAnalyseItem@@@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::Add

; 1288 : 
; 1289 : 				return true;

  0029c	b0 01		 mov	 al, 1
  0029e	e9 ae 0e 00 00	 jmp	 $LN1@AnalyseCar
$LN52@AnalyseCar:

; 1290 : 			}
; 1291 : 		}

  002a3	e9 23 fe ff ff	 jmp	 $LN2@AnalyseCar
$LN3@AnalyseCar:

; 1292 : 
; 1293 : 		return false;

  002a8	32 c0		 xor	 al, al
  002aa	e9 a2 0e 00 00	 jmp	 $LN1@AnalyseCar
$LN51@AnalyseCar:

; 1294 : 	}
; 1295 : 
; 1296 : 	//拆分分析
; 1297 : 	BYTE cbMagicCardIndex[MAX_INDEX];
; 1298 : 	CopyMemory(cbMagicCardIndex,cbCardIndex,sizeof(cbMagicCardIndex));

  002af	6a 22		 push	 34			; 00000022H
  002b1	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  002b4	50		 push	 eax
  002b5	8d 4d d8	 lea	 ecx, DWORD PTR _cbMagicCardIndex$[ebp]
  002b8	51		 push	 ecx
  002b9	e8 00 00 00 00	 call	 _memcpy
  002be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1299 : 
; 1300 : 	//如果有财神
; 1301 : 	BYTE cbMagicCardCount = 0;

  002c1	c6 85 bd fa ff
	ff 00		 mov	 BYTE PTR _cbMagicCardCount$[ebp], 0

; 1302 : 	BYTE cbTempMagicCount = 0;

  002c8	c6 85 b2 fa ff
	ff 00		 mov	 BYTE PTR _cbTempMagicCount$[ebp], 0

; 1303 : 
; 1304 : 	if(m_cbMagicIndex != MAX_INDEX)

  002cf	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002d5	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  002d9	83 f8 22	 cmp	 eax, 34			; 00000022H
  002dc	74 46		 je	 SHORT $LN57@AnalyseCar

; 1305 : 	{
; 1306 : 		cbMagicCardCount = cbCardIndex[m_cbMagicIndex];

  002de	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  002e8	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  002eb	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  002ee	88 8d bd fa ff
	ff		 mov	 BYTE PTR _cbMagicCardCount$[ebp], cl

; 1307 : 		//如果财神有代替牌，财神与代替牌转换
; 1308 : 		if(INDEX_REPLACE_CARD != MAX_INDEX)

  002f4	33 d2		 xor	 edx, edx
  002f6	74 2c		 je	 SHORT $LN57@AnalyseCar

; 1309 : 		{
; 1310 : 			cbMagicCardIndex[m_cbMagicIndex] = cbMagicCardIndex[INDEX_REPLACE_CARD];

  002f8	b8 01 00 00 00	 mov	 eax, 1
  002fd	6b c8 22	 imul	 ecx, eax, 34
  00300	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00306	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0030a	8a 4c 0d d8	 mov	 cl, BYTE PTR _cbMagicCardIndex$[ebp+ecx]
  0030e	88 4c 05 d8	 mov	 BYTE PTR _cbMagicCardIndex$[ebp+eax], cl

; 1311 : 			cbMagicCardIndex[INDEX_REPLACE_CARD] = cbMagicCardCount;

  00312	ba 01 00 00 00	 mov	 edx, 1
  00317	6b c2 22	 imul	 eax, edx, 34
  0031a	8a 8d bd fa ff
	ff		 mov	 cl, BYTE PTR _cbMagicCardCount$[ebp]
  00320	88 4c 05 d8	 mov	 BYTE PTR _cbMagicCardIndex$[ebp+eax], cl
$LN57@AnalyseCar:

; 1312 : 		}
; 1313 : 	}
; 1314 : 
; 1315 : 	if (cbCardCount>=3)

  00324	0f b6 95 b8 fa
	ff ff		 movzx	 edx, BYTE PTR _cbCardCount$[ebp]
  0032b	83 fa 03	 cmp	 edx, 3
  0032e	0f 8c b9 06 00
	00		 jl	 $LN59@AnalyseCar

; 1316 : 	{
; 1317 : 		for (BYTE i=0;i<MAX_INDEX-MAX_HUA_INDEX;i++)

  00334	c6 85 cb fa ff
	ff 00		 mov	 BYTE PTR _i$25[ebp], 0
  0033b	eb 0e		 jmp	 SHORT $LN10@AnalyseCar
$LN8@AnalyseCar:
  0033d	8a 85 cb fa ff
	ff		 mov	 al, BYTE PTR _i$25[ebp]
  00343	04 01		 add	 al, 1
  00345	88 85 cb fa ff
	ff		 mov	 BYTE PTR _i$25[ebp], al
$LN10@AnalyseCar:
  0034b	0f b6 8d cb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$25[ebp]
  00352	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00355	0f 8d 92 06 00
	00		 jge	 $LN59@AnalyseCar

; 1318 : 		{
; 1319 : 			//同牌判断
; 1320 : 			//如果是财神,并且财神数小于3,则不进行组合
; 1321 : 			if(cbMagicCardIndex[i] >= 3 || (cbMagicCardIndex[i]+cbMagicCardCount >= 3 &&

  0035b	0f b6 95 cb fa
	ff ff		 movzx	 edx, BYTE PTR _i$25[ebp]
  00362	0f b6 44 15 d8	 movzx	 eax, BYTE PTR _cbMagicCardIndex$[ebp+edx]
  00367	83 f8 03	 cmp	 eax, 3
  0036a	7d 48		 jge	 SHORT $LN61@AnalyseCar
  0036c	0f b6 8d cb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$25[ebp]
  00373	0f b6 54 0d d8	 movzx	 edx, BYTE PTR _cbMagicCardIndex$[ebp+ecx]
  00378	0f b6 85 bd fa
	ff ff		 movzx	 eax, BYTE PTR _cbMagicCardCount$[ebp]
  0037f	03 d0		 add	 edx, eax
  00381	83 fa 03	 cmp	 edx, 3
  00384	0f 8c f1 03 00
	00		 jl	 $LN60@AnalyseCar
  0038a	33 c9		 xor	 ecx, ecx
  0038c	75 26		 jne	 SHORT $LN61@AnalyseCar
  0038e	ba 01 00 00 00	 mov	 edx, 1
  00393	85 d2		 test	 edx, edx
  00395	0f 84 e0 03 00
	00		 je	 $LN60@AnalyseCar
  0039b	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  003a2	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  003ac	3b c2		 cmp	 eax, edx
  003ae	0f 84 c7 03 00
	00		 je	 $LN60@AnalyseCar
$LN61@AnalyseCar:

; 1322 : 				((INDEX_REPLACE_CARD!=MAX_INDEX && i != INDEX_REPLACE_CARD) || (INDEX_REPLACE_CARD==MAX_INDEX && i != m_cbMagicIndex)))
; 1323 : 				)
; 1324 : 			{
; 1325 : 				int nTempIndex = cbMagicCardIndex[i];

  003b4	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  003bb	0f b6 4c 05 d8	 movzx	 ecx, BYTE PTR _cbMagicCardIndex$[ebp+eax]
  003c0	89 8d ac fa ff
	ff		 mov	 DWORD PTR _nTempIndex$9[ebp], ecx
$LN13@AnalyseCar:

; 1326 : 				do
; 1327 : 				{
; 1328 : 					ASSERT(cbKindItemCount < CountArray(KindItem));
; 1329 : 					BYTE cbIndex = i;

  003c6	8a 95 cb fa ff
	ff		 mov	 dl, BYTE PTR _i$25[ebp]
  003cc	88 95 c1 fa ff
	ff		 mov	 BYTE PTR _cbIndex$22[ebp], dl

; 1330 : 					BYTE cbCenterCard = SwitchToCardData(i);

  003d2	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  003d9	50		 push	 eax
  003da	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003e0	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  003e5	88 85 b0 fa ff
	ff		 mov	 BYTE PTR _cbCenterCard$10[ebp], al

; 1331 : 					//如果是财神且财神有代替牌,则换成代替牌
; 1332 : 					if(i == m_cbMagicIndex && INDEX_REPLACE_CARD != MAX_INDEX)

  003eb	0f b6 8d cb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$25[ebp]
  003f2	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003f8	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  003fc	3b c8		 cmp	 ecx, eax
  003fe	75 1e		 jne	 SHORT $LN63@AnalyseCar
  00400	33 c9		 xor	 ecx, ecx
  00402	74 1a		 je	 SHORT $LN63@AnalyseCar

; 1333 : 					{
; 1334 : 						cbIndex = INDEX_REPLACE_CARD;

  00404	c6 85 c1 fa ff
	ff 22		 mov	 BYTE PTR _cbIndex$22[ebp], 34 ; 00000022H

; 1335 : 						cbCenterCard = SwitchToCardData(INDEX_REPLACE_CARD);

  0040b	6a 22		 push	 34			; 00000022H
  0040d	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00413	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00418	88 85 b0 fa ff
	ff		 mov	 BYTE PTR _cbCenterCard$10[ebp], al
$LN63@AnalyseCar:

; 1336 : 					}
; 1337 : 					TempKindItem.cbWeaveKind=WIK_PENG;

  0041e	c6 85 04 fb ff
	ff 08		 mov	 BYTE PTR _TempKindItem$[ebp], 8

; 1338 : 					TempKindItem.cbCenterCard=cbCenterCard;

  00425	8a 95 b0 fa ff
	ff		 mov	 dl, BYTE PTR _cbCenterCard$10[ebp]
  0042b	88 95 05 fb ff
	ff		 mov	 BYTE PTR _TempKindItem$[ebp+1], dl

; 1339 : 					TempKindItem.cbValidIndex[0] = nTempIndex>0?cbIndex:m_cbMagicIndex;

  00431	83 bd ac fa ff
	ff 00		 cmp	 DWORD PTR _nTempIndex$9[ebp], 0
  00438	7e 0e		 jle	 SHORT $LN98@AnalyseCar
  0043a	8a 85 c1 fa ff
	ff		 mov	 al, BYTE PTR _cbIndex$22[ebp]
  00440	88 85 9e fa ff
	ff		 mov	 BYTE PTR tv268[ebp], al
  00446	eb 0f		 jmp	 SHORT $LN99@AnalyseCar
$LN98@AnalyseCar:
  00448	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0044e	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00451	88 95 9e fa ff
	ff		 mov	 BYTE PTR tv268[ebp], dl
$LN99@AnalyseCar:
  00457	b8 01 00 00 00	 mov	 eax, 1
  0045c	6b c8 00	 imul	 ecx, eax, 0
  0045f	8a 95 9e fa ff
	ff		 mov	 dl, BYTE PTR tv268[ebp]
  00465	88 94 0d 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+ecx+2], dl

; 1340 : 					TempKindItem.cbValidIndex[1] = nTempIndex>1?cbIndex:m_cbMagicIndex;

  0046c	83 bd ac fa ff
	ff 01		 cmp	 DWORD PTR _nTempIndex$9[ebp], 1
  00473	7e 0e		 jle	 SHORT $LN100@AnalyseCar
  00475	8a 85 c1 fa ff
	ff		 mov	 al, BYTE PTR _cbIndex$22[ebp]
  0047b	88 85 9f fa ff
	ff		 mov	 BYTE PTR tv273[ebp], al
  00481	eb 0f		 jmp	 SHORT $LN101@AnalyseCar
$LN100@AnalyseCar:
  00483	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00489	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  0048c	88 95 9f fa ff
	ff		 mov	 BYTE PTR tv273[ebp], dl
$LN101@AnalyseCar:
  00492	b8 01 00 00 00	 mov	 eax, 1
  00497	c1 e0 00	 shl	 eax, 0
  0049a	8a 8d 9f fa ff
	ff		 mov	 cl, BYTE PTR tv273[ebp]
  004a0	88 8c 05 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+eax+2], cl

; 1341 : 					TempKindItem.cbValidIndex[2] = nTempIndex>2?cbIndex:m_cbMagicIndex;

  004a7	83 bd ac fa ff
	ff 02		 cmp	 DWORD PTR _nTempIndex$9[ebp], 2
  004ae	7e 0e		 jle	 SHORT $LN102@AnalyseCar
  004b0	8a 95 c1 fa ff
	ff		 mov	 dl, BYTE PTR _cbIndex$22[ebp]
  004b6	88 95 9c fa ff
	ff		 mov	 BYTE PTR tv278[ebp], dl
  004bc	eb 0f		 jmp	 SHORT $LN103@AnalyseCar
$LN102@AnalyseCar:
  004be	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004c4	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  004c7	88 8d 9c fa ff
	ff		 mov	 BYTE PTR tv278[ebp], cl
$LN103@AnalyseCar:
  004cd	ba 01 00 00 00	 mov	 edx, 1
  004d2	d1 e2		 shl	 edx, 1
  004d4	8a 85 9c fa ff
	ff		 mov	 al, BYTE PTR tv278[ebp]
  004da	88 84 15 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+edx+2], al

; 1342 : 					AddKindItem(TempKindItem, KindItem, cbKindItemCount, bMagicThree);

  004e1	8d 8d b1 fa ff
	ff		 lea	 ecx, DWORD PTR _bMagicThree$[ebp]
  004e7	51		 push	 ecx
  004e8	8d 95 b9 fa ff
	ff		 lea	 edx, DWORD PTR _cbKindItemCount$[ebp]
  004ee	52		 push	 edx
  004ef	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _KindItem$[ebp]
  004f5	50		 push	 eax
  004f6	8d 8d 04 fb ff
	ff		 lea	 ecx, DWORD PTR _TempKindItem$[ebp]
  004fc	51		 push	 ecx
  004fd	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00503	e8 00 00 00 00	 call	 ?AddKindItem@CGameLogic@@AAE_NAAUtagKindItem@@QAU2@AAEAA_N@Z ; CGameLogic::AddKindItem

; 1343 : 
; 1344 : 
; 1345 : 					//当前索引牌未与财神组合 且财神个数不为0 
; 1346 : 					if(nTempIndex>=3 && cbMagicCardCount >0)

  00508	83 bd ac fa ff
	ff 03		 cmp	 DWORD PTR _nTempIndex$9[ebp], 3
  0050f	0f 8c 11 02 00
	00		 jl	 $LN64@AnalyseCar
  00515	0f b6 95 bd fa
	ff ff		 movzx	 edx, BYTE PTR _cbMagicCardCount$[ebp]
  0051c	85 d2		 test	 edx, edx
  0051e	0f 8e 02 02 00
	00		 jle	 $LN64@AnalyseCar

; 1347 : 					{
; 1348 : 						--nTempIndex;

  00524	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _nTempIndex$9[ebp]
  0052a	83 e8 01	 sub	 eax, 1
  0052d	89 85 ac fa ff
	ff		 mov	 DWORD PTR _nTempIndex$9[ebp], eax

; 1349 : 						//1个财神与之组合
; 1350 : 						TempKindItem.cbWeaveKind=WIK_PENG;

  00533	c6 85 04 fb ff
	ff 08		 mov	 BYTE PTR _TempKindItem$[ebp], 8

; 1351 : 						TempKindItem.cbCenterCard=cbCenterCard;

  0053a	8a 8d b0 fa ff
	ff		 mov	 cl, BYTE PTR _cbCenterCard$10[ebp]
  00540	88 8d 05 fb ff
	ff		 mov	 BYTE PTR _TempKindItem$[ebp+1], cl

; 1352 : 						TempKindItem.cbValidIndex[0] = nTempIndex>0?cbIndex:m_cbMagicIndex;

  00546	83 bd ac fa ff
	ff 00		 cmp	 DWORD PTR _nTempIndex$9[ebp], 0
  0054d	7e 0e		 jle	 SHORT $LN104@AnalyseCar
  0054f	8a 95 c1 fa ff
	ff		 mov	 dl, BYTE PTR _cbIndex$22[ebp]
  00555	88 95 a6 fa ff
	ff		 mov	 BYTE PTR tv324[ebp], dl
  0055b	eb 0f		 jmp	 SHORT $LN105@AnalyseCar
$LN104@AnalyseCar:
  0055d	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00563	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00566	88 8d a6 fa ff
	ff		 mov	 BYTE PTR tv324[ebp], cl
$LN105@AnalyseCar:
  0056c	ba 01 00 00 00	 mov	 edx, 1
  00571	6b c2 00	 imul	 eax, edx, 0
  00574	8a 8d a6 fa ff
	ff		 mov	 cl, BYTE PTR tv324[ebp]
  0057a	88 8c 05 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+eax+2], cl

; 1353 : 						TempKindItem.cbValidIndex[1] = nTempIndex>1?cbIndex:m_cbMagicIndex;

  00581	83 bd ac fa ff
	ff 01		 cmp	 DWORD PTR _nTempIndex$9[ebp], 1
  00588	7e 0e		 jle	 SHORT $LN106@AnalyseCar
  0058a	8a 95 c1 fa ff
	ff		 mov	 dl, BYTE PTR _cbIndex$22[ebp]
  00590	88 95 a5 fa ff
	ff		 mov	 BYTE PTR tv329[ebp], dl
  00596	eb 0f		 jmp	 SHORT $LN107@AnalyseCar
$LN106@AnalyseCar:
  00598	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0059e	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  005a1	88 8d a5 fa ff
	ff		 mov	 BYTE PTR tv329[ebp], cl
$LN107@AnalyseCar:
  005a7	ba 01 00 00 00	 mov	 edx, 1
  005ac	c1 e2 00	 shl	 edx, 0
  005af	8a 85 a5 fa ff
	ff		 mov	 al, BYTE PTR tv329[ebp]
  005b5	88 84 15 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+edx+2], al

; 1354 : 						TempKindItem.cbValidIndex[2] = nTempIndex>2?cbIndex:m_cbMagicIndex;

  005bc	83 bd ac fa ff
	ff 02		 cmp	 DWORD PTR _nTempIndex$9[ebp], 2
  005c3	7e 0e		 jle	 SHORT $LN108@AnalyseCar
  005c5	8a 8d c1 fa ff
	ff		 mov	 cl, BYTE PTR _cbIndex$22[ebp]
  005cb	88 8d a4 fa ff
	ff		 mov	 BYTE PTR tv334[ebp], cl
  005d1	eb 0f		 jmp	 SHORT $LN109@AnalyseCar
$LN108@AnalyseCar:
  005d3	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  005d9	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  005dc	88 85 a4 fa ff
	ff		 mov	 BYTE PTR tv334[ebp], al
$LN109@AnalyseCar:
  005e2	b9 01 00 00 00	 mov	 ecx, 1
  005e7	d1 e1		 shl	 ecx, 1
  005e9	8a 95 a4 fa ff
	ff		 mov	 dl, BYTE PTR tv334[ebp]
  005ef	88 94 0d 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+ecx+2], dl

; 1355 : 						AddKindItem(TempKindItem, KindItem, cbKindItemCount, bMagicThree);

  005f6	8d 85 b1 fa ff
	ff		 lea	 eax, DWORD PTR _bMagicThree$[ebp]
  005fc	50		 push	 eax
  005fd	8d 8d b9 fa ff
	ff		 lea	 ecx, DWORD PTR _cbKindItemCount$[ebp]
  00603	51		 push	 ecx
  00604	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR _KindItem$[ebp]
  0060a	52		 push	 edx
  0060b	8d 85 04 fb ff
	ff		 lea	 eax, DWORD PTR _TempKindItem$[ebp]
  00611	50		 push	 eax
  00612	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00618	e8 00 00 00 00	 call	 ?AddKindItem@CGameLogic@@AAE_NAAUtagKindItem@@QAU2@AAEAA_N@Z ; CGameLogic::AddKindItem

; 1356 : 
; 1357 : 						//两个财神与之组合
; 1358 : 						if(cbMagicCardCount>1)

  0061d	0f b6 8d bd fa
	ff ff		 movzx	 ecx, BYTE PTR _cbMagicCardCount$[ebp]
  00624	83 f9 01	 cmp	 ecx, 1
  00627	0f 8e ea 00 00
	00		 jle	 $LN65@AnalyseCar

; 1359 : 						{
; 1360 : 							TempKindItem.cbWeaveKind=WIK_PENG;

  0062d	c6 85 04 fb ff
	ff 08		 mov	 BYTE PTR _TempKindItem$[ebp], 8

; 1361 : 							TempKindItem.cbCenterCard=cbCenterCard;

  00634	8a 95 b0 fa ff
	ff		 mov	 dl, BYTE PTR _cbCenterCard$10[ebp]
  0063a	88 95 05 fb ff
	ff		 mov	 BYTE PTR _TempKindItem$[ebp+1], dl

; 1362 : 							TempKindItem.cbValidIndex[0] = nTempIndex>0?cbIndex:m_cbMagicIndex;

  00640	83 bd ac fa ff
	ff 00		 cmp	 DWORD PTR _nTempIndex$9[ebp], 0
  00647	7e 0e		 jle	 SHORT $LN110@AnalyseCar
  00649	8a 85 c1 fa ff
	ff		 mov	 al, BYTE PTR _cbIndex$22[ebp]
  0064f	88 85 a3 fa ff
	ff		 mov	 BYTE PTR tv346[ebp], al
  00655	eb 0f		 jmp	 SHORT $LN111@AnalyseCar
$LN110@AnalyseCar:
  00657	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0065d	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00660	88 95 a3 fa ff
	ff		 mov	 BYTE PTR tv346[ebp], dl
$LN111@AnalyseCar:
  00666	b8 01 00 00 00	 mov	 eax, 1
  0066b	6b c8 00	 imul	 ecx, eax, 0
  0066e	8a 95 a3 fa ff
	ff		 mov	 dl, BYTE PTR tv346[ebp]
  00674	88 94 0d 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+ecx+2], dl

; 1363 : 							TempKindItem.cbValidIndex[1] = nTempIndex>1?cbIndex:m_cbMagicIndex;

  0067b	83 bd ac fa ff
	ff 01		 cmp	 DWORD PTR _nTempIndex$9[ebp], 1
  00682	7e 0e		 jle	 SHORT $LN112@AnalyseCar
  00684	8a 85 c1 fa ff
	ff		 mov	 al, BYTE PTR _cbIndex$22[ebp]
  0068a	88 85 a2 fa ff
	ff		 mov	 BYTE PTR tv351[ebp], al
  00690	eb 0f		 jmp	 SHORT $LN113@AnalyseCar
$LN112@AnalyseCar:
  00692	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00698	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  0069b	88 95 a2 fa ff
	ff		 mov	 BYTE PTR tv351[ebp], dl
$LN113@AnalyseCar:
  006a1	b8 01 00 00 00	 mov	 eax, 1
  006a6	c1 e0 00	 shl	 eax, 0
  006a9	8a 8d a2 fa ff
	ff		 mov	 cl, BYTE PTR tv351[ebp]
  006af	88 8c 05 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+eax+2], cl

; 1364 : 							TempKindItem.cbValidIndex[2] = nTempIndex>2?cbIndex:m_cbMagicIndex;

  006b6	83 bd ac fa ff
	ff 02		 cmp	 DWORD PTR _nTempIndex$9[ebp], 2
  006bd	7e 0e		 jle	 SHORT $LN114@AnalyseCar
  006bf	8a 95 c1 fa ff
	ff		 mov	 dl, BYTE PTR _cbIndex$22[ebp]
  006c5	88 95 a1 fa ff
	ff		 mov	 BYTE PTR tv356[ebp], dl
  006cb	eb 0f		 jmp	 SHORT $LN115@AnalyseCar
$LN114@AnalyseCar:
  006cd	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006d3	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  006d6	88 8d a1 fa ff
	ff		 mov	 BYTE PTR tv356[ebp], cl
$LN115@AnalyseCar:
  006dc	ba 01 00 00 00	 mov	 edx, 1
  006e1	d1 e2		 shl	 edx, 1
  006e3	8a 85 a1 fa ff
	ff		 mov	 al, BYTE PTR tv356[ebp]
  006e9	88 84 15 06 fb
	ff ff		 mov	 BYTE PTR _TempKindItem$[ebp+edx+2], al

; 1365 : 							AddKindItem(TempKindItem, KindItem, cbKindItemCount, bMagicThree);

  006f0	8d 8d b1 fa ff
	ff		 lea	 ecx, DWORD PTR _bMagicThree$[ebp]
  006f6	51		 push	 ecx
  006f7	8d 95 b9 fa ff
	ff		 lea	 edx, DWORD PTR _cbKindItemCount$[ebp]
  006fd	52		 push	 edx
  006fe	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _KindItem$[ebp]
  00704	50		 push	 eax
  00705	8d 8d 04 fb ff
	ff		 lea	 ecx, DWORD PTR _TempKindItem$[ebp]
  0070b	51		 push	 ecx
  0070c	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00712	e8 00 00 00 00	 call	 ?AddKindItem@CGameLogic@@AAE_NAAUtagKindItem@@QAU2@AAEAA_N@Z ; CGameLogic::AddKindItem
$LN65@AnalyseCar:

; 1366 : 						}
; 1367 : 
; 1368 : 						++nTempIndex;

  00717	8b 95 ac fa ff
	ff		 mov	 edx, DWORD PTR _nTempIndex$9[ebp]
  0071d	83 c2 01	 add	 edx, 1
  00720	89 95 ac fa ff
	ff		 mov	 DWORD PTR _nTempIndex$9[ebp], edx
$LN64@AnalyseCar:

; 1369 : 					}
; 1370 : 
; 1371 : 					//如果是财神,则退出
; 1372 : 					if(i == INDEX_REPLACE_CARD || ((i == m_cbMagicIndex) && INDEX_REPLACE_CARD == MAX_INDEX))

  00726	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  0072d	83 f8 22	 cmp	 eax, 34			; 00000022H
  00730	74 1e		 je	 SHORT $LN67@AnalyseCar
  00732	0f b6 8d cb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$25[ebp]
  00739	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0073f	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00743	3b c8		 cmp	 ecx, eax
  00745	75 0b		 jne	 SHORT $LN66@AnalyseCar
  00747	b9 01 00 00 00	 mov	 ecx, 1
  0074c	85 c9		 test	 ecx, ecx
  0074e	74 02		 je	 SHORT $LN66@AnalyseCar
$LN67@AnalyseCar:

; 1373 : 						break;

  00750	eb 29		 jmp	 SHORT $LN60@AnalyseCar
$LN66@AnalyseCar:

; 1374 : 
; 1375 : 					nTempIndex -= 3;

  00752	8b 95 ac fa ff
	ff		 mov	 edx, DWORD PTR _nTempIndex$9[ebp]
  00758	83 ea 03	 sub	 edx, 3
  0075b	89 95 ac fa ff
	ff		 mov	 DWORD PTR _nTempIndex$9[ebp], edx

; 1376 : 					//如果刚好搭配全部，则退出
; 1377 : 					if(nTempIndex == 0) break;

  00761	75 02		 jne	 SHORT $LN11@AnalyseCar
  00763	eb 16		 jmp	 SHORT $LN60@AnalyseCar
$LN11@AnalyseCar:

; 1378 : 
; 1379 : 				}while(nTempIndex+cbMagicCardCount >= 3);

  00765	0f b6 85 bd fa
	ff ff		 movzx	 eax, BYTE PTR _cbMagicCardCount$[ebp]
  0076c	03 85 ac fa ff
	ff		 add	 eax, DWORD PTR _nTempIndex$9[ebp]
  00772	83 f8 03	 cmp	 eax, 3
  00775	0f 8d 4b fc ff
	ff		 jge	 $LN13@AnalyseCar
$LN60@AnalyseCar:

; 1380 : 			}
; 1381 : 
; 1382 : 			//连牌判断
; 1383 : 			if ((i<(MAX_INDEX-MAX_HUA_INDEX-9))&&((i%9)<7))

  0077b	0f b6 8d cb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$25[ebp]
  00782	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00785	0f 8d 5d 02 00
	00		 jge	 $LN69@AnalyseCar
  0078b	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  00792	99		 cdq
  00793	b9 09 00 00 00	 mov	 ecx, 9
  00798	f7 f9		 idiv	 ecx
  0079a	83 fa 07	 cmp	 edx, 7
  0079d	0f 8d 45 02 00
	00		 jge	 $LN69@AnalyseCar

; 1384 : 			{
; 1385 : 				//只要财神牌数加上3个顺序索引的牌数大于等于3,则进行组合
; 1386 : 				if(cbMagicCardCount+cbMagicCardIndex[i]+cbMagicCardIndex[i+1]+cbMagicCardIndex[i+2] >= 3)

  007a3	0f b6 95 bd fa
	ff ff		 movzx	 edx, BYTE PTR _cbMagicCardCount$[ebp]
  007aa	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  007b1	0f b6 4c 05 d8	 movzx	 ecx, BYTE PTR _cbMagicCardIndex$[ebp+eax]
  007b6	03 d1		 add	 edx, ecx
  007b8	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  007bf	0f b6 4c 05 d9	 movzx	 ecx, BYTE PTR _cbMagicCardIndex$[ebp+eax+1]
  007c4	03 d1		 add	 edx, ecx
  007c6	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  007cd	0f b6 4c 05 da	 movzx	 ecx, BYTE PTR _cbMagicCardIndex$[ebp+eax+2]
  007d2	03 d1		 add	 edx, ecx
  007d4	83 fa 03	 cmp	 edx, 3
  007d7	0f 8c 0b 02 00
	00		 jl	 $LN69@AnalyseCar

; 1387 : 				{
; 1388 : 					BYTE cbIndex[3] = { cbMagicCardIndex[i],cbMagicCardIndex[i+1],cbMagicCardIndex[i+2] };

  007dd	0f b6 95 cb fa
	ff ff		 movzx	 edx, BYTE PTR _i$25[ebp]
  007e4	8a 44 15 d8	 mov	 al, BYTE PTR _cbMagicCardIndex$[ebp+edx]
  007e8	88 85 a8 fa ff
	ff		 mov	 BYTE PTR _cbIndex$8[ebp], al
  007ee	0f b6 8d cb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$25[ebp]
  007f5	8a 54 0d d9	 mov	 dl, BYTE PTR _cbMagicCardIndex$[ebp+ecx+1]
  007f9	88 95 a9 fa ff
	ff		 mov	 BYTE PTR _cbIndex$8[ebp+1], dl
  007ff	0f b6 85 cb fa
	ff ff		 movzx	 eax, BYTE PTR _i$25[ebp]
  00806	8a 4c 05 da	 mov	 cl, BYTE PTR _cbMagicCardIndex$[ebp+eax+2]
  0080a	88 8d aa fa ff
	ff		 mov	 BYTE PTR _cbIndex$8[ebp+2], cl

; 1389 : 
; 1390 : 					if(cbIndex[0]+cbIndex[1]+cbIndex[2]==0) continue;

  00810	ba 01 00 00 00	 mov	 edx, 1
  00815	6b c2 00	 imul	 eax, edx, 0
  00818	0f b6 8c 05 a8
	fa ff ff	 movzx	 ecx, BYTE PTR _cbIndex$8[ebp+eax]
  00820	ba 01 00 00 00	 mov	 edx, 1
  00825	c1 e2 00	 shl	 edx, 0
  00828	0f b6 84 15 a8
	fa ff ff	 movzx	 eax, BYTE PTR _cbIndex$8[ebp+edx]
  00830	03 c8		 add	 ecx, eax
  00832	ba 01 00 00 00	 mov	 edx, 1
  00837	d1 e2		 shl	 edx, 1
  00839	0f b6 84 15 a8
	fa ff ff	 movzx	 eax, BYTE PTR _cbIndex$8[ebp+edx]
  00841	03 c8		 add	 ecx, eax
  00843	75 05		 jne	 SHORT $LN71@AnalyseCar
  00845	e9 f3 fa ff ff	 jmp	 $LN8@AnalyseCar
$LN71@AnalyseCar:

; 1391 : 
; 1392 : 					int nMagicCountTemp;
; 1393 : 					nMagicCountTemp = cbMagicCardCount;

  0084a	0f b6 8d bd fa
	ff ff		 movzx	 ecx, BYTE PTR _cbMagicCardCount$[ebp]
  00851	89 8d 8c fa ff
	ff		 mov	 DWORD PTR _nMagicCountTemp$2[ebp], ecx
$LN14@AnalyseCar:

; 1394 : 
; 1395 : 					BYTE cbValidIndex[3];
; 1396 : 					while(nMagicCountTemp+cbIndex[0]+cbIndex[1]+cbIndex[2] >= 3)

  00857	ba 01 00 00 00	 mov	 edx, 1
  0085c	6b c2 00	 imul	 eax, edx, 0
  0085f	0f b6 8c 05 a8
	fa ff ff	 movzx	 ecx, BYTE PTR _cbIndex$8[ebp+eax]
  00867	03 8d 8c fa ff
	ff		 add	 ecx, DWORD PTR _nMagicCountTemp$2[ebp]
  0086d	ba 01 00 00 00	 mov	 edx, 1
  00872	c1 e2 00	 shl	 edx, 0
  00875	0f b6 84 15 a8
	fa ff ff	 movzx	 eax, BYTE PTR _cbIndex$8[ebp+edx]
  0087d	03 c8		 add	 ecx, eax
  0087f	ba 01 00 00 00	 mov	 edx, 1
  00884	d1 e2		 shl	 edx, 1
  00886	0f b6 84 15 a8
	fa ff ff	 movzx	 eax, BYTE PTR _cbIndex$8[ebp+edx]
  0088e	03 c8		 add	 ecx, eax
  00890	83 f9 03	 cmp	 ecx, 3
  00893	0f 8c 4f 01 00
	00		 jl	 $LN69@AnalyseCar

; 1397 : 					{
; 1398 : 						for(BYTE j = 0; j < CountArray(cbIndex); j++)

  00899	c6 85 c0 fa ff
	ff 00		 mov	 BYTE PTR _j$21[ebp], 0
  008a0	eb 0f		 jmp	 SHORT $LN18@AnalyseCar
$LN16@AnalyseCar:
  008a2	8a 8d c0 fa ff
	ff		 mov	 cl, BYTE PTR _j$21[ebp]
  008a8	80 c1 01	 add	 cl, 1
  008ab	88 8d c0 fa ff
	ff		 mov	 BYTE PTR _j$21[ebp], cl
$LN18@AnalyseCar:
  008b1	0f b6 95 c0 fa
	ff ff		 movzx	 edx, BYTE PTR _j$21[ebp]
  008b8	83 fa 03	 cmp	 edx, 3
  008bb	0f 83 b6 00 00
	00		 jae	 $LN17@AnalyseCar

; 1399 : 						{
; 1400 : 							if(cbIndex[j] > 0) 

  008c1	0f b6 85 c0 fa
	ff ff		 movzx	 eax, BYTE PTR _j$21[ebp]
  008c8	0f b6 8c 05 a8
	fa ff ff	 movzx	 ecx, BYTE PTR _cbIndex$8[ebp+eax]
  008d0	85 c9		 test	 ecx, ecx
  008d2	7e 78		 jle	 SHORT $LN72@AnalyseCar

; 1401 : 							{
; 1402 : 								cbIndex[j]--;

  008d4	0f b6 95 c0 fa
	ff ff		 movzx	 edx, BYTE PTR _j$21[ebp]
  008db	8a 84 15 a8 fa
	ff ff		 mov	 al, BYTE PTR _cbIndex$8[ebp+edx]
  008e2	2c 01		 sub	 al, 1
  008e4	0f b6 8d c0 fa
	ff ff		 movzx	 ecx, BYTE PTR _j$21[ebp]
  008eb	88 84 0d a8 fa
	ff ff		 mov	 BYTE PTR _cbIndex$8[ebp+ecx], al

; 1403 : 								cbValidIndex[j] = ((i+j==m_cbMagicIndex) && INDEX_REPLACE_CARD!=MAX_INDEX)?INDEX_REPLACE_CARD:i+j;

  008f2	0f b6 95 cb fa
	ff ff		 movzx	 edx, BYTE PTR _i$25[ebp]
  008f9	0f b6 85 c0 fa
	ff ff		 movzx	 eax, BYTE PTR _j$21[ebp]
  00900	03 d0		 add	 edx, eax
  00902	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00908	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  0090c	3b d0		 cmp	 edx, eax
  0090e	75 10		 jne	 SHORT $LN116@AnalyseCar
  00910	33 c9		 xor	 ecx, ecx
  00912	74 0c		 je	 SHORT $LN116@AnalyseCar
  00914	c7 85 84 fa ff
	ff 22 00 00 00	 mov	 DWORD PTR tv467[ebp], 34 ; 00000022H
  0091e	eb 16		 jmp	 SHORT $LN117@AnalyseCar
$LN116@AnalyseCar:
  00920	0f b6 95 cb fa
	ff ff		 movzx	 edx, BYTE PTR _i$25[ebp]
  00927	0f b6 85 c0 fa
	ff ff		 movzx	 eax, BYTE PTR _j$21[ebp]
  0092e	03 d0		 add	 edx, eax
  00930	89 95 84 fa ff
	ff		 mov	 DWORD PTR tv467[ebp], edx
$LN117@AnalyseCar:
  00936	0f b6 8d c0 fa
	ff ff		 movzx	 ecx, BYTE PTR _j$21[ebp]
  0093d	8a 95 84 fa ff
	ff		 mov	 dl, BYTE PTR tv467[ebp]
  00943	88 94 0d 88 fa
	ff ff		 mov	 BYTE PTR _cbValidIndex$1[ebp+ecx], dl

; 1404 : 							}
; 1405 : 							else 

  0094a	eb 26		 jmp	 SHORT $LN73@AnalyseCar
$LN72@AnalyseCar:

; 1406 : 							{
; 1407 : 								nMagicCountTemp--;

  0094c	8b 85 8c fa ff
	ff		 mov	 eax, DWORD PTR _nMagicCountTemp$2[ebp]
  00952	83 e8 01	 sub	 eax, 1
  00955	89 85 8c fa ff
	ff		 mov	 DWORD PTR _nMagicCountTemp$2[ebp], eax

; 1408 : 								cbValidIndex[j] = m_cbMagicIndex;														

  0095b	0f b6 8d c0 fa
	ff ff		 movzx	 ecx, BYTE PTR _j$21[ebp]
  00962	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00968	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  0096b	88 84 0d 88 fa
	ff ff		 mov	 BYTE PTR _cbValidIndex$1[ebp+ecx], al
$LN73@AnalyseCar:

; 1409 : 							}
; 1410 : 						}

  00972	e9 2b ff ff ff	 jmp	 $LN16@AnalyseCar
$LN17@AnalyseCar:

; 1411 : 						if(nMagicCountTemp >= 0)

  00977	83 bd 8c fa ff
	ff 00		 cmp	 DWORD PTR _nMagicCountTemp$2[ebp], 0
  0097e	7c 61		 jl	 SHORT $LN74@AnalyseCar

; 1412 : 						{
; 1413 : 							ASSERT(cbKindItemCount < CountArray(KindItem));
; 1414 : 							TempKindItem.cbWeaveKind=WIK_LEFT;

  00980	c6 85 04 fb ff
	ff 01		 mov	 BYTE PTR _TempKindItem$[ebp], 1

; 1415 : 							TempKindItem.cbCenterCard=SwitchToCardData(i);

  00987	0f b6 8d cb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$25[ebp]
  0098e	51		 push	 ecx
  0098f	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00995	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0099a	88 85 05 fb ff
	ff		 mov	 BYTE PTR _TempKindItem$[ebp+1], al

; 1416 : 							CopyMemory(TempKindItem.cbValidIndex,cbValidIndex,sizeof(cbValidIndex));

  009a0	6a 03		 push	 3
  009a2	8d 95 88 fa ff
	ff		 lea	 edx, DWORD PTR _cbValidIndex$1[ebp]
  009a8	52		 push	 edx
  009a9	8d 85 06 fb ff
	ff		 lea	 eax, DWORD PTR _TempKindItem$[ebp+2]
  009af	50		 push	 eax
  009b0	e8 00 00 00 00	 call	 _memcpy
  009b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1417 : 							AddKindItem(TempKindItem, KindItem, cbKindItemCount, bMagicThree);

  009b8	8d 8d b1 fa ff
	ff		 lea	 ecx, DWORD PTR _bMagicThree$[ebp]
  009be	51		 push	 ecx
  009bf	8d 95 b9 fa ff
	ff		 lea	 edx, DWORD PTR _cbKindItemCount$[ebp]
  009c5	52		 push	 edx
  009c6	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _KindItem$[ebp]
  009cc	50		 push	 eax
  009cd	8d 8d 04 fb ff
	ff		 lea	 ecx, DWORD PTR _TempKindItem$[ebp]
  009d3	51		 push	 ecx
  009d4	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009da	e8 00 00 00 00	 call	 ?AddKindItem@CGameLogic@@AAE_NAAUtagKindItem@@QAU2@AAEAA_N@Z ; CGameLogic::AddKindItem

; 1418 : 						}
; 1419 : 						else break;

  009df	eb 02		 jmp	 SHORT $LN75@AnalyseCar
$LN74@AnalyseCar:
  009e1	eb 05		 jmp	 SHORT $LN69@AnalyseCar
$LN75@AnalyseCar:

; 1420 : 					}

  009e3	e9 6f fe ff ff	 jmp	 $LN14@AnalyseCar
$LN69@AnalyseCar:

; 1421 : 				}
; 1422 : 			}
; 1423 : 		}

  009e8	e9 50 f9 ff ff	 jmp	 $LN8@AnalyseCar
$LN59@AnalyseCar:

; 1424 : 	}
; 1425 : 
; 1426 : 	//组合分析
; 1427 : 	if (cbKindItemCount>=cbLessKindItem)

  009ed	0f b6 95 b9 fa
	ff ff		 movzx	 edx, BYTE PTR _cbKindItemCount$[ebp]
  009f4	0f b6 85 c3 fa
	ff ff		 movzx	 eax, BYTE PTR _cbLessKindItem$[ebp]
  009fb	3b d0		 cmp	 edx, eax
  009fd	0f 8c 26 07 00
	00		 jl	 $LN76@AnalyseCar

; 1428 : 	{
; 1429 : 		ASSERT(27*2+28+16 >= cbKindItemCount);
; 1430 : 		//变量定义
; 1431 : 		BYTE cbCardIndexTemp[MAX_INDEX];
; 1432 : 		ZeroMemory(cbCardIndexTemp,sizeof(cbCardIndexTemp));

  00a03	6a 22		 push	 34			; 00000022H
  00a05	6a 00		 push	 0
  00a07	8d 4d b4	 lea	 ecx, DWORD PTR _cbCardIndexTemp$30[ebp]
  00a0a	51		 push	 ecx
  00a0b	e8 00 00 00 00	 call	 _memset
  00a10	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1433 : 
; 1434 : 		//变量定义
; 1435 : 		BYTE cbIndex[MAX_WEAVE];
; 1436 : 		for(BYTE i = 0; i < CountArray(cbIndex); i++)

  00a13	c6 85 b7 fa ff
	ff 00		 mov	 BYTE PTR _i$15[ebp], 0
  00a1a	eb 0f		 jmp	 SHORT $LN21@AnalyseCar
$LN19@AnalyseCar:
  00a1c	8a 95 b7 fa ff
	ff		 mov	 dl, BYTE PTR _i$15[ebp]
  00a22	80 c2 01	 add	 dl, 1
  00a25	88 95 b7 fa ff
	ff		 mov	 BYTE PTR _i$15[ebp], dl
$LN21@AnalyseCar:
  00a2b	0f b6 85 b7 fa
	ff ff		 movzx	 eax, BYTE PTR _i$15[ebp]
  00a32	83 f8 04	 cmp	 eax, 4
  00a35	73 16		 jae	 SHORT $LN20@AnalyseCar

; 1437 : 			cbIndex[i] = i;

  00a37	0f b6 8d b7 fa
	ff ff		 movzx	 ecx, BYTE PTR _i$15[ebp]
  00a3e	8a 95 b7 fa ff
	ff		 mov	 dl, BYTE PTR _i$15[ebp]
  00a44	88 94 0d 98 fa
	ff ff		 mov	 BYTE PTR _cbIndex$5[ebp+ecx], dl
  00a4b	eb cf		 jmp	 SHORT $LN19@AnalyseCar
$LN20@AnalyseCar:

; 1438 : 
; 1439 : 		tagKindItem * pKindItem[MAX_WEAVE];
; 1440 : 		ZeroMemory(&pKindItem,sizeof(pKindItem));

  00a4d	6a 10		 push	 16			; 00000010H
  00a4f	6a 00		 push	 0
  00a51	8d 45 a4	 lea	 eax, DWORD PTR _pKindItem$29[ebp]
  00a54	50		 push	 eax
  00a55	e8 00 00 00 00	 call	 _memset
  00a5a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@AnalyseCar:

; 1441 : 
; 1442 : 		tagKindItem KindItemTemp[CountArray(KindItem)];
; 1443 : 
; 1444 : 		//开始组合
; 1445 : 		do
; 1446 : 		{
; 1447 : 			//如果四个组合中的混牌大于手上的混牌个数则重置索引
; 1448 : 			cbTempMagicCount = 0;

  00a5d	c6 85 b2 fa ff
	ff 00		 mov	 BYTE PTR _cbTempMagicCount$[ebp], 0

; 1449 : 			for(int i=0;i<cbLessKindItem;i++) cbTempMagicCount +=  KindItem[cbIndex[i]].cbMagicCount; 

  00a64	c7 85 90 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$3[ebp], 0
  00a6e	eb 0f		 jmp	 SHORT $LN27@AnalyseCar
$LN25@AnalyseCar:
  00a70	8b 8d 90 fa ff
	ff		 mov	 ecx, DWORD PTR _i$3[ebp]
  00a76	83 c1 01	 add	 ecx, 1
  00a79	89 8d 90 fa ff
	ff		 mov	 DWORD PTR _i$3[ebp], ecx
$LN27@AnalyseCar:
  00a7f	0f b6 95 c3 fa
	ff ff		 movzx	 edx, BYTE PTR _cbLessKindItem$[ebp]
  00a86	39 95 90 fa ff
	ff		 cmp	 DWORD PTR _i$3[ebp], edx
  00a8c	7d 2a		 jge	 SHORT $LN26@AnalyseCar
  00a8e	8b 85 90 fa ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  00a94	0f b6 8c 05 98
	fa ff ff	 movzx	 ecx, BYTE PTR _cbIndex$5[ebp+eax]
  00a9c	6b d1 06	 imul	 edx, ecx, 6
  00a9f	0f b6 84 15 5d
	fd ff ff	 movzx	 eax, BYTE PTR _KindItem$[ebp+edx+5]
  00aa7	0f b6 8d b2 fa
	ff ff		 movzx	 ecx, BYTE PTR _cbTempMagicCount$[ebp]
  00aae	03 c8		 add	 ecx, eax
  00ab0	88 8d b2 fa ff
	ff		 mov	 BYTE PTR _cbTempMagicCount$[ebp], cl
  00ab6	eb b8		 jmp	 SHORT $LN25@AnalyseCar
$LN26@AnalyseCar:

; 1450 : 			if(cbTempMagicCount <= cbMagicCardCount)

  00ab8	0f b6 95 b2 fa
	ff ff		 movzx	 edx, BYTE PTR _cbTempMagicCount$[ebp]
  00abf	0f b6 85 bd fa
	ff ff		 movzx	 eax, BYTE PTR _cbMagicCardCount$[ebp]
  00ac6	3b d0		 cmp	 edx, eax
  00ac8	0f 8f 30 05 00
	00		 jg	 $LN77@AnalyseCar

; 1451 : 			{
; 1452 : 				//设置变量
; 1453 : 				CopyMemory(cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp));

  00ace	6a 22		 push	 34			; 00000022H
  00ad0	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00ad3	51		 push	 ecx
  00ad4	8d 55 b4	 lea	 edx, DWORD PTR _cbCardIndexTemp$30[ebp]
  00ad7	52		 push	 edx
  00ad8	e8 00 00 00 00	 call	 _memcpy
  00add	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1454 : 				CopyMemory(KindItemTemp,KindItem,sizeof(KindItem));

  00ae0	68 4c 02 00 00	 push	 588			; 0000024cH
  00ae5	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _KindItem$[ebp]
  00aeb	50		 push	 eax
  00aec	8d 8d 0c fb ff
	ff		 lea	 ecx, DWORD PTR _KindItemTemp$28[ebp]
  00af2	51		 push	 ecx
  00af3	e8 00 00 00 00	 call	 _memcpy
  00af8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1455 : 	
; 1456 : 				for (BYTE i=0;i<cbLessKindItem;i++)

  00afb	c6 85 b6 fa ff
	ff 00		 mov	 BYTE PTR _i$14[ebp], 0
  00b02	eb 0f		 jmp	 SHORT $LN30@AnalyseCar
$LN28@AnalyseCar:
  00b04	8a 95 b6 fa ff
	ff		 mov	 dl, BYTE PTR _i$14[ebp]
  00b0a	80 c2 01	 add	 dl, 1
  00b0d	88 95 b6 fa ff
	ff		 mov	 BYTE PTR _i$14[ebp], dl
$LN30@AnalyseCar:
  00b13	0f b6 85 b6 fa
	ff ff		 movzx	 eax, BYTE PTR _i$14[ebp]
  00b1a	0f b6 8d c3 fa
	ff ff		 movzx	 ecx, BYTE PTR _cbLessKindItem$[ebp]
  00b21	3b c1		 cmp	 eax, ecx
  00b23	7d 26		 jge	 SHORT $LN29@AnalyseCar

; 1457 : 					pKindItem[i]=&KindItemTemp[cbIndex[i]];

  00b25	0f b6 95 b6 fa
	ff ff		 movzx	 edx, BYTE PTR _i$14[ebp]
  00b2c	0f b6 84 15 98
	fa ff ff	 movzx	 eax, BYTE PTR _cbIndex$5[ebp+edx]
  00b34	6b c8 06	 imul	 ecx, eax, 6
  00b37	8d 94 0d 0c fb
	ff ff		 lea	 edx, DWORD PTR _KindItemTemp$28[ebp+ecx]
  00b3e	0f b6 85 b6 fa
	ff ff		 movzx	 eax, BYTE PTR _i$14[ebp]
  00b45	89 54 85 a4	 mov	 DWORD PTR _pKindItem$29[ebp+eax*4], edx
  00b49	eb b9		 jmp	 SHORT $LN28@AnalyseCar
$LN29@AnalyseCar:

; 1458 : 
; 1459 : 
; 1460 : 				//数量判断
; 1461 : 				bool bEnoughCard=true;

  00b4b	c6 85 a0 fa ff
	ff 01		 mov	 BYTE PTR _bEnoughCard$6[ebp], 1

; 1462 : 
; 1463 : 				for (BYTE i=0;i<cbLessKindItem*3;i++)

  00b52	c6 85 ba fa ff
	ff 00		 mov	 BYTE PTR _i$16[ebp], 0
  00b59	eb 0f		 jmp	 SHORT $LN33@AnalyseCar
$LN31@AnalyseCar:
  00b5b	8a 8d ba fa ff
	ff		 mov	 cl, BYTE PTR _i$16[ebp]
  00b61	80 c1 01	 add	 cl, 1
  00b64	88 8d ba fa ff
	ff		 mov	 BYTE PTR _i$16[ebp], cl
$LN33@AnalyseCar:
  00b6a	0f b6 95 ba fa
	ff ff		 movzx	 edx, BYTE PTR _i$16[ebp]
  00b71	0f b6 85 c3 fa
	ff ff		 movzx	 eax, BYTE PTR _cbLessKindItem$[ebp]
  00b78	6b c8 03	 imul	 ecx, eax, 3
  00b7b	3b d1		 cmp	 edx, ecx
  00b7d	0f 8d d6 00 00
	00		 jge	 $LN32@AnalyseCar

; 1464 : 				{
; 1465 : 					//存在判断
; 1466 : 					BYTE cbCardIndex=pKindItem[i/3]->cbValidIndex[i%3]; 

  00b83	0f b6 85 ba fa
	ff ff		 movzx	 eax, BYTE PTR _i$16[ebp]
  00b8a	99		 cdq
  00b8b	b9 03 00 00 00	 mov	 ecx, 3
  00b90	f7 f9		 idiv	 ecx
  00b92	8b 4c 85 a4	 mov	 ecx, DWORD PTR _pKindItem$29[ebp+eax*4]
  00b96	0f b6 85 ba fa
	ff ff		 movzx	 eax, BYTE PTR _i$16[ebp]
  00b9d	99		 cdq
  00b9e	be 03 00 00 00	 mov	 esi, 3
  00ba3	f7 fe		 idiv	 esi
  00ba5	8a 54 11 02	 mov	 dl, BYTE PTR [ecx+edx+2]
  00ba9	88 95 a7 fa ff
	ff		 mov	 BYTE PTR _cbCardIndex$7[ebp], dl

; 1467 : 					if (cbCardIndexTemp[cbCardIndex]==0)

  00baf	0f b6 85 a7 fa
	ff ff		 movzx	 eax, BYTE PTR _cbCardIndex$7[ebp]
  00bb6	0f b6 4c 05 b4	 movzx	 ecx, BYTE PTR _cbCardIndexTemp$30[ebp+eax]
  00bbb	85 c9		 test	 ecx, ecx
  00bbd	75 7c		 jne	 SHORT $LN78@AnalyseCar

; 1468 : 					{
; 1469 : 						if(m_cbMagicIndex != MAX_INDEX && cbCardIndexTemp[m_cbMagicIndex] > 0)

  00bbf	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00bc5	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00bc9	83 f8 22	 cmp	 eax, 34			; 00000022H
  00bcc	74 62		 je	 SHORT $LN80@AnalyseCar
  00bce	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00bd4	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00bd8	0f b6 44 15 b4	 movzx	 eax, BYTE PTR _cbCardIndexTemp$30[ebp+edx]
  00bdd	85 c0		 test	 eax, eax
  00bdf	7e 4f		 jle	 SHORT $LN80@AnalyseCar

; 1470 : 						{											
; 1471 : 							pKindItem[i/3]->cbValidIndex[i%3] = m_cbMagicIndex;

  00be1	0f b6 85 ba fa
	ff ff		 movzx	 eax, BYTE PTR _i$16[ebp]
  00be8	99		 cdq
  00be9	b9 03 00 00 00	 mov	 ecx, 3
  00bee	f7 f9		 idiv	 ecx
  00bf0	8b 4c 85 a4	 mov	 ecx, DWORD PTR _pKindItem$29[ebp+eax*4]
  00bf4	0f b6 85 ba fa
	ff ff		 movzx	 eax, BYTE PTR _i$16[ebp]
  00bfb	99		 cdq
  00bfc	be 03 00 00 00	 mov	 esi, 3
  00c01	f7 fe		 idiv	 esi
  00c03	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c09	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00c0c	88 44 11 02	 mov	 BYTE PTR [ecx+edx+2], al

; 1472 : 							cbCardIndexTemp[m_cbMagicIndex]--;

  00c10	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c16	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00c1a	8a 44 15 b4	 mov	 al, BYTE PTR _cbCardIndexTemp$30[ebp+edx]
  00c1e	2c 01		 sub	 al, 1
  00c20	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c26	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00c2a	88 44 15 b4	 mov	 BYTE PTR _cbCardIndexTemp$30[ebp+edx], al

; 1473 : 						}
; 1474 : 						else

  00c2e	eb 09		 jmp	 SHORT $LN81@AnalyseCar
$LN80@AnalyseCar:

; 1475 : 						{
; 1476 : 							bEnoughCard=false;

  00c30	c6 85 a0 fa ff
	ff 00		 mov	 BYTE PTR _bEnoughCard$6[ebp], 0

; 1477 : 							break;

  00c37	eb 20		 jmp	 SHORT $LN32@AnalyseCar
$LN81@AnalyseCar:

; 1478 : 						}

  00c39	eb 19		 jmp	 SHORT $LN79@AnalyseCar
$LN78@AnalyseCar:

; 1479 : 					}
; 1480 : 					else cbCardIndexTemp[cbCardIndex]--;

  00c3b	0f b6 85 a7 fa
	ff ff		 movzx	 eax, BYTE PTR _cbCardIndex$7[ebp]
  00c42	8a 4c 05 b4	 mov	 cl, BYTE PTR _cbCardIndexTemp$30[ebp+eax]
  00c46	80 e9 01	 sub	 cl, 1
  00c49	0f b6 95 a7 fa
	ff ff		 movzx	 edx, BYTE PTR _cbCardIndex$7[ebp]
  00c50	88 4c 15 b4	 mov	 BYTE PTR _cbCardIndexTemp$30[ebp+edx], cl
$LN79@AnalyseCar:

; 1481 : 				}

  00c54	e9 02 ff ff ff	 jmp	 $LN31@AnalyseCar
$LN32@AnalyseCar:

; 1482 : 
; 1483 : 				//胡牌判断
; 1484 : 				if (bEnoughCard==true)

  00c59	0f b6 85 a0 fa
	ff ff		 movzx	 eax, BYTE PTR _bEnoughCard$6[ebp]
  00c60	83 f8 01	 cmp	 eax, 1
  00c63	0f 85 95 03 00
	00		 jne	 $LN77@AnalyseCar

; 1485 : 				{
; 1486 : 					//牌眼判断
; 1487 : 					BYTE cbCardEye=0;

  00c69	c6 85 b5 fa ff
	ff 00		 mov	 BYTE PTR _cbCardEye$13[ebp], 0

; 1488 : 					bool bMagicEye = false;

  00c70	c6 85 b3 fa ff
	ff 00		 mov	 BYTE PTR _bMagicEye$11[ebp], 0

; 1489 : 					if(GetCardCount(cbCardIndexTemp) == 2)

  00c77	8d 4d b4	 lea	 ecx, DWORD PTR _cbCardIndexTemp$30[ebp]
  00c7a	51		 push	 ecx
  00c7b	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c81	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  00c86	0f b6 d0	 movzx	 edx, al
  00c89	83 fa 02	 cmp	 edx, 2
  00c8c	0f 85 39 01 00
	00		 jne	 $LN83@AnalyseCar

; 1490 : 					{
; 1491 : 						if(m_cbMagicIndex != MAX_INDEX && cbCardIndexTemp[m_cbMagicIndex]==2)

  00c92	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c98	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00c9c	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00c9f	74 3c		 je	 SHORT $LN84@AnalyseCar
  00ca1	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ca7	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00cab	0f b6 4c 05 b4	 movzx	 ecx, BYTE PTR _cbCardIndexTemp$30[ebp+eax]
  00cb0	83 f9 02	 cmp	 ecx, 2
  00cb3	75 28		 jne	 SHORT $LN84@AnalyseCar

; 1492 : 						{
; 1493 : 							cbCardEye = SwitchToCardData(m_cbMagicIndex);

  00cb5	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00cbb	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00cbf	50		 push	 eax
  00cc0	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cc6	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00ccb	88 85 b5 fa ff
	ff		 mov	 BYTE PTR _cbCardEye$13[ebp], al

; 1494 : 							bMagicEye = true;

  00cd1	c6 85 b3 fa ff
	ff 01		 mov	 BYTE PTR _bMagicEye$11[ebp], 1

; 1495 : 						}
; 1496 : 						else

  00cd8	e9 ee 00 00 00	 jmp	 $LN83@AnalyseCar
$LN84@AnalyseCar:

; 1497 : 						{
; 1498 : 							for (BYTE i=0;i<MAX_INDEX;i++)

  00cdd	c6 85 bc fa ff
	ff 00		 mov	 BYTE PTR _i$18[ebp], 0
  00ce4	eb 0f		 jmp	 SHORT $LN36@AnalyseCar
$LN34@AnalyseCar:
  00ce6	8a 8d bc fa ff
	ff		 mov	 cl, BYTE PTR _i$18[ebp]
  00cec	80 c1 01	 add	 cl, 1
  00cef	88 8d bc fa ff
	ff		 mov	 BYTE PTR _i$18[ebp], cl
$LN36@AnalyseCar:
  00cf5	0f b6 95 bc fa
	ff ff		 movzx	 edx, BYTE PTR _i$18[ebp]
  00cfc	83 fa 22	 cmp	 edx, 34			; 00000022H
  00cff	0f 8d c6 00 00
	00		 jge	 $LN83@AnalyseCar

; 1499 : 							{
; 1500 : 								if (cbCardIndexTemp[i]==2)

  00d05	0f b6 85 bc fa
	ff ff		 movzx	 eax, BYTE PTR _i$18[ebp]
  00d0c	0f b6 4c 05 b4	 movzx	 ecx, BYTE PTR _cbCardIndexTemp$30[ebp+eax]
  00d11	83 f9 02	 cmp	 ecx, 2
  00d14	75 48		 jne	 SHORT $LN86@AnalyseCar

; 1501 : 								{
; 1502 : 									cbCardEye=SwitchToCardData(i);

  00d16	0f b6 95 bc fa
	ff ff		 movzx	 edx, BYTE PTR _i$18[ebp]
  00d1d	52		 push	 edx
  00d1e	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d24	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00d29	88 85 b5 fa ff
	ff		 mov	 BYTE PTR _cbCardEye$13[ebp], al

; 1503 : 									if(m_cbMagicIndex != MAX_INDEX && i == m_cbMagicIndex) 

  00d2f	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d35	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00d39	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00d3c	74 1c		 je	 SHORT $LN88@AnalyseCar
  00d3e	0f b6 95 bc fa
	ff ff		 movzx	 edx, BYTE PTR _i$18[ebp]
  00d45	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d4b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00d4f	3b d1		 cmp	 edx, ecx
  00d51	75 07		 jne	 SHORT $LN88@AnalyseCar

; 1504 : 									{
; 1505 : 										bMagicEye = true;

  00d53	c6 85 b3 fa ff
	ff 01		 mov	 BYTE PTR _bMagicEye$11[ebp], 1
$LN88@AnalyseCar:

; 1506 : 									}
; 1507 : 									break;

  00d5a	eb 6f		 jmp	 SHORT $LN83@AnalyseCar
  00d5c	eb 68		 jmp	 SHORT $LN87@AnalyseCar
$LN86@AnalyseCar:

; 1508 : 								}
; 1509 : 								else if(i!=m_cbMagicIndex && m_cbMagicIndex != MAX_INDEX && cbCardIndexTemp[i]+cbCardIndexTemp[m_cbMagicIndex]==2)

  00d5e	0f b6 95 bc fa
	ff ff		 movzx	 edx, BYTE PTR _i$18[ebp]
  00d65	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d6b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00d6f	3b d1		 cmp	 edx, ecx
  00d71	74 53		 je	 SHORT $LN87@AnalyseCar
  00d73	8b 95 c4 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d79	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00d7d	83 f8 22	 cmp	 eax, 34			; 00000022H
  00d80	74 44		 je	 SHORT $LN87@AnalyseCar
  00d82	0f b6 8d bc fa
	ff ff		 movzx	 ecx, BYTE PTR _i$18[ebp]
  00d89	0f b6 54 0d b4	 movzx	 edx, BYTE PTR _cbCardIndexTemp$30[ebp+ecx]
  00d8e	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d94	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00d98	0f b6 44 0d b4	 movzx	 eax, BYTE PTR _cbCardIndexTemp$30[ebp+ecx]
  00d9d	03 d0		 add	 edx, eax
  00d9f	83 fa 02	 cmp	 edx, 2
  00da2	75 22		 jne	 SHORT $LN87@AnalyseCar

; 1510 : 								{
; 1511 : 									cbCardEye = SwitchToCardData(i);

  00da4	0f b6 8d bc fa
	ff ff		 movzx	 ecx, BYTE PTR _i$18[ebp]
  00dab	51		 push	 ecx
  00dac	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00db2	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00db7	88 85 b5 fa ff
	ff		 mov	 BYTE PTR _cbCardEye$13[ebp], al

; 1512 : 									bMagicEye = true;

  00dbd	c6 85 b3 fa ff
	ff 01		 mov	 BYTE PTR _bMagicEye$11[ebp], 1

; 1513 : 									break;

  00dc4	eb 05		 jmp	 SHORT $LN83@AnalyseCar
$LN87@AnalyseCar:

; 1514 : 								}
; 1515 : 							}

  00dc6	e9 1b ff ff ff	 jmp	 $LN34@AnalyseCar
$LN83@AnalyseCar:

; 1516 : 						}
; 1517 : 					}
; 1518 : 
; 1519 : 					//组合类型
; 1520 : 					if (cbCardEye!=0)

  00dcb	0f b6 95 b5 fa
	ff ff		 movzx	 edx, BYTE PTR _cbCardEye$13[ebp]
  00dd2	85 d2		 test	 edx, edx
  00dd4	0f 84 24 02 00
	00		 je	 $LN77@AnalyseCar

; 1521 : 					{
; 1522 : 						//变量定义
; 1523 : 						tagAnalyseItem AnalyseItem;
; 1524 : 						ZeroMemory(&AnalyseItem,sizeof(AnalyseItem));

  00dda	6a 1a		 push	 26			; 0000001aH
  00ddc	6a 00		 push	 0
  00dde	8d 85 e8 fa ff
	ff		 lea	 eax, DWORD PTR _AnalyseItem$27[ebp]
  00de4	50		 push	 eax
  00de5	e8 00 00 00 00	 call	 _memset
  00dea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1525 : 
; 1526 : 						//设置组合
; 1527 : 						for (BYTE i=0;i<cbWeaveCount;i++)

  00ded	c6 85 bf fa ff
	ff 00		 mov	 BYTE PTR _i$20[ebp], 0
  00df4	eb 0f		 jmp	 SHORT $LN39@AnalyseCar
$LN37@AnalyseCar:
  00df6	8a 8d bf fa ff
	ff		 mov	 cl, BYTE PTR _i$20[ebp]
  00dfc	80 c1 01	 add	 cl, 1
  00dff	88 8d bf fa ff
	ff		 mov	 BYTE PTR _i$20[ebp], cl
$LN39@AnalyseCar:
  00e05	0f b6 95 bf fa
	ff ff		 movzx	 edx, BYTE PTR _i$20[ebp]
  00e0c	0f b6 45 10	 movzx	 eax, BYTE PTR _cbWeaveCount$[ebp]
  00e10	3b d0		 cmp	 edx, eax
  00e12	0f 8d 81 00 00
	00		 jge	 $LN38@AnalyseCar

; 1528 : 						{
; 1529 : 							AnalyseItem.cbWeaveKind[i]=WeaveItem[i].cbWeaveKind;

  00e18	0f b6 8d bf fa
	ff ff		 movzx	 ecx, BYTE PTR _i$20[ebp]
  00e1f	6b d1 09	 imul	 edx, ecx, 9
  00e22	0f b6 85 bf fa
	ff ff		 movzx	 eax, BYTE PTR _i$20[ebp]
  00e29	8b 4d 0c	 mov	 ecx, DWORD PTR _WeaveItem$[ebp]
  00e2c	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00e2f	88 94 05 ea fa
	ff ff		 mov	 BYTE PTR _AnalyseItem$27[ebp+eax+2], dl

; 1530 : 							AnalyseItem.cbCenterCard[i]=WeaveItem[i].cbCenterCard;

  00e36	0f b6 85 bf fa
	ff ff		 movzx	 eax, BYTE PTR _i$20[ebp]
  00e3d	6b c8 09	 imul	 ecx, eax, 9
  00e40	0f b6 95 bf fa
	ff ff		 movzx	 edx, BYTE PTR _i$20[ebp]
  00e47	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  00e4a	8a 4c 08 01	 mov	 cl, BYTE PTR [eax+ecx+1]
  00e4e	88 8c 15 ee fa
	ff ff		 mov	 BYTE PTR _AnalyseItem$27[ebp+edx+6], cl

; 1531 : 							GetWeaveCard(WeaveItem[i].cbWeaveKind,WeaveItem[i].cbCenterCard,AnalyseItem.cbCardData[i]);

  00e55	0f b6 95 bf fa
	ff ff		 movzx	 edx, BYTE PTR _i$20[ebp]
  00e5c	8d 84 95 f2 fa
	ff ff		 lea	 eax, DWORD PTR _AnalyseItem$27[ebp+edx*4+10]
  00e63	50		 push	 eax
  00e64	0f b6 8d bf fa
	ff ff		 movzx	 ecx, BYTE PTR _i$20[ebp]
  00e6b	6b d1 09	 imul	 edx, ecx, 9
  00e6e	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  00e71	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [eax+edx+1]
  00e76	51		 push	 ecx
  00e77	0f b6 95 bf fa
	ff ff		 movzx	 edx, BYTE PTR _i$20[ebp]
  00e7e	6b c2 09	 imul	 eax, edx, 9
  00e81	8b 4d 0c	 mov	 ecx, DWORD PTR _WeaveItem$[ebp]
  00e84	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00e88	52		 push	 edx
  00e89	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e8f	e8 00 00 00 00	 call	 ?GetWeaveCard@CGameLogic@@QAEEEEQAE@Z ; CGameLogic::GetWeaveCard

; 1532 : 						}

  00e94	e9 5d ff ff ff	 jmp	 $LN37@AnalyseCar
$LN38@AnalyseCar:

; 1533 : 
; 1534 : 						//设置牌型
; 1535 : 						for (BYTE i=0;i<cbLessKindItem;i++) 

  00e99	c6 85 ca fa ff
	ff 00		 mov	 BYTE PTR _i$24[ebp], 0
  00ea0	eb 0e		 jmp	 SHORT $LN42@AnalyseCar
$LN40@AnalyseCar:
  00ea2	8a 85 ca fa ff
	ff		 mov	 al, BYTE PTR _i$24[ebp]
  00ea8	04 01		 add	 al, 1
  00eaa	88 85 ca fa ff
	ff		 mov	 BYTE PTR _i$24[ebp], al
$LN42@AnalyseCar:
  00eb0	0f b6 8d ca fa
	ff ff		 movzx	 ecx, BYTE PTR _i$24[ebp]
  00eb7	0f b6 95 c3 fa
	ff ff		 movzx	 edx, BYTE PTR _cbLessKindItem$[ebp]
  00ebe	3b ca		 cmp	 ecx, edx
  00ec0	0f 8d 11 01 00
	00		 jge	 $LN41@AnalyseCar

; 1536 : 						{
; 1537 : 							AnalyseItem.cbWeaveKind[i+cbWeaveCount]=pKindItem[i]->cbWeaveKind;

  00ec6	0f b6 85 ca fa
	ff ff		 movzx	 eax, BYTE PTR _i$24[ebp]
  00ecd	8b 4c 85 a4	 mov	 ecx, DWORD PTR _pKindItem$29[ebp+eax*4]
  00ed1	0f b6 95 ca fa
	ff ff		 movzx	 edx, BYTE PTR _i$24[ebp]
  00ed8	0f b6 45 10	 movzx	 eax, BYTE PTR _cbWeaveCount$[ebp]
  00edc	8d 84 05 ea fa
	ff ff		 lea	 eax, DWORD PTR _AnalyseItem$27[ebp+eax+2]
  00ee3	8a 09		 mov	 cl, BYTE PTR [ecx]
  00ee5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1538 : 							AnalyseItem.cbCenterCard[i+cbWeaveCount]=pKindItem[i]->cbCenterCard;

  00ee8	0f b6 95 ca fa
	ff ff		 movzx	 edx, BYTE PTR _i$24[ebp]
  00eef	8b 44 95 a4	 mov	 eax, DWORD PTR _pKindItem$29[ebp+edx*4]
  00ef3	0f b6 8d ca fa
	ff ff		 movzx	 ecx, BYTE PTR _i$24[ebp]
  00efa	0f b6 55 10	 movzx	 edx, BYTE PTR _cbWeaveCount$[ebp]
  00efe	8d 94 15 ee fa
	ff ff		 lea	 edx, DWORD PTR _AnalyseItem$27[ebp+edx+6]
  00f05	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  00f08	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1539 : 							AnalyseItem.cbCardData[cbWeaveCount+i][0] = SwitchToCardData(pKindItem[i]->cbValidIndex[0]);

  00f0b	0f b6 8d ca fa
	ff ff		 movzx	 ecx, BYTE PTR _i$24[ebp]
  00f12	8b 54 8d a4	 mov	 edx, DWORD PTR _pKindItem$29[ebp+ecx*4]
  00f16	b8 01 00 00 00	 mov	 eax, 1
  00f1b	6b c8 00	 imul	 ecx, eax, 0
  00f1e	0f b6 54 0a 02	 movzx	 edx, BYTE PTR [edx+ecx+2]
  00f23	52		 push	 edx
  00f24	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f2a	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00f2f	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cbWeaveCount$[ebp]
  00f33	0f b6 95 ca fa
	ff ff		 movzx	 edx, BYTE PTR _i$24[ebp]
  00f3a	03 ca		 add	 ecx, edx
  00f3c	8d 8c 8d f2 fa
	ff ff		 lea	 ecx, DWORD PTR _AnalyseItem$27[ebp+ecx*4+10]
  00f43	ba 01 00 00 00	 mov	 edx, 1
  00f48	6b d2 00	 imul	 edx, edx, 0
  00f4b	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1540 : 							AnalyseItem.cbCardData[cbWeaveCount+i][1] = SwitchToCardData(pKindItem[i]->cbValidIndex[1]);

  00f4e	0f b6 85 ca fa
	ff ff		 movzx	 eax, BYTE PTR _i$24[ebp]
  00f55	8b 4c 85 a4	 mov	 ecx, DWORD PTR _pKindItem$29[ebp+eax*4]
  00f59	ba 01 00 00 00	 mov	 edx, 1
  00f5e	c1 e2 00	 shl	 edx, 0
  00f61	0f b6 44 11 02	 movzx	 eax, BYTE PTR [ecx+edx+2]
  00f66	50		 push	 eax
  00f67	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f6d	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00f72	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cbWeaveCount$[ebp]
  00f76	0f b6 95 ca fa
	ff ff		 movzx	 edx, BYTE PTR _i$24[ebp]
  00f7d	03 ca		 add	 ecx, edx
  00f7f	8d 8c 8d f2 fa
	ff ff		 lea	 ecx, DWORD PTR _AnalyseItem$27[ebp+ecx*4+10]
  00f86	ba 01 00 00 00	 mov	 edx, 1
  00f8b	c1 e2 00	 shl	 edx, 0
  00f8e	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1541 : 							AnalyseItem.cbCardData[cbWeaveCount+i][2] = SwitchToCardData(pKindItem[i]->cbValidIndex[2]);

  00f91	0f b6 85 ca fa
	ff ff		 movzx	 eax, BYTE PTR _i$24[ebp]
  00f98	8b 4c 85 a4	 mov	 ecx, DWORD PTR _pKindItem$29[ebp+eax*4]
  00f9c	ba 01 00 00 00	 mov	 edx, 1
  00fa1	d1 e2		 shl	 edx, 1
  00fa3	0f b6 44 11 02	 movzx	 eax, BYTE PTR [ecx+edx+2]
  00fa8	50		 push	 eax
  00fa9	8b 8d c4 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00faf	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00fb4	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cbWeaveCount$[ebp]
  00fb8	0f b6 95 ca fa
	ff ff		 movzx	 edx, BYTE PTR _i$24[ebp]
  00fbf	03 ca		 add	 ecx, edx
  00fc1	8d 8c 8d f2 fa
	ff ff		 lea	 ecx, DWORD PTR _AnalyseItem$27[ebp+ecx*4+10]
  00fc8	ba 01 00 00 00	 mov	 edx, 1
  00fcd	d1 e2		 shl	 edx, 1
  00fcf	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1542 : 						}

  00fd2	e9 cb fe ff ff	 jmp	 $LN40@AnalyseCar
$LN41@AnalyseCar:

; 1543 : 
; 1544 : 						//设置牌眼
; 1545 : 						AnalyseItem.cbCardEye=cbCardEye;

  00fd7	8a 85 b5 fa ff
	ff		 mov	 al, BYTE PTR _cbCardEye$13[ebp]
  00fdd	88 85 e8 fa ff
	ff		 mov	 BYTE PTR _AnalyseItem$27[ebp], al

; 1546 : 						AnalyseItem.bMagicEye = bMagicEye;

  00fe3	8a 8d b3 fa ff
	ff		 mov	 cl, BYTE PTR _bMagicEye$11[ebp]
  00fe9	88 8d e9 fa ff
	ff		 mov	 BYTE PTR _AnalyseItem$27[ebp+1], cl

; 1547 : 
; 1548 : 						//插入结果
; 1549 : 						AnalyseItemArray.Add(AnalyseItem);

  00fef	8d 95 e8 fa ff
	ff		 lea	 edx, DWORD PTR _AnalyseItem$27[ebp]
  00ff5	52		 push	 edx
  00ff6	8b 4d 14	 mov	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  00ff9	e8 00 00 00 00	 call	 ?Add@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEHAAUtagAnalyseItem@@@Z ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::Add
$LN77@AnalyseCar:

; 1550 : 					}
; 1551 : 				}
; 1552 : 			}
; 1553 : 
; 1554 : 			//设置索引
; 1555 : 			if (cbIndex[cbLessKindItem-1]==(cbKindItemCount-1))

  00ffe	0f b6 85 c3 fa
	ff ff		 movzx	 eax, BYTE PTR _cbLessKindItem$[ebp]
  01005	0f b6 8c 05 97
	fa ff ff	 movzx	 ecx, BYTE PTR _cbIndex$5[ebp+eax-1]
  0100d	0f b6 95 b9 fa
	ff ff		 movzx	 edx, BYTE PTR _cbKindItemCount$[ebp]
  01014	83 ea 01	 sub	 edx, 1
  01017	3b ca		 cmp	 ecx, edx
  01019	0f 85 de 00 00
	00		 jne	 $LN91@AnalyseCar

; 1556 : 			{
; 1557 : 				BYTE i = cbLessKindItem - 1;

  0101f	0f b6 85 c3 fa
	ff ff		 movzx	 eax, BYTE PTR _cbLessKindItem$[ebp]
  01026	83 e8 01	 sub	 eax, 1
  01029	88 85 bb fa ff
	ff		 mov	 BYTE PTR _i$17[ebp], al

; 1558 : 				for (;i>0;i--)

  0102f	eb 0f		 jmp	 SHORT $LN45@AnalyseCar
$LN43@AnalyseCar:
  01031	8a 8d bb fa ff
	ff		 mov	 cl, BYTE PTR _i$17[ebp]
  01037	80 e9 01	 sub	 cl, 1
  0103a	88 8d bb fa ff
	ff		 mov	 BYTE PTR _i$17[ebp], cl
$LN45@AnalyseCar:
  01040	0f b6 95 bb fa
	ff ff		 movzx	 edx, BYTE PTR _i$17[ebp]
  01047	85 d2		 test	 edx, edx
  01049	0f 8e 9f 00 00
	00		 jle	 $LN44@AnalyseCar

; 1559 : 				{
; 1560 : 					if ((cbIndex[i-1]+1)!=cbIndex[i])

  0104f	0f b6 85 bb fa
	ff ff		 movzx	 eax, BYTE PTR _i$17[ebp]
  01056	0f b6 8c 05 97
	fa ff ff	 movzx	 ecx, BYTE PTR _cbIndex$5[ebp+eax-1]
  0105e	83 c1 01	 add	 ecx, 1
  01061	0f b6 95 bb fa
	ff ff		 movzx	 edx, BYTE PTR _i$17[ebp]
  01068	0f b6 84 15 98
	fa ff ff	 movzx	 eax, BYTE PTR _cbIndex$5[ebp+edx]
  01070	3b c8		 cmp	 ecx, eax
  01072	74 75		 je	 SHORT $LN93@AnalyseCar

; 1561 : 					{
; 1562 : 						BYTE cbNewIndex=cbIndex[i-1];

  01074	0f b6 8d bb fa
	ff ff		 movzx	 ecx, BYTE PTR _i$17[ebp]
  0107b	8a 94 0d 97 fa
	ff ff		 mov	 dl, BYTE PTR _cbIndex$5[ebp+ecx-1]
  01082	88 95 97 fa ff
	ff		 mov	 BYTE PTR _cbNewIndex$4[ebp], dl

; 1563 : 						for (BYTE j=(i-1);j<cbLessKindItem;j++) 

  01088	0f b6 85 bb fa
	ff ff		 movzx	 eax, BYTE PTR _i$17[ebp]
  0108f	83 e8 01	 sub	 eax, 1
  01092	88 85 b4 fa ff
	ff		 mov	 BYTE PTR _j$12[ebp], al
  01098	eb 0f		 jmp	 SHORT $LN48@AnalyseCar
$LN46@AnalyseCar:
  0109a	8a 8d b4 fa ff
	ff		 mov	 cl, BYTE PTR _j$12[ebp]
  010a0	80 c1 01	 add	 cl, 1
  010a3	88 8d b4 fa ff
	ff		 mov	 BYTE PTR _j$12[ebp], cl
$LN48@AnalyseCar:
  010a9	0f b6 95 b4 fa
	ff ff		 movzx	 edx, BYTE PTR _j$12[ebp]
  010b0	0f b6 85 c3 fa
	ff ff		 movzx	 eax, BYTE PTR _cbLessKindItem$[ebp]
  010b7	3b d0		 cmp	 edx, eax
  010b9	7d 2c		 jge	 SHORT $LN47@AnalyseCar

; 1564 : 							cbIndex[j]=cbNewIndex+j-i+2;

  010bb	0f b6 8d 97 fa
	ff ff		 movzx	 ecx, BYTE PTR _cbNewIndex$4[ebp]
  010c2	0f b6 95 b4 fa
	ff ff		 movzx	 edx, BYTE PTR _j$12[ebp]
  010c9	03 ca		 add	 ecx, edx
  010cb	0f b6 85 bb fa
	ff ff		 movzx	 eax, BYTE PTR _i$17[ebp]
  010d2	2b c8		 sub	 ecx, eax
  010d4	83 c1 02	 add	 ecx, 2
  010d7	0f b6 95 b4 fa
	ff ff		 movzx	 edx, BYTE PTR _j$12[ebp]
  010de	88 8c 15 98 fa
	ff ff		 mov	 BYTE PTR _cbIndex$5[ebp+edx], cl
  010e5	eb b3		 jmp	 SHORT $LN46@AnalyseCar
$LN47@AnalyseCar:

; 1565 : 						break;

  010e7	eb 05		 jmp	 SHORT $LN44@AnalyseCar
$LN93@AnalyseCar:

; 1566 : 					}
; 1567 : 				}

  010e9	e9 43 ff ff ff	 jmp	 $LN43@AnalyseCar
$LN44@AnalyseCar:

; 1568 : 				if (i==0)

  010ee	0f b6 85 bb fa
	ff ff		 movzx	 eax, BYTE PTR _i$17[ebp]
  010f5	85 c0		 test	 eax, eax
  010f7	75 02		 jne	 SHORT $LN94@AnalyseCar

; 1569 : 					break;

  010f9	eb 2e		 jmp	 SHORT $LN76@AnalyseCar
$LN94@AnalyseCar:

; 1570 : 			}
; 1571 : 			else

  010fb	eb 1f		 jmp	 SHORT $LN22@AnalyseCar
$LN91@AnalyseCar:

; 1572 : 				cbIndex[cbLessKindItem-1]++;

  010fd	0f b6 8d c3 fa
	ff ff		 movzx	 ecx, BYTE PTR _cbLessKindItem$[ebp]
  01104	8a 94 0d 97 fa
	ff ff		 mov	 dl, BYTE PTR _cbIndex$5[ebp+ecx-1]
  0110b	80 c2 01	 add	 dl, 1
  0110e	0f b6 85 c3 fa
	ff ff		 movzx	 eax, BYTE PTR _cbLessKindItem$[ebp]
  01115	88 94 05 97 fa
	ff ff		 mov	 BYTE PTR _cbIndex$5[ebp+eax-1], dl
$LN22@AnalyseCar:

; 1573 : 
; 1574 : 		} while (true);

  0111c	b9 01 00 00 00	 mov	 ecx, 1
  01121	85 c9		 test	 ecx, ecx
  01123	0f 85 34 f9 ff
	ff		 jne	 $LN24@AnalyseCar
$LN76@AnalyseCar:

; 1575 : 	}
; 1576 : 
; 1577 : 	return (AnalyseItemArray.GetCount()>0);

  01129	8b 4d 14	 mov	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  0112c	e8 00 00 00 00	 call	 ?GetCount@?$CWHArray@UtagAnalyseItem@@AAU1@@@QBEHXZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::GetCount
  01131	85 c0		 test	 eax, eax
  01133	7e 0c		 jle	 SHORT $LN118@AnalyseCar
  01135	c7 85 80 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv869[ebp], 1
  0113f	eb 0a		 jmp	 SHORT $LN119@AnalyseCar
$LN118@AnalyseCar:
  01141	c7 85 80 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv869[ebp], 0
$LN119@AnalyseCar:
  0114b	8a 85 80 fa ff
	ff		 mov	 al, BYTE PTR tv869[ebp]
$LN1@AnalyseCar:

; 1578 : }

  01151	5e		 pop	 esi
  01152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01155	33 cd		 xor	 ecx, ebp
  01157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0115c	8b e5		 mov	 esp, ebp
  0115e	5d		 pop	 ebp
  0115f	c2 10 00	 ret	 16			; 00000010H
?AnalyseCard@CGameLogic@@AAE_NQBEQBUtagWeaveItem@@EAAV?$CWHArray@UtagAnalyseItem@@AAU1@@@@Z ENDP ; CGameLogic::AnalyseCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv268 = -68						; size = 4
tv260 = -64						; size = 4
tv185 = -60						; size = 4
tv136 = -56						; size = 4
tv89 = -52						; size = 4
tv80 = -48						; size = 4
tv72 = -44						; size = 4
_i$1 = -40						; size = 4
_i$2 = -36						; size = 4
_i$3 = -32						; size = 4
_j$4 = -28						; size = 4
_i$5 = -24						; size = 4
_j$6 = -20						; size = 4
_this$ = -16						; size = 4
_cbCardIndex$7 = -12					; size = 2
_cbTempCardIndex$8 = -8					; size = 2
_bFind$9 = -4						; size = 1
_cbNoTempMagicIndex$10 = -3				; size = 1
_cbNoMagicIndex$11 = -2					; size = 1
_cbCardCount$12 = -1					; size = 1
_TempKindItem$ = 8					; size = 4
_KindItem$ = 12						; size = 4
_cbKindItemCount$ = 16					; size = 4
_bMagicThree$ = 20					; size = 4
?AddKindItem@CGameLogic@@AAE_NAAUtagKindItem@@QAU2@AAEAA_N@Z PROC ; CGameLogic::AddKindItem
; _this$ = ecx

; 1136 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1137 : 	TempKindItem.cbMagicCount =  

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00010	ba 01 00 00 00	 mov	 edx, 1
  00015	6b c2 00	 imul	 eax, edx, 0
  00018	8b 55 08	 mov	 edx, DWORD PTR _TempKindItem$[ebp]
  0001b	0f b6 44 02 02	 movzx	 eax, BYTE PTR [edx+eax+2]
  00020	3b c8		 cmp	 ecx, eax
  00022	75 09		 jne	 SHORT $LN36@AddKindIte
  00024	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN37@AddKindIte
$LN36@AddKindIte:
  0002d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN37@AddKindIte:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	c1 e0 00	 shl	 eax, 0
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _TempKindItem$[ebp]
  00046	0f b6 44 01 02	 movzx	 eax, BYTE PTR [ecx+eax+2]
  0004b	3b d0		 cmp	 edx, eax
  0004d	75 09		 jne	 SHORT $LN38@AddKindIte
  0004f	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00056	eb 07		 jmp	 SHORT $LN39@AddKindIte
$LN38@AddKindIte:
  00058	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN39@AddKindIte:
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	d1 e0		 shl	 eax, 1
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _TempKindItem$[ebp]
  00070	0f b6 44 01 02	 movzx	 eax, BYTE PTR [ecx+eax+2]
  00075	3b d0		 cmp	 edx, eax
  00077	75 09		 jne	 SHORT $LN40@AddKindIte
  00079	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  00080	eb 07		 jmp	 SHORT $LN41@AddKindIte
$LN40@AddKindIte:
  00082	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN41@AddKindIte:
  00089	8b 4d d4	 mov	 ecx, DWORD PTR tv72[ebp]
  0008c	03 4d d0	 add	 ecx, DWORD PTR tv80[ebp]
  0008f	03 4d cc	 add	 ecx, DWORD PTR tv89[ebp]
  00092	8b 55 08	 mov	 edx, DWORD PTR _TempKindItem$[ebp]
  00095	88 4a 05	 mov	 BYTE PTR [edx+5], cl

; 1138 : 		(m_cbMagicIndex == TempKindItem.cbValidIndex[0] ? 1 : 0) + 
; 1139 : 		(m_cbMagicIndex == TempKindItem.cbValidIndex[1] ? 1 : 0) +
; 1140 : 		(m_cbMagicIndex == TempKindItem.cbValidIndex[2] ? 1 : 0) ;
; 1141 : 
; 1142 : 	if(TempKindItem.cbMagicCount>=3) 

  00098	8b 45 08	 mov	 eax, DWORD PTR _TempKindItem$[ebp]
  0009b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0009f	83 f9 03	 cmp	 ecx, 3
  000a2	7c 50		 jl	 SHORT $LN20@AddKindIte

; 1143 : 	{
; 1144 : 		if(!bMagicThree)

  000a4	8b 55 14	 mov	 edx, DWORD PTR _bMagicThree$[ebp]
  000a7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000aa	85 c0		 test	 eax, eax
  000ac	75 3a		 jne	 SHORT $LN22@AddKindIte

; 1145 : 		{
; 1146 : 			bMagicThree = true;

  000ae	8b 4d 14	 mov	 ecx, DWORD PTR _bMagicThree$[ebp]
  000b1	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 1147 : 			CopyMemory(&KindItem[cbKindItemCount++],&TempKindItem,sizeof(TempKindItem));

  000b4	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  000b7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000ba	6b c8 06	 imul	 ecx, eax, 6
  000bd	03 4d 0c	 add	 ecx, DWORD PTR _KindItem$[ebp]
  000c0	89 4d c8	 mov	 DWORD PTR tv136[ebp], ecx
  000c3	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  000c6	8a 02		 mov	 al, BYTE PTR [edx]
  000c8	04 01		 add	 al, 1
  000ca	8b 4d 10	 mov	 ecx, DWORD PTR _cbKindItemCount$[ebp]
  000cd	88 01		 mov	 BYTE PTR [ecx], al
  000cf	6a 06		 push	 6
  000d1	8b 55 08	 mov	 edx, DWORD PTR _TempKindItem$[ebp]
  000d4	52		 push	 edx
  000d5	8b 45 c8	 mov	 eax, DWORD PTR tv136[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _memcpy
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1148 : 			return true;

  000e1	b0 01		 mov	 al, 1
  000e3	e9 ce 02 00 00	 jmp	 $LN1@AddKindIte
$LN22@AddKindIte:

; 1149 : 		}
; 1150 : 		return false;

  000e8	32 c0		 xor	 al, al
  000ea	e9 c7 02 00 00	 jmp	 $LN1@AddKindIte
  000ef	e9 c2 02 00 00	 jmp	 $LN1@AddKindIte
$LN20@AddKindIte:

; 1151 : 	}
; 1152 : 	else if(TempKindItem.cbMagicCount == 2)

  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _TempKindItem$[ebp]
  000f7	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  000fb	83 fa 02	 cmp	 edx, 2
  000fe	0f 85 0f 01 00
	00		 jne	 $LN23@AddKindIte

; 1153 : 	{
; 1154 : 		BYTE cbNoMagicIndex = 0;

  00104	c6 45 fe 00	 mov	 BYTE PTR _cbNoMagicIndex$11[ebp], 0

; 1155 : 		BYTE cbNoTempMagicIndex = 0;

  00108	c6 45 fd 00	 mov	 BYTE PTR _cbNoTempMagicIndex$10[ebp], 0

; 1156 : 		for(int i = 0; i < 3; i++)

  0010c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00113	eb 09		 jmp	 SHORT $LN4@AddKindIte
$LN2@AddKindIte:
  00115	8b 45 e8	 mov	 eax, DWORD PTR _i$5[ebp]
  00118	83 c0 01	 add	 eax, 1
  0011b	89 45 e8	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@AddKindIte:
  0011e	83 7d e8 03	 cmp	 DWORD PTR _i$5[ebp], 3
  00122	7d 25		 jge	 SHORT $LN3@AddKindIte

; 1157 : 		{
; 1158 : 			if(TempKindItem.cbValidIndex[i] != m_cbMagicIndex)

  00124	8b 4d 08	 mov	 ecx, DWORD PTR _TempKindItem$[ebp]
  00127	03 4d e8	 add	 ecx, DWORD PTR _i$5[ebp]
  0012a	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  0012e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00131	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00135	3b d1		 cmp	 edx, ecx
  00137	74 0e		 je	 SHORT $LN25@AddKindIte

; 1159 : 			{
; 1160 : 				cbNoTempMagicIndex = TempKindItem.cbValidIndex[i];

  00139	8b 55 08	 mov	 edx, DWORD PTR _TempKindItem$[ebp]
  0013c	03 55 e8	 add	 edx, DWORD PTR _i$5[ebp]
  0013f	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00142	88 45 fd	 mov	 BYTE PTR _cbNoTempMagicIndex$10[ebp], al

; 1161 : 				break;

  00145	eb 02		 jmp	 SHORT $LN3@AddKindIte
$LN25@AddKindIte:

; 1162 : 			}
; 1163 : 		}

  00147	eb cc		 jmp	 SHORT $LN2@AddKindIte
$LN3@AddKindIte:

; 1164 : 		bool bFind = false;

  00149	c6 45 fc 00	 mov	 BYTE PTR _bFind$9[ebp], 0

; 1165 : 		for(int j = 0; j < cbKindItemCount; j++)

  0014d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$4[ebp], 0
  00154	eb 09		 jmp	 SHORT $LN7@AddKindIte
$LN5@AddKindIte:
  00156	8b 4d e4	 mov	 ecx, DWORD PTR _j$4[ebp]
  00159	83 c1 01	 add	 ecx, 1
  0015c	89 4d e4	 mov	 DWORD PTR _j$4[ebp], ecx
$LN7@AddKindIte:
  0015f	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  00162	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00165	39 45 e4	 cmp	 DWORD PTR _j$4[ebp], eax
  00168	7d 61		 jge	 SHORT $LN6@AddKindIte

; 1166 : 		{
; 1167 : 			for(int i = 0; i < 3; i++)

  0016a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00171	eb 09		 jmp	 SHORT $LN10@AddKindIte
$LN8@AddKindIte:
  00173	8b 4d e0	 mov	 ecx, DWORD PTR _i$3[ebp]
  00176	83 c1 01	 add	 ecx, 1
  00179	89 4d e0	 mov	 DWORD PTR _i$3[ebp], ecx
$LN10@AddKindIte:
  0017c	83 7d e0 03	 cmp	 DWORD PTR _i$3[ebp], 3
  00180	7d 2f		 jge	 SHORT $LN9@AddKindIte

; 1168 : 			{
; 1169 : 				if(KindItem[j].cbValidIndex[i] != m_cbMagicIndex)

  00182	6b 55 e4 06	 imul	 edx, DWORD PTR _j$4[ebp], 6
  00186	03 55 0c	 add	 edx, DWORD PTR _KindItem$[ebp]
  00189	8b 45 e0	 mov	 eax, DWORD PTR _i$3[ebp]
  0018c	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  00191	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00194	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00198	3b c8		 cmp	 ecx, eax
  0019a	74 13		 je	 SHORT $LN26@AddKindIte

; 1170 : 				{
; 1171 : 					cbNoMagicIndex = KindItem[j].cbValidIndex[i];

  0019c	6b 4d e4 06	 imul	 ecx, DWORD PTR _j$4[ebp], 6
  001a0	03 4d 0c	 add	 ecx, DWORD PTR _KindItem$[ebp]
  001a3	8b 55 e0	 mov	 edx, DWORD PTR _i$3[ebp]
  001a6	8a 44 11 02	 mov	 al, BYTE PTR [ecx+edx+2]
  001aa	88 45 fe	 mov	 BYTE PTR _cbNoMagicIndex$11[ebp], al

; 1172 : 					break;

  001ad	eb 02		 jmp	 SHORT $LN9@AddKindIte
$LN26@AddKindIte:

; 1173 : 				}
; 1174 : 			}

  001af	eb c2		 jmp	 SHORT $LN8@AddKindIte
$LN9@AddKindIte:

; 1175 : 			if(cbNoMagicIndex == cbNoTempMagicIndex && cbNoMagicIndex != 0)

  001b1	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbNoMagicIndex$11[ebp]
  001b5	0f b6 55 fd	 movzx	 edx, BYTE PTR _cbNoTempMagicIndex$10[ebp]
  001b9	3b ca		 cmp	 ecx, edx
  001bb	75 0c		 jne	 SHORT $LN27@AddKindIte
  001bd	0f b6 45 fe	 movzx	 eax, BYTE PTR _cbNoMagicIndex$11[ebp]
  001c1	85 c0		 test	 eax, eax
  001c3	74 04		 je	 SHORT $LN27@AddKindIte

; 1176 : 			{
; 1177 : 				bFind = true;

  001c5	c6 45 fc 01	 mov	 BYTE PTR _bFind$9[ebp], 1
$LN27@AddKindIte:

; 1178 : 			}
; 1179 : 		}

  001c9	eb 8b		 jmp	 SHORT $LN5@AddKindIte
$LN6@AddKindIte:

; 1180 : 
; 1181 : 		if(!bFind)

  001cb	0f b6 4d fc	 movzx	 ecx, BYTE PTR _bFind$9[ebp]
  001cf	85 c9		 test	 ecx, ecx
  001d1	75 34		 jne	 SHORT $LN28@AddKindIte

; 1182 : 		{
; 1183 : 			CopyMemory(&KindItem[cbKindItemCount++],&TempKindItem,sizeof(TempKindItem));

  001d3	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  001d6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001d9	6b c8 06	 imul	 ecx, eax, 6
  001dc	03 4d 0c	 add	 ecx, DWORD PTR _KindItem$[ebp]
  001df	89 4d c4	 mov	 DWORD PTR tv185[ebp], ecx
  001e2	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  001e5	8a 02		 mov	 al, BYTE PTR [edx]
  001e7	04 01		 add	 al, 1
  001e9	8b 4d 10	 mov	 ecx, DWORD PTR _cbKindItemCount$[ebp]
  001ec	88 01		 mov	 BYTE PTR [ecx], al
  001ee	6a 06		 push	 6
  001f0	8b 55 08	 mov	 edx, DWORD PTR _TempKindItem$[ebp]
  001f3	52		 push	 edx
  001f4	8b 45 c4	 mov	 eax, DWORD PTR tv185[ebp]
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _memcpy
  001fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1184 : 			return true;

  00200	b0 01		 mov	 al, 1
  00202	e9 af 01 00 00	 jmp	 $LN1@AddKindIte
$LN28@AddKindIte:

; 1185 : 		}
; 1186 : 		return false;

  00207	32 c0		 xor	 al, al
  00209	e9 a8 01 00 00	 jmp	 $LN1@AddKindIte
  0020e	e9 a3 01 00 00	 jmp	 $LN1@AddKindIte
$LN23@AddKindIte:

; 1187 : 	}
; 1188 : 	else if(TempKindItem.cbMagicCount == 1)

  00213	8b 4d 08	 mov	 ecx, DWORD PTR _TempKindItem$[ebp]
  00216	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  0021a	83 fa 01	 cmp	 edx, 1
  0021d	0f 85 64 01 00
	00		 jne	 $LN29@AddKindIte

; 1189 : 	{
; 1190 : 		BYTE cbTempCardIndex[2] = {0};

  00223	c6 45 f8 00	 mov	 BYTE PTR _cbTempCardIndex$8[ebp], 0
  00227	33 c0		 xor	 eax, eax
  00229	88 45 f9	 mov	 BYTE PTR _cbTempCardIndex$8[ebp+1], al

; 1191 : 		BYTE cbCardIndex[2] = {0};

  0022c	c6 45 f4 00	 mov	 BYTE PTR _cbCardIndex$7[ebp], 0
  00230	33 c9		 xor	 ecx, ecx
  00232	88 4d f5	 mov	 BYTE PTR _cbCardIndex$7[ebp+1], cl

; 1192 : 		BYTE cbCardCount = 0;

  00235	c6 45 ff 00	 mov	 BYTE PTR _cbCardCount$12[ebp], 0

; 1193 : 		for(int i = 0; i < 3; i++)

  00239	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00240	eb 09		 jmp	 SHORT $LN13@AddKindIte
$LN11@AddKindIte:
  00242	8b 55 dc	 mov	 edx, DWORD PTR _i$2[ebp]
  00245	83 c2 01	 add	 edx, 1
  00248	89 55 dc	 mov	 DWORD PTR _i$2[ebp], edx
$LN13@AddKindIte:
  0024b	83 7d dc 03	 cmp	 DWORD PTR _i$2[ebp], 3
  0024f	7d 31		 jge	 SHORT $LN12@AddKindIte

; 1194 : 		{
; 1195 : 			if(TempKindItem.cbValidIndex[i] != m_cbMagicIndex)

  00251	8b 45 08	 mov	 eax, DWORD PTR _TempKindItem$[ebp]
  00254	03 45 dc	 add	 eax, DWORD PTR _i$2[ebp]
  00257	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0025b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0025e	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00262	3b c8		 cmp	 ecx, eax
  00264	74 1a		 je	 SHORT $LN31@AddKindIte

; 1196 : 			{
; 1197 : 				cbTempCardIndex[cbCardCount++] = TempKindItem.cbValidIndex[i];

  00266	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbCardCount$12[ebp]
  0026a	8b 55 08	 mov	 edx, DWORD PTR _TempKindItem$[ebp]
  0026d	03 55 dc	 add	 edx, DWORD PTR _i$2[ebp]
  00270	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00273	88 44 0d f8	 mov	 BYTE PTR _cbTempCardIndex$8[ebp+ecx], al
  00277	8a 4d ff	 mov	 cl, BYTE PTR _cbCardCount$12[ebp]
  0027a	80 c1 01	 add	 cl, 1
  0027d	88 4d ff	 mov	 BYTE PTR _cbCardCount$12[ebp], cl
$LN31@AddKindIte:

; 1198 : 			}
; 1199 : 		}

  00280	eb c0		 jmp	 SHORT $LN11@AddKindIte
$LN12@AddKindIte:

; 1200 : 		ASSERT(cbCardCount == 2);
; 1201 : 
; 1202 : 		for(int j = 0; j < cbKindItemCount; j++)

  00282	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$6[ebp], 0
  00289	eb 09		 jmp	 SHORT $LN16@AddKindIte
$LN14@AddKindIte:
  0028b	8b 55 ec	 mov	 edx, DWORD PTR _j$6[ebp]
  0028e	83 c2 01	 add	 edx, 1
  00291	89 55 ec	 mov	 DWORD PTR _j$6[ebp], edx
$LN16@AddKindIte:
  00294	8b 45 10	 mov	 eax, DWORD PTR _cbKindItemCount$[ebp]
  00297	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0029a	39 4d ec	 cmp	 DWORD PTR _j$6[ebp], ecx
  0029d	0f 8d b0 00 00
	00		 jge	 $LN15@AddKindIte

; 1203 : 		{
; 1204 : 			if(1 == KindItem[j].cbMagicCount)

  002a3	6b 55 ec 06	 imul	 edx, DWORD PTR _j$6[ebp], 6
  002a7	8b 45 0c	 mov	 eax, DWORD PTR _KindItem$[ebp]
  002aa	0f b6 4c 10 05	 movzx	 ecx, BYTE PTR [eax+edx+5]
  002af	83 f9 01	 cmp	 ecx, 1
  002b2	0f 85 96 00 00
	00		 jne	 $LN32@AddKindIte

; 1205 : 			{
; 1206 : 				cbCardCount = 0;

  002b8	c6 45 ff 00	 mov	 BYTE PTR _cbCardCount$12[ebp], 0

; 1207 : 				for(int i = 0; i < 3; i++)

  002bc	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  002c3	eb 09		 jmp	 SHORT $LN19@AddKindIte
$LN17@AddKindIte:
  002c5	8b 55 d8	 mov	 edx, DWORD PTR _i$1[ebp]
  002c8	83 c2 01	 add	 edx, 1
  002cb	89 55 d8	 mov	 DWORD PTR _i$1[ebp], edx
$LN19@AddKindIte:
  002ce	83 7d d8 03	 cmp	 DWORD PTR _i$1[ebp], 3
  002d2	7d 3a		 jge	 SHORT $LN18@AddKindIte

; 1208 : 				{
; 1209 : 					if(KindItem[j].cbValidIndex[i] != m_cbMagicIndex)

  002d4	6b 45 ec 06	 imul	 eax, DWORD PTR _j$6[ebp], 6
  002d8	03 45 0c	 add	 eax, DWORD PTR _KindItem$[ebp]
  002db	8b 4d d8	 mov	 ecx, DWORD PTR _i$1[ebp]
  002de	0f b6 54 08 02	 movzx	 edx, BYTE PTR [eax+ecx+2]
  002e3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002e6	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  002ea	3b d1		 cmp	 edx, ecx
  002ec	74 1e		 je	 SHORT $LN33@AddKindIte

; 1210 : 					{
; 1211 : 						cbCardIndex[cbCardCount++] = KindItem[j].cbValidIndex[i];

  002ee	6b 55 ec 06	 imul	 edx, DWORD PTR _j$6[ebp], 6
  002f2	03 55 0c	 add	 edx, DWORD PTR _KindItem$[ebp]
  002f5	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbCardCount$12[ebp]
  002f9	8b 4d d8	 mov	 ecx, DWORD PTR _i$1[ebp]
  002fc	8a 54 0a 02	 mov	 dl, BYTE PTR [edx+ecx+2]
  00300	88 54 05 f4	 mov	 BYTE PTR _cbCardIndex$7[ebp+eax], dl
  00304	8a 45 ff	 mov	 al, BYTE PTR _cbCardCount$12[ebp]
  00307	04 01		 add	 al, 1
  00309	88 45 ff	 mov	 BYTE PTR _cbCardCount$12[ebp], al
$LN33@AddKindIte:

; 1212 : 					}
; 1213 : 				}

  0030c	eb b7		 jmp	 SHORT $LN17@AddKindIte
$LN18@AddKindIte:

; 1214 : 				ASSERT(cbCardCount == 2);
; 1215 : 
; 1216 : 				if(cbTempCardIndex[0] == cbCardIndex[0] && cbTempCardIndex[1] == cbCardIndex[1])

  0030e	b9 01 00 00 00	 mov	 ecx, 1
  00313	6b d1 00	 imul	 edx, ecx, 0
  00316	0f b6 44 15 f8	 movzx	 eax, BYTE PTR _cbTempCardIndex$8[ebp+edx]
  0031b	b9 01 00 00 00	 mov	 ecx, 1
  00320	6b d1 00	 imul	 edx, ecx, 0
  00323	0f b6 4c 15 f4	 movzx	 ecx, BYTE PTR _cbCardIndex$7[ebp+edx]
  00328	3b c1		 cmp	 eax, ecx
  0032a	75 22		 jne	 SHORT $LN32@AddKindIte
  0032c	ba 01 00 00 00	 mov	 edx, 1
  00331	c1 e2 00	 shl	 edx, 0
  00334	0f b6 44 15 f8	 movzx	 eax, BYTE PTR _cbTempCardIndex$8[ebp+edx]
  00339	b9 01 00 00 00	 mov	 ecx, 1
  0033e	c1 e1 00	 shl	 ecx, 0
  00341	0f b6 54 0d f4	 movzx	 edx, BYTE PTR _cbCardIndex$7[ebp+ecx]
  00346	3b c2		 cmp	 eax, edx
  00348	75 04		 jne	 SHORT $LN32@AddKindIte

; 1217 : 				{
; 1218 : 					return false;

  0034a	32 c0		 xor	 al, al
  0034c	eb 68		 jmp	 SHORT $LN1@AddKindIte
$LN32@AddKindIte:

; 1219 : 				}
; 1220 : 			}
; 1221 : 		}

  0034e	e9 38 ff ff ff	 jmp	 $LN14@AddKindIte
$LN15@AddKindIte:

; 1222 : 
; 1223 : 
; 1224 : 		CopyMemory(&KindItem[cbKindItemCount++],&TempKindItem,sizeof(TempKindItem));

  00353	8b 45 10	 mov	 eax, DWORD PTR _cbKindItemCount$[ebp]
  00356	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00359	6b d1 06	 imul	 edx, ecx, 6
  0035c	03 55 0c	 add	 edx, DWORD PTR _KindItem$[ebp]
  0035f	89 55 c0	 mov	 DWORD PTR tv260[ebp], edx
  00362	8b 45 10	 mov	 eax, DWORD PTR _cbKindItemCount$[ebp]
  00365	8a 08		 mov	 cl, BYTE PTR [eax]
  00367	80 c1 01	 add	 cl, 1
  0036a	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  0036d	88 0a		 mov	 BYTE PTR [edx], cl
  0036f	6a 06		 push	 6
  00371	8b 45 08	 mov	 eax, DWORD PTR _TempKindItem$[ebp]
  00374	50		 push	 eax
  00375	8b 4d c0	 mov	 ecx, DWORD PTR tv260[ebp]
  00378	51		 push	 ecx
  00379	e8 00 00 00 00	 call	 _memcpy
  0037e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1225 : 		return true;

  00381	b0 01		 mov	 al, 1
  00383	eb 31		 jmp	 SHORT $LN1@AddKindIte

; 1226 : 	}
; 1227 : 	else

  00385	eb 2f		 jmp	 SHORT $LN1@AddKindIte
$LN29@AddKindIte:

; 1228 : 	{
; 1229 : 		CopyMemory(&KindItem[cbKindItemCount++],&TempKindItem,sizeof(TempKindItem));

  00387	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  0038a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0038d	6b c8 06	 imul	 ecx, eax, 6
  00390	03 4d 0c	 add	 ecx, DWORD PTR _KindItem$[ebp]
  00393	89 4d bc	 mov	 DWORD PTR tv268[ebp], ecx
  00396	8b 55 10	 mov	 edx, DWORD PTR _cbKindItemCount$[ebp]
  00399	8a 02		 mov	 al, BYTE PTR [edx]
  0039b	04 01		 add	 al, 1
  0039d	8b 4d 10	 mov	 ecx, DWORD PTR _cbKindItemCount$[ebp]
  003a0	88 01		 mov	 BYTE PTR [ecx], al
  003a2	6a 06		 push	 6
  003a4	8b 55 08	 mov	 edx, DWORD PTR _TempKindItem$[ebp]
  003a7	52		 push	 edx
  003a8	8b 45 bc	 mov	 eax, DWORD PTR tv268[ebp]
  003ab	50		 push	 eax
  003ac	e8 00 00 00 00	 call	 _memcpy
  003b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1230 : 		return true;

  003b4	b0 01		 mov	 al, 1
$LN1@AddKindIte:

; 1231 : 	}
; 1232 : }

  003b6	8b e5		 mov	 esp, ebp
  003b8	5d		 pop	 ebp
  003b9	c2 10 00	 ret	 16			; 00000010H
?AddKindItem@CGameLogic@@AAE_NAAUtagKindItem@@QAU2@AAEAA_N@Z ENDP ; CGameLogic::AddKindItem
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
_cbWeaveKind$ = 8					; size = 1
_cbCenterCard$ = 12					; size = 1
_cbCardBuffer$ = 16					; size = 4
?GetWeaveCard@CGameLogic@@QAEEEEQAE@Z PROC		; CGameLogic::GetWeaveCard
; _this$ = ecx

; 1076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1077 : 	//组合扑克
; 1078 : 	switch (cbWeaveKind)

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _cbWeaveKind$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR tv65[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
  00019	83 7d fc 0f	 cmp	 DWORD PTR tv65[ebp], 15	; 0000000fH
  0001d	0f 87 4e 01 00
	00		 ja	 $LN2@GetWeaveCa
  00023	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00026	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN11@GetWeaveCa[edx]
  0002d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@GetWeaveCa[eax*4]
$LN4@GetWeaveCa:

; 1079 : 	{
; 1080 : 	case WIK_LEFT:		//上牌操作
; 1081 : 		{
; 1082 : 			//设置变量
; 1083 : 			cbCardBuffer[0]=cbCenterCard;

  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	6b d1 00	 imul	 edx, ecx, 0
  0003c	8b 45 10	 mov	 eax, DWORD PTR _cbCardBuffer$[ebp]
  0003f	8a 4d 0c	 mov	 cl, BYTE PTR _cbCenterCard$[ebp]
  00042	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1084 : 			cbCardBuffer[1]=cbCenterCard+1;

  00045	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCenterCard$[ebp]
  00049	83 c2 01	 add	 edx, 1
  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	c1 e0 00	 shl	 eax, 0
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _cbCardBuffer$[ebp]
  00057	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 1085 : 			cbCardBuffer[2]=cbCenterCard+2;

  0005a	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCenterCard$[ebp]
  0005e	83 c2 02	 add	 edx, 2
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	d1 e0		 shl	 eax, 1
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _cbCardBuffer$[ebp]
  0006b	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 1086 : 
; 1087 : 			return 3;

  0006e	b0 03		 mov	 al, 3
  00070	e9 fe 00 00 00	 jmp	 $LN1@GetWeaveCa
$LN5@GetWeaveCa:

; 1088 : 		}
; 1089 : 	case WIK_RIGHT:		//上牌操作
; 1090 : 		{
; 1091 : 			//设置变量
; 1092 : 			cbCardBuffer[0]=cbCenterCard-2;

  00075	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCenterCard$[ebp]
  00079	83 ea 02	 sub	 edx, 2
  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	6b c8 00	 imul	 ecx, eax, 0
  00084	8b 45 10	 mov	 eax, DWORD PTR _cbCardBuffer$[ebp]
  00087	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1093 : 			cbCardBuffer[1]=cbCenterCard-1;

  0008a	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCenterCard$[ebp]
  0008e	83 e9 01	 sub	 ecx, 1
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	c1 e2 00	 shl	 edx, 0
  00099	8b 45 10	 mov	 eax, DWORD PTR _cbCardBuffer$[ebp]
  0009c	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1094 : 			cbCardBuffer[2]=cbCenterCard;

  0009f	b9 01 00 00 00	 mov	 ecx, 1
  000a4	d1 e1		 shl	 ecx, 1
  000a6	8b 55 10	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  000a9	8a 45 0c	 mov	 al, BYTE PTR _cbCenterCard$[ebp]
  000ac	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1095 : 
; 1096 : 			return 3;

  000af	b0 03		 mov	 al, 3
  000b1	e9 bd 00 00 00	 jmp	 $LN1@GetWeaveCa
$LN6@GetWeaveCa:

; 1097 : 		}
; 1098 : 	case WIK_CENTER:	//上牌操作
; 1099 : 		{
; 1100 : 			//设置变量
; 1101 : 			cbCardBuffer[0]=cbCenterCard-1;

  000b6	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCenterCard$[ebp]
  000ba	83 e9 01	 sub	 ecx, 1
  000bd	ba 01 00 00 00	 mov	 edx, 1
  000c2	6b c2 00	 imul	 eax, edx, 0
  000c5	8b 55 10	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  000c8	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 1102 : 			cbCardBuffer[1]=cbCenterCard;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	c1 e0 00	 shl	 eax, 0
  000d3	8b 4d 10	 mov	 ecx, DWORD PTR _cbCardBuffer$[ebp]
  000d6	8a 55 0c	 mov	 dl, BYTE PTR _cbCenterCard$[ebp]
  000d9	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 1103 : 			cbCardBuffer[2]=cbCenterCard+1;

  000dc	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCenterCard$[ebp]
  000e0	83 c0 01	 add	 eax, 1
  000e3	b9 01 00 00 00	 mov	 ecx, 1
  000e8	d1 e1		 shl	 ecx, 1
  000ea	8b 55 10	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  000ed	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1104 : 
; 1105 : 			return 3;

  000f0	b0 03		 mov	 al, 3
  000f2	eb 7f		 jmp	 SHORT $LN1@GetWeaveCa
$LN7@GetWeaveCa:

; 1106 : 		}
; 1107 : 	case WIK_PENG:		//碰牌操作
; 1108 : 		{
; 1109 : 			//设置变量
; 1110 : 			cbCardBuffer[0]=cbCenterCard;

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	6b c8 00	 imul	 ecx, eax, 0
  000fc	8b 55 10	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  000ff	8a 45 0c	 mov	 al, BYTE PTR _cbCenterCard$[ebp]
  00102	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1111 : 			cbCardBuffer[1]=cbCenterCard;

  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	c1 e1 00	 shl	 ecx, 0
  0010d	8b 55 10	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  00110	8a 45 0c	 mov	 al, BYTE PTR _cbCenterCard$[ebp]
  00113	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1112 : 			cbCardBuffer[2]=cbCenterCard;

  00116	b9 01 00 00 00	 mov	 ecx, 1
  0011b	d1 e1		 shl	 ecx, 1
  0011d	8b 55 10	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  00120	8a 45 0c	 mov	 al, BYTE PTR _cbCenterCard$[ebp]
  00123	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1113 : 
; 1114 : 			return 3;

  00126	b0 03		 mov	 al, 3
  00128	eb 49		 jmp	 SHORT $LN1@GetWeaveCa
$LN8@GetWeaveCa:

; 1115 : 		}
; 1116 : 	case WIK_GANG:		//杠牌操作
; 1117 : 		{
; 1118 : 			//设置变量
; 1119 : 			cbCardBuffer[0]=cbCenterCard;

  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	6b d1 00	 imul	 edx, ecx, 0
  00132	8b 45 10	 mov	 eax, DWORD PTR _cbCardBuffer$[ebp]
  00135	8a 4d 0c	 mov	 cl, BYTE PTR _cbCenterCard$[ebp]
  00138	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1120 : 			cbCardBuffer[1]=cbCenterCard;

  0013b	ba 01 00 00 00	 mov	 edx, 1
  00140	c1 e2 00	 shl	 edx, 0
  00143	8b 45 10	 mov	 eax, DWORD PTR _cbCardBuffer$[ebp]
  00146	8a 4d 0c	 mov	 cl, BYTE PTR _cbCenterCard$[ebp]
  00149	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1121 : 			cbCardBuffer[2]=cbCenterCard;

  0014c	ba 01 00 00 00	 mov	 edx, 1
  00151	d1 e2		 shl	 edx, 1
  00153	8b 45 10	 mov	 eax, DWORD PTR _cbCardBuffer$[ebp]
  00156	8a 4d 0c	 mov	 cl, BYTE PTR _cbCenterCard$[ebp]
  00159	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1122 : 			cbCardBuffer[3]=cbCenterCard;

  0015c	ba 01 00 00 00	 mov	 edx, 1
  00161	6b c2 03	 imul	 eax, edx, 3
  00164	8b 4d 10	 mov	 ecx, DWORD PTR _cbCardBuffer$[ebp]
  00167	8a 55 0c	 mov	 dl, BYTE PTR _cbCenterCard$[ebp]
  0016a	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 1123 : 
; 1124 : 			return 4;

  0016d	b0 04		 mov	 al, 4
  0016f	eb 02		 jmp	 SHORT $LN1@GetWeaveCa
$LN2@GetWeaveCa:

; 1125 : 		}
; 1126 : 	default:
; 1127 : 		{
; 1128 : 			ASSERT(FALSE);
; 1129 : 		}
; 1130 : 	}
; 1131 : 
; 1132 : 	return 0;

  00171	32 c0		 xor	 al, al
$LN1@GetWeaveCa:

; 1133 : }

  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c2 0c 00	 ret	 12			; 0000000cH
  00179	0f 1f 00	 npad	 3
$LN12@GetWeaveCa:
  0017c	00 00 00 00	 DD	 $LN4@GetWeaveCa
  00180	00 00 00 00	 DD	 $LN6@GetWeaveCa
  00184	00 00 00 00	 DD	 $LN5@GetWeaveCa
  00188	00 00 00 00	 DD	 $LN7@GetWeaveCa
  0018c	00 00 00 00	 DD	 $LN8@GetWeaveCa
  00190	00 00 00 00	 DD	 $LN2@GetWeaveCa
$LN11@GetWeaveCa:
  00194	00		 DB	 0
  00195	01		 DB	 1
  00196	05		 DB	 5
  00197	02		 DB	 2
  00198	05		 DB	 5
  00199	05		 DB	 5
  0019a	05		 DB	 5
  0019b	03		 DB	 3
  0019c	05		 DB	 5
  0019d	05		 DB	 5
  0019e	05		 DB	 5
  0019f	05		 DB	 5
  001a0	05		 DB	 5
  001a1	05		 DB	 5
  001a2	05		 DB	 5
  001a3	04		 DB	 4
?GetWeaveCard@CGameLogic@@QAEEEEQAE@Z ENDP		; CGameLogic::GetWeaveCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbCardCount$ = -2					; size = 1
_i$1 = -1						; size = 1
_cbCardIndex$ = 8					; size = 4
?GetCardCount@CGameLogic@@QAEEQBE@Z PROC		; CGameLogic::GetCardCount
; _this$ = ecx

; 1065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1066 : 	//数目统计
; 1067 : 	BYTE cbCardCount=0;

  00009	c6 45 fe 00	 mov	 BYTE PTR _cbCardCount$[ebp], 0

; 1068 : 	for (BYTE i=0;i<MAX_INDEX;i++) 

  0000d	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  00011	eb 08		 jmp	 SHORT $LN4@GetCardCou
$LN2@GetCardCou:
  00013	8a 45 ff	 mov	 al, BYTE PTR _i$1[ebp]
  00016	04 01		 add	 al, 1
  00018	88 45 ff	 mov	 BYTE PTR _i$1[ebp], al
$LN4@GetCardCou:
  0001b	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0001f	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00022	7d 16		 jge	 SHORT $LN3@GetCardCou

; 1069 : 		cbCardCount+=cbCardIndex[i];

  00024	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  00028	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  0002b	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0002f	0f b6 55 fe	 movzx	 edx, BYTE PTR _cbCardCount$[ebp]
  00033	03 d1		 add	 edx, ecx
  00035	88 55 fe	 mov	 BYTE PTR _cbCardCount$[ebp], dl
  00038	eb d9		 jmp	 SHORT $LN2@GetCardCou
$LN3@GetCardCou:

; 1070 : 
; 1071 : 	return cbCardCount;

  0003a	8a 45 fe	 mov	 al, BYTE PTR _cbCardCount$[ebp]

; 1072 : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetCardCount@CGameLogic@@QAEEQBE@Z ENDP		; CGameLogic::GetCardCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv83 = -8						; size = 4
_cbColor$ = -2						; size = 1
_cbValue$ = -1						; size = 1
_cbCardData$ = 8					; size = 1
?IsValidCard@CGameLogic@@QAE_NE@Z PROC			; CGameLogic::IsValidCard
; _this$ = ecx

; 1057 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1058 : 	BYTE cbValue = (cbCardData & MASK_VALUE);

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  0000d	83 e0 0f	 and	 eax, 15			; 0000000fH
  00010	88 45 ff	 mov	 BYTE PTR _cbValue$[ebp], al

; 1059 : 	BYTE cbColor = (cbCardData & MASK_COLOR) >> 4;

  00013	0f b6 4d 08	 movzx	 ecx, BYTE PTR _cbCardData$[ebp]
  00017	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0001d	c1 f9 04	 sar	 ecx, 4
  00020	88 4d fe	 mov	 BYTE PTR _cbColor$[ebp], cl

; 1060 : 	return (((cbValue >= 1) && (cbValue <= 9) && (cbColor <= 2)) || ((cbValue >= 1) && (cbValue <= (7 + MAX_HUA_INDEX)) && (cbColor == 3)));

  00023	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbValue$[ebp]
  00027	83 fa 01	 cmp	 edx, 1
  0002a	7c 12		 jl	 SHORT $LN3@IsValidCar
  0002c	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbValue$[ebp]
  00030	83 f8 09	 cmp	 eax, 9
  00033	7f 09		 jg	 SHORT $LN3@IsValidCar
  00035	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbColor$[ebp]
  00039	83 f9 02	 cmp	 ecx, 2
  0003c	7e 24		 jle	 SHORT $LN5@IsValidCar
$LN3@IsValidCar:
  0003e	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbValue$[ebp]
  00042	83 fa 01	 cmp	 edx, 1
  00045	7c 12		 jl	 SHORT $LN4@IsValidCar
  00047	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbValue$[ebp]
  0004b	83 f8 07	 cmp	 eax, 7
  0004e	7f 09		 jg	 SHORT $LN4@IsValidCar
  00050	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbColor$[ebp]
  00054	83 f9 03	 cmp	 ecx, 3
  00057	74 09		 je	 SHORT $LN5@IsValidCar
$LN4@IsValidCar:
  00059	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  00060	eb 07		 jmp	 SHORT $LN6@IsValidCar
$LN5@IsValidCar:
  00062	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
$LN6@IsValidCar:
  00069	8a 45 f8	 mov	 al, BYTE PTR tv83[ebp]

; 1061 : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?IsValidCard@CGameLogic@@QAE_NE@Z ENDP			; CGameLogic::IsValidCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv81 = -8						; size = 4
_i$1 = -1						; size = 1
_cbCardData$ = 8					; size = 4
_cbCardCount$ = 12					; size = 1
_cbCardIndex$ = 16					; size = 4
?SwitchToCardIndex@CGameLogic@@QAEEQBEEQAE@Z PROC	; CGameLogic::SwitchToCardIndex
; _this$ = ecx

; 1040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1041 : 	//设置变量
; 1042 : 	ZeroMemory(cbCardIndex,sizeof(BYTE)*MAX_INDEX);

  00009	6a 22		 push	 34			; 00000022H
  0000b	6a 00		 push	 0
  0000d	8b 45 10	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1043 : 
; 1044 : 	//转换扑克
; 1045 : 	for (BYTE i=0;i<cbCardCount;i++)

  00019	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@SwitchToCa
$LN2@SwitchToCa:
  0001f	8a 4d ff	 mov	 cl, BYTE PTR _i$1[ebp]
  00022	80 c1 01	 add	 cl, 1
  00025	88 4d ff	 mov	 BYTE PTR _i$1[ebp], cl
$LN4@SwitchToCa:
  00028	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  0002c	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  00030	3b d0		 cmp	 edx, eax
  00032	7d 2b		 jge	 SHORT $LN3@SwitchToCa

; 1046 : 	{
; 1047 : 		ASSERT(IsValidCard(cbCardData[i]));
; 1048 : 		cbCardIndex[SwitchToCardIndex(cbCardData[i])]++;

  00034	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00038	8b 55 08	 mov	 edx, DWORD PTR _cbCardData$[ebp]
  0003b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0003f	50		 push	 eax
  00040	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	03 4d 10	 add	 ecx, DWORD PTR _cbCardIndex$[ebp]
  0004e	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  00051	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00054	8a 02		 mov	 al, BYTE PTR [edx]
  00056	04 01		 add	 al, 1
  00058	8b 4d f8	 mov	 ecx, DWORD PTR tv81[ebp]
  0005b	88 01		 mov	 BYTE PTR [ecx], al

; 1049 : 	}

  0005d	eb c0		 jmp	 SHORT $LN2@SwitchToCa
$LN3@SwitchToCa:

; 1050 : 
; 1051 : 	return cbCardCount;

  0005f	8a 45 0c	 mov	 al, BYTE PTR _cbCardCount$[ebp]

; 1052 : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
?SwitchToCardIndex@CGameLogic@@QAEEQBEEQAE@Z ENDP	; CGameLogic::SwitchToCardIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_j$1 = -5						; size = 1
_j$2 = -4						; size = 1
_i$3 = -3						; size = 1
_i$4 = -2						; size = 1
_cbPosition$ = -1					; size = 1
_cbCardIndex$ = 8					; size = 4
_cbCardData$ = 12					; size = 4
?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z PROC		; CGameLogic::SwitchToCardData
; _this$ = ecx

; 1003 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1004 : 	//转换扑克
; 1005 : 	BYTE cbPosition=0;

  00009	c6 45 ff 00	 mov	 BYTE PTR _cbPosition$[ebp], 0

; 1006 : 	//财神
; 1007 : 	if(m_cbMagicIndex != MAX_INDEX)

  0000d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00010	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00014	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00017	74 4a		 je	 SHORT $LN14@SwitchToCa

; 1008 : 	{
; 1009 : 		for(BYTE i = 0; i < cbCardIndex[m_cbMagicIndex]; i++)

  00019	c6 45 fd 00	 mov	 BYTE PTR _i$3[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@SwitchToCa
$LN2@SwitchToCa:
  0001f	8a 55 fd	 mov	 dl, BYTE PTR _i$3[ebp]
  00022	80 c2 01	 add	 dl, 1
  00025	88 55 fd	 mov	 BYTE PTR _i$3[ebp], dl
$LN4@SwitchToCa:
  00028	0f b6 45 fd	 movzx	 eax, BYTE PTR _i$3[ebp]
  0002c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00036	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 25		 jge	 SHORT $LN14@SwitchToCa

; 1010 : 			cbCardData[cbPosition++] = SwitchToCardData(m_cbMagicIndex);

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00045	51		 push	 ecx
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0004e	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbPosition$[ebp]
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _cbCardData$[ebp]
  00055	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00058	8a 55 ff	 mov	 dl, BYTE PTR _cbPosition$[ebp]
  0005b	80 c2 01	 add	 dl, 1
  0005e	88 55 ff	 mov	 BYTE PTR _cbPosition$[ebp], dl
  00061	eb bc		 jmp	 SHORT $LN2@SwitchToCa
$LN14@SwitchToCa:

; 1011 : 	}
; 1012 : 	for (BYTE i=0;i<MAX_INDEX;i++)

  00063	c6 45 fe 00	 mov	 BYTE PTR _i$4[ebp], 0
  00067	eb 08		 jmp	 SHORT $LN7@SwitchToCa
$LN5@SwitchToCa:
  00069	8a 45 fe	 mov	 al, BYTE PTR _i$4[ebp]
  0006c	04 01		 add	 al, 1
  0006e	88 45 fe	 mov	 BYTE PTR _i$4[ebp], al
$LN7@SwitchToCa:
  00071	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$4[ebp]
  00075	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00078	0f 8d ca 00 00
	00		 jge	 $LN6@SwitchToCa

; 1013 : 	{
; 1014 : 		if(i == m_cbMagicIndex && m_cbMagicIndex != INDEX_REPLACE_CARD) 

  0007e	0f b6 55 fe	 movzx	 edx, BYTE PTR _i$4[ebp]
  00082	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00085	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00089	3b d1		 cmp	 edx, ecx
  0008b	75 56		 jne	 SHORT $LN15@SwitchToCa
  0008d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00090	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00094	83 f8 22	 cmp	 eax, 34			; 00000022H
  00097	74 4a		 je	 SHORT $LN15@SwitchToCa

; 1015 : 		{
; 1016 : 			//如果财神有代替牌，则代替牌代替财神原来的位置
; 1017 : 			if(INDEX_REPLACE_CARD != MAX_INDEX)

  00099	33 c9		 xor	 ecx, ecx
  0009b	74 44		 je	 SHORT $LN16@SwitchToCa

; 1018 : 			{
; 1019 : 				for(BYTE j = 0; j < cbCardIndex[INDEX_REPLACE_CARD]; j++)

  0009d	c6 45 fc 00	 mov	 BYTE PTR _j$2[ebp], 0
  000a1	eb 09		 jmp	 SHORT $LN10@SwitchToCa
$LN8@SwitchToCa:
  000a3	8a 55 fc	 mov	 dl, BYTE PTR _j$2[ebp]
  000a6	80 c2 01	 add	 dl, 1
  000a9	88 55 fc	 mov	 BYTE PTR _j$2[ebp], dl
$LN10@SwitchToCa:
  000ac	0f b6 45 fc	 movzx	 eax, BYTE PTR _j$2[ebp]
  000b0	b9 01 00 00 00	 mov	 ecx, 1
  000b5	6b d1 22	 imul	 edx, ecx, 34
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  000bb	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  000bf	3b c2		 cmp	 eax, edx
  000c1	7d 1e		 jge	 SHORT $LN16@SwitchToCa

; 1020 : 					cbCardData[cbPosition++] = SwitchToCardData(INDEX_REPLACE_CARD);

  000c3	6a 22		 push	 34			; 00000022H
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  000cd	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbPosition$[ebp]
  000d1	8b 55 0c	 mov	 edx, DWORD PTR _cbCardData$[ebp]
  000d4	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000d7	8a 45 ff	 mov	 al, BYTE PTR _cbPosition$[ebp]
  000da	04 01		 add	 al, 1
  000dc	88 45 ff	 mov	 BYTE PTR _cbPosition$[ebp], al
  000df	eb c2		 jmp	 SHORT $LN8@SwitchToCa
$LN16@SwitchToCa:

; 1021 : 			}
; 1022 : 			continue;

  000e1	eb 86		 jmp	 SHORT $LN5@SwitchToCa
$LN15@SwitchToCa:

; 1023 : 		}
; 1024 : 		if(i == INDEX_REPLACE_CARD) continue;

  000e3	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$4[ebp]
  000e7	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000ea	75 05		 jne	 SHORT $LN17@SwitchToCa
  000ec	e9 78 ff ff ff	 jmp	 $LN5@SwitchToCa
$LN17@SwitchToCa:

; 1025 : 		if (cbCardIndex[i]!=0)

  000f1	0f b6 55 fe	 movzx	 edx, BYTE PTR _i$4[ebp]
  000f5	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  000f8	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  000fc	85 c9		 test	 ecx, ecx
  000fe	74 43		 je	 SHORT $LN18@SwitchToCa

; 1026 : 		{
; 1027 : 			for (BYTE j=0;j<cbCardIndex[i];j++)

  00100	c6 45 fb 00	 mov	 BYTE PTR _j$1[ebp], 0
  00104	eb 09		 jmp	 SHORT $LN13@SwitchToCa
$LN11@SwitchToCa:
  00106	8a 55 fb	 mov	 dl, BYTE PTR _j$1[ebp]
  00109	80 c2 01	 add	 dl, 1
  0010c	88 55 fb	 mov	 BYTE PTR _j$1[ebp], dl
$LN13@SwitchToCa:
  0010f	0f b6 45 fb	 movzx	 eax, BYTE PTR _j$1[ebp]
  00113	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$4[ebp]
  00117	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  0011a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0011e	3b c1		 cmp	 eax, ecx
  00120	7d 21		 jge	 SHORT $LN18@SwitchToCa

; 1028 : 			{
; 1029 : 				ASSERT(cbPosition<MAX_COUNT);
; 1030 : 				cbCardData[cbPosition++]=SwitchToCardData(i);

  00122	0f b6 55 fe	 movzx	 edx, BYTE PTR _i$4[ebp]
  00126	52		 push	 edx
  00127	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0012f	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbPosition$[ebp]
  00133	8b 55 0c	 mov	 edx, DWORD PTR _cbCardData$[ebp]
  00136	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00139	8a 45 ff	 mov	 al, BYTE PTR _cbPosition$[ebp]
  0013c	04 01		 add	 al, 1
  0013e	88 45 ff	 mov	 BYTE PTR _cbPosition$[ebp], al

; 1031 : 			}

  00141	eb c3		 jmp	 SHORT $LN11@SwitchToCa
$LN18@SwitchToCa:

; 1032 : 		}
; 1033 : 	}

  00143	e9 21 ff ff ff	 jmp	 $LN5@SwitchToCa
$LN6@SwitchToCa:

; 1034 : 
; 1035 : 	return cbPosition;

  00148	8a 45 ff	 mov	 al, BYTE PTR _cbPosition$[ebp]

; 1036 : }

  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c2 08 00	 ret	 8
?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z ENDP		; CGameLogic::SwitchToCardData
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cbCardData$ = 8					; size = 1
?SwitchToCardIndex@CGameLogic@@QAEEE@Z PROC		; CGameLogic::SwitchToCardIndex
; _this$ = ecx

; 996  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 997  : 	ASSERT(IsValidCard(cbCardData));
; 998  : 	return ((cbCardData & MASK_COLOR) >> 4) * 9 + (cbCardData & MASK_VALUE) - 1;

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  0000b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00010	c1 f8 04	 sar	 eax, 4
  00013	6b c8 09	 imul	 ecx, eax, 9
  00016	0f b6 55 08	 movzx	 edx, BYTE PTR _cbCardData$[ebp]
  0001a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0001d	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]

; 999  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?SwitchToCardIndex@CGameLogic@@QAEEE@Z ENDP		; CGameLogic::SwitchToCardIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cbCardIndex$ = 8					; size = 1
?SwitchToCardData@CGameLogic@@QAEEE@Z PROC		; CGameLogic::SwitchToCardData
; _this$ = ecx

; 987  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 988  : 	ASSERT(cbCardIndex<MAX_INDEX);
; 989  : 	if(cbCardIndex < 27)

  00008	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardIndex$[ebp]
  0000c	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  0000f	7d 28		 jge	 SHORT $LN2@SwitchToCa

; 990  : 		return ((cbCardIndex/9)<<4)|(cbCardIndex%9+1);

  00011	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardIndex$[ebp]
  00015	99		 cdq
  00016	b9 09 00 00 00	 mov	 ecx, 9
  0001b	f7 f9		 idiv	 ecx
  0001d	8b c8		 mov	 ecx, eax
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardIndex$[ebp]
  00026	99		 cdq
  00027	be 09 00 00 00	 mov	 esi, 9
  0002c	f7 fe		 idiv	 esi
  0002e	83 c2 01	 add	 edx, 1
  00031	0b ca		 or	 ecx, edx
  00033	8a c1		 mov	 al, cl
  00035	eb 0c		 jmp	 SHORT $LN1@SwitchToCa
  00037	eb 0a		 jmp	 SHORT $LN1@SwitchToCa
$LN2@SwitchToCa:

; 991  : 	else return (0x30|(cbCardIndex-27+1));

  00039	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardIndex$[ebp]
  0003d	83 e8 1a	 sub	 eax, 26			; 0000001aH
  00040	83 c8 30	 or	 eax, 48			; 00000030H
$LN1@SwitchToCa:

; 992  : }

  00043	5e		 pop	 esi
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?SwitchToCardData@CGameLogic@@QAEEE@Z ENDP		; CGameLogic::SwitchToCardData
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -52						; size = 4
_this$ = -48						; size = 4
_cbCardCount$ = -44					; size = 1
_cbCurrentCard$1 = -43					; size = 1
_j$2 = -42						; size = 1
_cbCount$ = -41						; size = 1
_cbCardIndexTemp$ = -40					; size = 34
__$ArrayPad$ = -4					; size = 4
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
_cbHuCardData$ = 20					; size = 4
?GetHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAE@Z PROC ; CGameLogic::GetHuCard
; _this$ = ecx

; 958  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 959  : 	//复制数据
; 960  : 	BYTE cbCardIndexTemp[MAX_INDEX];
; 961  : 	CopyMemory( cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp) );

  00013	6a 22		 push	 34			; 00000022H
  00015	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00018	50		 push	 eax
  00019	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _memcpy
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 962  : 
; 963  : 	BYTE cbCount = 0;

  00025	c6 45 d7 00	 mov	 BYTE PTR _cbCount$[ebp], 0

; 964  : 	ZeroMemory(cbHuCardData,sizeof(cbHuCardData));

  00029	6a 04		 push	 4
  0002b	6a 00		 push	 0
  0002d	8b 55 14	 mov	 edx, DWORD PTR _cbHuCardData$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 _memset
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 965  : 
; 966  : 	BYTE cbCardCount = GetCardCount(cbCardIndexTemp);

  00039	8d 45 d8	 lea	 eax, DWORD PTR _cbCardIndexTemp$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  00045	88 45 d4	 mov	 BYTE PTR _cbCardCount$[ebp], al

; 967  : 	CChiHuRight chr;

  00048	8d 4d cc	 lea	 ecx, DWORD PTR _chr$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 968  : 
; 969  : 	if( (cbCardCount-2)%3 !=0 )

  00050	0f b6 45 d4	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  00054	83 e8 02	 sub	 eax, 2
  00057	99		 cdq
  00058	b9 03 00 00 00	 mov	 ecx, 3
  0005d	f7 f9		 idiv	 ecx
  0005f	85 d2		 test	 edx, edx
  00061	74 75		 je	 SHORT $LN5@GetHuCard

; 970  : 	{
; 971  : 		for( BYTE j = 0; j < MAX_INDEX; j++ )

  00063	c6 45 d6 00	 mov	 BYTE PTR _j$2[ebp], 0
  00067	eb 09		 jmp	 SHORT $LN4@GetHuCard
$LN2@GetHuCard:
  00069	8a 55 d6	 mov	 dl, BYTE PTR _j$2[ebp]
  0006c	80 c2 01	 add	 dl, 1
  0006f	88 55 d6	 mov	 BYTE PTR _j$2[ebp], dl
$LN4@GetHuCard:
  00072	0f b6 45 d6	 movzx	 eax, BYTE PTR _j$2[ebp]
  00076	83 f8 22	 cmp	 eax, 34			; 00000022H
  00079	7d 50		 jge	 SHORT $LN3@GetHuCard

; 972  : 		{
; 973  : 			BYTE cbCurrentCard = SwitchToCardData(j);

  0007b	0f b6 4d d6	 movzx	 ecx, BYTE PTR _j$2[ebp]
  0007f	51		 push	 ecx
  00080	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00088	88 45 d5	 mov	 BYTE PTR _cbCurrentCard$1[ebp], al

; 974  : 			if( WIK_CHI_HU == AnalyseChiHuCard(cbCardIndexTemp,WeaveItem,cbWeaveCount,cbCurrentCard,chr) )

  0008b	6a 00		 push	 0
  0008d	8d 55 cc	 lea	 edx, DWORD PTR _chr$[ebp]
  00090	52		 push	 edx
  00091	0f b6 45 d5	 movzx	 eax, BYTE PTR _cbCurrentCard$1[ebp]
  00095	50		 push	 eax
  00096	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cbWeaveCount$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 0c	 mov	 edx, DWORD PTR _WeaveItem$[ebp]
  0009e	52		 push	 edx
  0009f	8d 45 d8	 lea	 eax, DWORD PTR _cbCardIndexTemp$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  000ab	0f b6 c8	 movzx	 ecx, al
  000ae	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000b1	75 16		 jne	 SHORT $LN6@GetHuCard

; 975  : 			{
; 976  : 				cbHuCardData[cbCount++] = cbCurrentCard;

  000b3	0f b6 55 d7	 movzx	 edx, BYTE PTR _cbCount$[ebp]
  000b7	8b 45 14	 mov	 eax, DWORD PTR _cbHuCardData$[ebp]
  000ba	8a 4d d5	 mov	 cl, BYTE PTR _cbCurrentCard$1[ebp]
  000bd	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  000c0	8a 55 d7	 mov	 dl, BYTE PTR _cbCount$[ebp]
  000c3	80 c2 01	 add	 dl, 1
  000c6	88 55 d7	 mov	 BYTE PTR _cbCount$[ebp], dl
$LN6@GetHuCard:

; 977  : 			}
; 978  : 		}

  000c9	eb 9e		 jmp	 SHORT $LN2@GetHuCard
$LN3@GetHuCard:

; 979  : 		if(cbCount>0)

  000cb	0f b6 45 d7	 movzx	 eax, BYTE PTR _cbCount$[ebp]
  000cf	85 c0		 test	 eax, eax
  000d1	7e 05		 jle	 SHORT $LN5@GetHuCard

; 980  : 			return cbCount;

  000d3	8a 45 d7	 mov	 al, BYTE PTR _cbCount$[ebp]
  000d6	eb 02		 jmp	 SHORT $LN1@GetHuCard
$LN5@GetHuCard:

; 981  : 	}
; 982  : 
; 983  : 	return 0;

  000d8	32 c0		 xor	 al, al
$LN1@GetHuCard:

; 984  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 cd		 xor	 ecx, ebp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 10 00	 ret	 16			; 00000010H
?GetHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAE@Z ENDP ; CGameLogic::GetHuCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -60						; size = 4
_this$ = -56						; size = 4
_cbCurrentCard$1 = -50					; size = 1
_cbCardCount$ = -49					; size = 1
_cbCurrentCard$2 = -48					; size = 1
_bAdd$3 = -47						; size = 1
_cbCount$4 = -46					; size = 1
_j$5 = -45						; size = 1
_nCount$6 = -44						; size = 1
_j$7 = -43						; size = 1
_cbOutCount$ = -42					; size = 1
_i$8 = -41						; size = 1
_cbCardIndexTemp$ = -40					; size = 34
__$ArrayPad$ = -4					; size = 4
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
_cbOutCardCount$ = 20					; size = 4
_cbOutCardData$ = 24					; size = 4
_cbHuCardCount$ = 28					; size = 4
_cbHuCardData$ = 32					; size = 4
?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z PROC ; CGameLogic::AnalyseTingCard
; _this$ = ecx

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 903  : 	//复制数据
; 904  : 	BYTE cbOutCount = 0;

  00013	c6 45 d6 00	 mov	 BYTE PTR _cbOutCount$[ebp], 0

; 905  : 	BYTE cbCardIndexTemp[MAX_INDEX];
; 906  : 	CopyMemory(cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp));

  00017	6a 22		 push	 34			; 00000022H
  00019	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _memcpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 907  : 
; 908  : 	BYTE cbCardCount = GetCardCount(cbCardIndexTemp);

  00029	8d 55 d8	 lea	 edx, DWORD PTR _cbCardIndexTemp$[ebp]
  0002c	52		 push	 edx
  0002d	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  00035	88 45 cf	 mov	 BYTE PTR _cbCardCount$[ebp], al

; 909  : 	CChiHuRight chr;

  00038	8d 4d c4	 lea	 ecx, DWORD PTR _chr$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 910  : 
; 911  : 	if((cbCardCount-2)%3==0)

  00040	0f b6 45 cf	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  00044	83 e8 02	 sub	 eax, 2
  00047	99		 cdq
  00048	b9 03 00 00 00	 mov	 ecx, 3
  0004d	f7 f9		 idiv	 ecx
  0004f	85 d2		 test	 edx, edx
  00051	0f 85 27 01 00
	00		 jne	 $LN11@AnalyseTin

; 912  : 	{
; 913  : 		for(BYTE i = 0; i < MAX_INDEX-MAX_HUA_INDEX; i++)

  00057	c6 45 d7 00	 mov	 BYTE PTR _i$8[ebp], 0
  0005b	eb 09		 jmp	 SHORT $LN4@AnalyseTin
$LN2@AnalyseTin:
  0005d	8a 55 d7	 mov	 dl, BYTE PTR _i$8[ebp]
  00060	80 c2 01	 add	 dl, 1
  00063	88 55 d7	 mov	 BYTE PTR _i$8[ebp], dl
$LN4@AnalyseTin:
  00066	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$8[ebp]
  0006a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0006d	0f 8d 06 01 00
	00		 jge	 $LN3@AnalyseTin

; 914  : 		{
; 915  : 			if(cbCardIndexTemp[i] == 0) continue;

  00073	0f b6 4d d7	 movzx	 ecx, BYTE PTR _i$8[ebp]
  00077	0f b6 54 0d d8	 movzx	 edx, BYTE PTR _cbCardIndexTemp$[ebp+ecx]
  0007c	85 d2		 test	 edx, edx
  0007e	75 02		 jne	 SHORT $LN13@AnalyseTin
  00080	eb db		 jmp	 SHORT $LN2@AnalyseTin
$LN13@AnalyseTin:

; 916  : 			cbCardIndexTemp[i]--;

  00082	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$8[ebp]
  00086	8a 4c 05 d8	 mov	 cl, BYTE PTR _cbCardIndexTemp$[ebp+eax]
  0008a	80 e9 01	 sub	 cl, 1
  0008d	0f b6 55 d7	 movzx	 edx, BYTE PTR _i$8[ebp]
  00091	88 4c 15 d8	 mov	 BYTE PTR _cbCardIndexTemp$[ebp+edx], cl

; 917  : 
; 918  : 			bool bAdd=false;

  00095	c6 45 d1 00	 mov	 BYTE PTR _bAdd$3[ebp], 0

; 919  : 			BYTE nCount=0;

  00099	c6 45 d4 00	 mov	 BYTE PTR _nCount$6[ebp], 0

; 920  : 			for(BYTE j = 0; j < MAX_INDEX-MAX_HUA_INDEX; j++)

  0009d	c6 45 d5 00	 mov	 BYTE PTR _j$7[ebp], 0
  000a1	eb 08		 jmp	 SHORT $LN7@AnalyseTin
$LN5@AnalyseTin:
  000a3	8a 45 d5	 mov	 al, BYTE PTR _j$7[ebp]
  000a6	04 01		 add	 al, 1
  000a8	88 45 d5	 mov	 BYTE PTR _j$7[ebp], al
$LN7@AnalyseTin:
  000ab	0f b6 4d d5	 movzx	 ecx, BYTE PTR _j$7[ebp]
  000af	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000b2	0f 8d 93 00 00
	00		 jge	 $LN6@AnalyseTin

; 921  : 			{
; 922  : 				BYTE cbCurrentCard = SwitchToCardData(j);

  000b8	0f b6 55 d5	 movzx	 edx, BYTE PTR _j$7[ebp]
  000bc	52		 push	 edx
  000bd	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  000c5	88 45 ce	 mov	 BYTE PTR _cbCurrentCard$1[ebp], al

; 923  : 				if(WIK_CHI_HU == AnalyseChiHuCard(cbCardIndexTemp,WeaveItem,cbWeaveCount,cbCurrentCard,chr))

  000c8	6a 00		 push	 0
  000ca	8d 45 c4	 lea	 eax, DWORD PTR _chr$[ebp]
  000cd	50		 push	 eax
  000ce	0f b6 4d ce	 movzx	 ecx, BYTE PTR _cbCurrentCard$1[ebp]
  000d2	51		 push	 ecx
  000d3	0f b6 55 10	 movzx	 edx, BYTE PTR _cbWeaveCount$[ebp]
  000d7	52		 push	 edx
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  000db	50		 push	 eax
  000dc	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  000df	51		 push	 ecx
  000e0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  000e8	0f b6 d0	 movzx	 edx, al
  000eb	83 fa 40	 cmp	 edx, 64			; 00000040H
  000ee	75 56		 jne	 SHORT $LN14@AnalyseTin

; 924  : 				{
; 925  : 					if(bAdd==FALSE)

  000f0	0f b6 45 d1	 movzx	 eax, BYTE PTR _bAdd$3[ebp]
  000f4	85 c0		 test	 eax, eax
  000f6	75 24		 jne	 SHORT $LN15@AnalyseTin

; 926  : 					{
; 927  : 						bAdd=true;

  000f8	c6 45 d1 01	 mov	 BYTE PTR _bAdd$3[ebp], 1

; 928  : 						cbOutCardData[cbOutCount++] = SwitchToCardData(i);

  000fc	0f b6 4d d7	 movzx	 ecx, BYTE PTR _i$8[ebp]
  00100	51		 push	 ecx
  00101	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00109	0f b6 55 d6	 movzx	 edx, BYTE PTR _cbOutCount$[ebp]
  0010d	8b 4d 18	 mov	 ecx, DWORD PTR _cbOutCardData$[ebp]
  00110	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00113	8a 55 d6	 mov	 dl, BYTE PTR _cbOutCount$[ebp]
  00116	80 c2 01	 add	 dl, 1
  00119	88 55 d6	 mov	 BYTE PTR _cbOutCount$[ebp], dl
$LN15@AnalyseTin:

; 929  : 					}
; 930  : 					cbHuCardData[cbOutCount-1][nCount++]=SwitchToCardData(j);

  0011c	0f b6 45 d5	 movzx	 eax, BYTE PTR _j$7[ebp]
  00120	50		 push	 eax
  00121	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00129	0f b6 4d d6	 movzx	 ecx, BYTE PTR _cbOutCount$[ebp]
  0012d	83 e9 01	 sub	 ecx, 1
  00130	6b d1 1c	 imul	 edx, ecx, 28
  00133	03 55 20	 add	 edx, DWORD PTR _cbHuCardData$[ebp]
  00136	0f b6 4d d4	 movzx	 ecx, BYTE PTR _nCount$6[ebp]
  0013a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0013d	8a 55 d4	 mov	 dl, BYTE PTR _nCount$6[ebp]
  00140	80 c2 01	 add	 dl, 1
  00143	88 55 d4	 mov	 BYTE PTR _nCount$6[ebp], dl
$LN14@AnalyseTin:

; 931  : 				}
; 932  : 			}

  00146	e9 58 ff ff ff	 jmp	 $LN5@AnalyseTin
$LN6@AnalyseTin:

; 933  : 			if(bAdd)

  0014b	0f b6 45 d1	 movzx	 eax, BYTE PTR _bAdd$3[ebp]
  0014f	85 c0		 test	 eax, eax
  00151	74 0e		 je	 SHORT $LN16@AnalyseTin

; 934  : 				cbHuCardCount[cbOutCount-1]=nCount;

  00153	0f b6 4d d6	 movzx	 ecx, BYTE PTR _cbOutCount$[ebp]
  00157	8b 55 1c	 mov	 edx, DWORD PTR _cbHuCardCount$[ebp]
  0015a	8a 45 d4	 mov	 al, BYTE PTR _nCount$6[ebp]
  0015d	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
$LN16@AnalyseTin:

; 935  : 
; 936  : 			cbCardIndexTemp[i]++;

  00161	0f b6 4d d7	 movzx	 ecx, BYTE PTR _i$8[ebp]
  00165	8a 54 0d d8	 mov	 dl, BYTE PTR _cbCardIndexTemp$[ebp+ecx]
  00169	80 c2 01	 add	 dl, 1
  0016c	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$8[ebp]
  00170	88 54 05 d8	 mov	 BYTE PTR _cbCardIndexTemp$[ebp+eax], dl

; 937  : 		}

  00174	e9 e4 fe ff ff	 jmp	 $LN2@AnalyseTin
$LN3@AnalyseTin:

; 938  : 	}
; 939  : 	else

  00179	e9 85 00 00 00	 jmp	 $LN12@AnalyseTin
$LN11@AnalyseTin:

; 940  : 	{
; 941  : 		BYTE cbCount=0;

  0017e	c6 45 d2 00	 mov	 BYTE PTR _cbCount$4[ebp], 0

; 942  : 		for( BYTE j = 0; j < MAX_INDEX; j++ )

  00182	c6 45 d3 00	 mov	 BYTE PTR _j$5[ebp], 0
  00186	eb 09		 jmp	 SHORT $LN10@AnalyseTin
$LN8@AnalyseTin:
  00188	8a 4d d3	 mov	 cl, BYTE PTR _j$5[ebp]
  0018b	80 c1 01	 add	 cl, 1
  0018e	88 4d d3	 mov	 BYTE PTR _j$5[ebp], cl
$LN10@AnalyseTin:
  00191	0f b6 55 d3	 movzx	 edx, BYTE PTR _j$5[ebp]
  00195	83 fa 22	 cmp	 edx, 34			; 00000022H
  00198	7d 58		 jge	 SHORT $LN9@AnalyseTin

; 943  : 		{
; 944  : 			BYTE cbCurrentCard = SwitchToCardData(j);

  0019a	0f b6 45 d3	 movzx	 eax, BYTE PTR _j$5[ebp]
  0019e	50		 push	 eax
  0019f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  001a7	88 45 d0	 mov	 BYTE PTR _cbCurrentCard$2[ebp], al

; 945  : 			if( WIK_CHI_HU == AnalyseChiHuCard(cbCardIndexTemp,WeaveItem,cbWeaveCount,cbCurrentCard,chr) )

  001aa	6a 00		 push	 0
  001ac	8d 4d c4	 lea	 ecx, DWORD PTR _chr$[ebp]
  001af	51		 push	 ecx
  001b0	0f b6 55 d0	 movzx	 edx, BYTE PTR _cbCurrentCard$2[ebp]
  001b4	52		 push	 edx
  001b5	0f b6 45 10	 movzx	 eax, BYTE PTR _cbWeaveCount$[ebp]
  001b9	50		 push	 eax
  001ba	8b 4d 0c	 mov	 ecx, DWORD PTR _WeaveItem$[ebp]
  001bd	51		 push	 ecx
  001be	8d 55 d8	 lea	 edx, DWORD PTR _cbCardIndexTemp$[ebp]
  001c1	52		 push	 edx
  001c2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  001ca	0f b6 c0	 movzx	 eax, al
  001cd	83 f8 40	 cmp	 eax, 64			; 00000040H
  001d0	75 1e		 jne	 SHORT $LN17@AnalyseTin

; 946  : 			{
; 947  : 				cbHuCardData[0][cbCount++] = cbCurrentCard;

  001d2	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  001d7	6b d1 00	 imul	 edx, ecx, 0
  001da	03 55 20	 add	 edx, DWORD PTR _cbHuCardData$[ebp]
  001dd	0f b6 45 d2	 movzx	 eax, BYTE PTR _cbCount$4[ebp]
  001e1	8a 4d d0	 mov	 cl, BYTE PTR _cbCurrentCard$2[ebp]
  001e4	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  001e7	8a 55 d2	 mov	 dl, BYTE PTR _cbCount$4[ebp]
  001ea	80 c2 01	 add	 dl, 1
  001ed	88 55 d2	 mov	 BYTE PTR _cbCount$4[ebp], dl
$LN17@AnalyseTin:

; 948  : 			}
; 949  : 		}

  001f0	eb 96		 jmp	 SHORT $LN8@AnalyseTin
$LN9@AnalyseTin:

; 950  : 		cbHuCardCount[0]=cbCount;

  001f2	b8 01 00 00 00	 mov	 eax, 1
  001f7	6b c8 00	 imul	 ecx, eax, 0
  001fa	8b 55 1c	 mov	 edx, DWORD PTR _cbHuCardCount$[ebp]
  001fd	8a 45 d2	 mov	 al, BYTE PTR _cbCount$4[ebp]
  00200	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN12@AnalyseTin:

; 951  : 	}
; 952  : 
; 953  : 	cbOutCardCount = cbOutCount;

  00203	8b 4d 14	 mov	 ecx, DWORD PTR _cbOutCardCount$[ebp]
  00206	8a 55 d6	 mov	 dl, BYTE PTR _cbOutCount$[ebp]
  00209	88 11		 mov	 BYTE PTR [ecx], dl

; 954  : 	return cbOutCount;

  0020b	8a 45 d6	 mov	 al, BYTE PTR _cbOutCount$[ebp]

; 955  : }

  0020e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00211	33 cd		 xor	 ecx, ebp
  00213	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c2 1c 00	 ret	 28			; 0000001cH
?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z ENDP ; CGameLogic::AnalyseTingCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -56						; size = 4
_this$ = -52						; size = 4
_cbCurrentCard$1 = -47					; size = 1
_cbCardCount$ = -46					; size = 1
_bAdd$2 = -45						; size = 1
_nCount$3 = -44						; size = 1
_cbOutCount$ = -43					; size = 1
_j$4 = -42						; size = 1
_i$5 = -41						; size = 1
_cbCardIndexTemp$ = -40					; size = 34
__$ArrayPad$ = -4					; size = 4
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
_cbOutCard$ = 20					; size = 4
?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAY0BM@E@Z PROC ; CGameLogic::AnalyseTingCard
; _this$ = ecx

; 862  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 863  : 	//复制数据
; 864  : 	BYTE cbOutCount = 0;

  00013	c6 45 d5 00	 mov	 BYTE PTR _cbOutCount$[ebp], 0

; 865  : 	BYTE cbCardIndexTemp[MAX_INDEX];
; 866  : 	CopyMemory(cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp));

  00017	6a 22		 push	 34			; 00000022H
  00019	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _memcpy
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 867  : 
; 868  : 	BYTE cbCardCount = GetCardCount(cbCardIndexTemp);

  00029	8d 55 d8	 lea	 edx, DWORD PTR _cbCardIndexTemp$[ebp]
  0002c	52		 push	 edx
  0002d	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  00035	88 45 d2	 mov	 BYTE PTR _cbCardCount$[ebp], al

; 869  : 	CChiHuRight chr;

  00038	8d 4d c8	 lea	 ecx, DWORD PTR _chr$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 870  : 
; 871  : 	if((cbCardCount-2)%3==0)

  00040	0f b6 45 d2	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  00044	83 e8 02	 sub	 eax, 2
  00047	99		 cdq
  00048	b9 03 00 00 00	 mov	 ecx, 3
  0004d	f7 f9		 idiv	 ecx
  0004f	85 d2		 test	 edx, edx
  00051	0f 85 0f 01 00
	00		 jne	 $LN8@AnalyseTin

; 872  : 	{
; 873  : 		for(BYTE i = 0; i < MAX_INDEX-MAX_HUA_INDEX; i++)

  00057	c6 45 d7 00	 mov	 BYTE PTR _i$5[ebp], 0
  0005b	eb 09		 jmp	 SHORT $LN4@AnalyseTin
$LN2@AnalyseTin:
  0005d	8a 55 d7	 mov	 dl, BYTE PTR _i$5[ebp]
  00060	80 c2 01	 add	 dl, 1
  00063	88 55 d7	 mov	 BYTE PTR _i$5[ebp], dl
$LN4@AnalyseTin:
  00066	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$5[ebp]
  0006a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0006d	0f 8d f3 00 00
	00		 jge	 $LN8@AnalyseTin

; 874  : 		{
; 875  : 			if(cbCardIndexTemp[i] == 0) continue;

  00073	0f b6 4d d7	 movzx	 ecx, BYTE PTR _i$5[ebp]
  00077	0f b6 54 0d d8	 movzx	 edx, BYTE PTR _cbCardIndexTemp$[ebp+ecx]
  0007c	85 d2		 test	 edx, edx
  0007e	75 02		 jne	 SHORT $LN9@AnalyseTin
  00080	eb db		 jmp	 SHORT $LN2@AnalyseTin
$LN9@AnalyseTin:

; 876  : 			cbCardIndexTemp[i]--;

  00082	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$5[ebp]
  00086	8a 4c 05 d8	 mov	 cl, BYTE PTR _cbCardIndexTemp$[ebp+eax]
  0008a	80 e9 01	 sub	 cl, 1
  0008d	0f b6 55 d7	 movzx	 edx, BYTE PTR _i$5[ebp]
  00091	88 4c 15 d8	 mov	 BYTE PTR _cbCardIndexTemp$[ebp+edx], cl

; 877  : 			
; 878  : 			bool bAdd=false;

  00095	c6 45 d3 00	 mov	 BYTE PTR _bAdd$2[ebp], 0

; 879  : 			BYTE nCount=0;

  00099	c6 45 d4 00	 mov	 BYTE PTR _nCount$3[ebp], 0

; 880  : 			for(BYTE j = 0; j < MAX_INDEX-MAX_HUA_INDEX; j++)

  0009d	c6 45 d6 00	 mov	 BYTE PTR _j$4[ebp], 0
  000a1	eb 08		 jmp	 SHORT $LN7@AnalyseTin
$LN5@AnalyseTin:
  000a3	8a 45 d6	 mov	 al, BYTE PTR _j$4[ebp]
  000a6	04 01		 add	 al, 1
  000a8	88 45 d6	 mov	 BYTE PTR _j$4[ebp], al
$LN7@AnalyseTin:
  000ab	0f b6 4d d6	 movzx	 ecx, BYTE PTR _j$4[ebp]
  000af	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000b2	0f 8d 96 00 00
	00		 jge	 $LN6@AnalyseTin

; 881  : 			{
; 882  : 				BYTE cbCurrentCard = SwitchToCardData(j);

  000b8	0f b6 55 d6	 movzx	 edx, BYTE PTR _j$4[ebp]
  000bc	52		 push	 edx
  000bd	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  000c5	88 45 d1	 mov	 BYTE PTR _cbCurrentCard$1[ebp], al

; 883  : 				if(WIK_CHI_HU == AnalyseChiHuCard(cbCardIndexTemp,WeaveItem,cbWeaveCount,cbCurrentCard,chr))

  000c8	6a 00		 push	 0
  000ca	8d 45 c8	 lea	 eax, DWORD PTR _chr$[ebp]
  000cd	50		 push	 eax
  000ce	0f b6 4d d1	 movzx	 ecx, BYTE PTR _cbCurrentCard$1[ebp]
  000d2	51		 push	 ecx
  000d3	0f b6 55 10	 movzx	 edx, BYTE PTR _cbWeaveCount$[ebp]
  000d7	52		 push	 edx
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  000db	50		 push	 eax
  000dc	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  000df	51		 push	 ecx
  000e0	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  000e8	0f b6 d0	 movzx	 edx, al
  000eb	83 fa 40	 cmp	 edx, 64			; 00000040H
  000ee	75 59		 jne	 SHORT $LN10@AnalyseTin

; 884  : 				{
; 885  : 					if(bAdd==FALSE)

  000f0	0f b6 45 d3	 movzx	 eax, BYTE PTR _bAdd$2[ebp]
  000f4	85 c0		 test	 eax, eax
  000f6	75 2b		 jne	 SHORT $LN11@AnalyseTin

; 886  : 					{
; 887  : 						bAdd=true;

  000f8	c6 45 d3 01	 mov	 BYTE PTR _bAdd$2[ebp], 1

; 888  : 						cbOutCard[0][cbOutCount++] = SwitchToCardData(i);

  000fc	0f b6 4d d7	 movzx	 ecx, BYTE PTR _i$5[ebp]
  00100	51		 push	 ecx
  00101	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00109	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  0010e	6b ca 00	 imul	 ecx, edx, 0
  00111	03 4d 14	 add	 ecx, DWORD PTR _cbOutCard$[ebp]
  00114	0f b6 55 d5	 movzx	 edx, BYTE PTR _cbOutCount$[ebp]
  00118	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0011b	8a 45 d5	 mov	 al, BYTE PTR _cbOutCount$[ebp]
  0011e	04 01		 add	 al, 1
  00120	88 45 d5	 mov	 BYTE PTR _cbOutCount$[ebp], al
$LN11@AnalyseTin:

; 889  : 					}
; 890  : 					cbOutCard[cbOutCount][nCount++]=SwitchToCardData(j);

  00123	0f b6 4d d6	 movzx	 ecx, BYTE PTR _j$4[ebp]
  00127	51		 push	 ecx
  00128	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00130	0f b6 55 d5	 movzx	 edx, BYTE PTR _cbOutCount$[ebp]
  00134	6b ca 1c	 imul	 ecx, edx, 28
  00137	03 4d 14	 add	 ecx, DWORD PTR _cbOutCard$[ebp]
  0013a	0f b6 55 d4	 movzx	 edx, BYTE PTR _nCount$3[ebp]
  0013e	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00141	8a 45 d4	 mov	 al, BYTE PTR _nCount$3[ebp]
  00144	04 01		 add	 al, 1
  00146	88 45 d4	 mov	 BYTE PTR _nCount$3[ebp], al
$LN10@AnalyseTin:

; 891  : 				}
; 892  : 			}

  00149	e9 55 ff ff ff	 jmp	 $LN5@AnalyseTin
$LN6@AnalyseTin:

; 893  : 
; 894  : 			cbCardIndexTemp[i]++;

  0014e	0f b6 4d d7	 movzx	 ecx, BYTE PTR _i$5[ebp]
  00152	8a 54 0d d8	 mov	 dl, BYTE PTR _cbCardIndexTemp$[ebp+ecx]
  00156	80 c2 01	 add	 dl, 1
  00159	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$5[ebp]
  0015d	88 54 05 d8	 mov	 BYTE PTR _cbCardIndexTemp$[ebp+eax], dl

; 895  : 		}

  00161	e9 f7 fe ff ff	 jmp	 $LN2@AnalyseTin
$LN8@AnalyseTin:

; 896  : 	}
; 897  : 
; 898  : 	return cbOutCount;

  00166	8a 45 d5	 mov	 al, BYTE PTR _cbOutCount$[ebp]

; 899  : }

  00169	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016c	33 cd		 xor	 ecx, ebp
  0016e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c2 10 00	 ret	 16			; 00000010H
?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAY0BM@E@Z ENDP ; CGameLogic::AnalyseTingCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -56						; size = 4
_this$ = -52						; size = 4
_cbCurrentCard$1 = -46					; size = 1
_cbCurrentCard$2 = -45					; size = 1
_cbCardCount$ = -44					; size = 1
_j$3 = -43						; size = 1
_j$4 = -42						; size = 1
_i$5 = -41						; size = 1
_cbCardIndexTemp$ = -40					; size = 34
__$ArrayPad$ = -4					; size = 4
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@E@Z PROC ; CGameLogic::AnalyseTingCard
; _this$ = ecx

; 822  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 823  : 	//复制数据
; 824  : 	BYTE cbCardIndexTemp[MAX_INDEX];
; 825  : 	CopyMemory(cbCardIndexTemp, cbCardIndex, sizeof(cbCardIndexTemp));

  00013	6a 22		 push	 34			; 00000022H
  00015	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00018	50		 push	 eax
  00019	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _memcpy
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 826  : 
; 827  : 	BYTE cbCardCount = GetCardCount(cbCardIndexTemp);

  00025	8d 55 d8	 lea	 edx, DWORD PTR _cbCardIndexTemp$[ebp]
  00028	52		 push	 edx
  00029	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  00031	88 45 d4	 mov	 BYTE PTR _cbCardCount$[ebp], al

; 828  : 	CChiHuRight chr;

  00034	8d 4d c8	 lea	 ecx, DWORD PTR _chr$[ebp]
  00037	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 829  : 
; 830  : 	if((cbCardCount + 1) % 3 == 0)

  0003c	0f b6 45 d4	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	99		 cdq
  00044	b9 03 00 00 00	 mov	 ecx, 3
  00049	f7 f9		 idiv	 ecx
  0004b	85 d2		 test	 edx, edx
  0004d	0f 85 ad 00 00
	00		 jne	 $LN11@AnalyseTin

; 831  : 	{
; 832  : 		for(BYTE i = 0; i < MAX_INDEX - MAX_HUA_INDEX; i++)

  00053	c6 45 d7 00	 mov	 BYTE PTR _i$5[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@AnalyseTin
$LN2@AnalyseTin:
  00059	8a 55 d7	 mov	 dl, BYTE PTR _i$5[ebp]
  0005c	80 c2 01	 add	 dl, 1
  0005f	88 55 d7	 mov	 BYTE PTR _i$5[ebp], dl
$LN4@AnalyseTin:
  00062	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$5[ebp]
  00066	83 f8 22	 cmp	 eax, 34			; 00000022H
  00069	0f 8d 8f 00 00
	00		 jge	 $LN3@AnalyseTin

; 833  : 		{
; 834  : 			if(cbCardIndexTemp[i] == 0) continue;

  0006f	0f b6 4d d7	 movzx	 ecx, BYTE PTR _i$5[ebp]
  00073	0f b6 54 0d d8	 movzx	 edx, BYTE PTR _cbCardIndexTemp$[ebp+ecx]
  00078	85 d2		 test	 edx, edx
  0007a	75 02		 jne	 SHORT $LN13@AnalyseTin
  0007c	eb db		 jmp	 SHORT $LN2@AnalyseTin
$LN13@AnalyseTin:

; 835  : 			cbCardIndexTemp[i]--;

  0007e	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$5[ebp]
  00082	8a 4c 05 d8	 mov	 cl, BYTE PTR _cbCardIndexTemp$[ebp+eax]
  00086	80 e9 01	 sub	 cl, 1
  00089	0f b6 55 d7	 movzx	 edx, BYTE PTR _i$5[ebp]
  0008d	88 4c 15 d8	 mov	 BYTE PTR _cbCardIndexTemp$[ebp+edx], cl

; 836  : 
; 837  : 			for(BYTE j = 0; j < MAX_INDEX-MAX_HUA_INDEX; j++)

  00091	c6 45 d6 00	 mov	 BYTE PTR _j$4[ebp], 0
  00095	eb 08		 jmp	 SHORT $LN7@AnalyseTin
$LN5@AnalyseTin:
  00097	8a 45 d6	 mov	 al, BYTE PTR _j$4[ebp]
  0009a	04 01		 add	 al, 1
  0009c	88 45 d6	 mov	 BYTE PTR _j$4[ebp], al
$LN7@AnalyseTin:
  0009f	0f b6 4d d6	 movzx	 ecx, BYTE PTR _j$4[ebp]
  000a3	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000a6	7d 3e		 jge	 SHORT $LN6@AnalyseTin

; 838  : 			{
; 839  : 				BYTE cbCurrentCard = SwitchToCardData(j);

  000a8	0f b6 55 d6	 movzx	 edx, BYTE PTR _j$4[ebp]
  000ac	52		 push	 edx
  000ad	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  000b5	88 45 d3	 mov	 BYTE PTR _cbCurrentCard$2[ebp], al

; 840  : 				if(WIK_CHI_HU == AnalyseChiHuCard(cbCardIndexTemp, WeaveItem, cbWeaveCount, cbCurrentCard, chr))

  000b8	6a 00		 push	 0
  000ba	8d 45 c8	 lea	 eax, DWORD PTR _chr$[ebp]
  000bd	50		 push	 eax
  000be	0f b6 4d d3	 movzx	 ecx, BYTE PTR _cbCurrentCard$2[ebp]
  000c2	51		 push	 ecx
  000c3	0f b6 55 10	 movzx	 edx, BYTE PTR _cbWeaveCount$[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  000cb	50		 push	 eax
  000cc	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  000d8	0f b6 d0	 movzx	 edx, al
  000db	83 fa 40	 cmp	 edx, 64			; 00000040H
  000de	75 04		 jne	 SHORT $LN14@AnalyseTin

; 841  : 					return WIK_LISTEN;

  000e0	b0 20		 mov	 al, 32			; 00000020H
  000e2	eb 73		 jmp	 SHORT $LN1@AnalyseTin
$LN14@AnalyseTin:

; 842  : 			}

  000e4	eb b1		 jmp	 SHORT $LN5@AnalyseTin
$LN6@AnalyseTin:

; 843  : 
; 844  : 			cbCardIndexTemp[i]++;

  000e6	0f b6 45 d7	 movzx	 eax, BYTE PTR _i$5[ebp]
  000ea	8a 4c 05 d8	 mov	 cl, BYTE PTR _cbCardIndexTemp$[ebp+eax]
  000ee	80 c1 01	 add	 cl, 1
  000f1	0f b6 55 d7	 movzx	 edx, BYTE PTR _i$5[ebp]
  000f5	88 4c 15 d8	 mov	 BYTE PTR _cbCardIndexTemp$[ebp+edx], cl

; 845  : 		}

  000f9	e9 5b ff ff ff	 jmp	 $LN2@AnalyseTin
$LN3@AnalyseTin:

; 846  : 	}
; 847  : 	else

  000fe	eb 55		 jmp	 SHORT $LN12@AnalyseTin
$LN11@AnalyseTin:

; 848  : 	{
; 849  : 		for(BYTE j = 0; j < MAX_INDEX-MAX_HUA_INDEX; j++)

  00100	c6 45 d5 00	 mov	 BYTE PTR _j$3[ebp], 0
  00104	eb 08		 jmp	 SHORT $LN10@AnalyseTin
$LN8@AnalyseTin:
  00106	8a 45 d5	 mov	 al, BYTE PTR _j$3[ebp]
  00109	04 01		 add	 al, 1
  0010b	88 45 d5	 mov	 BYTE PTR _j$3[ebp], al
$LN10@AnalyseTin:
  0010e	0f b6 4d d5	 movzx	 ecx, BYTE PTR _j$3[ebp]
  00112	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00115	7d 3e		 jge	 SHORT $LN12@AnalyseTin

; 850  : 		{
; 851  : 			BYTE cbCurrentCard = SwitchToCardData(j);

  00117	0f b6 55 d5	 movzx	 edx, BYTE PTR _j$3[ebp]
  0011b	52		 push	 edx
  0011c	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00124	88 45 d2	 mov	 BYTE PTR _cbCurrentCard$1[ebp], al

; 852  : 			if(WIK_CHI_HU == AnalyseChiHuCard(cbCardIndexTemp,WeaveItem,cbWeaveCount,cbCurrentCard,chr))

  00127	6a 00		 push	 0
  00129	8d 45 c8	 lea	 eax, DWORD PTR _chr$[ebp]
  0012c	50		 push	 eax
  0012d	0f b6 4d d2	 movzx	 ecx, BYTE PTR _cbCurrentCard$1[ebp]
  00131	51		 push	 ecx
  00132	0f b6 55 10	 movzx	 edx, BYTE PTR _cbWeaveCount$[ebp]
  00136	52		 push	 edx
  00137	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  0013a	50		 push	 eax
  0013b	8d 4d d8	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  0013e	51		 push	 ecx
  0013f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00142	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  00147	0f b6 d0	 movzx	 edx, al
  0014a	83 fa 40	 cmp	 edx, 64			; 00000040H
  0014d	75 04		 jne	 SHORT $LN15@AnalyseTin

; 853  : 				return WIK_LISTEN;

  0014f	b0 20		 mov	 al, 32			; 00000020H
  00151	eb 04		 jmp	 SHORT $LN1@AnalyseTin
$LN15@AnalyseTin:

; 854  : 		}

  00153	eb b1		 jmp	 SHORT $LN8@AnalyseTin
$LN12@AnalyseTin:

; 855  : 	}
; 856  : 
; 857  : 	return WIK_NULL;

  00155	32 c0		 xor	 al, al
$LN1@AnalyseTin:

; 858  : }

  00157	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015a	33 cd		 xor	 ecx, ebp
  0015c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c2 0c 00	 ret	 12			; 0000000cH
?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@E@Z ENDP ; CGameLogic::AnalyseTingCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_AnalyseItemArray$ = -84				; size = 20
_this$ = -64						; size = 4
tv83 = -60						; size = 4
$T2 = -56						; size = 1
$T3 = -55						; size = 1
$T4 = -54						; size = 1
_cbChiHuKind$ = -53					; size = 1
_cbCardIndexTemp$ = -52					; size = 34
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
_cbCurrentCard$ = 20					; size = 1
_ChiHuRight$ = 24					; size = 4
_b4HZHu$ = 28						; size = 1
?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z PROC ; CGameLogic::AnalyseChiHuCard
; _this$ = ecx

; 766  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 767  : 	//变量定义
; 768  : 	BYTE cbChiHuKind=WIK_NULL;

  0002b	c6 45 cb 00	 mov	 BYTE PTR _cbChiHuKind$[ebp], 0

; 769  : 	CAnalyseItemArray AnalyseItemArray;

  0002f	8d 4d ac	 lea	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$CWHArray@UtagAnalyseItem@@AAU1@@@QAE@XZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::CWHArray<tagAnalyseItem,tagAnalyseItem &>
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 770  : 
; 771  : 	//设置变量
; 772  : 	AnalyseItemArray.RemoveAll();

  0003e	8d 4d ac	 lea	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  00041	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@UtagAnalyseItem@@AAU1@@@QAEXXZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::RemoveAll

; 773  : 	ChiHuRight.SetEmpty();

  00046	8b 4d 18	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  00049	e8 00 00 00 00	 call	 ?SetEmpty@CChiHuRight@@QAEXXZ ; CChiHuRight::SetEmpty

; 774  : 
; 775  : 	//构造扑克
; 776  : 	BYTE cbCardIndexTemp[MAX_INDEX];
; 777  : 	CopyMemory(cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp));

  0004e	6a 22		 push	 34			; 00000022H
  00050	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00053	50		 push	 eax
  00054	8d 4d cc	 lea	 ecx, DWORD PTR _cbCardIndexTemp$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 _memcpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 778  : 
; 779  : 	//cbCurrentCard一定不为0			!!!!!!!!!
; 780  : 	ASSERT(cbCurrentCard != 0);
; 781  : 	if(cbCurrentCard == 0) return WIK_NULL;

  00060	0f b6 55 14	 movzx	 edx, BYTE PTR _cbCurrentCard$[ebp]
  00064	85 d2		 test	 edx, edx
  00066	75 1b		 jne	 SHORT $LN2@AnalyseChi
  00068	c6 45 ca 00	 mov	 BYTE PTR $T4[ebp], 0
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00073	8d 4d ac	 lea	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  00076	e8 00 00 00 00	 call	 ??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>
  0007b	8a 45 ca	 mov	 al, BYTE PTR $T4[ebp]
  0007e	e9 b8 00 00 00	 jmp	 $LN1@AnalyseChi
$LN2@AnalyseChi:

; 782  : 
; 783  : 	//插入扑克
; 784  : 	if (cbCurrentCard!=0)

  00083	0f b6 45 14	 movzx	 eax, BYTE PTR _cbCurrentCard$[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 24		 je	 SHORT $LN3@AnalyseChi

; 785  : 		cbCardIndexTemp[SwitchToCardIndex(cbCurrentCard)]++;

  0008b	0f b6 4d 14	 movzx	 ecx, BYTE PTR _cbCurrentCard$[ebp]
  0008f	51		 push	 ecx
  00090	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00098	0f b6 d0	 movzx	 edx, al
  0009b	8d 44 15 cc	 lea	 eax, DWORD PTR _cbCardIndexTemp$[ebp+edx]
  0009f	89 45 c4	 mov	 DWORD PTR tv83[ebp], eax
  000a2	8b 4d c4	 mov	 ecx, DWORD PTR tv83[ebp]
  000a5	8a 11		 mov	 dl, BYTE PTR [ecx]
  000a7	80 c2 01	 add	 dl, 1
  000aa	8b 45 c4	 mov	 eax, DWORD PTR tv83[ebp]
  000ad	88 10		 mov	 BYTE PTR [eax], dl
$LN3@AnalyseChi:

; 786  : 
; 787  : 	if(b4HZHu && cbCardIndexTemp[31]==4)//四个红中直接胡牌

  000af	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _b4HZHu$[ebp]
  000b3	85 c9		 test	 ecx, ecx
  000b5	74 2a		 je	 SHORT $LN4@AnalyseChi
  000b7	ba 01 00 00 00	 mov	 edx, 1
  000bc	6b c2 1f	 imul	 eax, edx, 31
  000bf	0f b6 4c 05 cc	 movzx	 ecx, BYTE PTR _cbCardIndexTemp$[ebp+eax]
  000c4	83 f9 04	 cmp	 ecx, 4
  000c7	75 18		 jne	 SHORT $LN4@AnalyseChi

; 788  : 	{
; 789  : 		return WIK_CHI_HU;

  000c9	c6 45 c9 40	 mov	 BYTE PTR $T3[ebp], 64	; 00000040H
  000cd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d4	8d 4d ac	 lea	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  000d7	e8 00 00 00 00	 call	 ??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>
  000dc	8a 45 c9	 mov	 al, BYTE PTR $T3[ebp]
  000df	eb 5a		 jmp	 SHORT $LN1@AnalyseChi
$LN4@AnalyseChi:

; 790  : 	}
; 791  : 	//分析扑克
; 792  : 	AnalyseCard(cbCardIndexTemp,WeaveItem,cbWeaveCount,AnalyseItemArray);

  000e1	8d 55 ac	 lea	 edx, DWORD PTR _AnalyseItemArray$[ebp]
  000e4	52		 push	 edx
  000e5	0f b6 45 10	 movzx	 eax, BYTE PTR _cbWeaveCount$[ebp]
  000e9	50		 push	 eax
  000ea	8b 4d 0c	 mov	 ecx, DWORD PTR _WeaveItem$[ebp]
  000ed	51		 push	 ecx
  000ee	8d 55 cc	 lea	 edx, DWORD PTR _cbCardIndexTemp$[ebp]
  000f1	52		 push	 edx
  000f2	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	e8 00 00 00 00	 call	 ?AnalyseCard@CGameLogic@@AAE_NQBEQBUtagWeaveItem@@EAAV?$CWHArray@UtagAnalyseItem@@AAU1@@@@Z ; CGameLogic::AnalyseCard

; 793  : 
; 794  : 	//胡牌分析
; 795  : 	if (AnalyseItemArray.GetCount()>0)

  000fa	8d 4d ac	 lea	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  000fd	e8 00 00 00 00	 call	 ?GetCount@?$CWHArray@UtagAnalyseItem@@AAU1@@@QBEHXZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::GetCount
  00102	85 c0		 test	 eax, eax
  00104	7e 0a		 jle	 SHORT $LN5@AnalyseChi

; 796  : 	{
; 797  : 		//牌型分析
; 798  : // 		for (int i=0;i<AnalyseItemArray.GetCount();i++)
; 799  : // 		{
; 800  : // 			//变量定义
; 801  : // 			tagAnalyseItem * pAnalyseItem=&AnalyseItemArray[i];
; 802  : // 
; 803  : //  			//碰碰胡
; 804  : //  			if(IsPengPeng(pAnalyseItem)) 
; 805  : // 			{
; 806  : // 				ChiHuRight |= CHR_PENG_PENG;
; 807  : // 			}
; 808  : // 
; 809  : // 		}
; 810  : 
; 811  : 		ChiHuRight |= CHR_PING_HU;

  00106	6a 01		 push	 1
  00108	8b 4d 18	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  0010b	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=
$LN5@AnalyseChi:

; 812  : 	}
; 813  : 
; 814  : 	if(!ChiHuRight.IsEmpty())

  00110	8b 4d 18	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  00113	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  00118	0f b6 c0	 movzx	 eax, al
  0011b	85 c0		 test	 eax, eax
  0011d	75 04		 jne	 SHORT $LN6@AnalyseChi

; 815  : 		cbChiHuKind = WIK_CHI_HU;

  0011f	c6 45 cb 40	 mov	 BYTE PTR _cbChiHuKind$[ebp], 64 ; 00000040H
$LN6@AnalyseChi:

; 816  : 
; 817  : 	return cbChiHuKind;

  00123	8a 4d cb	 mov	 cl, BYTE PTR _cbChiHuKind$[ebp]
  00126	88 4d c8	 mov	 BYTE PTR $T2[ebp], cl
  00129	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00130	8d 4d ac	 lea	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  00133	e8 00 00 00 00	 call	 ??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>
  00138	8a 45 c8	 mov	 al, BYTE PTR $T2[ebp]
$LN1@AnalyseChi:

; 818  : }

  0013b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00145	59		 pop	 ecx
  00146	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	33 cd		 xor	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _AnalyseItemArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CWHArray@UtagAnalyseItem@@AAU1@@@UAE@XZ ; CWHArray<tagAnalyseItem,tagAnalyseItem &>::~CWHArray<tagAnalyseItem,tagAnalyseItem &>
__ehhandler$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ENDP ; CGameLogic::AnalyseChiHuCard
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbActionMask$ = -3					; size = 1
_i$1 = -2						; size = 1
_i$2 = -1						; size = 1
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
_cbProvideCard$ = 20					; size = 1
_GangCardResult$ = 24					; size = 4
?AnalyseGangCardEx@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAUtagGangCardResult@@@Z PROC ; CGameLogic::AnalyseGangCardEx
; _this$ = ecx

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 733  : 	//设置变量
; 734  : 	BYTE cbActionMask=WIK_NULL;

  0000a	c6 45 fd 00	 mov	 BYTE PTR _cbActionMask$[ebp], 0

; 735  : 	ZeroMemory(&GangCardResult,sizeof(GangCardResult));

  0000e	6a 05		 push	 5
  00010	6a 00		 push	 0
  00012	8b 45 18	 mov	 eax, DWORD PTR _GangCardResult$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 736  : 
; 737  : 	//手上杠牌
; 738  : 	for (BYTE i=0;i<MAX_INDEX;i++)

  0001e	c6 45 ff 00	 mov	 BYTE PTR _i$2[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@AnalyseGan
$LN2@AnalyseGan:
  00024	8a 4d ff	 mov	 cl, BYTE PTR _i$2[ebp]
  00027	80 c1 01	 add	 cl, 1
  0002a	88 4d ff	 mov	 BYTE PTR _i$2[ebp], cl
$LN4@AnalyseGan:
  0002d	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$2[ebp]
  00031	83 fa 22	 cmp	 edx, 34			; 00000022H
  00034	7d 54		 jge	 SHORT $LN3@AnalyseGan

; 739  : 	{
; 740  : 		if(i == m_cbMagicIndex) continue;

  00036	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$2[ebp]
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00041	3b c2		 cmp	 eax, edx
  00043	75 02		 jne	 SHORT $LN8@AnalyseGan
  00045	eb dd		 jmp	 SHORT $LN2@AnalyseGan
$LN8@AnalyseGan:

; 741  : 		if (cbCardIndex[i]==4)

  00047	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$2[ebp]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  0004e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00052	83 fa 04	 cmp	 edx, 4
  00055	75 31		 jne	 SHORT $LN9@AnalyseGan

; 742  : 		{
; 743  : 			cbActionMask|=WIK_GANG;

  00057	0f b6 45 fd	 movzx	 eax, BYTE PTR _cbActionMask$[ebp]
  0005b	83 c8 10	 or	 eax, 16			; 00000010H
  0005e	88 45 fd	 mov	 BYTE PTR _cbActionMask$[ebp], al

; 744  : 			GangCardResult.cbCardData[GangCardResult.cbCardCount++]=SwitchToCardData(i);

  00061	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$2[ebp]
  00065	51		 push	 ecx
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0006e	8b 55 18	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  00071	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]
  00074	8b 55 18	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  00077	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al
  0007b	8b 45 18	 mov	 eax, DWORD PTR _GangCardResult$[ebp]
  0007e	8a 08		 mov	 cl, BYTE PTR [eax]
  00080	80 c1 01	 add	 cl, 1
  00083	8b 55 18	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  00086	88 0a		 mov	 BYTE PTR [edx], cl
$LN9@AnalyseGan:

; 745  : 		}
; 746  : 	}

  00088	eb 9a		 jmp	 SHORT $LN2@AnalyseGan
$LN3@AnalyseGan:

; 747  : 
; 748  : 	//组合杠牌
; 749  : 	for (BYTE i=0;i<cbWeaveCount;i++)

  0008a	c6 45 fe 00	 mov	 BYTE PTR _i$1[ebp], 0
  0008e	eb 08		 jmp	 SHORT $LN7@AnalyseGan
$LN5@AnalyseGan:
  00090	8a 45 fe	 mov	 al, BYTE PTR _i$1[ebp]
  00093	04 01		 add	 al, 1
  00095	88 45 fe	 mov	 BYTE PTR _i$1[ebp], al
$LN7@AnalyseGan:
  00098	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0009c	0f b6 55 10	 movzx	 edx, BYTE PTR _cbWeaveCount$[ebp]
  000a0	3b ca		 cmp	 ecx, edx
  000a2	7d 5e		 jge	 SHORT $LN6@AnalyseGan

; 750  : 	{
; 751  : 		if (WeaveItem[i].cbWeaveKind==WIK_PENG)

  000a4	0f b6 45 fe	 movzx	 eax, BYTE PTR _i$1[ebp]
  000a8	6b c8 09	 imul	 ecx, eax, 9
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _WeaveItem$[ebp]
  000ae	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000b2	83 f8 08	 cmp	 eax, 8
  000b5	75 49		 jne	 SHORT $LN10@AnalyseGan

; 752  : 		{
; 753  : 			if (WeaveItem[i].cbCenterCard==cbProvideCard)//之后抓来的的牌才能和碰组成杠

  000b7	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$1[ebp]
  000bb	6b d1 09	 imul	 edx, ecx, 9
  000be	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  000c1	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [eax+edx+1]
  000c6	0f b6 55 14	 movzx	 edx, BYTE PTR _cbProvideCard$[ebp]
  000ca	3b ca		 cmp	 ecx, edx
  000cc	75 32		 jne	 SHORT $LN10@AnalyseGan

; 754  : 			{
; 755  : 				cbActionMask|=WIK_GANG;

  000ce	0f b6 45 fd	 movzx	 eax, BYTE PTR _cbActionMask$[ebp]
  000d2	83 c8 10	 or	 eax, 16			; 00000010H
  000d5	88 45 fd	 mov	 BYTE PTR _cbActionMask$[ebp], al

; 756  : 				GangCardResult.cbCardData[GangCardResult.cbCardCount++]=WeaveItem[i].cbCenterCard;

  000d8	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$1[ebp]
  000dc	6b d1 09	 imul	 edx, ecx, 9
  000df	8b 45 18	 mov	 eax, DWORD PTR _GangCardResult$[ebp]
  000e2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e5	8b 45 18	 mov	 eax, DWORD PTR _GangCardResult$[ebp]
  000e8	8b 75 0c	 mov	 esi, DWORD PTR _WeaveItem$[ebp]
  000eb	8a 54 16 01	 mov	 dl, BYTE PTR [esi+edx+1]
  000ef	88 54 08 01	 mov	 BYTE PTR [eax+ecx+1], dl
  000f3	8b 45 18	 mov	 eax, DWORD PTR _GangCardResult$[ebp]
  000f6	8a 08		 mov	 cl, BYTE PTR [eax]
  000f8	80 c1 01	 add	 cl, 1
  000fb	8b 55 18	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  000fe	88 0a		 mov	 BYTE PTR [edx], cl
$LN10@AnalyseGan:

; 757  : 			}
; 758  : 		}
; 759  : 	}

  00100	eb 8e		 jmp	 SHORT $LN5@AnalyseGan
$LN6@AnalyseGan:

; 760  : 
; 761  : 	return cbActionMask;

  00102	8a 45 fd	 mov	 al, BYTE PTR _cbActionMask$[ebp]

; 762  : }

  00105	5e		 pop	 esi
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 14 00	 ret	 20			; 00000014H
?AnalyseGangCardEx@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAUtagGangCardResult@@@Z ENDP ; CGameLogic::AnalyseGangCardEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbActionMask$ = -3					; size = 1
_i$1 = -2						; size = 1
_i$2 = -1						; size = 1
_cbCardIndex$ = 8					; size = 4
_WeaveItem$ = 12					; size = 4
_cbWeaveCount$ = 16					; size = 1
_GangCardResult$ = 20					; size = 4
?AnalyseGangCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAUtagGangCardResult@@@Z PROC ; CGameLogic::AnalyseGangCard
; _this$ = ecx

; 699  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 	//设置变量
; 701  : 	BYTE cbActionMask=WIK_NULL;

  0000a	c6 45 fd 00	 mov	 BYTE PTR _cbActionMask$[ebp], 0

; 702  : 	ZeroMemory(&GangCardResult,sizeof(GangCardResult));

  0000e	6a 05		 push	 5
  00010	6a 00		 push	 0
  00012	8b 45 14	 mov	 eax, DWORD PTR _GangCardResult$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 703  : 
; 704  : 	//手上杠牌
; 705  : 	for (BYTE i=0;i<MAX_INDEX;i++)

  0001e	c6 45 ff 00	 mov	 BYTE PTR _i$2[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@AnalyseGan
$LN2@AnalyseGan:
  00024	8a 4d ff	 mov	 cl, BYTE PTR _i$2[ebp]
  00027	80 c1 01	 add	 cl, 1
  0002a	88 4d ff	 mov	 BYTE PTR _i$2[ebp], cl
$LN4@AnalyseGan:
  0002d	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$2[ebp]
  00031	83 fa 22	 cmp	 edx, 34			; 00000022H
  00034	7d 54		 jge	 SHORT $LN3@AnalyseGan

; 706  : 	{
; 707  : 		if(i == m_cbMagicIndex) continue;

  00036	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$2[ebp]
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00041	3b c2		 cmp	 eax, edx
  00043	75 02		 jne	 SHORT $LN8@AnalyseGan
  00045	eb dd		 jmp	 SHORT $LN2@AnalyseGan
$LN8@AnalyseGan:

; 708  : 		if (cbCardIndex[i]==4)

  00047	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$2[ebp]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  0004e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00052	83 fa 04	 cmp	 edx, 4
  00055	75 31		 jne	 SHORT $LN9@AnalyseGan

; 709  : 		{
; 710  : 			cbActionMask|=WIK_GANG;

  00057	0f b6 45 fd	 movzx	 eax, BYTE PTR _cbActionMask$[ebp]
  0005b	83 c8 10	 or	 eax, 16			; 00000010H
  0005e	88 45 fd	 mov	 BYTE PTR _cbActionMask$[ebp], al

; 711  : 			GangCardResult.cbCardData[GangCardResult.cbCardCount++]=SwitchToCardData(i);

  00061	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$2[ebp]
  00065	51		 push	 ecx
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0006e	8b 55 14	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  00071	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]
  00074	8b 55 14	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  00077	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al
  0007b	8b 45 14	 mov	 eax, DWORD PTR _GangCardResult$[ebp]
  0007e	8a 08		 mov	 cl, BYTE PTR [eax]
  00080	80 c1 01	 add	 cl, 1
  00083	8b 55 14	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  00086	88 0a		 mov	 BYTE PTR [edx], cl
$LN9@AnalyseGan:

; 712  : 		}
; 713  : 	}

  00088	eb 9a		 jmp	 SHORT $LN2@AnalyseGan
$LN3@AnalyseGan:

; 714  : 
; 715  : 	//组合杠牌
; 716  : 	for (BYTE i=0;i<cbWeaveCount;i++)

  0008a	c6 45 fe 00	 mov	 BYTE PTR _i$1[ebp], 0
  0008e	eb 08		 jmp	 SHORT $LN7@AnalyseGan
$LN5@AnalyseGan:
  00090	8a 45 fe	 mov	 al, BYTE PTR _i$1[ebp]
  00093	04 01		 add	 al, 1
  00095	88 45 fe	 mov	 BYTE PTR _i$1[ebp], al
$LN7@AnalyseGan:
  00098	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0009c	0f b6 55 10	 movzx	 edx, BYTE PTR _cbWeaveCount$[ebp]
  000a0	3b ca		 cmp	 ecx, edx
  000a2	7d 70		 jge	 SHORT $LN6@AnalyseGan

; 717  : 	{
; 718  : 		if (WeaveItem[i].cbWeaveKind==WIK_PENG)

  000a4	0f b6 45 fe	 movzx	 eax, BYTE PTR _i$1[ebp]
  000a8	6b c8 09	 imul	 ecx, eax, 9
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _WeaveItem$[ebp]
  000ae	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000b2	83 f8 08	 cmp	 eax, 8
  000b5	75 58		 jne	 SHORT $LN10@AnalyseGan

; 719  : 		{
; 720  : 			if (cbCardIndex[SwitchToCardIndex(WeaveItem[i].cbCenterCard)]==1)

  000b7	0f b6 4d fe	 movzx	 ecx, BYTE PTR _i$1[ebp]
  000bb	6b d1 09	 imul	 edx, ecx, 9
  000be	8b 45 0c	 mov	 eax, DWORD PTR _WeaveItem$[ebp]
  000c1	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [eax+edx+1]
  000c6	51		 push	 ecx
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  000cf	0f b6 d0	 movzx	 edx, al
  000d2	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  000d5	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  000d9	83 f9 01	 cmp	 ecx, 1
  000dc	75 31		 jne	 SHORT $LN10@AnalyseGan

; 721  : 			{
; 722  : 				cbActionMask|=WIK_GANG;

  000de	0f b6 55 fd	 movzx	 edx, BYTE PTR _cbActionMask$[ebp]
  000e2	83 ca 10	 or	 edx, 16			; 00000010H
  000e5	88 55 fd	 mov	 BYTE PTR _cbActionMask$[ebp], dl

; 723  : 				GangCardResult.cbCardData[GangCardResult.cbCardCount++]=WeaveItem[i].cbCenterCard;

  000e8	0f b6 45 fe	 movzx	 eax, BYTE PTR _i$1[ebp]
  000ec	6b c8 09	 imul	 ecx, eax, 9
  000ef	8b 55 14	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  000f2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f5	8b 55 14	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  000f8	8b 75 0c	 mov	 esi, DWORD PTR _WeaveItem$[ebp]
  000fb	8a 4c 0e 01	 mov	 cl, BYTE PTR [esi+ecx+1]
  000ff	88 4c 02 01	 mov	 BYTE PTR [edx+eax+1], cl
  00103	8b 55 14	 mov	 edx, DWORD PTR _GangCardResult$[ebp]
  00106	8a 02		 mov	 al, BYTE PTR [edx]
  00108	04 01		 add	 al, 1
  0010a	8b 4d 14	 mov	 ecx, DWORD PTR _GangCardResult$[ebp]
  0010d	88 01		 mov	 BYTE PTR [ecx], al
$LN10@AnalyseGan:

; 724  : 			}
; 725  : 		}
; 726  : 	}

  0010f	e9 7c ff ff ff	 jmp	 $LN5@AnalyseGan
$LN6@AnalyseGan:

; 727  : 
; 728  : 	return cbActionMask;

  00114	8a 45 fd	 mov	 al, BYTE PTR _cbActionMask$[ebp]

; 729  : }

  00117	5e		 pop	 esi
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 10 00	 ret	 16			; 00000010H
?AnalyseGangCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAUtagGangCardResult@@@Z ENDP ; CGameLogic::AnalyseGangCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv83 = -8						; size = 4
_this$ = -4						; size = 4
_cbCardIndex$ = 8					; size = 4
_cbCurrentCard$ = 12					; size = 1
?EstimateGangCard@CGameLogic@@QAEEQBEE@Z PROC		; CGameLogic::EstimateGangCard
; _this$ = ecx

; 685  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 686  : 	//参数效验
; 687  : 	ASSERT(IsValidCard(cbCurrentCard));
; 688  : 
; 689  : 	//过滤判断
; 690  : 	if (IsMagicCard(cbCurrentCard) || IsHuaCard(cbCurrentCard)) 

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCurrentCard$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?IsMagicCard@CGameLogic@@QAE_NE@Z ; CGameLogic::IsMagicCard
  00016	0f b6 c8	 movzx	 ecx, al
  00019	85 c9		 test	 ecx, ecx
  0001b	75 14		 jne	 SHORT $LN3@EstimateGa
  0001d	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCurrentCard$[ebp]
  00021	52		 push	 edx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?IsHuaCard@CGameLogic@@QAE_NE@Z ; CGameLogic::IsHuaCard
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 04		 je	 SHORT $LN2@EstimateGa
$LN3@EstimateGa:

; 691  : 		return WIK_NULL;

  00031	32 c0		 xor	 al, al
  00033	eb 2f		 jmp	 SHORT $LN1@EstimateGa
$LN2@EstimateGa:

; 692  : 
; 693  : 	//杠牌判断
; 694  : 	return (cbCardIndex[SwitchToCardIndex(cbCurrentCard)]==3)?WIK_GANG:WIK_NULL;

  00035	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCurrentCard$[ebp]
  00039	51		 push	 ecx
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00042	0f b6 d0	 movzx	 edx, al
  00045	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00048	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0004c	83 f9 03	 cmp	 ecx, 3
  0004f	75 09		 jne	 SHORT $LN5@EstimateGa
  00051	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR tv83[ebp], 16	; 00000010H
  00058	eb 07		 jmp	 SHORT $LN6@EstimateGa
$LN5@EstimateGa:
  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN6@EstimateGa:
  00061	8a 45 f8	 mov	 al, BYTE PTR tv83[ebp]
$LN1@EstimateGa:

; 695  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?EstimateGangCard@CGameLogic@@QAEEQBEE@Z ENDP		; CGameLogic::EstimateGangCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv92 = -12						; size = 4
_this$ = -8						; size = 4
_cbCardCount$ = -1					; size = 1
_cbCardIndex$ = 8					; size = 4
_cbCurrentCard$ = 12					; size = 1
?EstimatePengCard@CGameLogic@@QAEEQBEE@Z PROC		; CGameLogic::EstimatePengCard
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 	//参数效验
; 668  : 	ASSERT(IsValidCard(cbCurrentCard));
; 669  : 
; 670  : 	//过滤判断
; 671  : 	if (IsMagicCard(cbCurrentCard) || IsHuaCard(cbCurrentCard)) 

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCurrentCard$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?IsMagicCard@CGameLogic@@QAE_NE@Z ; CGameLogic::IsMagicCard
  00016	0f b6 c8	 movzx	 ecx, al
  00019	85 c9		 test	 ecx, ecx
  0001b	75 14		 jne	 SHORT $LN3@EstimatePe
  0001d	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCurrentCard$[ebp]
  00021	52		 push	 edx
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?IsHuaCard@CGameLogic@@QAE_NE@Z ; CGameLogic::IsHuaCard
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 04		 je	 SHORT $LN2@EstimatePe
$LN3@EstimatePe:

; 672  : 		return WIK_NULL;

  00031	32 c0		 xor	 al, al
  00033	eb 5c		 jmp	 SHORT $LN1@EstimatePe
$LN2@EstimatePe:

; 673  : 
; 674  : 	//检查碰后有没有牌出
; 675  : 	BYTE cbCardCount=GetCardCount(cbCardIndex);

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00038	51		 push	 ecx
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  00041	88 45 ff	 mov	 BYTE PTR _cbCardCount$[ebp], al

; 676  : 	if( (cbCardCount-2) == cbCardIndex[31])

  00044	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbCardCount$[ebp]
  00048	83 ea 02	 sub	 edx, 2
  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	6b c8 1f	 imul	 ecx, eax, 31
  00053	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00056	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0005a	3b d1		 cmp	 edx, ecx
  0005c	75 04		 jne	 SHORT $LN4@EstimatePe

; 677  : 		return WIK_NULL;

  0005e	32 c0		 xor	 al, al
  00060	eb 2f		 jmp	 SHORT $LN1@EstimatePe
$LN4@EstimatePe:

; 678  : 
; 679  : 	//碰牌判断
; 680  : 	return (cbCardIndex[SwitchToCardIndex(cbCurrentCard)]>=2)?WIK_PENG:WIK_NULL;

  00062	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCurrentCard$[ebp]
  00066	52		 push	 edx
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  0006f	0f b6 c0	 movzx	 eax, al
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00075	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00079	83 fa 02	 cmp	 edx, 2
  0007c	7c 09		 jl	 SHORT $LN6@EstimatePe
  0007e	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR tv92[ebp], 8
  00085	eb 07		 jmp	 SHORT $LN7@EstimatePe
$LN6@EstimatePe:
  00087	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN7@EstimatePe:
  0008e	8a 45 f4	 mov	 al, BYTE PTR tv92[ebp]
$LN1@EstimatePe:

; 681  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
?EstimatePengCard@CGameLogic@@QAEEQBEE@Z ENDP		; CGameLogic::EstimatePengCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_cbItemKind$ = -60					; size = 3
_cbExcursion$ = -56					; size = 3
_this$ = -52						; size = 4
_cbValueIndex$1 = -46					; size = 1
_cbMagicCardCount$ = -45				; size = 1
_cbEatKind$ = -44					; size = 1
_i$2 = -43						; size = 1
_cbFirstIndex$ = -42					; size = 1
_cbCurrentIndex$ = -41					; size = 1
_cbMagicCardIndex$ = -40				; size = 34
__$ArrayPad$ = -4					; size = 4
_cbCardIndex$ = 8					; size = 4
_cbCurrentCard$ = 12					; size = 1
?EstimateEatCard@CGameLogic@@QAEEQBEE@Z PROC		; CGameLogic::EstimateEatCard
; _this$ = ecx

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 603  : 	//参数效验
; 604  : 	ASSERT(IsValidCard(cbCurrentCard));
; 605  : 
; 606  : 	BYTE cbCurrentIndex=SwitchToCardIndex(cbCurrentCard);

  00013	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCurrentCard$[ebp]
  00017	50		 push	 eax
  00018	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00020	88 45 d7	 mov	 BYTE PTR _cbCurrentIndex$[ebp], al

; 607  : 
; 608  : 	//过滤判断
; 609  : 	if (cbCurrentIndex == m_cbMagicIndex) return WIK_NULL;

  00023	0f b6 4d d7	 movzx	 ecx, BYTE PTR _cbCurrentIndex$[ebp]
  00027	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0002e	3b c8		 cmp	 ecx, eax
  00030	75 07		 jne	 SHORT $LN5@EstimateEa
  00032	32 c0		 xor	 al, al
  00034	e9 d9 01 00 00	 jmp	 $LN1@EstimateEa
$LN5@EstimateEa:

; 610  : 	if (cbCurrentIndex == INDEX_REPLACE_CARD && m_cbMagicIndex>=27) return WIK_NULL;

  00039	0f b6 4d d7	 movzx	 ecx, BYTE PTR _cbCurrentIndex$[ebp]
  0003d	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00040	75 13		 jne	 SHORT $LN6@EstimateEa
  00042	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00049	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  0004c	7c 07		 jl	 SHORT $LN6@EstimateEa
  0004e	32 c0		 xor	 al, al
  00050	e9 bd 01 00 00	 jmp	 $LN1@EstimateEa
$LN6@EstimateEa:

; 611  : 	if (cbCurrentCard >= 0x31 && cbCurrentIndex != INDEX_REPLACE_CARD) return WIK_NULL;

  00055	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCurrentCard$[ebp]
  00059	83 f9 31	 cmp	 ecx, 49			; 00000031H
  0005c	7c 10		 jl	 SHORT $LN7@EstimateEa
  0005e	0f b6 55 d7	 movzx	 edx, BYTE PTR _cbCurrentIndex$[ebp]
  00062	83 fa 22	 cmp	 edx, 34			; 00000022H
  00065	74 07		 je	 SHORT $LN7@EstimateEa
  00067	32 c0		 xor	 al, al
  00069	e9 a4 01 00 00	 jmp	 $LN1@EstimateEa
$LN7@EstimateEa:

; 612  : 
; 613  : 	//变量定义
; 614  : 	BYTE cbExcursion[3]={0,1,2};

  0006e	c6 45 c8 00	 mov	 BYTE PTR _cbExcursion$[ebp], 0
  00072	c6 45 c9 01	 mov	 BYTE PTR _cbExcursion$[ebp+1], 1
  00076	c6 45 ca 02	 mov	 BYTE PTR _cbExcursion$[ebp+2], 2

; 615  : 	BYTE cbItemKind[3]={WIK_LEFT,WIK_CENTER,WIK_RIGHT};

  0007a	c6 45 c4 01	 mov	 BYTE PTR _cbItemKind$[ebp], 1
  0007e	c6 45 c5 02	 mov	 BYTE PTR _cbItemKind$[ebp+1], 2
  00082	c6 45 c6 04	 mov	 BYTE PTR _cbItemKind$[ebp+2], 4

; 616  : 
; 617  : 	//拆分分析
; 618  : 	BYTE cbMagicCardIndex[MAX_INDEX];
; 619  : 	CopyMemory(cbMagicCardIndex,cbCardIndex,sizeof(cbMagicCardIndex));

  00086	6a 22		 push	 34			; 00000022H
  00088	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  0008b	50		 push	 eax
  0008c	8d 4d d8	 lea	 ecx, DWORD PTR _cbMagicCardIndex$[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 _memcpy
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 620  : 
; 621  : 	//如果有财神
; 622  : 	BYTE cbMagicCardCount = 0;

  00098	c6 45 d3 00	 mov	 BYTE PTR _cbMagicCardCount$[ebp], 0

; 623  : 	if(m_cbMagicIndex != MAX_INDEX)

  0009c	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0009f	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000a3	83 f8 22	 cmp	 eax, 34			; 00000022H
  000a6	74 3a		 je	 SHORT $LN8@EstimateEa

; 624  : 	{
; 625  : 		cbMagicCardCount = cbCardIndex[m_cbMagicIndex];

  000a8	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  000af	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  000b2	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  000b5	88 4d d3	 mov	 BYTE PTR _cbMagicCardCount$[ebp], cl

; 626  : 		//如果财神有代替牌，财神与代替牌转换
; 627  : 		if(INDEX_REPLACE_CARD != MAX_INDEX)

  000b8	33 d2		 xor	 edx, edx
  000ba	74 26		 je	 SHORT $LN8@EstimateEa

; 628  : 		{
; 629  : 			cbMagicCardIndex[m_cbMagicIndex] = cbMagicCardIndex[INDEX_REPLACE_CARD];

  000bc	b8 01 00 00 00	 mov	 eax, 1
  000c1	6b c8 22	 imul	 ecx, eax, 34
  000c4	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000cb	8a 4c 0d d8	 mov	 cl, BYTE PTR _cbMagicCardIndex$[ebp+ecx]
  000cf	88 4c 05 d8	 mov	 BYTE PTR _cbMagicCardIndex$[ebp+eax], cl

; 630  : 			cbMagicCardIndex[INDEX_REPLACE_CARD] = cbMagicCardCount;

  000d3	ba 01 00 00 00	 mov	 edx, 1
  000d8	6b c2 22	 imul	 eax, edx, 34
  000db	8a 4d d3	 mov	 cl, BYTE PTR _cbMagicCardCount$[ebp]
  000de	88 4c 05 d8	 mov	 BYTE PTR _cbMagicCardIndex$[ebp+eax], cl
$LN8@EstimateEa:

; 631  : 		}
; 632  : 	}
; 633  : 
; 634  : 	//吃牌判断
; 635  : 	BYTE cbEatKind=0,cbFirstIndex=0;

  000e2	c6 45 d4 00	 mov	 BYTE PTR _cbEatKind$[ebp], 0
  000e6	c6 45 d6 00	 mov	 BYTE PTR _cbFirstIndex$[ebp], 0

; 636  : 	if (cbCurrentIndex == INDEX_REPLACE_CARD) cbCurrentIndex = m_cbMagicIndex;

  000ea	0f b6 55 d7	 movzx	 edx, BYTE PTR _cbCurrentIndex$[ebp]
  000ee	83 fa 22	 cmp	 edx, 34			; 00000022H
  000f1	75 09		 jne	 SHORT $LN10@EstimateEa
  000f3	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000f9	88 4d d7	 mov	 BYTE PTR _cbCurrentIndex$[ebp], cl
$LN10@EstimateEa:

; 637  : 	for (BYTE i=0;i<CountArray(cbItemKind);i++)

  000fc	c6 45 d5 00	 mov	 BYTE PTR _i$2[ebp], 0
  00100	eb 09		 jmp	 SHORT $LN4@EstimateEa
$LN2@EstimateEa:
  00102	8a 55 d5	 mov	 dl, BYTE PTR _i$2[ebp]
  00105	80 c2 01	 add	 dl, 1
  00108	88 55 d5	 mov	 BYTE PTR _i$2[ebp], dl
$LN4@EstimateEa:
  0010b	0f b6 45 d5	 movzx	 eax, BYTE PTR _i$2[ebp]
  0010f	83 f8 03	 cmp	 eax, 3
  00112	0f 83 f7 00 00
	00		 jae	 $LN3@EstimateEa

; 638  : 	{
; 639  : 		BYTE cbValueIndex=cbCurrentIndex%9;

  00118	0f b6 45 d7	 movzx	 eax, BYTE PTR _cbCurrentIndex$[ebp]
  0011c	99		 cdq
  0011d	b9 09 00 00 00	 mov	 ecx, 9
  00122	f7 f9		 idiv	 ecx
  00124	88 55 d2	 mov	 BYTE PTR _cbValueIndex$1[ebp], dl

; 640  : 		if ((cbValueIndex>=cbExcursion[i])&&((cbValueIndex-cbExcursion[i])<=6))

  00127	0f b6 55 d2	 movzx	 edx, BYTE PTR _cbValueIndex$1[ebp]
  0012b	0f b6 45 d5	 movzx	 eax, BYTE PTR _i$2[ebp]
  0012f	0f b6 4c 05 c8	 movzx	 ecx, BYTE PTR _cbExcursion$[ebp+eax]
  00134	3b d1		 cmp	 edx, ecx
  00136	0f 8c ce 00 00
	00		 jl	 $LN11@EstimateEa
  0013c	0f b6 55 d2	 movzx	 edx, BYTE PTR _cbValueIndex$1[ebp]
  00140	0f b6 45 d5	 movzx	 eax, BYTE PTR _i$2[ebp]
  00144	0f b6 4c 05 c8	 movzx	 ecx, BYTE PTR _cbExcursion$[ebp+eax]
  00149	2b d1		 sub	 edx, ecx
  0014b	83 fa 06	 cmp	 edx, 6
  0014e	0f 8f b6 00 00
	00		 jg	 $LN11@EstimateEa

; 641  : 		{
; 642  : 			//吃牌判断
; 643  : 			cbFirstIndex=cbCurrentIndex-cbExcursion[i];

  00154	0f b6 55 d7	 movzx	 edx, BYTE PTR _cbCurrentIndex$[ebp]
  00158	0f b6 45 d5	 movzx	 eax, BYTE PTR _i$2[ebp]
  0015c	0f b6 4c 05 c8	 movzx	 ecx, BYTE PTR _cbExcursion$[ebp+eax]
  00161	2b d1		 sub	 edx, ecx
  00163	88 55 d6	 mov	 BYTE PTR _cbFirstIndex$[ebp], dl

; 644  : 
; 645  : 			//吃牌不能包含有财神
; 646  : 			if(m_cbMagicIndex != MAX_INDEX &&
; 647  : 				m_cbMagicIndex >= cbFirstIndex && m_cbMagicIndex <= cbFirstIndex+2) continue;

  00166	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00169	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0016d	83 f8 22	 cmp	 eax, 34			; 00000022H
  00170	74 26		 je	 SHORT $LN12@EstimateEa
  00172	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00175	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00179	0f b6 45 d6	 movzx	 eax, BYTE PTR _cbFirstIndex$[ebp]
  0017d	3b d0		 cmp	 edx, eax
  0017f	7c 17		 jl	 SHORT $LN12@EstimateEa
  00181	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00188	0f b6 45 d6	 movzx	 eax, BYTE PTR _cbFirstIndex$[ebp]
  0018c	83 c0 02	 add	 eax, 2
  0018f	3b d0		 cmp	 edx, eax
  00191	7f 05		 jg	 SHORT $LN12@EstimateEa
  00193	e9 6a ff ff ff	 jmp	 $LN2@EstimateEa
$LN12@EstimateEa:

; 648  : 
; 649  : 			if ((cbCurrentIndex!=cbFirstIndex)&&(cbMagicCardIndex[cbFirstIndex]==0))

  00198	0f b6 4d d7	 movzx	 ecx, BYTE PTR _cbCurrentIndex$[ebp]
  0019c	0f b6 55 d6	 movzx	 edx, BYTE PTR _cbFirstIndex$[ebp]
  001a0	3b ca		 cmp	 ecx, edx
  001a2	74 12		 je	 SHORT $LN13@EstimateEa
  001a4	0f b6 45 d6	 movzx	 eax, BYTE PTR _cbFirstIndex$[ebp]
  001a8	0f b6 4c 05 d8	 movzx	 ecx, BYTE PTR _cbMagicCardIndex$[ebp+eax]
  001ad	85 c9		 test	 ecx, ecx
  001af	75 05		 jne	 SHORT $LN13@EstimateEa

; 650  : 				continue;

  001b1	e9 4c ff ff ff	 jmp	 $LN2@EstimateEa
$LN13@EstimateEa:

; 651  : 			if ((cbCurrentIndex!=(cbFirstIndex+1))&&(cbMagicCardIndex[cbFirstIndex+1]==0))

  001b6	0f b6 55 d7	 movzx	 edx, BYTE PTR _cbCurrentIndex$[ebp]
  001ba	0f b6 45 d6	 movzx	 eax, BYTE PTR _cbFirstIndex$[ebp]
  001be	83 c0 01	 add	 eax, 1
  001c1	3b d0		 cmp	 edx, eax
  001c3	74 12		 je	 SHORT $LN14@EstimateEa
  001c5	0f b6 4d d6	 movzx	 ecx, BYTE PTR _cbFirstIndex$[ebp]
  001c9	0f b6 54 0d d9	 movzx	 edx, BYTE PTR _cbMagicCardIndex$[ebp+ecx+1]
  001ce	85 d2		 test	 edx, edx
  001d0	75 05		 jne	 SHORT $LN14@EstimateEa

; 652  : 				continue;

  001d2	e9 2b ff ff ff	 jmp	 $LN2@EstimateEa
$LN14@EstimateEa:

; 653  : 			if ((cbCurrentIndex!=(cbFirstIndex+2))&&(cbMagicCardIndex[cbFirstIndex+2]==0))

  001d7	0f b6 45 d7	 movzx	 eax, BYTE PTR _cbCurrentIndex$[ebp]
  001db	0f b6 4d d6	 movzx	 ecx, BYTE PTR _cbFirstIndex$[ebp]
  001df	83 c1 02	 add	 ecx, 2
  001e2	3b c1		 cmp	 eax, ecx
  001e4	74 12		 je	 SHORT $LN15@EstimateEa
  001e6	0f b6 55 d6	 movzx	 edx, BYTE PTR _cbFirstIndex$[ebp]
  001ea	0f b6 44 15 da	 movzx	 eax, BYTE PTR _cbMagicCardIndex$[ebp+edx+2]
  001ef	85 c0		 test	 eax, eax
  001f1	75 05		 jne	 SHORT $LN15@EstimateEa

; 654  : 				continue;

  001f3	e9 0a ff ff ff	 jmp	 $LN2@EstimateEa
$LN15@EstimateEa:

; 655  : 
; 656  : 			//设置类型
; 657  : 			cbEatKind|=cbItemKind[i];

  001f8	0f b6 4d d5	 movzx	 ecx, BYTE PTR _i$2[ebp]
  001fc	0f b6 54 0d c4	 movzx	 edx, BYTE PTR _cbItemKind$[ebp+ecx]
  00201	0f b6 45 d4	 movzx	 eax, BYTE PTR _cbEatKind$[ebp]
  00205	0b c2		 or	 eax, edx
  00207	88 45 d4	 mov	 BYTE PTR _cbEatKind$[ebp], al
$LN11@EstimateEa:

; 658  : 		}
; 659  : 	}

  0020a	e9 f3 fe ff ff	 jmp	 $LN2@EstimateEa
$LN3@EstimateEa:

; 660  : 
; 661  : 	return cbEatKind;

  0020f	8a 45 d4	 mov	 al, BYTE PTR _cbEatKind$[ebp]
$LN1@EstimateEa:

; 662  : }

  00212	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00215	33 cd		 xor	 ecx, ebp
  00217	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021c	8b e5		 mov	 esp, ebp
  0021e	5d		 pop	 ebp
  0021f	c2 08 00	 ret	 8
?EstimateEatCard@CGameLogic@@QAEEQBEE@Z ENDP		; CGameLogic::EstimateEatCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_k$1 = -32						; size = 4
_k$2 = -28						; size = 4
_this$ = -24						; size = 4
_i$3 = -20						; size = 4
_i$4 = -16						; size = 4
_j$5 = -12						; size = 4
_bEnjoinCard$6 = -6					; size = 1
_bEnjoinCard$7 = -5					; size = 1
_cbOutCardIndexCount$ = -4				; size = 1
_cbCardDataTemp$8 = -3					; size = 1
_cbCardData$ = -2					; size = 1
_cbOutCardIndex$ = -1					; size = 1
_cbCardIndex$ = 8					; size = 4
_cbEnjoinOutCard$ = 12					; size = 4
_cbEnjoinOutCardCount$ = 16				; size = 1
?AutomatismOutCard@CGameLogic@@QAEEQBE0E@Z PROC		; CGameLogic::AutomatismOutCard
; _this$ = ecx

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 518  : 	// 先打财神
; 519  : 	if(m_cbMagicIndex != MAX_INDEX)

  00009	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00010	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00013	74 27		 je	 SHORT $LN17@Automatism

; 520  : 	{
; 521  : 		if(cbCardIndex[m_cbMagicIndex] > 0)

  00015	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00018	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  0001f	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00023	85 d2		 test	 edx, edx
  00025	7e 15		 jle	 SHORT $LN17@Automatism

; 522  : 		{
; 523  : 			return SwitchToCardData(m_cbMagicIndex);

  00027	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002e	51		 push	 ecx
  0002f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00037	e9 a5 01 00 00	 jmp	 $LN1@Automatism
$LN17@Automatism:

; 524  : 		}
; 525  : 	}
; 526  : 
; 527  : 	//而后打字牌，字牌打自己多的，数目一样就按东南西北中发白的顺序
; 528  : 	BYTE cbCardData = 0;

  0003c	c6 45 fe 00	 mov	 BYTE PTR _cbCardData$[ebp], 0

; 529  : 	BYTE cbOutCardIndex  = MAX_INDEX;

  00040	c6 45 ff 22	 mov	 BYTE PTR _cbOutCardIndex$[ebp], 34 ; 00000022H

; 530  : 	BYTE cbOutCardIndexCount = 0;

  00044	c6 45 fc 00	 mov	 BYTE PTR _cbOutCardIndexCount$[ebp], 0

; 531  : 	for(int i = MAX_INDEX - 7; i < MAX_INDEX - 1; i++)

  00048	c7 45 ec 1b 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 27	; 0000001bH
  0004f	eb 09		 jmp	 SHORT $LN4@Automatism
$LN2@Automatism:
  00051	8b 55 ec	 mov	 edx, DWORD PTR _i$3[ebp]
  00054	83 c2 01	 add	 edx, 1
  00057	89 55 ec	 mov	 DWORD PTR _i$3[ebp], edx
$LN4@Automatism:
  0005a	83 7d ec 21	 cmp	 DWORD PTR _i$3[ebp], 33	; 00000021H
  0005e	7d 24		 jge	 SHORT $LN3@Automatism

; 532  : 	{
; 533  : 		if(cbCardIndex[i] > cbOutCardIndexCount)

  00060	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00063	03 45 ec	 add	 eax, DWORD PTR _i$3[ebp]
  00066	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00069	0f b6 55 fc	 movzx	 edx, BYTE PTR _cbOutCardIndexCount$[ebp]
  0006d	3b ca		 cmp	 ecx, edx
  0006f	7e 11		 jle	 SHORT $LN19@Automatism

; 534  : 		{
; 535  : 			cbOutCardIndexCount = cbCardIndex[i];

  00071	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00074	03 45 ec	 add	 eax, DWORD PTR _i$3[ebp]
  00077	8a 08		 mov	 cl, BYTE PTR [eax]
  00079	88 4d fc	 mov	 BYTE PTR _cbOutCardIndexCount$[ebp], cl

; 536  : 			cbOutCardIndex = i;

  0007c	8a 55 ec	 mov	 dl, BYTE PTR _i$3[ebp]
  0007f	88 55 ff	 mov	 BYTE PTR _cbOutCardIndex$[ebp], dl
$LN19@Automatism:

; 537  : 		}
; 538  : 	}

  00082	eb cd		 jmp	 SHORT $LN2@Automatism
$LN3@Automatism:

; 539  : 
; 540  : 	if(cbOutCardIndex != MAX_INDEX)

  00084	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbOutCardIndex$[ebp]
  00088	83 f8 22	 cmp	 eax, 34			; 00000022H
  0008b	74 56		 je	 SHORT $LN20@Automatism

; 541  : 	{
; 542  : 		cbCardData = SwitchToCardData(cbOutCardIndex);

  0008d	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbOutCardIndex$[ebp]
  00091	51		 push	 ecx
  00092	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0009a	88 45 fe	 mov	 BYTE PTR _cbCardData$[ebp], al

; 543  : 		bool bEnjoinCard = false;

  0009d	c6 45 fb 00	 mov	 BYTE PTR _bEnjoinCard$7[ebp], 0

; 544  : 		for(int k = 0; k < cbEnjoinOutCardCount; k++)

  000a1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _k$2[ebp], 0
  000a8	eb 09		 jmp	 SHORT $LN7@Automatism
$LN5@Automatism:
  000aa	8b 55 e4	 mov	 edx, DWORD PTR _k$2[ebp]
  000ad	83 c2 01	 add	 edx, 1
  000b0	89 55 e4	 mov	 DWORD PTR _k$2[ebp], edx
$LN7@Automatism:
  000b3	0f b6 45 10	 movzx	 eax, BYTE PTR _cbEnjoinOutCardCount$[ebp]
  000b7	39 45 e4	 cmp	 DWORD PTR _k$2[ebp], eax
  000ba	7d 17		 jge	 SHORT $LN6@Automatism

; 545  : 		{
; 546  : 			if(cbCardData == cbEnjoinOutCard[k])

  000bc	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbCardData$[ebp]
  000c0	8b 55 0c	 mov	 edx, DWORD PTR _cbEnjoinOutCard$[ebp]
  000c3	03 55 e4	 add	 edx, DWORD PTR _k$2[ebp]
  000c6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000c9	3b c8		 cmp	 ecx, eax
  000cb	75 04		 jne	 SHORT $LN21@Automatism

; 547  : 			{
; 548  : 				bEnjoinCard = true;

  000cd	c6 45 fb 01	 mov	 BYTE PTR _bEnjoinCard$7[ebp], 1
$LN21@Automatism:

; 549  : 			}
; 550  : 		}

  000d1	eb d7		 jmp	 SHORT $LN5@Automatism
$LN6@Automatism:

; 551  : 		if(!bEnjoinCard)

  000d3	0f b6 4d fb	 movzx	 ecx, BYTE PTR _bEnjoinCard$7[ebp]
  000d7	85 c9		 test	 ecx, ecx
  000d9	75 08		 jne	 SHORT $LN20@Automatism

; 552  : 		{
; 553  : 			return cbCardData;

  000db	8a 45 fe	 mov	 al, BYTE PTR _cbCardData$[ebp]
  000de	e9 fe 00 00 00	 jmp	 $LN1@Automatism
$LN20@Automatism:

; 554  : 		}		
; 555  : 	}
; 556  : 
; 557  : 	//没有字牌就打边张，1或9，顺序为万筒索，2，8，而后3，7，而后4，6，而后5
; 558  : 	for(int i = 0; i < 5; i++)

  000e3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  000ea	eb 09		 jmp	 SHORT $LN10@Automatism
$LN8@Automatism:
  000ec	8b 55 f0	 mov	 edx, DWORD PTR _i$4[ebp]
  000ef	83 c2 01	 add	 edx, 1
  000f2	89 55 f0	 mov	 DWORD PTR _i$4[ebp], edx
$LN10@Automatism:
  000f5	83 7d f0 05	 cmp	 DWORD PTR _i$4[ebp], 5
  000f9	0f 8d df 00 00
	00		 jge	 $LN9@Automatism

; 559  : 	{
; 560  : 		for(int j = 0; j < 3; j++)

  000ff	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$5[ebp], 0
  00106	eb 09		 jmp	 SHORT $LN13@Automatism
$LN11@Automatism:
  00108	8b 45 f4	 mov	 eax, DWORD PTR _j$5[ebp]
  0010b	83 c0 01	 add	 eax, 1
  0010e	89 45 f4	 mov	 DWORD PTR _j$5[ebp], eax
$LN13@Automatism:
  00111	83 7d f4 03	 cmp	 DWORD PTR _j$5[ebp], 3
  00115	0f 8d be 00 00
	00		 jge	 $LN12@Automatism

; 561  : 		{
; 562  : 			cbOutCardIndex  = MAX_INDEX;

  0011b	c6 45 ff 22	 mov	 BYTE PTR _cbOutCardIndex$[ebp], 34 ; 00000022H

; 563  : 			if(cbCardIndex[j * 9 + i] > 0)

  0011f	6b 4d f4 09	 imul	 ecx, DWORD PTR _j$5[ebp], 9
  00123	03 4d f0	 add	 ecx, DWORD PTR _i$4[ebp]
  00126	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  00129	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0012d	85 c0		 test	 eax, eax
  0012f	7e 0c		 jle	 SHORT $LN23@Automatism

; 564  : 			{
; 565  : 				cbOutCardIndex = j * 9 + i;

  00131	6b 4d f4 09	 imul	 ecx, DWORD PTR _j$5[ebp], 9
  00135	03 4d f0	 add	 ecx, DWORD PTR _i$4[ebp]
  00138	88 4d ff	 mov	 BYTE PTR _cbOutCardIndex$[ebp], cl
  0013b	eb 2b		 jmp	 SHORT $LN24@Automatism
$LN23@Automatism:

; 566  : 			}
; 567  : 			else if(cbCardIndex[j * 9 + (9 - i - 1)] > 0)

  0013d	6b 55 f4 09	 imul	 edx, DWORD PTR _j$5[ebp], 9
  00141	b8 09 00 00 00	 mov	 eax, 9
  00146	2b 45 f0	 sub	 eax, DWORD PTR _i$4[ebp]
  00149	03 45 08	 add	 eax, DWORD PTR _cbCardIndex$[ebp]
  0014c	0f b6 4c 10 ff	 movzx	 ecx, BYTE PTR [eax+edx-1]
  00151	85 c9		 test	 ecx, ecx
  00153	7e 13		 jle	 SHORT $LN24@Automatism

; 568  : 			{
; 569  : 				cbOutCardIndex = j * 9 + (9 - i - 1);

  00155	6b 55 f4 09	 imul	 edx, DWORD PTR _j$5[ebp], 9
  00159	b8 09 00 00 00	 mov	 eax, 9
  0015e	2b 45 f0	 sub	 eax, DWORD PTR _i$4[ebp]
  00161	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  00165	88 4d ff	 mov	 BYTE PTR _cbOutCardIndex$[ebp], cl
$LN24@Automatism:

; 570  : 			}
; 571  : 
; 572  : 			if(cbOutCardIndex != MAX_INDEX)

  00168	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbOutCardIndex$[ebp]
  0016c	83 fa 22	 cmp	 edx, 34			; 00000022H
  0016f	74 63		 je	 SHORT $LN26@Automatism

; 573  : 			{
; 574  : 				BYTE cbCardDataTemp = SwitchToCardData(cbOutCardIndex);

  00171	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbOutCardIndex$[ebp]
  00175	50		 push	 eax
  00176	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0017e	88 45 fd	 mov	 BYTE PTR _cbCardDataTemp$8[ebp], al

; 575  : 				bool bEnjoinCard = false;

  00181	c6 45 fa 00	 mov	 BYTE PTR _bEnjoinCard$6[ebp], 0

; 576  : 				for(int k = 0; k < cbEnjoinOutCardCount; k++)

  00185	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _k$1[ebp], 0
  0018c	eb 09		 jmp	 SHORT $LN16@Automatism
$LN14@Automatism:
  0018e	8b 4d e0	 mov	 ecx, DWORD PTR _k$1[ebp]
  00191	83 c1 01	 add	 ecx, 1
  00194	89 4d e0	 mov	 DWORD PTR _k$1[ebp], ecx
$LN16@Automatism:
  00197	0f b6 55 10	 movzx	 edx, BYTE PTR _cbEnjoinOutCardCount$[ebp]
  0019b	39 55 e0	 cmp	 DWORD PTR _k$1[ebp], edx
  0019e	7d 17		 jge	 SHORT $LN15@Automatism

; 577  : 				{
; 578  : 					if(cbCardDataTemp == cbEnjoinOutCard[k])

  001a0	0f b6 45 fd	 movzx	 eax, BYTE PTR _cbCardDataTemp$8[ebp]
  001a4	8b 4d 0c	 mov	 ecx, DWORD PTR _cbEnjoinOutCard$[ebp]
  001a7	03 4d e0	 add	 ecx, DWORD PTR _k$1[ebp]
  001aa	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001ad	3b c2		 cmp	 eax, edx
  001af	75 04		 jne	 SHORT $LN27@Automatism

; 579  : 					{
; 580  : 						bEnjoinCard = true;

  001b1	c6 45 fa 01	 mov	 BYTE PTR _bEnjoinCard$6[ebp], 1
$LN27@Automatism:

; 581  : 					}
; 582  : 				}

  001b5	eb d7		 jmp	 SHORT $LN14@Automatism
$LN15@Automatism:

; 583  : 				if(!bEnjoinCard)

  001b7	0f b6 45 fa	 movzx	 eax, BYTE PTR _bEnjoinCard$6[ebp]
  001bb	85 c0		 test	 eax, eax
  001bd	75 07		 jne	 SHORT $LN28@Automatism

; 584  : 				{
; 585  : 					return cbCardDataTemp;

  001bf	8a 45 fd	 mov	 al, BYTE PTR _cbCardDataTemp$8[ebp]
  001c2	eb 1d		 jmp	 SHORT $LN1@Automatism

; 586  : 				}
; 587  : 				else

  001c4	eb 0e		 jmp	 SHORT $LN26@Automatism
$LN28@Automatism:

; 588  : 				{
; 589  : 					if(cbCardData == 0)

  001c6	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbCardData$[ebp]
  001ca	85 c9		 test	 ecx, ecx
  001cc	75 06		 jne	 SHORT $LN26@Automatism

; 590  : 					{
; 591  : 						cbCardData = cbCardDataTemp;

  001ce	8a 55 fd	 mov	 dl, BYTE PTR _cbCardDataTemp$8[ebp]
  001d1	88 55 fe	 mov	 BYTE PTR _cbCardData$[ebp], dl
$LN26@Automatism:

; 592  : 					}
; 593  : 				}
; 594  : 			}
; 595  : 		}

  001d4	e9 2f ff ff ff	 jmp	 $LN11@Automatism
$LN12@Automatism:

; 596  : 	}

  001d9	e9 0e ff ff ff	 jmp	 $LN8@Automatism
$LN9@Automatism:

; 597  : 	return cbCardData;

  001de	8a 45 fe	 mov	 al, BYTE PTR _cbCardData$[ebp]
$LN1@Automatism:

; 598  : }

  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c2 0c 00	 ret	 12			; 0000000cH
?AutomatismOutCard@CGameLogic@@QAEEQBE0E@Z ENDP		; CGameLogic::AutomatismOutCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
$T8 = -28						; size = 4
$T9 = -24						; size = 4
$T10 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
_this$ = -8						; size = 4
_wFanShu$ = -4						; size = 2
_ChiHuRight$ = 8					; size = 4
?GetChiHuTime@CGameLogic@@QAEGABVCChiHuRight@@@Z PROC	; CGameLogic::GetChiHuTime
; _this$ = ecx

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 480  : 	WORD wFanShu = 1;//平胡一倍

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax

; 481  : 
; 482  : 	if(!(ChiHuRight&CHR_TIAN_HU).IsEmpty())

  00012	68 00 01 00 00	 push	 256			; 00000100H
  00017	8d 4d f4	 lea	 ecx, DWORD PTR $T12[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  0001e	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  0002a	0f b6 d0	 movzx	 edx, al
  0002d	85 d2		 test	 edx, edx
  0002f	75 0e		 jne	 SHORT $LN2@GetChiHuTi

; 483  : 		wFanShu=16;

  00031	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00036	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  0003a	e9 48 01 00 00	 jmp	 $LN3@GetChiHuTi
$LN2@GetChiHuTi:

; 484  : 	else if(!(ChiHuRight&CHR_QI_SHOU_LISTEN).IsEmpty())//起首听

  0003f	68 00 04 00 00	 push	 1024			; 00000400H
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T11[ebp]
  00047	51		 push	 ecx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  0004b	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  00050	8b c8		 mov	 ecx, eax
  00052	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  00057	0f b6 d0	 movzx	 edx, al
  0005a	85 d2		 test	 edx, edx
  0005c	75 0e		 jne	 SHORT $LN4@GetChiHuTi

; 485  : 		wFanShu=8;

  0005e	b8 08 00 00 00	 mov	 eax, 8
  00063	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  00067	e9 1b 01 00 00	 jmp	 $LN3@GetChiHuTi
$LN4@GetChiHuTi:

; 486  : 	else if(!(ChiHuRight&CHR_PENG_PENG).IsEmpty())//碰碰胡

  0006c	6a 02		 push	 2
  0006e	8d 4d ec	 lea	 ecx, DWORD PTR $T10[ebp]
  00071	51		 push	 ecx
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  00075	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  0007a	8b c8		 mov	 ecx, eax
  0007c	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  00081	0f b6 d0	 movzx	 edx, al
  00084	85 d2		 test	 edx, edx
  00086	75 0e		 jne	 SHORT $LN6@GetChiHuTi

; 487  : 		wFanShu=3;

  00088	b8 03 00 00 00	 mov	 eax, 3
  0008d	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  00091	e9 f1 00 00 00	 jmp	 $LN3@GetChiHuTi
$LN6@GetChiHuTi:

; 488  : 	else if(!(ChiHuRight&CHR_DAN_DIAN_QI_DUI).IsEmpty())//单点大七对

  00096	6a 04		 push	 4
  00098	8d 4d e8	 lea	 ecx, DWORD PTR $T9[ebp]
  0009b	51		 push	 ecx
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  0009f	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  000a4	8b c8		 mov	 ecx, eax
  000a6	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  000ab	0f b6 d0	 movzx	 edx, al
  000ae	85 d2		 test	 edx, edx
  000b0	75 0e		 jne	 SHORT $LN8@GetChiHuTi

; 489  : 		wFanShu=6;

  000b2	b8 06 00 00 00	 mov	 eax, 6
  000b7	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  000bb	e9 c7 00 00 00	 jmp	 $LN3@GetChiHuTi
$LN8@GetChiHuTi:

; 490  : 	else if(!(ChiHuRight&CHR_MA_QI_DUI).IsEmpty())//麻七对

  000c0	6a 08		 push	 8
  000c2	8d 4d e4	 lea	 ecx, DWORD PTR $T8[ebp]
  000c5	51		 push	 ecx
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  000c9	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  000ce	8b c8		 mov	 ecx, eax
  000d0	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  000d5	0f b6 d0	 movzx	 edx, al
  000d8	85 d2		 test	 edx, edx
  000da	75 0e		 jne	 SHORT $LN10@GetChiHuTi

; 491  : 		wFanShu=5;

  000dc	b8 05 00 00 00	 mov	 eax, 5
  000e1	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  000e5	e9 9d 00 00 00	 jmp	 $LN3@GetChiHuTi
$LN10@GetChiHuTi:

; 492  : 	else if(!(ChiHuRight&CHR_MA_QI_WANG).IsEmpty())//麻七王

  000ea	6a 10		 push	 16			; 00000010H
  000ec	8d 4d e0	 lea	 ecx, DWORD PTR $T7[ebp]
  000ef	51		 push	 ecx
  000f0	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  000f3	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  000f8	8b c8		 mov	 ecx, eax
  000fa	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  000ff	0f b6 d0	 movzx	 edx, al
  00102	85 d2		 test	 edx, edx
  00104	75 0b		 jne	 SHORT $LN12@GetChiHuTi

; 493  : 		wFanShu=10;

  00106	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0010b	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  0010f	eb 76		 jmp	 SHORT $LN3@GetChiHuTi
$LN12@GetChiHuTi:

; 494  : 	else if(!(ChiHuRight&CHR_MA_QI_WZW).IsEmpty())//麻七王中王

  00111	6a 20		 push	 32			; 00000020H
  00113	8d 4d dc	 lea	 ecx, DWORD PTR $T6[ebp]
  00116	51		 push	 ecx
  00117	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  0011a	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  0011f	8b c8		 mov	 ecx, eax
  00121	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  00126	0f b6 d0	 movzx	 edx, al
  00129	85 d2		 test	 edx, edx
  0012b	75 0b		 jne	 SHORT $LN14@GetChiHuTi

; 495  : 		wFanShu=20;

  0012d	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00132	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  00136	eb 4f		 jmp	 SHORT $LN3@GetChiHuTi
$LN14@GetChiHuTi:

; 496  : 	else if(!(ChiHuRight&CHR_SHI_SAN_LAN).IsEmpty())//十三烂

  00138	6a 40		 push	 64			; 00000040H
  0013a	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  0013d	51		 push	 ecx
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  00141	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  00146	8b c8		 mov	 ecx, eax
  00148	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  0014d	0f b6 d0	 movzx	 edx, al
  00150	85 d2		 test	 edx, edx
  00152	75 0b		 jne	 SHORT $LN16@GetChiHuTi

; 497  : 		wFanShu=2;

  00154	b8 02 00 00 00	 mov	 eax, 2
  00159	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  0015d	eb 28		 jmp	 SHORT $LN3@GetChiHuTi
$LN16@GetChiHuTi:

; 498  : 	else if(!(ChiHuRight&CHR_QX_SHI_SAN_LAN).IsEmpty())//七星十三烂

  0015f	68 80 00 00 00	 push	 128			; 00000080H
  00164	8d 4d d4	 lea	 ecx, DWORD PTR $T4[ebp]
  00167	51		 push	 ecx
  00168	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  0016b	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  00170	8b c8		 mov	 ecx, eax
  00172	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  00177	0f b6 d0	 movzx	 edx, al
  0017a	85 d2		 test	 edx, edx
  0017c	75 09		 jne	 SHORT $LN3@GetChiHuTi

; 499  : 		wFanShu=4;

  0017e	b8 04 00 00 00	 mov	 eax, 4
  00183	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
$LN3@GetChiHuTi:

; 500  : 
; 501  : 	if(!(ChiHuRight&CHR_GANG_SHANG_HUA).IsEmpty())//杠上开花

  00187	68 00 00 80 00	 push	 8388608			; 00800000H
  0018c	8d 4d d0	 lea	 ecx, DWORD PTR $T3[ebp]
  0018f	51		 push	 ecx
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  00193	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  00198	8b c8		 mov	 ecx, eax
  0019a	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  0019f	0f b6 d0	 movzx	 edx, al
  001a2	85 d2		 test	 edx, edx
  001a4	75 0c		 jne	 SHORT $LN19@GetChiHuTi

; 502  : 		wFanShu *= 2;

  001a6	0f b7 45 fc	 movzx	 eax, WORD PTR _wFanShu$[ebp]
  001aa	d1 e0		 shl	 eax, 1
  001ac	66 89 45 fc	 mov	 WORD PTR _wFanShu$[ebp], ax
  001b0	eb 2b		 jmp	 SHORT $LN20@GetChiHuTi
$LN19@GetChiHuTi:

; 503  : 	else if(!(ChiHuRight&CHR_QIANG_GANG_HU).IsEmpty())//抢杠

  001b2	68 00 00 00 02	 push	 33554432		; 02000000H
  001b7	8d 4d cc	 lea	 ecx, DWORD PTR $T2[ebp]
  001ba	51		 push	 ecx
  001bb	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  001be	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  001c3	8b c8		 mov	 ecx, eax
  001c5	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  001ca	0f b6 d0	 movzx	 edx, al
  001cd	85 d2		 test	 edx, edx
  001cf	75 0c		 jne	 SHORT $LN20@GetChiHuTi

; 504  : 	{
; 505  : 		wFanShu = 2*wFanShu+1;

  001d1	0f b7 45 fc	 movzx	 eax, WORD PTR _wFanShu$[ebp]
  001d5	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  001d9	66 89 4d fc	 mov	 WORD PTR _wFanShu$[ebp], cx
$LN20@GetChiHuTi:

; 506  : 	}
; 507  : 	
; 508  : 	if(!(ChiHuRight&CHR_ZI_MO).IsEmpty())

  001dd	68 00 00 00 08	 push	 134217728		; 08000000H
  001e2	8d 55 c8	 lea	 edx, DWORD PTR $T1[ebp]
  001e5	52		 push	 edx
  001e6	8b 4d 08	 mov	 ecx, DWORD PTR _ChiHuRight$[ebp]
  001e9	e8 00 00 00 00	 call	 ??ICChiHuRight@@QBE?AV0@K@Z ; CChiHuRight::operator&
  001ee	8b c8		 mov	 ecx, eax
  001f0	e8 00 00 00 00	 call	 ?IsEmpty@CChiHuRight@@QAE_NXZ ; CChiHuRight::IsEmpty
  001f5	0f b6 c0	 movzx	 eax, al
  001f8	85 c0		 test	 eax, eax
  001fa	75 0a		 jne	 SHORT $LN22@GetChiHuTi

; 509  : 		wFanShu *= 2;

  001fc	0f b7 4d fc	 movzx	 ecx, WORD PTR _wFanShu$[ebp]
  00200	d1 e1		 shl	 ecx, 1
  00202	66 89 4d fc	 mov	 WORD PTR _wFanShu$[ebp], cx
$LN22@GetChiHuTi:

; 510  : 
; 511  : 
; 512  : 	return wFanShu;

  00206	66 8b 45 fc	 mov	 ax, WORD PTR _wFanShu$[ebp]

; 513  : }

  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 04 00	 ret	 4
?GetChiHuTime@CGameLogic@@QAEGABVCChiHuRight@@@Z ENDP	; CGameLogic::GetChiHuTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ChiHuRight$ = 8					; size = 4
?GetChiHuActionRank@CGameLogic@@QAEGABVCChiHuRight@@@Z PROC ; CGameLogic::GetChiHuActionRank
; _this$ = ecx

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 474  : 	return 1;

  00007	b8 01 00 00 00	 mov	 eax, 1

; 475  : }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?GetChiHuActionRank@CGameLogic@@QAEGABVCChiHuRight@@@Z ENDP ; CGameLogic::GetChiHuActionRank
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cbUserAction$ = 8					; size = 1
?GetUserActionRank@CGameLogic@@QAEEE@Z PROC		; CGameLogic::GetUserActionRank
; _this$ = ecx

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 456  : 	//胡牌等级
; 457  : 	if (cbUserAction&WIK_CHI_HU) { return 4; }

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _cbUserAction$[ebp]
  0000b	83 e0 40	 and	 eax, 64			; 00000040H
  0000e	74 04		 je	 SHORT $LN2@GetUserAct
  00010	b0 04		 mov	 al, 4
  00012	eb 29		 jmp	 SHORT $LN1@GetUserAct
$LN2@GetUserAct:

; 458  : 
; 459  : 	//杠牌等级
; 460  : 	if (cbUserAction&WIK_GANG) { return 3; }

  00014	0f b6 4d 08	 movzx	 ecx, BYTE PTR _cbUserAction$[ebp]
  00018	83 e1 10	 and	 ecx, 16			; 00000010H
  0001b	74 04		 je	 SHORT $LN3@GetUserAct
  0001d	b0 03		 mov	 al, 3
  0001f	eb 1c		 jmp	 SHORT $LN1@GetUserAct
$LN3@GetUserAct:

; 461  : 
; 462  : 	//碰牌等级
; 463  : 	if (cbUserAction&WIK_PENG) { return 2; }

  00021	0f b6 55 08	 movzx	 edx, BYTE PTR _cbUserAction$[ebp]
  00025	83 e2 08	 and	 edx, 8
  00028	74 04		 je	 SHORT $LN4@GetUserAct
  0002a	b0 02		 mov	 al, 2
  0002c	eb 0f		 jmp	 SHORT $LN1@GetUserAct
$LN4@GetUserAct:

; 464  : 
; 465  : 	//上牌等级
; 466  : 	if (cbUserAction&(WIK_RIGHT|WIK_CENTER|WIK_LEFT)) { return 1; }

  0002e	0f b6 45 08	 movzx	 eax, BYTE PTR _cbUserAction$[ebp]
  00032	83 e0 07	 and	 eax, 7
  00035	74 04		 je	 SHORT $LN5@GetUserAct
  00037	b0 01		 mov	 al, 1
  00039	eb 02		 jmp	 SHORT $LN1@GetUserAct
$LN5@GetUserAct:

; 467  : 
; 468  : 	return 0;

  0003b	32 c0		 xor	 al, al
$LN1@GetUserAct:

; 469  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GetUserActionRank@CGameLogic@@QAEEE@Z ENDP		; CGameLogic::GetUserActionRank
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$1 = -8						; size = 4
_cbHuaCardCount$ = -1					; size = 1
_cbCardIndex$ = 8					; size = 4
?IsHuaCard@CGameLogic@@QAEEQAE@Z PROC			; CGameLogic::IsHuaCard
; _this$ = ecx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 356  : 	BYTE cbHuaCardCount = 0;

  00009	c6 45 ff 00	 mov	 BYTE PTR _cbHuaCardCount$[ebp], 0

; 357  : 	for(int i = MAX_INDEX - MAX_HUA_INDEX; i < MAX_INDEX; i++)

  0000d	c7 45 f8 22 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 34	; 00000022H
  00014	eb 09		 jmp	 SHORT $LN4@IsHuaCard
$LN2@IsHuaCard:
  00016	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00019	83 c0 01	 add	 eax, 1
  0001c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@IsHuaCard:
  0001f	83 7d f8 22	 cmp	 DWORD PTR _i$1[ebp], 34	; 00000022H
  00023	7d 21		 jge	 SHORT $LN3@IsHuaCard

; 358  : 	{
; 359  : 		if(cbCardIndex[i] > 0)

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00028	03 4d f8	 add	 ecx, DWORD PTR _i$1[ebp]
  0002b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0002e	85 d2		 test	 edx, edx
  00030	7e 12		 jle	 SHORT $LN5@IsHuaCard

; 360  : 		{
; 361  : 			cbHuaCardCount += cbCardIndex[i];

  00032	8b 45 08	 mov	 eax, DWORD PTR _cbCardIndex$[ebp]
  00035	03 45 f8	 add	 eax, DWORD PTR _i$1[ebp]
  00038	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0003b	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbHuaCardCount$[ebp]
  0003f	03 d1		 add	 edx, ecx
  00041	88 55 ff	 mov	 BYTE PTR _cbHuaCardCount$[ebp], dl
$LN5@IsHuaCard:

; 362  : 		}
; 363  : 	}

  00044	eb d0		 jmp	 SHORT $LN2@IsHuaCard
$LN3@IsHuaCard:

; 364  : 
; 365  : 	return cbHuaCardCount;

  00046	8a 45 ff	 mov	 al, BYTE PTR _cbHuaCardCount$[ebp]

; 366  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?IsHuaCard@CGameLogic@@QAEEQAE@Z ENDP			; CGameLogic::IsHuaCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
_cbCardData$ = 8					; size = 1
?IsHuaCard@CGameLogic@@QAE_NE@Z PROC			; CGameLogic::IsHuaCard
; _this$ = ecx

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 348  : 	ASSERT(IsValidCard(cbCardData));
; 349  : 
; 350  : 	return cbCardData >= 0x38;

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  0000d	83 f8 38	 cmp	 eax, 56			; 00000038H
  00010	7c 09		 jl	 SHORT $LN3@IsHuaCard
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@IsHuaCard
$LN3@IsHuaCard:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsHuaCard:
  00022	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 351  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?IsHuaCard@CGameLogic@@QAE_NE@Z ENDP			; CGameLogic::IsHuaCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv74 = -8						; size = 4
_this$ = -4						; size = 4
_cbCardData$ = 8					; size = 1
?IsMagicCard@CGameLogic@@QAE_NE@Z PROC			; CGameLogic::IsMagicCard
; _this$ = ecx

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 340  : 	if(m_cbMagicIndex != MAX_INDEX)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00010	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00013	74 30		 je	 SHORT $LN2@IsMagicCar

; 341  : 		return SwitchToCardIndex(cbCardData) == m_cbMagicIndex;

  00015	0f b6 55 08	 movzx	 edx, BYTE PTR _cbCardData$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00022	0f b6 c0	 movzx	 eax, al
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0002c	3b c2		 cmp	 eax, edx
  0002e	75 09		 jne	 SHORT $LN4@IsMagicCar
  00030	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00037	eb 07		 jmp	 SHORT $LN5@IsMagicCar
$LN4@IsMagicCar:
  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN5@IsMagicCar:
  00040	8a 45 f8	 mov	 al, BYTE PTR tv74[ebp]
  00043	eb 02		 jmp	 SHORT $LN1@IsMagicCar
$LN2@IsMagicCar:

; 342  : 	return false;

  00045	32 c0		 xor	 al, al
$LN1@IsMagicCar:

; 343  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?IsMagicCard@CGameLogic@@QAE_NE@Z ENDP			; CGameLogic::IsMagicCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T1 = -32						; size = 4
_cbCardPos$ = -25					; size = 1
_cbDeleteCount$ = -24					; size = 1
_i$2 = -23						; size = 1
_i$3 = -22						; size = 1
_j$4 = -21						; size = 1
_cbTempCardData$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_cbCardData$ = 8					; size = 4
_cbCardCount$ = 12					; size = 1
_cbRemoveCard$ = 16					; size = 4
_cbRemoveCount$ = 20					; size = 1
?RemoveCard@CGameLogic@@QAE_NQAEEQBEE@Z PROC		; CGameLogic::RemoveCard
; _this$ = ecx

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 411  : 	//检验数据
; 412  : 	ASSERT(cbCardCount<=MAX_COUNT);
; 413  : 	ASSERT(cbRemoveCount<=cbCardCount);
; 414  : 
; 415  : 	//定义变量
; 416  : 	BYTE cbDeleteCount=0,cbTempCardData[MAX_COUNT];

  00013	c6 45 e8 00	 mov	 BYTE PTR _cbDeleteCount$[ebp], 0

; 417  : 	if (cbCardCount>CountArray(cbTempCardData))

  00017	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  0001b	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  0001e	76 07		 jbe	 SHORT $LN11@RemoveCard

; 418  : 		return false;

  00020	32 c0		 xor	 al, al
  00022	e9 e8 00 00 00	 jmp	 $LN15@RemoveCard
$LN11@RemoveCard:

; 419  : 	CopyMemory(cbTempCardData,cbCardData,cbCardCount*sizeof(cbCardData[0]));

  00027	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCardCount$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _cbCardData$[ebp]
  0002f	52		 push	 edx
  00030	8d 45 ec	 lea	 eax, DWORD PTR _cbTempCardData$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _memcpy
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 420  : 
; 421  : 	//置零扑克
; 422  : 	for (BYTE i=0;i<cbRemoveCount;i++)

  0003c	c6 45 e9 00	 mov	 BYTE PTR _i$2[ebp], 0
  00040	eb 09		 jmp	 SHORT $LN4@RemoveCard
$LN2@RemoveCard:
  00042	8a 4d e9	 mov	 cl, BYTE PTR _i$2[ebp]
  00045	80 c1 01	 add	 cl, 1
  00048	88 4d e9	 mov	 BYTE PTR _i$2[ebp], cl
$LN4@RemoveCard:
  0004b	0f b6 55 e9	 movzx	 edx, BYTE PTR _i$2[ebp]
  0004f	0f b6 45 14	 movzx	 eax, BYTE PTR _cbRemoveCount$[ebp]
  00053	3b d0		 cmp	 edx, eax
  00055	7d 5d		 jge	 SHORT $LN3@RemoveCard

; 423  : 	{
; 424  : 		for (BYTE j=0;j<cbCardCount;j++)

  00057	c6 45 eb 00	 mov	 BYTE PTR _j$4[ebp], 0
  0005b	eb 09		 jmp	 SHORT $LN7@RemoveCard
$LN5@RemoveCard:
  0005d	8a 4d eb	 mov	 cl, BYTE PTR _j$4[ebp]
  00060	80 c1 01	 add	 cl, 1
  00063	88 4d eb	 mov	 BYTE PTR _j$4[ebp], cl
$LN7@RemoveCard:
  00066	0f b6 55 eb	 movzx	 edx, BYTE PTR _j$4[ebp]
  0006a	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  0006e	3b d0		 cmp	 edx, eax
  00070	7d 40		 jge	 SHORT $LN6@RemoveCard

; 425  : 		{
; 426  : 			if (cbRemoveCard[i]==cbTempCardData[j])

  00072	0f b6 4d e9	 movzx	 ecx, BYTE PTR _i$2[ebp]
  00076	8b 55 10	 mov	 edx, DWORD PTR _cbRemoveCard$[ebp]
  00079	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0007d	0f b6 4d eb	 movzx	 ecx, BYTE PTR _j$4[ebp]
  00081	0f b6 54 0d ec	 movzx	 edx, BYTE PTR _cbTempCardData$[ebp+ecx]
  00086	3b c2		 cmp	 eax, edx
  00088	75 26		 jne	 SHORT $LN12@RemoveCard

; 427  : 			{
; 428  : 				cbDeleteCount++;

  0008a	8a 45 e8	 mov	 al, BYTE PTR _cbDeleteCount$[ebp]
  0008d	04 01		 add	 al, 1
  0008f	88 45 e8	 mov	 BYTE PTR _cbDeleteCount$[ebp], al

; 429  : 				cbTempCardData[j]=0;

  00092	0f b6 4d eb	 movzx	 ecx, BYTE PTR _j$4[ebp]
  00096	89 4d e0	 mov	 DWORD PTR $T1[ebp], ecx
  00099	83 7d e0 0e	 cmp	 DWORD PTR $T1[ebp], 14	; 0000000eH
  0009d	73 02		 jae	 SHORT $LN16@RemoveCard
  0009f	eb 05		 jmp	 SHORT $LN17@RemoveCard
$LN16@RemoveCard:
  000a1	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN17@RemoveCard:
  000a6	8b 55 e0	 mov	 edx, DWORD PTR $T1[ebp]
  000a9	c6 44 15 ec 00	 mov	 BYTE PTR _cbTempCardData$[ebp+edx], 0

; 430  : 				break;

  000ae	eb 02		 jmp	 SHORT $LN6@RemoveCard
$LN12@RemoveCard:

; 431  : 			}
; 432  : 		}

  000b0	eb ab		 jmp	 SHORT $LN5@RemoveCard
$LN6@RemoveCard:

; 433  : 	}

  000b2	eb 8e		 jmp	 SHORT $LN2@RemoveCard
$LN3@RemoveCard:

; 434  : 
; 435  : 	//成功判断
; 436  : 	if (cbDeleteCount!=cbRemoveCount) 

  000b4	0f b6 45 e8	 movzx	 eax, BYTE PTR _cbDeleteCount$[ebp]
  000b8	0f b6 4d 14	 movzx	 ecx, BYTE PTR _cbRemoveCount$[ebp]
  000bc	3b c1		 cmp	 eax, ecx
  000be	74 04		 je	 SHORT $LN13@RemoveCard

; 437  : 	{
; 438  : 		ASSERT(FALSE);
; 439  : 		return false;

  000c0	32 c0		 xor	 al, al
  000c2	eb 4b		 jmp	 SHORT $LN15@RemoveCard
$LN13@RemoveCard:

; 440  : 	}
; 441  : 
; 442  : 	//清理扑克
; 443  : 	BYTE cbCardPos=0;

  000c4	c6 45 e7 00	 mov	 BYTE PTR _cbCardPos$[ebp], 0

; 444  : 	for (BYTE i=0;i<cbCardCount;i++)

  000c8	c6 45 ea 00	 mov	 BYTE PTR _i$3[ebp], 0
  000cc	eb 09		 jmp	 SHORT $LN10@RemoveCard
$LN8@RemoveCard:
  000ce	8a 55 ea	 mov	 dl, BYTE PTR _i$3[ebp]
  000d1	80 c2 01	 add	 dl, 1
  000d4	88 55 ea	 mov	 BYTE PTR _i$3[ebp], dl
$LN10@RemoveCard:
  000d7	0f b6 45 ea	 movzx	 eax, BYTE PTR _i$3[ebp]
  000db	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCardCount$[ebp]
  000df	3b c1		 cmp	 eax, ecx
  000e1	7d 2a		 jge	 SHORT $LN9@RemoveCard

; 445  : 	{
; 446  : 		if (cbTempCardData[i]!=0) 

  000e3	0f b6 55 ea	 movzx	 edx, BYTE PTR _i$3[ebp]
  000e7	0f b6 44 15 ec	 movzx	 eax, BYTE PTR _cbTempCardData$[ebp+edx]
  000ec	85 c0		 test	 eax, eax
  000ee	74 1b		 je	 SHORT $LN14@RemoveCard

; 447  : 			cbCardData[cbCardPos++]=cbTempCardData[i];

  000f0	0f b6 4d ea	 movzx	 ecx, BYTE PTR _i$3[ebp]
  000f4	0f b6 55 e7	 movzx	 edx, BYTE PTR _cbCardPos$[ebp]
  000f8	8b 45 08	 mov	 eax, DWORD PTR _cbCardData$[ebp]
  000fb	8a 4c 0d ec	 mov	 cl, BYTE PTR _cbTempCardData$[ebp+ecx]
  000ff	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00102	8a 55 e7	 mov	 dl, BYTE PTR _cbCardPos$[ebp]
  00105	80 c2 01	 add	 dl, 1
  00108	88 55 e7	 mov	 BYTE PTR _cbCardPos$[ebp], dl
$LN14@RemoveCard:

; 448  : 	}

  0010b	eb c1		 jmp	 SHORT $LN8@RemoveCard
$LN9@RemoveCard:

; 449  : 
; 450  : 	return true;

  0010d	b0 01		 mov	 al, 1
$LN15@RemoveCard:

; 451  : }

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	33 cd		 xor	 ecx, ebp
  00114	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 10 00	 ret	 16			; 00000010H
?RemoveCard@CGameLogic@@QAE_NQAEEQBEE@Z ENDP		; CGameLogic::RemoveCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_cbSwitchData$ = -6					; size = 1
_bSorted$ = -5						; size = 1
_cbLast$ = -4						; size = 1
_cbCard2$ = -3						; size = 1
_cbCard1$ = -2						; size = 1
_i$1 = -1						; size = 1
_cbCardData$ = 8					; size = 4
_cbCardCount$ = 12					; size = 1
?SortCardList@CGameLogic@@QAE_NQAEE@Z PROC		; CGameLogic::SortCardList
; _this$ = ecx

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 371  : 	//数目过虑
; 372  : 	if (cbCardCount==0||cbCardCount>MAX_COUNT) return false;

  0000a	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCardCount$[ebp]
  0000e	85 c0		 test	 eax, eax
  00010	74 09		 je	 SHORT $LN9@SortCardLi
  00012	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCardCount$[ebp]
  00016	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00019	7e 07		 jle	 SHORT $LN8@SortCardLi
$LN9@SortCardLi:
  0001b	32 c0		 xor	 al, al
  0001d	e9 fe 00 00 00	 jmp	 $LN1@SortCardLi
$LN8@SortCardLi:

; 373  : 
; 374  : 	//排序操作
; 375  : 	bool bSorted=true;

  00022	c6 45 fb 01	 mov	 BYTE PTR _bSorted$[ebp], 1

; 376  : 	BYTE cbSwitchData=0,cbLast=cbCardCount-1;

  00026	c6 45 fa 00	 mov	 BYTE PTR _cbSwitchData$[ebp], 0
  0002a	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCardCount$[ebp]
  0002e	83 ea 01	 sub	 edx, 1
  00031	88 55 fc	 mov	 BYTE PTR _cbLast$[ebp], dl
$LN4@SortCardLi:

; 377  : 	BYTE cbCard1, cbCard2;
; 378  : 	do
; 379  : 	{
; 380  : 		bSorted=true;

  00034	c6 45 fb 01	 mov	 BYTE PTR _bSorted$[ebp], 1

; 381  : 		for (BYTE i=0;i<cbLast;i++)

  00038	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  0003c	eb 08		 jmp	 SHORT $LN7@SortCardLi
$LN5@SortCardLi:
  0003e	8a 45 ff	 mov	 al, BYTE PTR _i$1[ebp]
  00041	04 01		 add	 al, 1
  00043	88 45 ff	 mov	 BYTE PTR _i$1[ebp], al
$LN7@SortCardLi:
  00046	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0004a	0f b6 55 fc	 movzx	 edx, BYTE PTR _cbLast$[ebp]
  0004e	3b ca		 cmp	 ecx, edx
  00050	0f 8d b4 00 00
	00		 jge	 $LN6@SortCardLi

; 382  : 		{
; 383  : 			cbCard1 = cbCardData[i];

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardData$[ebp]
  0005d	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00060	88 55 fe	 mov	 BYTE PTR _cbCard1$[ebp], dl

; 384  : 			cbCard2 = cbCardData[i+1];

  00063	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardData$[ebp]
  0006a	8a 54 01 01	 mov	 dl, BYTE PTR [ecx+eax+1]
  0006e	88 55 fd	 mov	 BYTE PTR _cbCard2$[ebp], dl

; 385  : 			//如果财神有代替牌，财神与代替牌转换
; 386  : 			if(INDEX_REPLACE_CARD != MAX_INDEX  && m_cbMagicIndex != INDEX_REPLACE_CARD)

  00071	33 c0		 xor	 eax, eax
  00073	74 50		 je	 SHORT $LN10@SortCardLi

; 387  : 			{
; 388  : 				if(SwitchToCardIndex(cbCard1) == INDEX_REPLACE_CARD) cbCard1 = SwitchToCardData(m_cbMagicIndex);

  00075	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cbCard1$[ebp]
  00079	51		 push	 ecx
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00082	0f b6 d0	 movzx	 edx, al
  00085	83 fa 22	 cmp	 edx, 34			; 00000022H
  00088	75 13		 jne	 SHORT $LN11@SortCardLi
  0008a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00091	51		 push	 ecx
  00092	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  0009a	88 45 fe	 mov	 BYTE PTR _cbCard1$[ebp], al
$LN11@SortCardLi:

; 389  : 				if(SwitchToCardIndex(cbCard2) == INDEX_REPLACE_CARD) cbCard2 = SwitchToCardData(m_cbMagicIndex);

  0009d	0f b6 55 fd	 movzx	 edx, BYTE PTR _cbCard2$[ebp]
  000a1	52		 push	 edx
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  000aa	0f b6 c0	 movzx	 eax, al
  000ad	83 f8 22	 cmp	 eax, 34			; 00000022H
  000b0	75 13		 jne	 SHORT $LN10@SortCardLi
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  000b9	52		 push	 edx
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  000c2	88 45 fd	 mov	 BYTE PTR _cbCard2$[ebp], al
$LN10@SortCardLi:

; 390  : 			}
; 391  : 			if (cbCard1>cbCard2)

  000c5	0f b6 45 fe	 movzx	 eax, BYTE PTR _cbCard1$[ebp]
  000c9	0f b6 4d fd	 movzx	 ecx, BYTE PTR _cbCard2$[ebp]
  000cd	3b c1		 cmp	 eax, ecx
  000cf	7e 34		 jle	 SHORT $LN13@SortCardLi

; 392  : 			{
; 393  : 				//设置标志
; 394  : 				bSorted=false;

  000d1	c6 45 fb 00	 mov	 BYTE PTR _bSorted$[ebp], 0

; 395  : 
; 396  : 				//扑克数据
; 397  : 				cbSwitchData=cbCardData[i];

  000d5	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  000d9	8b 45 08	 mov	 eax, DWORD PTR _cbCardData$[ebp]
  000dc	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  000df	88 4d fa	 mov	 BYTE PTR _cbSwitchData$[ebp], cl

; 398  : 				cbCardData[i]=cbCardData[i+1];

  000e2	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  000e6	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardData$[ebp]
  000ed	8b 75 08	 mov	 esi, DWORD PTR _cbCardData$[ebp]
  000f0	8a 54 16 01	 mov	 dl, BYTE PTR [esi+edx+1]
  000f4	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 399  : 				cbCardData[i+1]=cbSwitchData;

  000f7	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardData$[ebp]
  000fe	8a 55 fa	 mov	 dl, BYTE PTR _cbSwitchData$[ebp]
  00101	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl
$LN13@SortCardLi:

; 400  : 			}	
; 401  : 		}

  00105	e9 34 ff ff ff	 jmp	 $LN5@SortCardLi
$LN6@SortCardLi:

; 402  : 		cbLast--;

  0010a	8a 45 fc	 mov	 al, BYTE PTR _cbLast$[ebp]
  0010d	2c 01		 sub	 al, 1
  0010f	88 45 fc	 mov	 BYTE PTR _cbLast$[ebp], al

; 403  : 	} while(bSorted==false);

  00112	0f b6 4d fb	 movzx	 ecx, BYTE PTR _bSorted$[ebp]
  00116	85 c9		 test	 ecx, ecx
  00118	0f 84 16 ff ff
	ff		 je	 $LN4@SortCardLi

; 404  : 
; 405  : 	return true;

  0011e	b0 01		 mov	 al, 1
$LN1@SortCardLi:

; 406  : }

  00120	5e		 pop	 esi
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 08 00	 ret	 8
?SortCardList@CGameLogic@@QAE_NQAEE@Z ENDP		; CGameLogic::SortCardList
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbRemoveIndex$ = -1					; size = 1
_cbCardIndex$ = 8					; size = 4
_cbRemoveCard$ = 12					; size = 1
?RemoveCard@CGameLogic@@QAE_NQAEE@Z PROC		; CGameLogic::RemoveCard
; _this$ = ecx

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 	//效验扑克
; 320  : 	ASSERT(IsValidCard(cbRemoveCard));
; 321  : 	ASSERT(cbCardIndex[SwitchToCardIndex(cbRemoveCard)] > 0);
; 322  : 
; 323  : 	//删除扑克
; 324  : 	BYTE cbRemoveIndex = SwitchToCardIndex(cbRemoveCard);

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbRemoveCard$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00016	88 45 ff	 mov	 BYTE PTR _cbRemoveIndex$[ebp], al

; 325  : 	if (cbCardIndex[cbRemoveIndex] > 0)

  00019	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbRemoveIndex$[ebp]
  0001d	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  00020	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00024	85 c0		 test	 eax, eax
  00026	7e 1a		 jle	 SHORT $LN2@RemoveCard

; 326  : 	{
; 327  : 		cbCardIndex[cbRemoveIndex]--;

  00028	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbRemoveIndex$[ebp]
  0002c	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  0002f	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  00032	2c 01		 sub	 al, 1
  00034	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbRemoveIndex$[ebp]
  00038	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  0003b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 328  : 		return true;

  0003e	b0 01		 mov	 al, 1
  00040	eb 02		 jmp	 SHORT $LN1@RemoveCard
$LN2@RemoveCard:

; 329  : 	}
; 330  : 
; 331  : 	//失败效验
; 332  : 	ASSERT(FALSE);
; 333  : 
; 334  : 	return false;

  00042	32 c0		 xor	 al, al
$LN1@RemoveCard:

; 335  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
?RemoveCard@CGameLogic@@QAE_NQAEE@Z ENDP		; CGameLogic::RemoveCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv93 = -12						; size = 4
_this$ = -8						; size = 4
_cbRemoveIndex$1 = -3					; size = 1
_j$2 = -2						; size = 1
_i$3 = -1						; size = 1
_cbCardIndex$ = 8					; size = 4
_cbRemoveCard$ = 12					; size = 4
_cbRemoveCount$ = 16					; size = 1
?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z PROC		; CGameLogic::RemoveCard
; _this$ = ecx

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 283  : 	//删除扑克
; 284  : 	for (BYTE i=0;i<cbRemoveCount;i++)

  00009	c6 45 ff 00	 mov	 BYTE PTR _i$3[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN4@RemoveCard
$LN2@RemoveCard:
  0000f	8a 45 ff	 mov	 al, BYTE PTR _i$3[ebp]
  00012	04 01		 add	 al, 1
  00014	88 45 ff	 mov	 BYTE PTR _i$3[ebp], al
$LN4@RemoveCard:
  00017	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$3[ebp]
  0001b	0f b6 55 10	 movzx	 edx, BYTE PTR _cbRemoveCount$[ebp]
  0001f	3b ca		 cmp	 ecx, edx
  00021	0f 8d 8d 00 00
	00		 jge	 $LN3@RemoveCard

; 285  : 	{
; 286  : 		//效验扑克
; 287  : 		ASSERT(IsValidCard(cbRemoveCard[i]));
; 288  : 		ASSERT(cbCardIndex[SwitchToCardIndex(cbRemoveCard[i])]>0);
; 289  : 
; 290  : 		//删除扑克
; 291  : 		BYTE cbRemoveIndex=SwitchToCardIndex(cbRemoveCard[i]);

  00027	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$3[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _cbRemoveCard$[ebp]
  0002e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00032	52		 push	 edx
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  0003b	88 45 fd	 mov	 BYTE PTR _cbRemoveIndex$1[ebp], al

; 292  : 		if (cbCardIndex[cbRemoveIndex]==0)

  0003e	0f b6 45 fd	 movzx	 eax, BYTE PTR _cbRemoveIndex$1[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _cbCardIndex$[ebp]
  00045	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00049	85 d2		 test	 edx, edx
  0004b	75 4c		 jne	 SHORT $LN8@RemoveCard

; 293  : 		{
; 294  : 			//错误断言
; 295  : 			ASSERT(FALSE);
; 296  : 
; 297  : 			//还原删除
; 298  : 			for (BYTE j=0;j<i;j++) 

  0004d	c6 45 fe 00	 mov	 BYTE PTR _j$2[ebp], 0
  00051	eb 08		 jmp	 SHORT $LN7@RemoveCard
$LN5@RemoveCard:
  00053	8a 45 fe	 mov	 al, BYTE PTR _j$2[ebp]
  00056	04 01		 add	 al, 1
  00058	88 45 fe	 mov	 BYTE PTR _j$2[ebp], al
$LN7@RemoveCard:
  0005b	0f b6 4d fe	 movzx	 ecx, BYTE PTR _j$2[ebp]
  0005f	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$3[ebp]
  00063	3b ca		 cmp	 ecx, edx
  00065	7d 2c		 jge	 SHORT $LN6@RemoveCard

; 299  : 			{
; 300  : 				ASSERT(IsValidCard(cbRemoveCard[j]));
; 301  : 				cbCardIndex[SwitchToCardIndex(cbRemoveCard[j])]++;

  00067	0f b6 45 fe	 movzx	 eax, BYTE PTR _j$2[ebp]
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _cbRemoveCard$[ebp]
  0006e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00072	52		 push	 edx
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  0007b	0f b6 c0	 movzx	 eax, al
  0007e	03 45 08	 add	 eax, DWORD PTR _cbCardIndex$[ebp]
  00081	89 45 f4	 mov	 DWORD PTR tv93[ebp], eax
  00084	8b 4d f4	 mov	 ecx, DWORD PTR tv93[ebp]
  00087	8a 11		 mov	 dl, BYTE PTR [ecx]
  00089	80 c2 01	 add	 dl, 1
  0008c	8b 45 f4	 mov	 eax, DWORD PTR tv93[ebp]
  0008f	88 10		 mov	 BYTE PTR [eax], dl

; 302  : 			}

  00091	eb c0		 jmp	 SHORT $LN5@RemoveCard
$LN6@RemoveCard:

; 303  : 
; 304  : 			return false;

  00093	32 c0		 xor	 al, al
  00095	eb 1f		 jmp	 SHORT $LN1@RemoveCard

; 305  : 		}
; 306  : 		else 

  00097	eb 16		 jmp	 SHORT $LN9@RemoveCard
$LN8@RemoveCard:

; 307  : 		{
; 308  : 			//删除扑克
; 309  : 			--cbCardIndex[cbRemoveIndex];

  00099	0f b6 4d fd	 movzx	 ecx, BYTE PTR _cbRemoveIndex$1[ebp]
  0009d	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  000a0	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  000a3	2c 01		 sub	 al, 1
  000a5	0f b6 4d fd	 movzx	 ecx, BYTE PTR _cbRemoveIndex$1[ebp]
  000a9	8b 55 08	 mov	 edx, DWORD PTR _cbCardIndex$[ebp]
  000ac	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN9@RemoveCard:

; 310  : 		}
; 311  : 	}

  000af	e9 5b ff ff ff	 jmp	 $LN2@RemoveCard
$LN3@RemoveCard:

; 312  : 
; 313  : 	return true;

  000b4	b0 01		 mov	 al, 1
$LN1@RemoveCard:

; 314  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 0c 00	 ret	 12			; 0000000cH
?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z ENDP		; CGameLogic::RemoveCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -28						; size = 4
_cbPosition$ = -22					; size = 1
_cbRandCount$ = -21					; size = 1
_cbCardDataTemp$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_cbCardData$ = 8					; size = 4
_cbCardBuffer$ = 12					; size = 4
_cbBufferCount$ = 16					; size = 1
?RandCardList@CGameLogic@@QAEXQAE0E@Z PROC		; CGameLogic::RandCardList
; _this$ = ecx

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 264  : 	//混乱准备
; 265  : 	BYTE cbCardDataTemp[MAX_COUNT] = {0};

  00013	c6 45 ec 00	 mov	 BYTE PTR _cbCardDataTemp$[ebp], 0
  00017	33 c0		 xor	 eax, eax
  00019	89 45 ed	 mov	 DWORD PTR _cbCardDataTemp$[ebp+1], eax
  0001c	89 45 f1	 mov	 DWORD PTR _cbCardDataTemp$[ebp+5], eax
  0001f	89 45 f5	 mov	 DWORD PTR _cbCardDataTemp$[ebp+9], eax
  00022	88 45 f9	 mov	 BYTE PTR _cbCardDataTemp$[ebp+13], al

; 266  : 	CopyMemory(cbCardDataTemp,cbCardData,sizeof(BYTE) * cbBufferCount);

  00025	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cbBufferCount$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _cbCardData$[ebp]
  0002d	52		 push	 edx
  0002e	8d 45 ec	 lea	 eax, DWORD PTR _cbCardDataTemp$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 267  : 
; 268  : 	//混乱扑克
; 269  : 	BYTE cbRandCount=0,cbPosition=0;

  0003a	c6 45 eb 00	 mov	 BYTE PTR _cbRandCount$[ebp], 0
  0003e	c6 45 ea 00	 mov	 BYTE PTR _cbPosition$[ebp], 0
$LN4@RandCardLi:

; 270  : 	do
; 271  : 	{
; 272  : 		cbPosition=rand()%(cbBufferCount-cbRandCount);

  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00048	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cbBufferCount$[ebp]
  0004c	0f b6 55 eb	 movzx	 edx, BYTE PTR _cbRandCount$[ebp]
  00050	2b ca		 sub	 ecx, edx
  00052	99		 cdq
  00053	f7 f9		 idiv	 ecx
  00055	88 55 ea	 mov	 BYTE PTR _cbPosition$[ebp], dl

; 273  : 		cbCardBuffer[cbRandCount++]=cbCardDataTemp[cbPosition];

  00058	0f b6 45 ea	 movzx	 eax, BYTE PTR _cbPosition$[ebp]
  0005c	0f b6 4d eb	 movzx	 ecx, BYTE PTR _cbRandCount$[ebp]
  00060	8b 55 0c	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  00063	8a 44 05 ec	 mov	 al, BYTE PTR _cbCardDataTemp$[ebp+eax]
  00067	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0006a	8a 4d eb	 mov	 cl, BYTE PTR _cbRandCount$[ebp]
  0006d	80 c1 01	 add	 cl, 1
  00070	88 4d eb	 mov	 BYTE PTR _cbRandCount$[ebp], cl

; 274  : 		cbCardDataTemp[cbPosition]=cbCardDataTemp[cbBufferCount-cbRandCount];

  00073	0f b6 55 10	 movzx	 edx, BYTE PTR _cbBufferCount$[ebp]
  00077	0f b6 45 eb	 movzx	 eax, BYTE PTR _cbRandCount$[ebp]
  0007b	2b d0		 sub	 edx, eax
  0007d	0f b6 4d ea	 movzx	 ecx, BYTE PTR _cbPosition$[ebp]
  00081	8a 54 15 ec	 mov	 dl, BYTE PTR _cbCardDataTemp$[ebp+edx]
  00085	88 54 0d ec	 mov	 BYTE PTR _cbCardDataTemp$[ebp+ecx], dl

; 275  : 	} while (cbRandCount<cbBufferCount);

  00089	0f b6 45 eb	 movzx	 eax, BYTE PTR _cbRandCount$[ebp]
  0008d	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cbBufferCount$[ebp]
  00091	3b c1		 cmp	 eax, ecx
  00093	7c ad		 jl	 SHORT $LN4@RandCardLi

; 276  : 
; 277  : 	return;
; 278  : }

  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 cd		 xor	 ecx, ebp
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH
?RandCardList@CGameLogic@@QAEXQAE0E@Z ENDP		; CGameLogic::RandCardList
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -124						; size = 4
_cbPosition$ = -118					; size = 1
_cbRandCount$ = -117					; size = 1
_cbCardDataTemp$ = -116					; size = 112
__$ArrayPad$ = -4					; size = 4
_cbCardBuffer$ = 8					; size = 4
_cbBufferCount$ = 12					; size = 1
?RandCardList@CGameLogic@@QAEXQAEE@Z PROC		; CGameLogic::RandCardList
; _this$ = ecx

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx

; 245  : 	//混乱准备
; 246  : 	BYTE cbCardDataTemp[CountArray(m_cbCardDataArray)];
; 247  : 	CopyMemory(cbCardDataTemp,m_cbCardDataArray,sizeof(m_cbCardDataArray));

  00013	6a 70		 push	 112			; 00000070H
  00015	68 00 00 00 00	 push	 OFFSET ?m_cbCardDataArray@CGameLogic@@1QBEB ; CGameLogic::m_cbCardDataArray
  0001a	8d 45 8c	 lea	 eax, DWORD PTR _cbCardDataTemp$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memcpy
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 248  : 
; 249  : 	//混乱扑克
; 250  : 	BYTE cbRandCount=0,cbPosition=0;

  00026	c6 45 8b 00	 mov	 BYTE PTR _cbRandCount$[ebp], 0
  0002a	c6 45 8a 00	 mov	 BYTE PTR _cbPosition$[ebp], 0
$LN4@RandCardLi:

; 251  : 	do
; 252  : 	{
; 253  : 		cbPosition=rand()%(cbBufferCount-cbRandCount);

  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00034	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbBufferCount$[ebp]
  00038	0f b6 55 8b	 movzx	 edx, BYTE PTR _cbRandCount$[ebp]
  0003c	2b ca		 sub	 ecx, edx
  0003e	99		 cdq
  0003f	f7 f9		 idiv	 ecx
  00041	88 55 8a	 mov	 BYTE PTR _cbPosition$[ebp], dl

; 254  : 		cbCardBuffer[cbRandCount++]=cbCardDataTemp[cbPosition];

  00044	0f b6 45 8a	 movzx	 eax, BYTE PTR _cbPosition$[ebp]
  00048	0f b6 4d 8b	 movzx	 ecx, BYTE PTR _cbRandCount$[ebp]
  0004c	8b 55 08	 mov	 edx, DWORD PTR _cbCardBuffer$[ebp]
  0004f	8a 44 05 8c	 mov	 al, BYTE PTR _cbCardDataTemp$[ebp+eax]
  00053	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00056	8a 4d 8b	 mov	 cl, BYTE PTR _cbRandCount$[ebp]
  00059	80 c1 01	 add	 cl, 1
  0005c	88 4d 8b	 mov	 BYTE PTR _cbRandCount$[ebp], cl

; 255  : 		cbCardDataTemp[cbPosition]=cbCardDataTemp[cbBufferCount-cbRandCount];

  0005f	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbBufferCount$[ebp]
  00063	0f b6 45 8b	 movzx	 eax, BYTE PTR _cbRandCount$[ebp]
  00067	2b d0		 sub	 edx, eax
  00069	0f b6 4d 8a	 movzx	 ecx, BYTE PTR _cbPosition$[ebp]
  0006d	8a 54 15 8c	 mov	 dl, BYTE PTR _cbCardDataTemp$[ebp+edx]
  00071	88 54 0d 8c	 mov	 BYTE PTR _cbCardDataTemp$[ebp+ecx], dl

; 256  : 	} while (cbRandCount<cbBufferCount);

  00075	0f b6 45 8b	 movzx	 eax, BYTE PTR _cbRandCount$[ebp]
  00079	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbBufferCount$[ebp]
  0007d	3b c1		 cmp	 eax, ecx
  0007f	7c ad		 jl	 SHORT $LN4@RandCardLi

; 257  : 
; 258  : 	return;
; 259  : }

  00081	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00084	33 cd		 xor	 ecx, ebp
  00086	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?RandCardList@CGameLogic@@QAEXQAEE@Z ENDP		; CGameLogic::RandCardList
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CGameLogic@@UAE@XZ PROC				; CGameLogic::~CGameLogic
; _this$ = ecx

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGameLogic@@6B@

; 240  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1CGameLogic@@UAE@XZ ENDP				; CGameLogic::~CGameLogic
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CGameLogic@@QAE@XZ PROC				; CGameLogic::CGameLogic
; _this$ = ecx

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGameLogic@@6B@

; 234  : 	m_cbMagicIndex = MAX_INDEX;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c6 41 04 22	 mov	 BYTE PTR [ecx+4], 34	; 00000022H

; 235  : }

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CGameLogic@@QAE@XZ ENDP				; CGameLogic::CGameLogic
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_dwRightHead$ = -8					; size = 4
_i$1 = -1						; size = 1
_dwRight$ = 8						; size = 4
?IsValidRight@CChiHuRight@@AAE_NK@Z PROC		; CChiHuRight::IsValidRight
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 201  : 	DWORD dwRightHead = dwRight & 0xF0000000;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwRight$[ebp]
  0000c	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00011	89 45 f8	 mov	 DWORD PTR _dwRightHead$[ebp], eax

; 202  : 	for(BYTE i = 0; i < CountArray(m_dwRightMask); i++)

  00014	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  00018	eb 09		 jmp	 SHORT $LN4@IsValidRig
$LN2@IsValidRig:
  0001a	8a 4d ff	 mov	 cl, BYTE PTR _i$1[ebp]
  0001d	80 c1 01	 add	 cl, 1
  00020	88 4d ff	 mov	 BYTE PTR _i$1[ebp], cl
$LN4@IsValidRig:
  00023	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  00027	83 fa 01	 cmp	 edx, 1
  0002a	73 16		 jae	 SHORT $LN3@IsValidRig

; 203  : 		if(m_dwRightMask[i] == dwRightHead) return true;

  0002c	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  00030	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?m_dwRightMask@CChiHuRight@@0PAKA[eax*4]
  00037	3b 4d f8	 cmp	 ecx, DWORD PTR _dwRightHead$[ebp]
  0003a	75 04		 jne	 SHORT $LN5@IsValidRig
  0003c	b0 01		 mov	 al, 1
  0003e	eb 04		 jmp	 SHORT $LN1@IsValidRig
$LN5@IsValidRig:

; 204  : 	return false;

  00040	eb d8		 jmp	 SHORT $LN2@IsValidRig
$LN3@IsValidRig:
  00042	32 c0		 xor	 al, al
$LN1@IsValidRig:

; 205  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?IsValidRight@CChiHuRight@@AAE_NK@Z ENDP		; CChiHuRight::IsValidRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwRight$ = 8						; size = 4
_cbRightCount$ = 12					; size = 1
?SetRightData@CChiHuRight@@QAE_NQBKE@Z PROC		; CChiHuRight::SetRightData
; _this$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 	ASSERT(cbRightCount <= CountArray(m_dwRight));
; 190  : 	if(cbRightCount > CountArray(m_dwRight)) return false;

  00007	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbRightCount$[ebp]
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	76 04		 jbe	 SHORT $LN2@SetRightDa
  00010	32 c0		 xor	 al, al
  00012	eb 2a		 jmp	 SHORT $LN1@SetRightDa
$LN2@SetRightDa:

; 191  : 
; 192  : 	ZeroMemory(m_dwRight,sizeof(m_dwRight));

  00014	6a 04		 push	 4
  00016	6a 00		 push	 0
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _memset
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 193  : 	CopyMemory(m_dwRight,dwRight,sizeof(DWORD)*cbRightCount);

  00024	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbRightCount$[ebp]
  00028	c1 e2 02	 shl	 edx, 2
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR _dwRight$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _memcpy
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  : 
; 195  : 	return true;

  0003c	b0 01		 mov	 al, 1
$LN1@SetRightDa:

; 196  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?SetRightData@CChiHuRight@@QAE_NQBKE@Z ENDP		; CChiHuRight::SetRightData
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwRight$ = 8						; size = 4
_cbMaxCount$ = 12					; size = 1
?GetRightData@CChiHuRight@@QAEEQAKE@Z PROC		; CChiHuRight::GetRightData
; _this$ = ecx

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : 	ASSERT(cbMaxCount >= CountArray(m_dwRight));
; 180  : 	if(cbMaxCount < CountArray(m_dwRight)) return 0;

  00007	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbMaxCount$[ebp]
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	73 04		 jae	 SHORT $LN2@GetRightDa
  00010	32 c0		 xor	 al, al
  00012	eb 14		 jmp	 SHORT $LN1@GetRightDa
$LN2@GetRightDa:

; 181  : 
; 182  : 	CopyMemory(dwRight,m_dwRight,sizeof(DWORD)*CountArray(m_dwRight));

  00014	6a 04		 push	 4
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _dwRight$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _memcpy
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 	return CountArray(m_dwRight);

  00026	b0 01		 mov	 al, 1
$LN1@GetRightDa:

; 184  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?GetRightData@CChiHuRight@@QAEEQAKE@Z ENDP		; CChiHuRight::GetRightData
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetEmpty@CChiHuRight@@QAEXXZ PROC			; CChiHuRight::SetEmpty
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 172  : 	ZeroMemory(m_dwRight,sizeof(m_dwRight));

  00007	6a 04		 push	 4
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 173  : 	return;
; 174  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?SetEmpty@CChiHuRight@@QAEXXZ ENDP			; CChiHuRight::SetEmpty
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -1						; size = 1
?IsEmpty@CChiHuRight@@QAE_NXZ PROC			; CChiHuRight::IsEmpty
; _this$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 164  : 	for(BYTE i = 0; i < CountArray(m_dwRight); i++)

  00009	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN4@IsEmpty
$LN2@IsEmpty:
  0000f	8a 45 ff	 mov	 al, BYTE PTR _i$1[ebp]
  00012	04 01		 add	 al, 1
  00014	88 45 ff	 mov	 BYTE PTR _i$1[ebp], al
$LN4@IsEmpty:
  00017	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0001b	83 f9 01	 cmp	 ecx, 1
  0001e	73 13		 jae	 SHORT $LN3@IsEmpty

; 165  : 		if(m_dwRight[i]) return false;

  00020	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  00024	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  0002b	74 04		 je	 SHORT $LN5@IsEmpty
  0002d	32 c0		 xor	 al, al
  0002f	eb 04		 jmp	 SHORT $LN1@IsEmpty
$LN5@IsEmpty:

; 166  : 	return true;

  00031	eb dc		 jmp	 SHORT $LN2@IsEmpty
$LN3@IsEmpty:
  00033	b0 01		 mov	 al, 1
$LN1@IsEmpty:

; 167  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?IsEmpty@CChiHuRight@@QAE_NXZ ENDP			; CChiHuRight::IsEmpty
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_chr$ = 8						; size = 4
??9CChiHuRight@@QBE_NV0@@Z PROC				; CChiHuRight::operator!=
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 158  : 	return !((*this)==chr);

  00009	8b 45 08	 mov	 eax, DWORD PTR _chr$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??8CChiHuRight@@QBE_NV0@@Z ; CChiHuRight::operator==
  00015	0f b6 c8	 movzx	 ecx, al
  00018	85 c9		 test	 ecx, ecx
  0001a	75 09		 jne	 SHORT $LN3@operator
  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00023	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002c	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 159  : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??9CChiHuRight@@QBE_NV0@@Z ENDP				; CChiHuRight::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_chr$ = -4						; size = 4
_dwRight$ = 8						; size = 4
??9CChiHuRight@@QBE_NK@Z PROC				; CChiHuRight::operator!=
; _this$ = ecx

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 150  : 	CChiHuRight chr;

  00009	8d 4d fc	 lea	 ecx, DWORD PTR _chr$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 151  : 	chr = dwRight;

  00011	8b 45 08	 mov	 eax, DWORD PTR _dwRight$[ebp]
  00014	50		 push	 eax
  00015	8d 4d fc	 lea	 ecx, DWORD PTR _chr$[ebp]
  00018	e8 00 00 00 00	 call	 ??4CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator=

; 152  : 	return (*this)!=chr;

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _chr$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??9CChiHuRight@@QBE_NV0@@Z ; CChiHuRight::operator!=

; 153  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??9CChiHuRight@@QBE_NK@Z ENDP				; CChiHuRight::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 2
_chr$ = 8						; size = 4
??8CChiHuRight@@QBE_NV0@@Z PROC				; CChiHuRight::operator==
; _this$ = ecx

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 	for(WORD i = 0; i < CountArray(m_dwRight); i++)

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 45 fc	 mov	 WORD PTR _i$1[ebp], ax
  0000f	eb 0c		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00011	66 8b 4d fc	 mov	 cx, WORD PTR _i$1[ebp]
  00015	66 83 c1 01	 add	 cx, 1
  00019	66 89 4d fc	 mov	 WORD PTR _i$1[ebp], cx
$LN4@operator:
  0001d	0f b7 55 fc	 movzx	 edx, WORD PTR _i$1[ebp]
  00021	83 fa 01	 cmp	 edx, 1
  00024	73 1a		 jae	 SHORT $LN3@operator

; 141  : 	{
; 142  : 		if(m_dwRight[i] != chr.m_dwRight[i]) return false;

  00026	0f b7 45 fc	 movzx	 eax, WORD PTR _i$1[ebp]
  0002a	0f b7 4d fc	 movzx	 ecx, WORD PTR _i$1[ebp]
  0002e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00031	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00034	3b 44 8d 08	 cmp	 eax, DWORD PTR _chr$[ebp+ecx*4]
  00038	74 04		 je	 SHORT $LN5@operator
  0003a	32 c0		 xor	 al, al
  0003c	eb 04		 jmp	 SHORT $LN1@operator
$LN5@operator:

; 143  : 	}

  0003e	eb d1		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 144  : 	return true;

  00040	b0 01		 mov	 al, 1
$LN1@operator:

; 145  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??8CChiHuRight@@QBE_NV0@@Z ENDP				; CChiHuRight::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_chr$ = -4						; size = 4
_dwRight$ = 8						; size = 4
??8CChiHuRight@@QBE_NK@Z PROC				; CChiHuRight::operator==
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 	CChiHuRight chr;

  00009	8d 4d fc	 lea	 ecx, DWORD PTR _chr$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 133  : 	chr = dwRight;

  00011	8b 45 08	 mov	 eax, DWORD PTR _dwRight$[ebp]
  00014	50		 push	 eax
  00015	8d 4d fc	 lea	 ecx, DWORD PTR _chr$[ebp]
  00018	e8 00 00 00 00	 call	 ??4CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator=

; 134  : 	return (*this)==chr;

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _chr$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??8CChiHuRight@@QBE_NV0@@Z ; CChiHuRight::operator==

; 135  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??8CChiHuRight@@QBE_NK@Z ENDP				; CChiHuRight::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_dwRight$ = 12						; size = 4
??UCChiHuRight@@QBE?AV0@K@Z PROC			; CChiHuRight::operator|
; _this$ = ecx

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  : 	CChiHuRight chr = *this;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR _chr$[ebp], ecx

; 126  : 	return chr |= dwRight;

  00011	8b 55 0c	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00014	52		 push	 edx
  00015	8d 4d f8	 lea	 ecx, DWORD PTR _chr$[ebp]
  00018	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 127  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??UCChiHuRight@@QBE?AV0@K@Z ENDP			; CChiHuRight::operator|
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_dwRight$ = 12						; size = 4
??UCChiHuRight@@QAE?AV0@K@Z PROC			; CChiHuRight::operator|
; _this$ = ecx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	CChiHuRight chr = *this;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR _chr$[ebp], ecx

; 119  : 	return chr |= dwRight;

  00011	8b 55 0c	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00014	52		 push	 edx
  00015	8d 4d f8	 lea	 ecx, DWORD PTR _chr$[ebp]
  00018	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 120  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??UCChiHuRight@@QAE?AV0@K@Z ENDP			; CChiHuRight::operator|
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_dwRight$ = 12						; size = 4
??ICChiHuRight@@QBE?AV0@K@Z PROC			; CChiHuRight::operator&
; _this$ = ecx

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 	CChiHuRight chr = *this;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR _chr$[ebp], ecx

; 112  : 	return (chr &= dwRight);

  00011	8b 55 0c	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00014	52		 push	 edx
  00015	8d 4d f8	 lea	 ecx, DWORD PTR _chr$[ebp]
  00018	e8 00 00 00 00	 call	 ??_4CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator&=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 113  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??ICChiHuRight@@QBE?AV0@K@Z ENDP			; CChiHuRight::operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_chr$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_dwRight$ = 12						; size = 4
??ICChiHuRight@@QAE?AV0@K@Z PROC			; CChiHuRight::operator&
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 	CChiHuRight chr = *this;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR _chr$[ebp], ecx

; 105  : 	return (chr &= dwRight);

  00011	8b 55 0c	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00014	52		 push	 edx
  00015	8d 4d f8	 lea	 ecx, DWORD PTR _chr$[ebp]
  00018	e8 00 00 00 00	 call	 ??_4CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator&=
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 106  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??ICChiHuRight@@QAE?AV0@K@Z ENDP			; CChiHuRight::operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -1						; size = 1
_dwRight$ = 8						; size = 4
??_5CChiHuRight@@QAEAAV0@K@Z PROC			; CChiHuRight::operator|=
; _this$ = ecx

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 86   : 	//验证权位
; 87   : 	if(!IsValidRight(dwRight)) return *this;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dwRight$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?IsValidRight@CChiHuRight@@AAE_NK@Z ; CChiHuRight::IsValidRight
  00015	0f b6 c8	 movzx	 ecx, al
  00018	85 c9		 test	 ecx, ecx
  0001a	75 05		 jne	 SHORT $LN5@operator
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	eb 5d		 jmp	 SHORT $LN1@operator
$LN5@operator:

; 88   : 
; 89   : 	for(BYTE i = 0; i < CountArray(m_dwRightMask); i++)

  00021	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00027	8a 55 ff	 mov	 dl, BYTE PTR _i$1[ebp]
  0002a	80 c2 01	 add	 dl, 1
  0002d	88 55 ff	 mov	 BYTE PTR _i$1[ebp], dl
$LN4@operator:
  00030	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  00034	83 f8 01	 cmp	 eax, 1
  00037	73 42		 jae	 SHORT $LN3@operator

; 90   : 	{
; 91   : 		if((dwRight&m_dwRightMask[i]) || (i==0&&dwRight<0x10000000))

  00039	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0003d	8b 55 08	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00040	23 14 8d 00 00
	00 00		 and	 edx, DWORD PTR ?m_dwRightMask@CChiHuRight@@0PAKA[ecx*4]
  00047	75 11		 jne	 SHORT $LN7@operator
  00049	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  0004d	85 c0		 test	 eax, eax
  0004f	75 28		 jne	 SHORT $LN6@operator
  00051	81 7d 08 00 00
	00 10		 cmp	 DWORD PTR _dwRight$[ebp], 268435456 ; 10000000H
  00058	73 1f		 jae	 SHORT $LN6@operator
$LN7@operator:

; 92   : 		{
; 93   : 			m_dwRight[i] |= (dwRight&MASK_CHI_HU_RIGHT);

  0005a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00061	81 e2 ff ff ff
	0f		 and	 edx, 268435455		; 0fffffffH
  00067	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	0b 14 88	 or	 edx, DWORD PTR [eax+ecx*4]
  0006d	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 94   : 			break;

  00077	eb 02		 jmp	 SHORT $LN3@operator
$LN6@operator:

; 95   : 		}
; 96   : 	}

  00079	eb ac		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 97   : 
; 98   : 	return *this;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 99   : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
??_5CChiHuRight@@QAEAAV0@K@Z ENDP			; CChiHuRight::operator|=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_dwTailRight$1 = -16					; size = 4
_dwHeadRight$2 = -12					; size = 4
_this$ = -8						; size = 4
_bNavigate$ = -2					; size = 1
_i$3 = -1						; size = 1
_dwRight$ = 8						; size = 4
??_4CChiHuRight@@QAEAAV0@K@Z PROC			; CChiHuRight::operator&=
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 56   : 	bool bNavigate = false;

  00009	c6 45 fe 00	 mov	 BYTE PTR _bNavigate$[ebp], 0

; 57   : 	//验证权位
; 58   : 	if(!IsValidRight(dwRight))

  0000d	8b 45 08	 mov	 eax, DWORD PTR _dwRight$[ebp]
  00010	50		 push	 eax
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?IsValidRight@CChiHuRight@@AAE_NK@Z ; CChiHuRight::IsValidRight
  00019	0f b6 c8	 movzx	 ecx, al
  0001c	85 c9		 test	 ecx, ecx
  0001e	75 44		 jne	 SHORT $LN5@operator

; 59   : 	{
; 60   : 		//验证取反权位
; 61   : 		ASSERT(IsValidRight(~dwRight));
; 62   : 		if(!IsValidRight(~dwRight)) return *this;

  00020	8b 55 08	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00023	f7 d2		 not	 edx
  00025	52		 push	 edx
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?IsValidRight@CChiHuRight@@AAE_NK@Z ; CChiHuRight::IsValidRight
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	75 08		 jne	 SHORT $LN6@operator
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	e9 9a 00 00 00	 jmp	 $LN1@operator
$LN6@operator:

; 63   : 		//调整权位
; 64   : 		DWORD dwHeadRight = (~dwRight)&0xF0000000;

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  00040	f7 d1		 not	 ecx
  00042	81 e1 00 00 00
	f0		 and	 ecx, -268435456		; f0000000H
  00048	89 4d f4	 mov	 DWORD PTR _dwHeadRight$2[ebp], ecx

; 65   : 		DWORD dwTailRight = dwRight&MASK_CHI_HU_RIGHT;

  0004b	8b 55 08	 mov	 edx, DWORD PTR _dwRight$[ebp]
  0004e	81 e2 ff ff ff
	0f		 and	 edx, 268435455		; 0fffffffH
  00054	89 55 f0	 mov	 DWORD PTR _dwTailRight$1[ebp], edx

; 66   : 		dwRight = dwHeadRight|dwTailRight;

  00057	8b 45 f4	 mov	 eax, DWORD PTR _dwHeadRight$2[ebp]
  0005a	0b 45 f0	 or	 eax, DWORD PTR _dwTailRight$1[ebp]
  0005d	89 45 08	 mov	 DWORD PTR _dwRight$[ebp], eax

; 67   : 		bNavigate = true;

  00060	c6 45 fe 01	 mov	 BYTE PTR _bNavigate$[ebp], 1
$LN5@operator:

; 68   : 	}
; 69   : 
; 70   : 	for(BYTE i = 0; i < CountArray(m_dwRightMask); i++)

  00064	c6 45 ff 00	 mov	 BYTE PTR _i$3[ebp], 0
  00068	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0006a	8a 4d ff	 mov	 cl, BYTE PTR _i$3[ebp]
  0006d	80 c1 01	 add	 cl, 1
  00070	88 4d ff	 mov	 BYTE PTR _i$3[ebp], cl
$LN4@operator:
  00073	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$3[ebp]
  00077	83 fa 01	 cmp	 edx, 1
  0007a	73 58		 jae	 SHORT $LN3@operator

; 71   : 	{
; 72   : 		if((dwRight&m_dwRightMask[i]) || (i==0&&dwRight<0x10000000))

  0007c	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$3[ebp]
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  00083	23 0c 85 00 00
	00 00		 and	 ecx, DWORD PTR ?m_dwRightMask@CChiHuRight@@0PAKA[eax*4]
  0008a	75 11		 jne	 SHORT $LN9@operator
  0008c	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$3[ebp]
  00090	85 d2		 test	 edx, edx
  00092	75 28		 jne	 SHORT $LN7@operator
  00094	81 7d 08 00 00
	00 10		 cmp	 DWORD PTR _dwRight$[ebp], 268435456 ; 10000000H
  0009b	73 1f		 jae	 SHORT $LN7@operator
$LN9@operator:

; 73   : 		{
; 74   : 			m_dwRight[i] &= (dwRight&MASK_CHI_HU_RIGHT);

  0009d	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$3[ebp]
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  000a4	81 e1 ff ff ff
	0f		 and	 ecx, 268435455		; 0fffffffH
  000aa	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ad	23 0c 82	 and	 ecx, DWORD PTR [edx+eax*4]
  000b0	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$3[ebp]
  000b4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b7	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  000ba	eb 16		 jmp	 SHORT $LN8@operator
$LN7@operator:

; 75   : 		}
; 76   : 		else if(!bNavigate)

  000bc	0f b6 45 fe	 movzx	 eax, BYTE PTR _bNavigate$[ebp]
  000c0	85 c0		 test	 eax, eax
  000c2	75 0e		 jne	 SHORT $LN8@operator

; 77   : 			m_dwRight[i] = 0;

  000c4	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$3[ebp]
  000c8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0
$LN8@operator:

; 78   : 	}

  000d2	eb 96		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 79   : 
; 80   : 	return *this;

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 81   : }

  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 04 00	 ret	 4
??_4CChiHuRight@@QAEAAV0@K@Z ENDP			; CChiHuRight::operator&=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
_dwOtherRight$ = -12					; size = 4
_this$ = -8						; size = 4
_i$1 = -1						; size = 1
_dwRight$ = 8						; size = 4
??4CChiHuRight@@QAEAAV0@K@Z PROC			; CChiHuRight::operator=
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 32   : 	DWORD dwOtherRight = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwOtherRight$[ebp], 0

; 33   : 	//验证权位
; 34   : 	if(!IsValidRight(dwRight))

  00010	8b 45 08	 mov	 eax, DWORD PTR _dwRight$[ebp]
  00013	50		 push	 eax
  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?IsValidRight@CChiHuRight@@AAE_NK@Z ; CChiHuRight::IsValidRight
  0001c	0f b6 c8	 movzx	 ecx, al
  0001f	85 c9		 test	 ecx, ecx
  00021	75 29		 jne	 SHORT $LN5@operator

; 35   : 	{
; 36   : 		//验证取反权位
; 37   : 		ASSERT(IsValidRight(~dwRight));
; 38   : 		if(!IsValidRight(~dwRight)) return *this;

  00023	8b 55 08	 mov	 edx, DWORD PTR _dwRight$[ebp]
  00026	f7 d2		 not	 edx
  00028	52		 push	 edx
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?IsValidRight@CChiHuRight@@AAE_NK@Z ; CChiHuRight::IsValidRight
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 05		 jne	 SHORT $LN6@operator
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	eb 6f		 jmp	 SHORT $LN1@operator
$LN6@operator:

; 39   : 		dwRight = ~dwRight;

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  00040	f7 d1		 not	 ecx
  00042	89 4d 08	 mov	 DWORD PTR _dwRight$[ebp], ecx

; 40   : 		dwOtherRight = MASK_CHI_HU_RIGHT;

  00045	c7 45 f4 ff ff
	ff 0f		 mov	 DWORD PTR _dwOtherRight$[ebp], 268435455 ; 0fffffffH
$LN5@operator:

; 41   : 	}
; 42   : 
; 43   : 	for(BYTE i = 0; i < CountArray(m_dwRightMask); i++)

  0004c	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  00050	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00052	8a 55 ff	 mov	 dl, BYTE PTR _i$1[ebp]
  00055	80 c2 01	 add	 dl, 1
  00058	88 55 ff	 mov	 BYTE PTR _i$1[ebp], dl
$LN4@operator:
  0005b	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  0005f	83 f8 01	 cmp	 eax, 1
  00062	73 45		 jae	 SHORT $LN3@operator

; 44   : 	{
; 45   : 		if((dwRight&m_dwRightMask[i]) || (i==0&&dwRight<0x10000000))

  00064	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00068	8b 55 08	 mov	 edx, DWORD PTR _dwRight$[ebp]
  0006b	23 14 8d 00 00
	00 00		 and	 edx, DWORD PTR ?m_dwRightMask@CChiHuRight@@0PAKA[ecx*4]
  00072	75 11		 jne	 SHORT $LN9@operator
  00074	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  00078	85 c0		 test	 eax, eax
  0007a	75 1e		 jne	 SHORT $LN7@operator
  0007c	81 7d 08 00 00
	00 10		 cmp	 DWORD PTR _dwRight$[ebp], 268435456 ; 10000000H
  00083	73 15		 jae	 SHORT $LN7@operator
$LN9@operator:

; 46   : 			m_dwRight[i] = dwRight&MASK_CHI_HU_RIGHT;

  00085	8b 4d 08	 mov	 ecx, DWORD PTR _dwRight$[ebp]
  00088	81 e1 ff ff ff
	0f		 and	 ecx, 268435455		; 0fffffffH
  0008e	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  00092	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  00098	eb 0d		 jmp	 SHORT $LN8@operator
$LN7@operator:

; 47   : 		else m_dwRight[i] = dwOtherRight;

  0009a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  0009e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	8b 45 f4	 mov	 eax, DWORD PTR _dwOtherRight$[ebp]
  000a4	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN8@operator:

; 48   : 	}

  000a7	eb a9		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 49   : 
; 50   : 	return *this;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 51   : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
??4CChiHuRight@@QAEAAV0@K@Z ENDP			; CChiHuRight::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
_TEXT	SEGMENT
tv92 = -16						; size = 8
_this$ = -8						; size = 4
_i$1 = -1						; size = 1
??0CChiHuRight@@QAE@XZ PROC				; CChiHuRight::CChiHuRight
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 14   : 	ZeroMemory(m_dwRight,sizeof(m_dwRight));

  00009	6a 04		 push	 4
  0000b	6a 00		 push	 0
  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15   : 
; 16   : 	if(!m_bInit)

  00019	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?m_bInit@CChiHuRight@@0_NA ; CChiHuRight::m_bInit
  00020	85 c9		 test	 ecx, ecx
  00022	75 67		 jne	 SHORT $LN3@CChiHuRigh

; 17   : 	{
; 18   : 		m_bInit = true;

  00024	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInit@CChiHuRight@@0_NA, 1 ; CChiHuRight::m_bInit

; 19   : 		for(BYTE i = 0; i < CountArray(m_dwRightMask); i++)

  0002b	c6 45 ff 00	 mov	 BYTE PTR _i$1[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@CChiHuRigh
$LN2@CChiHuRigh:
  00031	8a 55 ff	 mov	 dl, BYTE PTR _i$1[ebp]
  00034	80 c2 01	 add	 dl, 1
  00037	88 55 ff	 mov	 BYTE PTR _i$1[ebp], dl
$LN4@CChiHuRigh:
  0003a	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  0003e	83 f8 01	 cmp	 eax, 1
  00041	73 48		 jae	 SHORT $LN3@CChiHuRigh

; 20   : 		{
; 21   : 			if(0 == i)

  00043	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00047	85 c9		 test	 ecx, ecx
  00049	75 11		 jne	 SHORT $LN6@CChiHuRigh

; 22   : 				m_dwRightMask[i] = 0;

  0004b	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$1[ebp]
  0004f	c7 04 95 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ?m_dwRightMask@CChiHuRight@@0PAKA[edx*4], 0

; 23   : 			else

  0005a	eb 2d		 jmp	 SHORT $LN7@CChiHuRigh
$LN6@CChiHuRigh:

; 24   : 				m_dwRightMask[i] = (DWORD(pow(2,i-1)))<<28;

  0005c	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$1[ebp]
  00060	83 e8 01	 sub	 eax, 1
  00063	50		 push	 eax
  00064	6a 02		 push	 2
  00066	e8 00 00 00 00	 call	 ??$pow@HH@@YANHH@Z	; pow<int,int>
  0006b	83 c4 08	 add	 esp, 8
  0006e	dd 5d f0	 fstp	 QWORD PTR tv92[ebp]
  00071	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR tv92[ebp]
  00076	e8 00 00 00 00	 call	 __dtoui3
  0007b	c1 e0 1c	 shl	 eax, 28			; 0000001cH
  0007e	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$1[ebp]
  00082	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?m_dwRightMask@CChiHuRight@@0PAKA[ecx*4], eax
$LN7@CChiHuRigh:

; 25   : 		}

  00089	eb a6		 jmp	 SHORT $LN2@CChiHuRigh
$LN3@CChiHuRigh:

; 26   : 	}
; 27   : }

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
??0CChiHuRight@@QAE@XZ ENDP				; CChiHuRight::CChiHuRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ
text$di	SEGMENT
??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ PROC ; `dynamic initializer for 'ATL::CImage::isCImageStaticInitialized'', COMDAT

; 510  : __declspec(selectany) bool CImage::isCImageStaticInitialized = CImage::CImageStaticInitialize();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?CImageStaticInitialize@CImage@ATL@@CA_NXZ ; ATL::CImage::CImageStaticInitialize
  00008	a2 00 00 00 00	 mov	 BYTE PTR ?isCImageStaticInitialized@CImage@ATL@@0_NA, al ; ATL::CImage::isCImageStaticInitialized
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ ENDP ; `dynamic initializer for 'ATL::CImage::isCImageStaticInitialized''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ
text$yd	SEGMENT
??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ PROC ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
  00008	e8 00 00 00 00	 call	 ??1CDCCache@CImage@ATL@@QAE@XZ ; ATL::CImage::CDCCache::~CDCCache
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ ENDP ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ
text$yd	SEGMENT
??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ PROC ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
  00008	e8 00 00 00 00	 call	 ??1CInitGDIPlus@CImage@ATL@@QAE@XZ ; ATL::CImage::CInitGDIPlus::~CInitGDIPlus
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ ENDP ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?CImageStaticInitialize@CImage@ATL@@CA_NXZ
_TEXT	SEGMENT
?CImageStaticInitialize@CImage@ATL@@CA_NXZ PROC		; ATL::CImage::CImageStaticInitialize, COMDAT

; 501  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 502  : 		GetInitGDIPlusInstance();

  00003	e8 00 00 00 00	 call	 ?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ ; ATL::CImage::GetInitGDIPlusInstance

; 503  : 		GetCDCCacheInstance();

  00008	e8 00 00 00 00	 call	 ?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ ; ATL::CImage::GetCDCCacheInstance

; 504  : 		return true;

  0000d	b0 01		 mov	 al, 1

; 505  : 	}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?CImageStaticInitialize@CImage@ATL@@CA_NXZ ENDP		; ATL::CImage::CImageStaticInitialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ
_TEXT	SEGMENT
?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ PROC ; ATL::CImage::GetCDCCacheInstance, COMDAT

; 495  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 496  : 		static CDCCache cache;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00008	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0000f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00017	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0001d	7e 3a		 jle	 SHORT $LN2@GetCDCCach
  0001f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00024	e8 00 00 00 00	 call	 __Init_thread_header
  00029	83 c4 04	 add	 esp, 4
  0002c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA, -1 ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00033	75 24		 jne	 SHORT $LN2@GetCDCCach
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
  0003a	e8 00 00 00 00	 call	 ??0CDCCache@CImage@ATL@@QAE@XZ ; ATL::CImage::CDCCache::CDCCache
  0003f	68 00 00 00 00	 push	 OFFSET ??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache''
  00044	e8 00 00 00 00	 call	 _atexit
  00049	83 c4 04	 add	 esp, 4
  0004c	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00051	e8 00 00 00 00	 call	 __Init_thread_footer
  00056	83 c4 04	 add	 esp, 4
$LN2@GetCDCCach:

; 497  : 		return &cache;

  00059	b8 00 00 00 00	 mov	 eax, OFFSET ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache

; 498  : 	}

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ ENDP ; ATL::CImage::GetCDCCacheInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ
_TEXT	SEGMENT
?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ PROC ; ATL::CImage::GetInitGDIPlusInstance, COMDAT

; 442  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 		static CInitGDIPlus gdiPlus;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00008	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0000f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00017	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0001d	7e 3a		 jle	 SHORT $LN2@GetInitGDI
  0001f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00024	e8 00 00 00 00	 call	 __Init_thread_header
  00029	83 c4 04	 add	 esp, 4
  0002c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA, -1 ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00033	75 24		 jne	 SHORT $LN2@GetInitGDI
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
  0003a	e8 00 00 00 00	 call	 ??0CInitGDIPlus@CImage@ATL@@QAE@XZ ; ATL::CImage::CInitGDIPlus::CInitGDIPlus
  0003f	68 00 00 00 00	 push	 OFFSET ??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus''
  00044	e8 00 00 00 00	 call	 _atexit
  00049	83 c4 04	 add	 esp, 4
  0004c	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00051	e8 00 00 00 00	 call	 __Init_thread_footer
  00056	83 c4 04	 add	 esp, 4
$LN2@GetInitGDI:

; 444  : 		return &gdiPlus;

  00059	b8 00 00 00 00	 mov	 eax, OFFSET ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus

; 445  : 	}

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ ENDP ; ATL::CImage::GetInitGDIPlusInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ PROC	; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus, COMDAT
; _this$ = ecx

; 570  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 571  : 	EnterCriticalSection(&m_sect);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 572  : 	if( m_dwToken != 0 )

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0001a	74 0b		 je	 SHORT $LN2@ReleaseGDI

; 573  : 	{
; 574  : 		Gdiplus::GdiplusShutdown( m_dwToken );

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _GdiplusShutdown@4
$LN2@ReleaseGDI:

; 575  : 	}
; 576  : 	m_dwToken = 0;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 577  : 	LeaveCriticalSection(&m_sect);

  00030	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00033	83 c2 04	 add	 edx, 4
  00036	52		 push	 edx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 578  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ ENDP	; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??1CInitGDIPlus@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CInitGDIPlus@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CInitGDIPlus::~CInitGDIPlus, COMDAT
; _this$ = ecx

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 543  : 	ReleaseGDIPlus();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ ; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus

; 544  : 	DeleteCriticalSection(&m_sect);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 545  : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1CInitGDIPlus@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CInitGDIPlus::~CInitGDIPlus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??0CInitGDIPlus@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CInitGDIPlus@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CInitGDIPlus::CInitGDIPlus, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 533  : 	m_dwToken( 0 ), m_nCImageObjects( 0 ), m_dwLastError(S_OK)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 535  : 	if (!_AtlInitializeCriticalSectionEx(&m_sect, 0, 0))

  00024	6a 00		 push	 0
  00026	6a 00		 push	 0
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 04	 add	 eax, 4
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	85 c0		 test	 eax, eax
  00039	75 15		 jne	 SHORT $LN1@CInitGDIPl

; 536  : 	{
; 537  : 		m_dwLastError = HRESULT_FROM_WIN32(GetLastError());

  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00047	83 c4 04	 add	 esp, 4
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN1@CInitGDIPl:

; 538  : 	}
; 539  : }

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??0CInitGDIPlus@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CInitGDIPlus::CInitGDIPlus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??1CDCCache@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iDC$ = -4						; size = 4
??1CDCCache@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CDCCache::~CDCCache, COMDAT
; _this$ = ecx

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 607  : 	int iDC;
; 608  : 
; 609  : 	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iDC$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CDCCache
$LN2@CDCCache:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _iDC$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _iDC$[ebp], eax
$LN4@CDCCache:
  0001b	83 7d fc 04	 cmp	 DWORD PTR _iDC$[ebp], 4
  0001f	7d 1e		 jge	 SHORT $LN1@CDCCache

; 610  : 	{
; 611  : 		if( m_ahDCs[iDC] != NULL )

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _iDC$[ebp]
  00024	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00027	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  0002b	74 10		 je	 SHORT $LN5@CDCCache

; 612  : 		{
; 613  : 			::DeleteDC( m_ahDCs[iDC] );

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _iDC$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00036	52		 push	 edx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$LN5@CDCCache:

; 614  : 		}
; 615  : 	}

  0003d	eb d3		 jmp	 SHORT $LN2@CDCCache
$LN1@CDCCache:

; 616  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??1CDCCache@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CDCCache::~CDCCache
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??0CDCCache@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iDC$ = -4						; size = 4
??0CDCCache@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CDCCache::CDCCache, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 597  : 	int iDC;
; 598  : 
; 599  : 	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iDC$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CDCCache
$LN2@CDCCache:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _iDC$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _iDC$[ebp], eax
$LN4@CDCCache:
  0001b	83 7d fc 04	 cmp	 DWORD PTR _iDC$[ebp], 4
  0001f	7d 0f		 jge	 SHORT $LN1@CDCCache

; 600  : 	{
; 601  : 		m_ahDCs[iDC] = NULL;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _iDC$[ebp]
  00024	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00027	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0

; 602  : 	}

  0002e	eb e2		 jmp	 SHORT $LN2@CDCCache
$LN1@CDCCache:

; 603  : }

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??0CDCCache@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CDCCache::CDCCache
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ
text$di	SEGMENT
??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ PROC	; `dynamic initializer for 'ATL::CAtlStringMgr::isInitialized'', COMDAT

; 165  : __declspec(selectany) bool CAtlStringMgr::isInitialized = CAtlStringMgr::StaticInitialize();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ ; ATL::CAtlStringMgr::StaticInitialize
  00008	a2 00 00 00 00	 mov	 BYTE PTR ?isInitialized@CAtlStringMgr@ATL@@0_NA, al ; ATL::CAtlStringMgr::isInitialized
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ ENDP	; `dynamic initializer for 'ATL::CAtlStringMgr::isInitialized''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_nAlign$ = 12						; size = 4
??$AtlAlignUp@H@ATL@@YGHHK@Z PROC			; ATL::AtlAlignUp<int>, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   : 	return( N( (n+(nAlign-1))&~(N( nAlign )-1) ) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _nAlign$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00009	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _nAlign$[ebp]
  00010	83 ea 01	 sub	 edx, 1
  00013	f7 d2		 not	 edx
  00015	23 c2		 and	 eax, edx

; 30   : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$AtlAlignUp@H@ATL@@YGHHK@Z ENDP			; ATL::AtlAlignUp<int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ
text$yd	SEGMENT
??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ PROC ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
  00008	e8 00 00 00 00	 call	 ??1CAtlStringMgr@ATL@@UAE@XZ ; ATL::CAtlStringMgr::~CAtlStringMgr
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ENDP ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ
text$yd	SEGMENT
??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ PROC ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
  00008	e8 00 00 00 00	 call	 ??1CWin32Heap@ATL@@UAE@XZ ; ATL::CWin32Heap::~CWin32Heap
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ENDP ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCAtlStringMgr@ATL@@UAEPAXI@Z PROC			; ATL::CAtlStringMgr::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAtlStringMgr@ATL@@UAE@XZ ; ATL::CAtlStringMgr::~CAtlStringMgr
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 1c		 push	 28			; 0000001cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCAtlStringMgr@ATL@@UAEPAXI@Z ENDP			; ATL::CAtlStringMgr::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ
_TEXT	SEGMENT
?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ PROC	; ATL::CAtlStringMgr::StaticInitialize, COMDAT

; 157  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 		GetInstance();

  00003	e8 00 00 00 00	 call	 ?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::CAtlStringMgr::GetInstance

; 159  : 		return true;

  00008	b0 01		 mov	 al, 1

; 160  : 	}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ ENDP	; ATL::CAtlStringMgr::StaticInitialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ PROC	; ATL::CAtlStringMgr::Clone, COMDAT
; _this$ = ecx

; 148  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 		return this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 150  : 	}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ ENDP	; ATL::CAtlStringMgr::Clone
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ PROC ; ATL::CAtlStringMgr::GetNilString, COMDAT
; _this$ = ecx

; 143  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 144  : 		m_nil.AddRef();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ?AddRef@CStringData@ATL@@QAEXXZ ; ATL::CStringData::AddRef

; 145  : 		return &m_nil;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 08	 add	 eax, 8

; 146  : 	}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ ENDP ; ATL::CAtlStringMgr::GetNilString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT
_nTotalSize$ = -36					; size = 4
_nDataBytes$ = -32					; size = 4
___atl_condVal$1 = -28					; size = 4
___atl_condVal$2 = -24					; size = 4
_this$ = -20						; size = 4
tv77 = -16						; size = 4
tv65 = -12						; size = 4
_pNewData$ = -8						; size = 4
_nAlignedChars$ = -4					; size = 4
_pData$ = 8						; size = 4
_nChars$ = 12						; size = 4
_nCharSize$ = 16					; size = 4
?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z PROC ; ATL::CAtlStringMgr::Reallocate, COMDAT
; _this$ = ecx

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@Reallocate:

; 113  : 		ATLENSURE_RETURN_VAL( nChars>=0, NULL );

  00009	83 7d 0c 00	 cmp	 DWORD PTR _nChars$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN15@Reallocate
  0000f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00016	eb 07		 jmp	 SHORT $LN16@Reallocate
$LN15@Reallocate:
  00018	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN16@Reallocate:
  0001f	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]
  00022	89 45 e8	 mov	 DWORD PTR ___atl_condVal$2[ebp], eax
  00025	83 7d e8 00	 cmp	 DWORD PTR ___atl_condVal$2[ebp], 0
  00029	75 07		 jne	 SHORT $LN2@Reallocate
  0002b	33 c0		 xor	 eax, eax
  0002d	e9 c4 00 00 00	 jmp	 $LN1@Reallocate
$LN2@Reallocate:
  00032	33 c9		 xor	 ecx, ecx
  00034	75 d3		 jne	 SHORT $LN4@Reallocate

; 114  : 		ATLASSERT( pData->pStringMgr == this );
; 115  : 
; 116  : 		CStringData* pNewData;
; 117  : 		ULONG nTotalSize;
; 118  : 		ULONG nDataBytes;
; 119  : 
; 120  : 		if( FAILED(::ATL::AtlAdd(&nChars, nChars, 1)) )

  00036	6a 01		 push	 1
  00038	8b 55 0c	 mov	 edx, DWORD PTR _nChars$[ebp]
  0003b	52		 push	 edx
  0003c	8d 45 0c	 lea	 eax, DWORD PTR _nChars$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$AtlAdd@H@ATL@@YAJPAHHH@Z ; ATL::AtlAdd<int>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	85 c0		 test	 eax, eax
  0004a	7d 07		 jge	 SHORT $LN9@Reallocate

; 121  : 		{
; 122  : 			return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 a3 00 00 00	 jmp	 $LN1@Reallocate
$LN9@Reallocate:

; 123  : 		}
; 124  : 
; 125  : 		int nAlignedChars = ::ATL::AtlAlignUp( nChars, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

  00053	6a 08		 push	 8
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$AtlAlignUp@H@ATL@@YGHHK@Z ; ATL::AtlAlignUp<int>
  0005e	89 45 fc	 mov	 DWORD PTR _nAlignedChars$[ebp], eax
$LN7@Reallocate:

; 126  : 		ATLENSURE_RETURN_VAL( nChars<=nAlignedChars, NULL );

  00061	8b 55 0c	 mov	 edx, DWORD PTR _nChars$[ebp]
  00064	3b 55 fc	 cmp	 edx, DWORD PTR _nAlignedChars$[ebp]
  00067	7f 09		 jg	 SHORT $LN17@Reallocate
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN18@Reallocate
$LN17@Reallocate:
  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN18@Reallocate:
  00079	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0007c	89 45 e4	 mov	 DWORD PTR ___atl_condVal$1[ebp], eax
  0007f	83 7d e4 00	 cmp	 DWORD PTR ___atl_condVal$1[ebp], 0
  00083	75 04		 jne	 SHORT $LN5@Reallocate
  00085	33 c0		 xor	 eax, eax
  00087	eb 6d		 jmp	 SHORT $LN1@Reallocate
$LN5@Reallocate:
  00089	33 c9		 xor	 ecx, ecx
  0008b	75 d4		 jne	 SHORT $LN7@Reallocate

; 127  : 
; 128  : 		if(	FAILED(::ATL::AtlMultiply(&nDataBytes, static_cast<ULONG>(nAlignedChars), static_cast<ULONG>(nCharSize))) ||

  0008d	8b 55 10	 mov	 edx, DWORD PTR _nCharSize$[ebp]
  00090	52		 push	 edx
  00091	8b 45 fc	 mov	 eax, DWORD PTR _nAlignedChars$[ebp]
  00094	50		 push	 eax
  00095	8d 4d e0	 lea	 ecx, DWORD PTR _nDataBytes$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ??$AtlMultiply@K@ATL@@YAJPAKKK@Z ; ATL::AtlMultiply<unsigned long>
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	85 c0		 test	 eax, eax
  000a3	7c 16		 jl	 SHORT $LN12@Reallocate
  000a5	8b 55 e0	 mov	 edx, DWORD PTR _nDataBytes$[ebp]
  000a8	52		 push	 edx
  000a9	6a 10		 push	 16			; 00000010H
  000ab	8d 45 dc	 lea	 eax, DWORD PTR _nTotalSize$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??$AtlAdd@K@ATL@@YAJPAKKK@Z ; ATL::AtlAdd<unsigned long>
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	85 c0		 test	 eax, eax
  000b9	7d 04		 jge	 SHORT $LN11@Reallocate
$LN12@Reallocate:

; 129  : 			FAILED(::ATL::AtlAdd(&nTotalSize, static_cast<ULONG>(sizeof( CStringData )), nDataBytes)))
; 130  : 		{
; 131  : 			return NULL;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 37		 jmp	 SHORT $LN1@Reallocate
$LN11@Reallocate:

; 132  : 		}
; 133  : 		pNewData = static_cast< CStringData* >( m_pMemMgr->Reallocate( pData, nTotalSize ) );

  000bf	8b 4d dc	 mov	 ecx, DWORD PTR _nTotalSize$[ebp]
  000c2	51		 push	 ecx
  000c3	8b 55 08	 mov	 edx, DWORD PTR _pData$[ebp]
  000c6	52		 push	 edx
  000c7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000d0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d2	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000d5	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000d8	ff d2		 call	 edx
  000da	89 45 f8	 mov	 DWORD PTR _pNewData$[ebp], eax

; 134  : 		if( pNewData == NULL )

  000dd	83 7d f8 00	 cmp	 DWORD PTR _pNewData$[ebp], 0
  000e1	75 04		 jne	 SHORT $LN13@Reallocate

; 135  : 		{
; 136  : 			return NULL;

  000e3	33 c0		 xor	 eax, eax
  000e5	eb 0f		 jmp	 SHORT $LN1@Reallocate
$LN13@Reallocate:

; 137  : 		}
; 138  : 		pNewData->nAllocLength = nAlignedChars - 1;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _nAlignedChars$[ebp]
  000ea	83 e8 01	 sub	 eax, 1
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  000f0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 139  : 
; 140  : 		return pNewData;

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _pNewData$[ebp]
$LN1@Reallocate:

; 141  : 	}

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z ENDP ; ATL::CAtlStringMgr::Reallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pData$ = 8						; size = 4
?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z PROC	; ATL::CAtlStringMgr::Free, COMDAT
; _this$ = ecx

; 102  : 	{		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Free:

; 103  : 		ATLASSUME(pData != NULL);

  00007	33 c0		 xor	 eax, eax
  00009	75 fc		 jne	 SHORT $LN2@Free

; 104  : 		ATLASSERT(pData->pStringMgr == this);
; 105  : 			
; 106  : 		m_pMemMgr->Free( pData );

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00020	ff d0		 call	 eax

; 107  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z ENDP	; ATL::CAtlStringMgr::Free
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT
_nTotalSize$ = -36					; size = 4
_nDataBytes$ = -32					; size = 4
___atl_condVal$1 = -28					; size = 4
___atl_condVal$2 = -24					; size = 4
tv77 = -20						; size = 4
tv65 = -16						; size = 4
_nAlignedChars$ = -12					; size = 4
_this$ = -8						; size = 4
_pData$ = -4						; size = 4
_nChars$ = 8						; size = 4
_nCharSize$ = 12					; size = 4
?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z PROC ; ATL::CAtlStringMgr::Allocate, COMDAT
; _this$ = ecx

; 69   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@Allocate:

; 70   : 		ATLENSURE_RETURN_VAL( nChars>=0, NULL );

  00009	83 7d 08 00	 cmp	 DWORD PTR _nChars$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN15@Allocate
  0000f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00016	eb 07		 jmp	 SHORT $LN16@Allocate
$LN15@Allocate:
  00018	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN16@Allocate:
  0001f	8b 45 f0	 mov	 eax, DWORD PTR tv65[ebp]
  00022	89 45 e8	 mov	 DWORD PTR ___atl_condVal$2[ebp], eax
  00025	83 7d e8 00	 cmp	 DWORD PTR ___atl_condVal$2[ebp], 0
  00029	75 07		 jne	 SHORT $LN2@Allocate
  0002b	33 c0		 xor	 eax, eax
  0002d	e9 de 00 00 00	 jmp	 $LN1@Allocate
$LN2@Allocate:
  00032	33 c9		 xor	 ecx, ecx
  00034	75 d3		 jne	 SHORT $LN4@Allocate

; 71   : 
; 72   : 		size_t nTotalSize;
; 73   : 		CStringData* pData;
; 74   : 		size_t nDataBytes;
; 75   : 
; 76   : 		if( FAILED(::ATL::AtlAdd(&nChars, nChars, 1)) )

  00036	6a 01		 push	 1
  00038	8b 55 08	 mov	 edx, DWORD PTR _nChars$[ebp]
  0003b	52		 push	 edx
  0003c	8d 45 08	 lea	 eax, DWORD PTR _nChars$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$AtlAdd@H@ATL@@YAJPAHHH@Z ; ATL::AtlAdd<int>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	85 c0		 test	 eax, eax
  0004a	7d 07		 jge	 SHORT $LN9@Allocate

; 77   : 		{
; 78   : 			return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 bd 00 00 00	 jmp	 $LN1@Allocate
$LN9@Allocate:

; 79   : 		}
; 80   : 
; 81   : 		int nAlignedChars = ::ATL::AtlAlignUp( nChars, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

  00053	6a 08		 push	 8
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$AtlAlignUp@H@ATL@@YGHHK@Z ; ATL::AtlAlignUp<int>
  0005e	89 45 f4	 mov	 DWORD PTR _nAlignedChars$[ebp], eax
$LN7@Allocate:

; 82   : 		ATLENSURE_RETURN_VAL( nChars<=nAlignedChars, NULL );

  00061	8b 55 08	 mov	 edx, DWORD PTR _nChars$[ebp]
  00064	3b 55 f4	 cmp	 edx, DWORD PTR _nAlignedChars$[ebp]
  00067	7f 09		 jg	 SHORT $LN17@Allocate
  00069	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN18@Allocate
$LN17@Allocate:
  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN18@Allocate:
  00079	8b 45 ec	 mov	 eax, DWORD PTR tv77[ebp]
  0007c	89 45 e4	 mov	 DWORD PTR ___atl_condVal$1[ebp], eax
  0007f	83 7d e4 00	 cmp	 DWORD PTR ___atl_condVal$1[ebp], 0
  00083	75 07		 jne	 SHORT $LN5@Allocate
  00085	33 c0		 xor	 eax, eax
  00087	e9 84 00 00 00	 jmp	 $LN1@Allocate
$LN5@Allocate:
  0008c	33 c9		 xor	 ecx, ecx
  0008e	75 d1		 jne	 SHORT $LN7@Allocate

; 83   : 
; 84   : 		if(	FAILED(::ATL::AtlMultiply(&nDataBytes, static_cast<size_t>(nAlignedChars), static_cast<size_t>(nCharSize))) ||

  00090	8b 55 0c	 mov	 edx, DWORD PTR _nCharSize$[ebp]
  00093	52		 push	 edx
  00094	8b 45 f4	 mov	 eax, DWORD PTR _nAlignedChars$[ebp]
  00097	50		 push	 eax
  00098	8d 4d e0	 lea	 ecx, DWORD PTR _nDataBytes$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	85 c0		 test	 eax, eax
  000a6	7c 16		 jl	 SHORT $LN12@Allocate
  000a8	8b 55 e0	 mov	 edx, DWORD PTR _nDataBytes$[ebp]
  000ab	52		 push	 edx
  000ac	6a 10		 push	 16			; 00000010H
  000ae	8d 45 dc	 lea	 eax, DWORD PTR _nTotalSize$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??$AtlAdd@I@ATL@@YAJPAIII@Z ; ATL::AtlAdd<unsigned int>
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	85 c0		 test	 eax, eax
  000bc	7d 04		 jge	 SHORT $LN11@Allocate
$LN12@Allocate:

; 85   : 			FAILED(::ATL::AtlAdd(&nTotalSize, static_cast<size_t>(sizeof( CStringData )), nDataBytes)))
; 86   : 		{
; 87   : 			return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	eb 4e		 jmp	 SHORT $LN1@Allocate
$LN11@Allocate:

; 88   : 		}
; 89   : 		pData = static_cast< CStringData* >( m_pMemMgr->Allocate( nTotalSize ) );

  000c2	8b 4d dc	 mov	 ecx, DWORD PTR _nTotalSize$[ebp]
  000c5	51		 push	 ecx
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	8b 10		 mov	 edx, DWORD PTR [eax]
  000d1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000d4	8b 02		 mov	 eax, DWORD PTR [edx]
  000d6	ff d0		 call	 eax
  000d8	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 90   : 		if( pData == NULL )

  000db	83 7d fc 00	 cmp	 DWORD PTR _pData$[ebp], 0
  000df	75 04		 jne	 SHORT $LN13@Allocate

; 91   : 		{
; 92   : 			return( NULL );

  000e1	33 c0		 xor	 eax, eax
  000e3	eb 2b		 jmp	 SHORT $LN1@Allocate
$LN13@Allocate:

; 93   : 		}
; 94   : 		pData->pStringMgr = this;

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000e8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	89 11		 mov	 DWORD PTR [ecx], edx

; 95   : 		pData->nRefs = 1;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000f0	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 96   : 		pData->nAllocLength = nAlignedChars - 1;

  000f7	8b 4d f4	 mov	 ecx, DWORD PTR _nAlignedChars$[ebp]
  000fa	83 e9 01	 sub	 ecx, 1
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00100	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 97   : 		pData->nDataLength = 0;

  00103	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00106	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 98   : 
; 99   : 		return( pData );

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
$LN1@Allocate:

; 100  : 	}

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 08 00	 ret	 8
?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z ENDP ; ATL::CAtlStringMgr::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ PROC ; ATL::CAtlStringMgr::GetInstance, COMDAT

; 55   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : #pragma warning(push)
; 57   : #pragma warning(disable: 4640)
; 58   : 		static CWin32Heap strHeap( ::GetProcessHeap() );

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00008	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0000f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00017	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0001d	7e 41		 jle	 SHORT $LN2@GetInstanc
  0001f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00024	e8 00 00 00 00	 call	 __Init_thread_header
  00029	83 c4 04	 add	 esp, 4
  0002c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA, -1 ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00033	75 2b		 jne	 SHORT $LN2@GetInstanc
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0003b	50		 push	 eax
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
  00041	e8 00 00 00 00	 call	 ??0CWin32Heap@ATL@@QAE@PAX@Z ; ATL::CWin32Heap::CWin32Heap
  00046	68 00 00 00 00	 push	 OFFSET ??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap''
  0004b	e8 00 00 00 00	 call	 _atexit
  00050	83 c4 04	 add	 esp, 4
  00053	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00058	e8 00 00 00 00	 call	 __Init_thread_footer
  0005d	83 c4 04	 add	 esp, 4
$LN2@GetInstanc:

; 59   : 		static CAtlStringMgr strMgr(&strHeap);

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  00066	64 8b 15 00 00
	00 00		 mov	 edx, DWORD PTR fs:__tls_array
  0006d	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00076	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  0007c	7e 3f		 jle	 SHORT $LN3@GetInstanc
  0007e	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00083	e8 00 00 00 00	 call	 __Init_thread_header
  00088	83 c4 04	 add	 esp, 4
  0008b	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA, -1 ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00092	75 29		 jne	 SHORT $LN3@GetInstanc
  00094	68 00 00 00 00	 push	 OFFSET ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
  0009e	e8 00 00 00 00	 call	 ??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z ; ATL::CAtlStringMgr::CAtlStringMgr
  000a3	68 00 00 00 00	 push	 OFFSET ??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr''
  000a8	e8 00 00 00 00	 call	 _atexit
  000ad	83 c4 04	 add	 esp, 4
  000b0	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  000b5	e8 00 00 00 00	 call	 __Init_thread_footer
  000ba	83 c4 04	 add	 esp, 4
$LN3@GetInstanc:

; 60   : #pragma warning(pop)
; 61   : 
; 62   : 		return &strMgr;

  000bd	b8 00 00 00 00	 mov	 eax, OFFSET ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr

; 63   : 	}

  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ ENDP ; ATL::CAtlStringMgr::GetInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CAtlStringMgr@ATL@@UAE@XZ PROC			; ATL::CAtlStringMgr::~CAtlStringMgr, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAtlStringMgr@ATL@@6B@

; 45   : 		isInitialized = false;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?isInitialized@CAtlStringMgr@ATL@@0_NA, 0 ; ATL::CAtlStringMgr::isInitialized

; 46   : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1CAtlStringMgr@ATL@@UAE@XZ ENDP			; ATL::CAtlStringMgr::~CAtlStringMgr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pMemMgr$ = 8						; size = 4
??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z PROC	; ATL::CAtlStringMgr::CAtlStringMgr, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAtlStringMgr@ATL@@6B@

; 39   : 		m_pMemMgr( pMemMgr )

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _pMemMgr$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 40   : 	{

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	e8 00 00 00 00	 call	 ??0CNilStringData@ATL@@QAE@XZ ; ATL::CNilStringData::CNilStringData

; 41   : 		m_nil.SetManager( this );

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	83 c1 08	 add	 ecx, 8
  0002e	e8 00 00 00 00	 call	 ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z ; ATL::CNilStringData::SetManager

; 42   : 	}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z ENDP	; ATL::CAtlStringMgr::CAtlStringMgr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00008	e8 00 00 00 00	 call	 ??1CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::~CAtlWinModule
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2815 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00008	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  0000d	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2799 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2800 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A ; ATL::_AtlBaseModule
  0000c	e8 00 00 00 00	 call	 ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
  00011	50		 push	 eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2801 : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2794 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2795 : 		Term();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Term@CAtlWinModule@ATL@@QAEXXZ ; ATL::CAtlWinModule::Term

; 2796 : 	}

  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2780 : 	CAtlWinModule()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2781 : 	{

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2782 : 		cbSize = sizeof(_ATL_WIN_MODULE);

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 2c 00 00
	00		 mov	 DWORD PTR [eax], 44	; 0000002cH

; 2783 : 		HRESULT hr = AtlWinModuleInit(this);

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
  00023	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2784 : 		if (FAILED(hr))

  00026	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002a	7d 10		 jge	 SHORT $LN1@CAtlWinMod

; 2785 : 		{
; 2786 : 			ATLASSERT(0);
; 2787 : 			CAtlBaseModule::m_bInitFailed = true;

  0002c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2788 : 			cbSize = 0;

  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN1@CAtlWinMod:

; 2789 : 			return;
; 2790 : 		}
; 2791 : 	}

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00008	e8 00 00 00 00	 call	 ??1CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::~CAtlComModule
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2559 : __declspec(selectany) CAtlComModule _AtlComModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00008	e8 00 00 00 00	 call	 ??0CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::CAtlComModule
  0000d	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_factory$1 = -16					; size = 4
_pCache$2 = -12						; size = 4
_this$ = -8						; size = 4
_ppEntry$3 = -4						; size = 4
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2456 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2457 : 		if (cbSize == 0)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 02		 jne	 SHORT $LN5@Term

; 2458 : 			return;

  00011	eb 76		 jmp	 SHORT $LN1@Term
$LN5@Term:

; 2459 : 
; 2460 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	89 55 fc	 mov	 DWORD PTR _ppEntry$3[ebp], edx
  0001c	eb 09		 jmp	 SHORT $LN4@Term
$LN2@Term:
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _ppEntry$3[ebp]
  00021	83 c0 04	 add	 eax, 4
  00024	89 45 fc	 mov	 DWORD PTR _ppEntry$3[ebp], eax
$LN4@Term:
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _ppEntry$3[ebp]
  0002d	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00030	73 43		 jae	 SHORT $LN3@Term

; 2461 : 		{
; 2462 : 			if (*ppEntry != NULL)

  00032	8b 45 fc	 mov	 eax, DWORD PTR _ppEntry$3[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 39		 je	 SHORT $LN6@Term

; 2463 : 			{
; 2464 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _ppEntry$3[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00042	89 45 f4	 mov	 DWORD PTR _pCache$2[ebp], eax

; 2465 : 				
; 2466 : 				if (pCache->pCF != NULL)

  00045	8b 4d f4	 mov	 ecx, DWORD PTR _pCache$2[ebp]
  00048	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0004b	74 26		 je	 SHORT $LN6@Term

; 2467 : 				{
; 2468 : 					// Decode factory pointer if it's not null
; 2469 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _pCache$2[ebp]
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	50		 push	 eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4
  00059	89 45 f0	 mov	 DWORD PTR _factory$1[ebp], eax

; 2470 : 					_Analysis_assume_(factory != nullptr);
; 2471 : 					factory->Release();					

  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _factory$1[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	8b 45 f0	 mov	 eax, DWORD PTR _factory$1[ebp]
  00064	50		 push	 eax
  00065	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00068	ff d1		 call	 ecx

; 2472 : 					pCache->pCF = NULL;

  0006a	8b 55 f4	 mov	 edx, DWORD PTR _pCache$2[ebp]
  0006d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN6@Term:

; 2473 : 				}				
; 2474 : 			}
; 2475 : 		}

  00073	eb a9		 jmp	 SHORT $LN2@Term
$LN3@Term:

; 2476 : 		m_csObjMap.Term();

  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	83 c1 10	 add	 ecx, 16			; 00000010H
  0007b	e8 00 00 00 00	 call	 ?Term@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Term

; 2477 : 		// Set to 0 to indicate that this function has been called
; 2478 : 		// At this point no one should be concerned about cbsize
; 2479 : 		// having the correct value
; 2480 : 		cbSize = 0;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Term:

; 2481 : 	}

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2450 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlComModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2451 : 		Term();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term

; 2452 : 	}

  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2429 : 	CAtlComModule() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2430 : 	{

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_ATL_COM_MODULE70@ATL@@QAE@XZ

; 2431 : 		cbSize = 0;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2432 : 
; 2433 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ___ImageBase

; 2434 : 
; 2435 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 08 04 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET ___pobjMapEntryFirst+4

; 2436 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ___pobjMapEntryLast

; 2437 : 
; 2438 : 		if (FAILED(m_csObjMap.Init()))

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 10	 add	 ecx, 16			; 00000010H
  0003c	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  00041	85 c0		 test	 eax, eax
  00043	7d 09		 jge	 SHORT $LN2@CAtlComMod

; 2439 : 		{
; 2440 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2441 : 			ATLASSERT(0);
; 2442 : 			CAtlBaseModule::m_bInitFailed = true;

  00045	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2443 : 			return;

  0004c	eb 09		 jmp	 SHORT $LN1@CAtlComMod
$LN2@CAtlComMod:

; 2444 : 		}
; 2445 : 		// Set cbSize on success.
; 2446 : 		cbSize = sizeof(_ATL_COM_MODULE);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	c7 01 28 00 00
	00		 mov	 DWORD PTR [ecx], 40	; 00000028H
$LN1@CAtlComMod:

; 2447 : 	}

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7650 : 	if (pWinModule == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00008	75 07		 jne	 SHORT $LN5@AtlWinModu

; 7651 : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0000f	eb 7d		 jmp	 SHORT $LN1@AtlWinModu
$LN5@AtlWinModu:

; 7652 : 	if (pWinModule->cbSize == 0)

  00011	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	75 04		 jne	 SHORT $LN6@AtlWinModu

; 7653 : 		return S_OK;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 71		 jmp	 SHORT $LN1@AtlWinModu
$LN6@AtlWinModu:

; 7654 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00020	83 39 2c	 cmp	 DWORD PTR [ecx], 44	; 0000002cH
  00023	74 07		 je	 SHORT $LN7@AtlWinModu

; 7655 : 		return E_INVALIDARG;

  00025	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0002a	eb 62		 jmp	 SHORT $LN1@AtlWinModu
$LN7@AtlWinModu:

; 7656 : 
; 7657 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00033	eb 09		 jmp	 SHORT $LN4@AtlWinModu
$LN2@AtlWinModu:
  00035	8b 55 fc	 mov	 edx, DWORD PTR _i$1[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 fc	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@AtlWinModu:
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00041	83 c1 20	 add	 ecx, 32			; 00000020H
  00044	e8 00 00 00 00	 call	 ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
  00049	39 45 fc	 cmp	 DWORD PTR _i$1[ebp], eax
  0004c	7d 1f		 jge	 SHORT $LN3@AtlWinModu

; 7658 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _hInst$[ebp]
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00055	51		 push	 ecx
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00059	83 c1 20	 add	 ecx, 32			; 00000020H
  0005c	e8 00 00 00 00	 call	 ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
  00061	0f b7 10	 movzx	 edx, WORD PTR [eax]
  00064	52		 push	 edx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassW@8
  0006b	eb c8		 jmp	 SHORT $LN2@AtlWinModu
$LN3@AtlWinModu:

; 7659 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00070	83 c1 20	 add	 ecx, 32			; 00000020H
  00073	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 7660 : 	pWinModule->m_csWindowCreate.Term();

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0007b	83 c1 04	 add	 ecx, 4
  0007e	e8 00 00 00 00	 call	 ?Term@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Term

; 7661 : 	pWinModule->cbSize = 0;

  00083	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 7662 : 	return S_OK;

  0008c	33 c0		 xor	 eax, eax
$LN1@AtlWinModu:

; 7663 : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8394 : 	if (pWinModule == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00008	75 07		 jne	 SHORT $LN2@AtlWinModu

; 8395 : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0000f	eb 2a		 jmp	 SHORT $LN1@AtlWinModu
$LN2@AtlWinModu:

; 8396 : 
; 8397 : 	// check only in the DLL
; 8398 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00011	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00014	83 38 2c	 cmp	 DWORD PTR [eax], 44	; 0000002cH
  00017	74 07		 je	 SHORT $LN3@AtlWinModu

; 8399 : 		return E_INVALIDARG;

  00019	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001e	eb 1b		 jmp	 SHORT $LN1@AtlWinModu
$LN3@AtlWinModu:

; 8400 : 
; 8401 : 	pWinModule->m_pCreateWndList = NULL;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00023	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 8402 : 
; 8403 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0002d	83 c1 04	 add	 ecx, 4
  00030	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  00035	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8404 : 	if (FAILED(hr))
; 8405 : 	{
; 8406 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
; 8407 : 		ATLASSERT(0);
; 8408 : 	}
; 8409 : 	return hr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$LN1@AtlWinModu:

; 8410 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	e8 00 00 00 00	 call	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 04	 add	 ecx, 4
  0002c	e8 00 00 00 00	 call	 ??0CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::CComCriticalSection
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 20	 add	 ecx, 32			; 00000020H
  0003e	e8 00 00 00 00	 call	 ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  00043	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 0b		 jl	 SHORT $LN3@operator
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00016	7c 0c		 jl	 SHORT $LN2@operator
$LN3@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 01		 push	 1
  0001a	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0001f	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN2@operator:

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0002c	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
$LN4@operator:

; 243  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 		if(m_aT != NULL)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 37		 je	 SHORT $LN5@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)

  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00018	eb 09		 jmp	 SHORT $LN4@RemoveAll
$LN2@RemoveAll:
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0001d	83 c1 01	 add	 ecx, 1
  00020	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0002c	7d 02		 jge	 SHORT $LN3@RemoveAll

; 219  : 				m_aT[i].~T();

  0002e	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN3@RemoveAll:

; 220  : 			free(m_aT);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN5@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 224  : 		m_nAllocSize = 0;

  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 225  :     }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 160  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 		return m_nSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 162  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 311  : 	RemoveAll();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 312  : }

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 120  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 121  : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??0CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::CComCriticalSection
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\afx.inl
;	COMDAT ?_AfxInitManaged@@YAHXZ
_TEXT	SEGMENT
?_AfxInitManaged@@YAHXZ PROC				; _AfxInitManaged, COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : 	return 0;

  00003	33 c0		 xor	 eax, eax

; 78   : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
?_AfxInitManaged@@YAHXZ ENDP				; _AfxInitManaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pMgr$ = 8						; size = 4
?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z PROC ; ATL::CNilStringData::SetManager, COMDAT
; _this$ = ecx

; 123  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 		ATLASSERT( pStringMgr == NULL );
; 125  : 		pStringMgr = pMgr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pMgr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 126  : 	}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z ENDP ; ATL::CNilStringData::SetManager
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpstr.h
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CNilStringData@ATL@@QAE@XZ PROC			; ATL::CNilStringData::CNilStringData, COMDAT
; _this$ = ecx

; 112  : 	CNilStringData() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	{
; 114  : 		pStringMgr = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 115  : 		nRefs = 2;  // Never gets freed by IAtlStringMgr

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 0c 02 00
	00 00		 mov	 DWORD PTR [ecx+12], 2

; 116  : 		nDataLength = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 117  : 		nAllocLength = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 118  : 		achNil[0] = 0;

  0002e	b9 02 00 00 00	 mov	 ecx, 2
  00033	6b d1 00	 imul	 edx, ecx, 0
  00036	33 c0		 xor	 eax, eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	66 89 44 11 10	 mov	 WORD PTR [ecx+edx+16], ax

; 119  : 		achNil[1] = 0;

  00040	ba 02 00 00 00	 mov	 edx, 2
  00045	c1 e2 00	 shl	 edx, 0
  00048	33 c0		 xor	 eax, eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	66 89 44 11 10	 mov	 WORD PTR [ecx+edx+16], ax

; 120  : 	}

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??0CNilStringData@ATL@@QAE@XZ ENDP			; ATL::CNilStringData::CNilStringData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpstr.h
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AddRef@CStringData@ATL@@QAEXXZ PROC			; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 63   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 		ATLASSERT(nRefs > 0);
; 65   : 		_InterlockedIncrement(&nRefs);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0000d	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 66   : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@H@ATL@@YAJPAHHH@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@H@ATL@@YAJPAHHH@Z PROC			; ATL::AtlAdd<int>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00008	2b 45 0c	 sub	 eax, DWORD PTR _tLeft$[ebp]
  0000b	3b 45 10	 cmp	 eax, DWORD PTR _tRight$[ebp]
  0000e	7d 0f		 jge	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00010	68 16 02 00 00	 push	 534			; 00000216H
  00015	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  0001a	83 c4 04	 add	 esp, 4
  0001d	eb 0d		 jmp	 SHORT $LN1@AtlAdd
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00022	03 4d 10	 add	 ecx, DWORD PTR _tRight$[ebp]
  00025	8b 55 08	 mov	 edx, DWORD PTR _ptResult$[ebp]
  00028	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 	return S_OK;

  0002a	33 c0		 xor	 eax, eax
$LN1@AtlAdd:

; 106  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$AtlAdd@H@ATL@@YAJPAHHH@Z ENDP			; ATL::AtlAdd<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlAdd<unsigned int>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	83 c8 ff	 or	 eax, -1
  00006	2b 45 0c	 sub	 eax, DWORD PTR _tLeft$[ebp]
  00009	3b 45 10	 cmp	 eax, DWORD PTR _tRight$[ebp]
  0000c	73 0f		 jae	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0000e	68 16 02 00 00	 push	 534			; 00000216H
  00013	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00018	83 c4 04	 add	 esp, 4
  0001b	eb 0d		 jmp	 SHORT $LN1@AtlAdd
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00020	03 4d 10	 add	 ecx, DWORD PTR _tRight$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR _ptResult$[ebp]
  00026	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 	return S_OK;

  00028	33 c0		 xor	 eax, eax
$LN1@AtlAdd:

; 106  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$AtlAdd@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlAdd<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCWin32Heap@ATL@@UAEPAXI@Z PROC			; ATL::CWin32Heap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CWin32Heap@ATL@@UAE@XZ ; ATL::CWin32Heap::~CWin32Heap
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCWin32Heap@ATL@@UAEPAXI@Z ENDP			; ATL::CWin32Heap::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?GetSize@CWin32Heap@ATL@@UAEIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?GetSize@CWin32Heap@ATL@@UAEIPAX@Z PROC			; ATL::CWin32Heap::GetSize, COMDAT
; _this$ = ecx

; 175  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  : 		return( ::HeapSize( m_hHeap, 0, p ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapSize@12

; 177  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?GetSize@CWin32Heap@ATL@@UAEIPAX@Z ENDP			; ATL::CWin32Heap::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_nBytes$ = 12						; size = 4
?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z PROC		; ATL::CWin32Heap::Reallocate, COMDAT
; _this$ = ecx

; 160  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 		if( p == NULL )

  00007	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  0000b	75 12		 jne	 SHORT $LN2@Reallocate

; 162  : 		{
; 163  : 			return( Allocate( nBytes ) );

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	ff d0		 call	 eax
  0001d	eb 32		 jmp	 SHORT $LN1@Reallocate
$LN2@Reallocate:

; 164  : 		}
; 165  : 
; 166  : 		if (nBytes==0)

  0001f	83 7d 0c 00	 cmp	 DWORD PTR _nBytes$[ebp], 0
  00023	75 15		 jne	 SHORT $LN3@Reallocate

; 167  : 		{
; 168  : 			  Free(p);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00034	ff d2		 call	 edx

; 169  : 			  return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 17		 jmp	 SHORT $LN1@Reallocate
$LN3@Reallocate:

; 170  : 		}
; 171  : 
; 172  : 		return( ::HeapReAlloc( m_hHeap, 0, p, nBytes ) );

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00041	51		 push	 ecx
  00042	6a 00		 push	 0
  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapReAlloc@16
$LN1@Reallocate:

; 173  : 	}

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z ENDP		; ATL::CWin32Heap::Reallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?Free@CWin32Heap@ATL@@UAEXPAX@Z
_TEXT	SEGMENT
_bSuccess$1 = -8					; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?Free@CWin32Heap@ATL@@UAEXPAX@Z PROC			; ATL::CWin32Heap::Free, COMDAT
; _this$ = ecx

; 148  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 		if( p != NULL )

  00009	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  0000d	74 16		 je	 SHORT $LN1@Free

; 150  : 		{
; 151  : 			BOOL bSuccess;
; 152  : 
; 153  : 			bSuccess = ::HeapFree( m_hHeap, 0, p );

  0000f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	52		 push	 edx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
  00022	89 45 f8	 mov	 DWORD PTR _bSuccess$1[ebp], eax
$LN1@Free:

; 154  : 			ATLASSERT( bSuccess );
; 155  : 		}
; 156  : 	}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Free@CWin32Heap@ATL@@UAEXPAX@Z ENDP			; ATL::CWin32Heap::Free
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?Allocate@CWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?Allocate@CWin32Heap@ATL@@UAEPAXI@Z PROC		; ATL::CWin32Heap::Allocate, COMDAT
; _this$ = ecx

; 144  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  : 		return( ::HeapAlloc( m_hHeap, 0, nBytes ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12

; 146  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?Allocate@CWin32Heap@ATL@@UAEPAXI@Z ENDP		; ATL::CWin32Heap::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ??1CWin32Heap@ATL@@UAE@XZ
_TEXT	SEGMENT
_bSuccess$1 = -8					; size = 4
_this$ = -4						; size = 4
??1CWin32Heap@ATL@@UAE@XZ PROC				; ATL::CWin32Heap::~CWin32Heap, COMDAT
; _this$ = ecx

; 109  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWin32Heap@ATL@@6B@

; 110  : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 111  : 		if( m_bOwnHeap && (m_hHeap != NULL) )

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00019	85 d2		 test	 edx, edx
  0001b	74 19		 je	 SHORT $LN1@CWin32Heap
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00024	74 10		 je	 SHORT $LN1@CWin32Heap

; 112  : 		{
; 113  : 			BOOL bSuccess;
; 114  : 
; 115  : 			bSuccess = ::HeapDestroy( m_hHeap );

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002c	52		 push	 edx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapDestroy@4
  00033	89 45 f8	 mov	 DWORD PTR _bSuccess$1[ebp], eax
$LN1@CWin32Heap:

; 116  : 			ATLASSERT( bSuccess );
; 117  : 		}
; 118  : #endif
; 119  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??1CWin32Heap@ATL@@UAE@XZ ENDP				; ATL::CWin32Heap::~CWin32Heap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ??0CWin32Heap@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hHeap$ = 8						; size = 4
??0CWin32Heap@ATL@@QAE@PAX@Z PROC			; ATL::CWin32Heap::CWin32Heap, COMDAT
; _this$ = ecx

; 89   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWin32Heap@ATL@@6B@

; 87   : 		m_hHeap( hHeap ),

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _hHeap$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 88   : 		m_bOwnHeap( false )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 90   : 		ATLASSERT( hHeap != NULL );
; 91   : 	}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0CWin32Heap@ATL@@QAE@PAX@Z ENDP			; ATL::CWin32Heap::CWin32Heap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 274  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 		return m_hInst;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 276  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 		DeleteCriticalSection(&m_sec);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 141  : 		return S_OK;

  00011	33 c0		 xor	 eax, eax

; 142  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hRes$ = -4						; size = 4
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 128  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 129  : 		HRESULT hRes = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hRes$[ebp], 0

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	85 c0		 test	 eax, eax
  00022	75 12		 jne	 SHORT $LN2@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00030	83 c4 04	 add	 esp, 4
  00033	89 45 fc	 mov	 DWORD PTR _hRes$[ebp], eax
$LN2@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _hRes$[ebp]

; 136  : 	}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00007	6a 18		 push	 24			; 00000018H
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 	}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);
; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwSpinCount$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _lpCriticalSection$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 736  : #endif
; 737  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwExceptionFlags$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwExceptionCode$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 32   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceISAPI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceISAPI@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceISAPI'', COMDAT

; 119  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceISAPI> atlTraceISAPI(_T("atlTraceISAPI"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60887
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceISAPI@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceISAPI''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSync@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSync@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSync'', COMDAT

; 118  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSync> atlTraceSync(_T("atlTraceSync"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60840
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceSync@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSync''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSecurity@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSecurity@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSecurity'', COMDAT

; 117  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSecurity> atlTraceSecurity(_T("atlTraceSecurity"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60793
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceSecurity@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSecurity''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceUtil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceUtil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceUtil'', COMDAT

; 116  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceUtil> atlTraceUtil(_T("atlTraceUtil"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60746
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceUtil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceUtil''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceMap@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceMap@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceMap'', COMDAT

; 115  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceMap> atlTraceMap(_T("atlTraceMap"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60741
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceMap@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceMap''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceString@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceString@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceString'', COMDAT

; 114  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceString> atlTraceString(_T("atlTraceString"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60694
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceString@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceString''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceStencil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceStencil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceStencil'', COMDAT

; 113  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceStencil> atlTraceStencil(_T("atlTraceStencil"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60647
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceStencil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceStencil''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCache@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCache@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCache'', COMDAT

; 112  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCache> atlTraceCache(_T("atlTraceCache"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60600
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceCache@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCache''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceTime@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceTime@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceTime'', COMDAT

; 111  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceTime> atlTraceTime(_T("atlTraceTime"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60553
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceTime@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceTime''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60506
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceAllocation@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceAllocation@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceAllocation'', COMDAT

; 109  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceAllocation> atlTraceAllocation(_T("atlTraceAllocation"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60459
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceAllocation@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceAllocation''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceNotImpl@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceNotImpl@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceNotImpl'', COMDAT

; 108  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceNotImpl> atlTraceNotImpl(_T("atlTraceNotImpl"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60412
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceNotImpl@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceNotImpl''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSnapin@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSnapin@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSnapin'', COMDAT

; 107  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSnapin> atlTraceSnapin(_T("atlTraceSnapin"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60365
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceSnapin@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSnapin''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBProvider@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBProvider@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBProvider'', COMDAT

; 106  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBProvider> atlTraceDBProvider(_T("atlTraceDBProvider"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60318
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceDBProvider@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBProvider''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBClient@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBClient@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBClient'', COMDAT

; 105  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBClient> atlTraceDBClient(_T("atlTraceDBClient"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60271
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceDBClient@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBClient''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceHosting@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceHosting@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceHosting'', COMDAT

; 104  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceHosting> atlTraceHosting(_T("atlTraceHosting"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60224
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceHosting@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceHosting''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceControls@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceControls@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceControls'', COMDAT

; 103  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceControls> atlTraceControls(_T("atlTraceControls"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60177
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceControls@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceControls''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceWindowing@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceWindowing@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceWindowing'', COMDAT

; 102  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceWindowing> atlTraceWindowing(_T("atlTraceWindowing"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60130
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceWindowing@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceWindowing''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRefcount@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRefcount@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRefcount'', COMDAT

; 101  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRefcount> atlTraceRefcount(_T("atlTraceRefcount"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60083
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceRefcount@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRefcount''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRegistrar@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRegistrar@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRegistrar'', COMDAT

; 100  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRegistrar> atlTraceRegistrar(_T("atlTraceRegistrar"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60036
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceRegistrar@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRegistrar''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceQI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceQI@ATL@@YAXXZ PROC				; ATL::`dynamic initializer for 'atlTraceQI'', COMDAT

; 99   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceQI> atlTraceQI(_T("atlTraceQI"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG59989
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceQI@ATL@@YAXXZ ENDP				; ATL::`dynamic initializer for 'atlTraceQI''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCOM@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCOM@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCOM'', COMDAT

; 98   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCom> atlTraceCOM(_T("atlTraceCOM"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG59942
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceCOM@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCOM''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceGeneral@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceGeneral@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceGeneral'', COMDAT

; 97   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceGeneral> atlTraceGeneral(_T("atlTraceGeneral"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG59871
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceGeneral@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceGeneral''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlAdd<unsigned long>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	83 c8 ff	 or	 eax, -1
  00006	2b 45 0c	 sub	 eax, DWORD PTR _tLeft$[ebp]
  00009	3b 45 10	 cmp	 eax, DWORD PTR _tRight$[ebp]
  0000c	73 0f		 jae	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0000e	68 16 02 00 00	 push	 534			; 00000216H
  00013	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00018	83 c4 04	 add	 esp, 4
  0001b	eb 0d		 jmp	 SHORT $LN1@AtlAdd
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00020	03 4d 10	 add	 ecx, DWORD PTR _tRight$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR _ptResult$[ebp]
  00026	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 	return S_OK;

  00028	33 c0		 xor	 eax, eax
$LN1@AtlAdd:

; 106  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$AtlAdd@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlAdd<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_i64Result$ = -8					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlMultiply<unsigned long>, COMDAT

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 181  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00009	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _i64Result$[ebp], eax
  0000f	89 55 fc	 mov	 DWORD PTR _i64Result$[ebp+4], edx

; 182  : 	if(i64Result>ULONG_MAX)

  00012	83 7d fc 00	 cmp	 DWORD PTR _i64Result$[ebp+4], 0
  00016	77 06		 ja	 SHORT $LN4@AtlMultipl
  00018	83 7d f8 ff	 cmp	 DWORD PTR _i64Result$[ebp], -1
  0001c	76 0f		 jbe	 SHORT $LN2@AtlMultipl
$LN4@AtlMultipl:

; 183  : 	{
; 184  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001e	68 16 02 00 00	 push	 534			; 00000216H
  00023	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00028	83 c4 04	 add	 esp, 4
  0002b	eb 0a		 jmp	 SHORT $LN1@AtlMultipl
$LN2@AtlMultipl:

; 185  : 	}
; 186  : 	*piResult=static_cast<unsigned long _ATL_W64>(i64Result);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i64Result$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 187  : 	return S_OK;

  00035	33 c0		 xor	 eax, eax
$LN1@AtlMultipl:

; 188  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$AtlMultiply@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlMultiply<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_i64Result$ = -8					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00009	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _i64Result$[ebp], eax
  0000f	89 55 fc	 mov	 DWORD PTR _i64Result$[ebp+4], edx

; 152  : 	if(i64Result>UINT_MAX)

  00012	83 7d fc 00	 cmp	 DWORD PTR _i64Result$[ebp+4], 0
  00016	77 06		 ja	 SHORT $LN4@AtlMultipl
  00018	83 7d f8 ff	 cmp	 DWORD PTR _i64Result$[ebp], -1
  0001c	76 0f		 jbe	 SHORT $LN2@AtlMultipl
$LN4@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001e	68 16 02 00 00	 push	 534			; 00000216H
  00023	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00028	83 c4 04	 add	 esp, 4
  0002b	eb 0a		 jmp	 SHORT $LN1@AtlMultipl
$LN2@AtlMultipl:

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i64Result$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 157  : 	return S_OK;

  00035	33 c0		 xor	 eax, eax
$LN1@AtlMultipl:

; 158  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -4						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00008	7f 08		 jg	 SHORT $LN3@HRESULT_FR
  0000a	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR tv68[ebp], eax
  00010	eb 18		 jmp	 SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00015	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001b	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  00021	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00027	89 4d fc	 mov	 DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00013	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00017	76 11		 jbe	 SHORT $LN1@vector
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001c	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001f	8b 55 08	 mov	 edx, DWORD PTR ___t$[ebp]
  00022	03 55 0c	 add	 edx, DWORD PTR ___s$[ebp]
  00025	89 55 08	 mov	 DWORD PTR ___t$[ebp], edx
  00028	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
