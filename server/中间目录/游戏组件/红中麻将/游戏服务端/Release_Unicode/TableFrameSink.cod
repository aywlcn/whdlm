; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	D:\qijianban\laok\服务端\游戏组件\老K子游戏\红中麻将\服务器组件\TableFrameSink.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	__pAtlLocaleNameToIndexTable
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?CLSID_ImageOle@@3U_GUID@@A			; CLSID_ImageOle
PUBLIC	?IID_IImageOle@@3U_GUID@@A			; IID_IImageOle
PUBLIC	?IID_IRichEditOleCallback2@@3U_GUID@@A		; IID_IRichEditOleCallback2
PUBLIC	?CLSID_WinFormsControl@@3U_GUID@@B		; CLSID_WinFormsControl
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	__pIncludeInitManaged
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	_LIBID_ShockwaveFlashObjects
PUBLIC	_IID_IShockwaveFlash
PUBLIC	_DIID__IShockwaveFlashEvents
PUBLIC	_CLSID_ShockwaveFlash
PUBLIC	?szInvalidDateTime@ATL@@3QB_WB			; ATL::szInvalidDateTime
PUBLIC	_IID_IFlashFactory
PUBLIC	_IID_IDispatchEx
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QB_WB		; ATL::szInvalidDateTimeSpan
PUBLIC	_IID_IFlashObjectInterface
PUBLIC	_CLSID_FlashObjectInterface
PUBLIC	_LIBID_ATLLib
PUBLIC	_CLSID_Registrar
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	_IID_IRegistrar
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	__pAtlLcidToLocaleNameTable
PUBLIC	?_AfxInitManaged@@YAHXZ				; _AfxInitManaged
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	_IID_IDocHostUIHandlerDispatch
_BSS	SEGMENT
?GenericSansSerifFontFamily@Gdiplus@@3PAVFontFamily@1@A DD 01H DUP (?) ; Gdiplus::GenericSansSerifFontFamily
?GenericSerifFontFamily@Gdiplus@@3PAVFontFamily@1@A DD 01H DUP (?) ; Gdiplus::GenericSerifFontFamily
?GenericMonospaceFontFamily@Gdiplus@@3PAVFontFamily@1@A DD 01H DUP (?) ; Gdiplus::GenericMonospaceFontFamily
?GenericSansSerifFontFamilyBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericSansSerifFontFamilyBuffer
?GenericSerifFontFamilyBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericSerifFontFamilyBuffer
?GenericMonospaceFontFamilyBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericMonospaceFontFamilyBuffer
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
_BSS	SEGMENT
?GenericTypographicStringFormatBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericTypographicStringFormatBuffer
?GenericDefaultStringFormatBuffer@Gdiplus@@3PAEA DB 08H DUP (?) ; Gdiplus::GenericDefaultStringFormatBuffer
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT __pAtlLcidToLocaleNameTable
CONST	SEGMENT
__pAtlLcidToLocaleNameTable DD 01H
	DD	FLAT:$SG61324
	DD	02H
	DD	FLAT:$SG61325
	DD	03H
	DD	FLAT:$SG61326
	DD	04H
	DD	FLAT:$SG61327
	DD	05H
	DD	FLAT:$SG61328
	DD	06H
	DD	FLAT:$SG61329
	DD	07H
	DD	FLAT:$SG61330
	DD	08H
	DD	FLAT:$SG61331
	DD	09H
	DD	FLAT:$SG61332
	DD	0aH
	DD	FLAT:$SG61333
	DD	0bH
	DD	FLAT:$SG61334
	DD	0cH
	DD	FLAT:$SG61335
	DD	0dH
	DD	FLAT:$SG61336
	DD	0eH
	DD	FLAT:$SG61337
	DD	0fH
	DD	FLAT:$SG61338
	DD	010H
	DD	FLAT:$SG61339
	DD	011H
	DD	FLAT:$SG61340
	DD	012H
	DD	FLAT:$SG61341
	DD	013H
	DD	FLAT:$SG61342
	DD	014H
	DD	FLAT:$SG61343
	DD	015H
	DD	FLAT:$SG61344
	DD	016H
	DD	FLAT:$SG61345
	DD	018H
	DD	FLAT:$SG61346
	DD	019H
	DD	FLAT:$SG61347
	DD	01aH
	DD	FLAT:$SG61348
	DD	01bH
	DD	FLAT:$SG61349
	DD	01cH
	DD	FLAT:$SG61350
	DD	01dH
	DD	FLAT:$SG61351
	DD	01eH
	DD	FLAT:$SG61352
	DD	01fH
	DD	FLAT:$SG61353
	DD	020H
	DD	FLAT:$SG61354
	DD	021H
	DD	FLAT:$SG61355
	DD	022H
	DD	FLAT:$SG61356
	DD	023H
	DD	FLAT:$SG61357
	DD	024H
	DD	FLAT:$SG61358
	DD	025H
	DD	FLAT:$SG61359
	DD	026H
	DD	FLAT:$SG61360
	DD	027H
	DD	FLAT:$SG61361
	DD	029H
	DD	FLAT:$SG61362
	DD	02aH
	DD	FLAT:$SG61363
	DD	02bH
	DD	FLAT:$SG61364
	DD	02cH
	DD	FLAT:$SG61365
	DD	02dH
	DD	FLAT:$SG61366
	DD	02fH
	DD	FLAT:$SG61367
	DD	036H
	DD	FLAT:$SG61368
	DD	037H
	DD	FLAT:$SG61369
	DD	038H
	DD	FLAT:$SG61370
	DD	039H
	DD	FLAT:$SG61371
	DD	03eH
	DD	FLAT:$SG61372
	DD	03fH
	DD	FLAT:$SG61373
	DD	040H
	DD	FLAT:$SG61374
	DD	041H
	DD	FLAT:$SG61375
	DD	043H
	DD	FLAT:$SG61376
	DD	044H
	DD	FLAT:$SG61377
	DD	046H
	DD	FLAT:$SG61378
	DD	047H
	DD	FLAT:$SG61379
	DD	049H
	DD	FLAT:$SG61380
	DD	04aH
	DD	FLAT:$SG61381
	DD	04bH
	DD	FLAT:$SG61382
	DD	04eH
	DD	FLAT:$SG61383
	DD	04fH
	DD	FLAT:$SG61384
	DD	050H
	DD	FLAT:$SG61385
	DD	056H
	DD	FLAT:$SG61386
	DD	057H
	DD	FLAT:$SG61387
	DD	05aH
	DD	FLAT:$SG61388
	DD	065H
	DD	FLAT:$SG61389
	DD	07fH
	DD	FLAT:$SG61390
	DD	0401H
	DD	FLAT:$SG61391
	DD	0402H
	DD	FLAT:$SG61392
	DD	0403H
	DD	FLAT:$SG61393
	DD	0404H
	DD	FLAT:$SG61394
	DD	0405H
	DD	FLAT:$SG61395
	DD	0406H
	DD	FLAT:$SG61396
	DD	0407H
	DD	FLAT:$SG61397
	DD	0408H
	DD	FLAT:$SG61398
	DD	0409H
	DD	FLAT:$SG61399
	DD	040bH
	DD	FLAT:$SG61400
	DD	040cH
	DD	FLAT:$SG61401
	DD	040dH
	DD	FLAT:$SG61402
	DD	040eH
	DD	FLAT:$SG61403
	DD	040fH
	DD	FLAT:$SG61404
	DD	0410H
	DD	FLAT:$SG61405
	DD	0411H
	DD	FLAT:$SG61406
	DD	0412H
	DD	FLAT:$SG61407
	DD	0413H
	DD	FLAT:$SG61408
	DD	0414H
	DD	FLAT:$SG61409
	DD	0415H
	DD	FLAT:$SG61410
	DD	0416H
	DD	FLAT:$SG61411
	DD	0418H
	DD	FLAT:$SG61412
	DD	0419H
	DD	FLAT:$SG61413
	DD	041aH
	DD	FLAT:$SG61414
	DD	041bH
	DD	FLAT:$SG61415
	DD	041cH
	DD	FLAT:$SG61416
	DD	041dH
	DD	FLAT:$SG61417
	DD	041eH
	DD	FLAT:$SG61418
	DD	041fH
	DD	FLAT:$SG61419
	DD	0420H
	DD	FLAT:$SG61420
	DD	0421H
	DD	FLAT:$SG61421
	DD	0422H
	DD	FLAT:$SG61422
	DD	0423H
	DD	FLAT:$SG61423
	DD	0424H
	DD	FLAT:$SG61424
	DD	0425H
	DD	FLAT:$SG61425
	DD	0426H
	DD	FLAT:$SG61426
	DD	0427H
	DD	FLAT:$SG61427
	DD	0429H
	DD	FLAT:$SG61428
	DD	042aH
	DD	FLAT:$SG61429
	DD	042bH
	DD	FLAT:$SG61430
	DD	042cH
	DD	FLAT:$SG61431
	DD	042dH
	DD	FLAT:$SG61432
	DD	042fH
	DD	FLAT:$SG61433
	DD	0432H
	DD	FLAT:$SG61434
	DD	0434H
	DD	FLAT:$SG61435
	DD	0435H
	DD	FLAT:$SG61436
	DD	0436H
	DD	FLAT:$SG61437
	DD	0437H
	DD	FLAT:$SG61438
	DD	0438H
	DD	FLAT:$SG61439
	DD	0439H
	DD	FLAT:$SG61440
	DD	043aH
	DD	FLAT:$SG61441
	DD	043bH
	DD	FLAT:$SG61442
	DD	043eH
	DD	FLAT:$SG61443
	DD	043fH
	DD	FLAT:$SG61444
	DD	0440H
	DD	FLAT:$SG61445
	DD	0441H
	DD	FLAT:$SG61446
	DD	0443H
	DD	FLAT:$SG61447
	DD	0444H
	DD	FLAT:$SG61448
	DD	0445H
	DD	FLAT:$SG61449
	DD	0446H
	DD	FLAT:$SG61450
	DD	0447H
	DD	FLAT:$SG61451
	DD	0449H
	DD	FLAT:$SG61452
	DD	044aH
	DD	FLAT:$SG61453
	DD	044bH
	DD	FLAT:$SG61454
	DD	044cH
	DD	FLAT:$SG61455
	DD	044eH
	DD	FLAT:$SG61456
	DD	044fH
	DD	FLAT:$SG61457
	DD	0450H
	DD	FLAT:$SG61458
	DD	0452H
	DD	FLAT:$SG61459
	DD	0456H
	DD	FLAT:$SG61460
	DD	0457H
	DD	FLAT:$SG61461
	DD	045aH
	DD	FLAT:$SG61462
	DD	0465H
	DD	FLAT:$SG61463
	DD	046bH
	DD	FLAT:$SG61464
	DD	046cH
	DD	FLAT:$SG61465
	DD	0481H
	DD	FLAT:$SG61466
	DD	0801H
	DD	FLAT:$SG61467
	DD	0804H
	DD	FLAT:$SG61468
	DD	0807H
	DD	FLAT:$SG61469
	DD	0809H
	DD	FLAT:$SG61470
	DD	080aH
	DD	FLAT:$SG61471
	DD	080cH
	DD	FLAT:$SG61472
	DD	0810H
	DD	FLAT:$SG61473
	DD	0813H
	DD	FLAT:$SG61474
	DD	0814H
	DD	FLAT:$SG61475
	DD	0816H
	DD	FLAT:$SG61476
	DD	081aH
	DD	FLAT:$SG61477
	DD	081dH
	DD	FLAT:$SG61478
	DD	082cH
	DD	FLAT:$SG61479
	DD	083bH
	DD	FLAT:$SG61480
	DD	083eH
	DD	FLAT:$SG61481
	DD	0843H
	DD	FLAT:$SG61482
	DD	086bH
	DD	FLAT:$SG61483
	DD	0c01H
	DD	FLAT:$SG61484
	DD	0c04H
	DD	FLAT:$SG61485
	DD	0c07H
	DD	FLAT:$SG61486
	DD	0c09H
	DD	FLAT:$SG61487
	DD	0c0aH
	DD	FLAT:$SG61488
	DD	0c0cH
	DD	FLAT:$SG61489
	DD	0c1aH
	DD	FLAT:$SG61490
	DD	0c3bH
	DD	FLAT:$SG61491
	DD	0c6bH
	DD	FLAT:$SG61492
	DD	01001H
	DD	FLAT:$SG61493
	DD	01004H
	DD	FLAT:$SG61494
	DD	01007H
	DD	FLAT:$SG61495
	DD	01009H
	DD	FLAT:$SG61496
	DD	0100aH
	DD	FLAT:$SG61497
	DD	0100cH
	DD	FLAT:$SG61498
	DD	0101aH
	DD	FLAT:$SG61499
	DD	0103bH
	DD	FLAT:$SG61500
	DD	01401H
	DD	FLAT:$SG61501
	DD	01404H
	DD	FLAT:$SG61502
	DD	01407H
	DD	FLAT:$SG61503
	DD	01409H
	DD	FLAT:$SG61504
	DD	0140aH
	DD	FLAT:$SG61505
	DD	0140cH
	DD	FLAT:$SG61506
	DD	0141aH
	DD	FLAT:$SG61507
	DD	0143bH
	DD	FLAT:$SG61508
	DD	01801H
	DD	FLAT:$SG61509
	DD	01809H
	DD	FLAT:$SG61510
	DD	0180aH
	DD	FLAT:$SG61511
	DD	0180cH
	DD	FLAT:$SG61512
	DD	0181aH
	DD	FLAT:$SG61513
	DD	0183bH
	DD	FLAT:$SG61514
	DD	01c01H
	DD	FLAT:$SG61515
	DD	01c09H
	DD	FLAT:$SG61516
	DD	01c0aH
	DD	FLAT:$SG61517
	DD	01c1aH
	DD	FLAT:$SG61518
	DD	01c3bH
	DD	FLAT:$SG61519
	DD	02001H
	DD	FLAT:$SG61520
	DD	02009H
	DD	FLAT:$SG61521
	DD	0200aH
	DD	FLAT:$SG61522
	DD	0203bH
	DD	FLAT:$SG61523
	DD	02401H
	DD	FLAT:$SG61524
	DD	02409H
	DD	FLAT:$SG61525
	DD	0240aH
	DD	FLAT:$SG61526
	DD	0243bH
	DD	FLAT:$SG61527
	DD	02801H
	DD	FLAT:$SG61528
	DD	02809H
	DD	FLAT:$SG61529
	DD	0280aH
	DD	FLAT:$SG61530
	DD	02c01H
	DD	FLAT:$SG61531
	DD	02c09H
	DD	FLAT:$SG61532
	DD	02c0aH
	DD	FLAT:$SG61533
	DD	03001H
	DD	FLAT:$SG61534
	DD	03009H
	DD	FLAT:$SG61535
	DD	0300aH
	DD	FLAT:$SG61536
	DD	03401H
	DD	FLAT:$SG61537
	DD	03409H
	DD	FLAT:$SG61538
	DD	0340aH
	DD	FLAT:$SG61539
	DD	03801H
	DD	FLAT:$SG61540
	DD	0380aH
	DD	FLAT:$SG61541
	DD	03c01H
	DD	FLAT:$SG61542
	DD	03c0aH
	DD	FLAT:$SG61543
	DD	04001H
	DD	FLAT:$SG61544
	DD	0400aH
	DD	FLAT:$SG61545
	DD	0440aH
	DD	FLAT:$SG61546
	DD	0480aH
	DD	FLAT:$SG61547
	DD	04c0aH
	DD	FLAT:$SG61548
	DD	0500aH
	DD	FLAT:$SG61549
	DD	07c04H
	DD	FLAT:$SG61550
	DD	07c1aH
	DD	FLAT:$SG61551
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_FlashObjectInterface
CONST	SEGMENT
_CLSID_FlashObjectInterface DD 0d27cdb71H
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _IID_IFlashObjectInterface
CONST	SEGMENT
_IID_IFlashObjectInterface DD 0d27cdb72H
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QB_WB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QB_WB DD FLAT:$SG82626	; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT _IID_IDispatchEx
CONST	SEGMENT
_IID_IDispatchEx DD 0a6ef9860H
	DW	0c720H
	DW	011d0H
	DB	093H
	DB	037H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	0dH
	DB	0caH
	DB	0a9H
CONST	ENDS
;	COMDAT _IID_IFlashFactory
CONST	SEGMENT
_IID_IFlashFactory DD 0d27cdb70H
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QB_WB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QB_WB DD FLAT:$SG82624		; ATL::szInvalidDateTime
CONST	ENDS
;	COMDAT _CLSID_ShockwaveFlash
CONST	SEGMENT
_CLSID_ShockwaveFlash DD 0d27cdb6eH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _DIID__IShockwaveFlashEvents
CONST	SEGMENT
_DIID__IShockwaveFlashEvents DD 0d27cdb6dH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _IID_IShockwaveFlash
CONST	SEGMENT
_IID_IShockwaveFlash DD 0d27cdb6cH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _LIBID_ShockwaveFlashObjects
CONST	SEGMENT
_LIBID_ShockwaveFlashObjects DD 0d27cdb6bH
	DW	0ae6dH
	DW	011cfH
	DB	096H
	DB	0b8H
	DB	044H
	DB	045H
	DB	053H
	DB	054H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT __pIncludeInitManaged
_DATA	SEGMENT
__pIncludeInitManaged DD FLAT:?_AfxInitManaged@@YAHXZ
_DATA	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
_DATA	SEGMENT
?PADDING@@3PAEA DB 080H					; PADDING
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
;	COMDAT ?CLSID_WinFormsControl@@3U_GUID@@B
CONST	SEGMENT
?CLSID_WinFormsControl@@3U_GUID@@B DD 0b7e7a666H	; CLSID_WinFormsControl
	DW	0d623H
	DW	0457fH
	DB	0a3H
	DB	0aH
	DB	06aH
	DB	049H
	DB	0a3H
	DB	0e5H
	DB	0b4H
	DB	070H
CONST	ENDS
;	COMDAT ?IID_IRichEditOleCallback2@@3U_GUID@@A
_DATA	SEGMENT
?IID_IRichEditOleCallback2@@3U_GUID@@A DD 089fc1386H	; IID_IRichEditOleCallback2
	DW	091e5H
	DW	0415fH
	DB	0adH
	DB	08fH
	DB	04H
	DB	041H
	DB	05cH
	DB	015H
	DB	0f8H
	DB	0f5H
_DATA	ENDS
;	COMDAT ?IID_IImageOle@@3U_GUID@@A
_DATA	SEGMENT
?IID_IImageOle@@3U_GUID@@A DD 0e41fe3bbH		; IID_IImageOle
	DW	07218H
	DW	0423dH
	DB	095H
	DB	02eH
	DB	096H
	DB	0e5H
	DB	056H
	DB	0aeH
	DB	0e3H
	DB	0fH
_DATA	ENDS
;	COMDAT ?CLSID_ImageOle@@3U_GUID@@A
_DATA	SEGMENT
?CLSID_ImageOle@@3U_GUID@@A DD 0c5b3a481H		; CLSID_ImageOle
	DW	021e3H
	DW	04cabH
	DB	08aH
	DB	0bdH
	DB	03cH
	DB	06aH
	DB	085H
	DB	089H
	DB	02aH
	DB	0d2H
_DATA	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:$SG109682			; ATL::szDelete
CONST	ENDS
;	COMDAT __pAtlLocaleNameToIndexTable
CONST	SEGMENT
__pAtlLocaleNameToIndexTable DD FLAT:$SG61553
	DD	042H
	DD	FLAT:$SG61554
	DD	02cH
	DD	FLAT:$SG61555
	DD	071H
	DD	FLAT:$SG61556
	DD	00H
	DD	FLAT:$SG61557
	DD	0d8H
	DD	FLAT:$SG61558
	DD	0daH
	DD	FLAT:$SG61559
	DD	0b1H
	DD	FLAT:$SG61560
	DD	0a0H
	DD	FLAT:$SG61561
	DD	08fH
	DD	FLAT:$SG61562
	DD	0cfH
	DD	FLAT:$SG61563
	DD	0d5H
	DD	FLAT:$SG61564
	DD	0d2H
	DD	FLAT:$SG61565
	DD	0a9H
	DD	FLAT:$SG61566
	DD	0b9H
	DD	FLAT:$SG61567
	DD	0c4H
	DD	FLAT:$SG61568
	DD	0dcH
	DD	FLAT:$SG61569
	DD	043H
	DD	FLAT:$SG61570
	DD	0ccH
	DD	FLAT:$SG61571
	DD	0bfH
	DD	FLAT:$SG61572
	DD	0c8H
	DD	FLAT:$SG61573
	DD	029H
	DD	FLAT:$SG61574
	DD	09bH
	DD	FLAT:$SG61575
	DD	06bH
	DD	FLAT:$SG61576
	DD	021H
	DD	FLAT:$SG61577
	DD	063H
	DD	FLAT:$SG61578
	DD	01H
	DD	FLAT:$SG61579
	DD	044H
	DD	FLAT:$SG61580
	DD	07dH
	DD	FLAT:$SG61581
	DD	0b7H
	DD	FLAT:$SG61582
	DD	02H
	DD	FLAT:$SG61583
	DD	045H
	DD	FLAT:$SG61584
	DD	04H
	DD	FLAT:$SG61585
	DD	047H
	DD	FLAT:$SG61586
	DD	087H
	DD	FLAT:$SG61587
	DD	05H
	DD	FLAT:$SG61588
	DD	048H
	DD	FLAT:$SG61589
	DD	06H
	DD	FLAT:$SG61590
	DD	0a2H
	DD	FLAT:$SG61591
	DD	091H
	DD	FLAT:$SG61592
	DD	049H
	DD	FLAT:$SG61593
	DD	0b3H
	DD	FLAT:$SG61594
	DD	0abH
	DD	FLAT:$SG61595
	DD	041H
	DD	FLAT:$SG61596
	DD	08bH
	DD	FLAT:$SG61597
	DD	07H
	DD	FLAT:$SG61598
	DD	04aH
	DD	FLAT:$SG61599
	DD	08H
	DD	FLAT:$SG61600
	DD	0a3H
	DD	FLAT:$SG61601
	DD	0cdH
	DD	FLAT:$SG61602
	DD	0acH
	DD	FLAT:$SG61603
	DD	0c9H
	DD	FLAT:$SG61604
	DD	092H
	DD	FLAT:$SG61605
	DD	0baH
	DD	FLAT:$SG61606
	DD	0c5H
	DD	FLAT:$SG61607
	DD	0b4H
	DD	FLAT:$SG61608
	DD	0d6H
	DD	FLAT:$SG61609
	DD	0d0H
	DD	FLAT:$SG61610
	DD	04bH
	DD	FLAT:$SG61611
	DD	0c0H
	DD	FLAT:$SG61612
	DD	0d3H
	DD	FLAT:$SG61613
	DD	09H
	DD	FLAT:$SG61614
	DD	0d1H
	DD	FLAT:$SG61615
	DD	0ddH
	DD	FLAT:$SG61616
	DD	0d7H
	DD	FLAT:$SG61617
	DD	0caH
	DD	FLAT:$SG61618
	DD	0b5H
	DD	FLAT:$SG61619
	DD	0c1H
	DD	FLAT:$SG61620
	DD	0d4H
	DD	FLAT:$SG61621
	DD	0a4H
	DD	FLAT:$SG61622
	DD	0adH
	DD	FLAT:$SG61623
	DD	0dfH
	DD	FLAT:$SG61624
	DD	093H
	DD	FLAT:$SG61625
	DD	0e0H
	DD	FLAT:$SG61626
	DD	0bbH
	DD	FLAT:$SG61627
	DD	0ceH
	DD	FLAT:$SG61628
	DD	0e1H
	DD	FLAT:$SG61629
	DD	0dbH
	DD	FLAT:$SG61630
	DD	0deH
	DD	FLAT:$SG61631
	DD	0d9H
	DD	FLAT:$SG61632
	DD	0c6H
	DD	FLAT:$SG61633
	DD	023H
	DD	FLAT:$SG61634
	DD	065H
	DD	FLAT:$SG61635
	DD	02aH
	DD	FLAT:$SG61636
	DD	06cH
	DD	FLAT:$SG61637
	DD	026H
	DD	FLAT:$SG61638
	DD	068H
	DD	FLAT:$SG61639
	DD	0aH
	DD	FLAT:$SG61640
	DD	04cH
	DD	FLAT:$SG61641
	DD	02eH
	DD	FLAT:$SG61642
	DD	073H
	DD	FLAT:$SG61643
	DD	0bH
	DD	FLAT:$SG61644
	DD	094H
	DD	FLAT:$SG61645
	DD	0a5H
	DD	FLAT:$SG61646
	DD	0aeH
	DD	FLAT:$SG61647
	DD	04dH
	DD	FLAT:$SG61648
	DD	0b6H
	DD	FLAT:$SG61649
	DD	0bcH
	DD	FLAT:$SG61650
	DD	03eH
	DD	FLAT:$SG61651
	DD	088H
	DD	FLAT:$SG61652
	DD	037H
	DD	FLAT:$SG61653
	DD	07fH
	DD	FLAT:$SG61654
	DD	0cH
	DD	FLAT:$SG61655
	DD	04eH
	DD	FLAT:$SG61656
	DD	02fH
	DD	FLAT:$SG61657
	DD	074H
	DD	FLAT:$SG61658
	DD	018H
	DD	FLAT:$SG61659
	DD	0afH
	DD	FLAT:$SG61660
	DD	05aH
	DD	FLAT:$SG61661
	DD	0dH
	DD	FLAT:$SG61662
	DD	04fH
	DD	FLAT:$SG61663
	DD	028H
	DD	FLAT:$SG61664
	DD	06aH
	DD	FLAT:$SG61665
	DD	01fH
	DD	FLAT:$SG61666
	DD	061H
	DD	FLAT:$SG61667
	DD	0eH
	DD	FLAT:$SG61668
	DD	050H
	DD	FLAT:$SG61669
	DD	0fH
	DD	FLAT:$SG61670
	DD	095H
	DD	FLAT:$SG61671
	DD	051H
	DD	FLAT:$SG61672
	DD	010H
	DD	FLAT:$SG61673
	DD	052H
	DD	FLAT:$SG61674
	DD	02dH
	DD	FLAT:$SG61675
	DD	072H
	DD	FLAT:$SG61676
	DD	031H
	DD	FLAT:$SG61677
	DD	078H
	DD	FLAT:$SG61678
	DD	03aH
	DD	FLAT:$SG61679
	DD	082H
	DD	FLAT:$SG61680
	DD	011H
	DD	FLAT:$SG61681
	DD	03fH
	DD	FLAT:$SG61682
	DD	089H
	DD	FLAT:$SG61683
	DD	053H
	DD	FLAT:$SG61684
	DD	032H
	DD	FLAT:$SG61685
	DD	079H
	DD	FLAT:$SG61686
	DD	025H
	DD	FLAT:$SG61687
	DD	067H
	DD	FLAT:$SG61688
	DD	024H
	DD	FLAT:$SG61689
	DD	066H
	DD	FLAT:$SG61690
	DD	08eH
	DD	FLAT:$SG61691
	DD	02bH
	DD	FLAT:$SG61692
	DD	06dH
	DD	FLAT:$SG61693
	DD	083H
	DD	FLAT:$SG61694
	DD	03dH
	DD	FLAT:$SG61695
	DD	086H
	DD	FLAT:$SG61696
	DD	03bH
	DD	FLAT:$SG61697
	DD	084H
	DD	FLAT:$SG61698
	DD	030H
	DD	FLAT:$SG61699
	DD	09dH
	DD	FLAT:$SG61700
	DD	077H
	DD	FLAT:$SG61701
	DD	075H
	DD	FLAT:$SG61702
	DD	055H
	DD	FLAT:$SG61703
	DD	012H
	DD	FLAT:$SG61704
	DD	096H
	DD	FLAT:$SG61705
	DD	054H
	DD	FLAT:$SG61706
	DD	097H
	DD	FLAT:$SG61707
	DD	013H
	DD	FLAT:$SG61708
	DD	08dH
	DD	FLAT:$SG61709
	DD	036H
	DD	FLAT:$SG61710
	DD	07eH
	DD	FLAT:$SG61711
	DD	014H
	DD	FLAT:$SG61712
	DD	056H
	DD	FLAT:$SG61713
	DD	015H
	DD	FLAT:$SG61714
	DD	057H
	DD	FLAT:$SG61715
	DD	098H
	DD	FLAT:$SG61716
	DD	08cH
	DD	FLAT:$SG61717
	DD	09fH
	DD	FLAT:$SG61718
	DD	0a8H
	DD	FLAT:$SG61719
	DD	016H
	DD	FLAT:$SG61720
	DD	058H
	DD	FLAT:$SG61721
	DD	017H
	DD	FLAT:$SG61722
	DD	059H
	DD	FLAT:$SG61723
	DD	03cH
	DD	FLAT:$SG61724
	DD	085H
	DD	FLAT:$SG61725
	DD	0a7H
	DD	FLAT:$SG61726
	DD	076H
	DD	FLAT:$SG61727
	DD	09cH
	DD	FLAT:$SG61728
	DD	019H
	DD	FLAT:$SG61729
	DD	05bH
	DD	FLAT:$SG61730
	DD	022H
	DD	FLAT:$SG61731
	DD	064H
	DD	FLAT:$SG61732
	DD	0beH
	DD	FLAT:$SG61733
	DD	0c3H
	DD	FLAT:$SG61734
	DD	0b0H
	DD	FLAT:$SG61735
	DD	0b8H
	DD	FLAT:$SG61736
	DD	0cbH
	DD	FLAT:$SG61737
	DD	0c7H
	DD	FLAT:$SG61738
	DD	01aH
	DD	FLAT:$SG61739
	DD	05cH
	DD	FLAT:$SG61740
	DD	0e3H
	DD	FLAT:$SG61741
	DD	0c2H
	DD	FLAT:$SG61742
	DD	0bdH
	DD	FLAT:$SG61743
	DD	0a6H
	DD	FLAT:$SG61744
	DD	099H
	DD	FLAT:$SG61745
	DD	01bH
	DD	FLAT:$SG61746
	DD	09aH
	DD	FLAT:$SG61747
	DD	05dH
	DD	FLAT:$SG61748
	DD	033H
	DD	FLAT:$SG61749
	DD	07aH
	DD	FLAT:$SG61750
	DD	040H
	DD	FLAT:$SG61751
	DD	08aH
	DD	FLAT:$SG61752
	DD	038H
	DD	FLAT:$SG61753
	DD	080H
	DD	FLAT:$SG61754
	DD	039H
	DD	FLAT:$SG61755
	DD	081H
	DD	FLAT:$SG61756
	DD	01cH
	DD	FLAT:$SG61757
	DD	05eH
	DD	FLAT:$SG61758
	DD	06eH
	DD	FLAT:$SG61759
	DD	01dH
	DD	FLAT:$SG61760
	DD	05fH
	DD	FLAT:$SG61761
	DD	035H
	DD	FLAT:$SG61762
	DD	07cH
	DD	FLAT:$SG61763
	DD	020H
	DD	FLAT:$SG61764
	DD	062H
	DD	FLAT:$SG61765
	DD	01eH
	DD	FLAT:$SG61766
	DD	060H
	DD	FLAT:$SG61767
	DD	034H
	DD	FLAT:$SG61768
	DD	09eH
	DD	FLAT:$SG61769
	DD	07bH
	DD	FLAT:$SG61770
	DD	027H
	DD	FLAT:$SG61771
	DD	069H
	DD	FLAT:$SG61772
	DD	06fH
	DD	FLAT:$SG61773
	DD	03H
	DD	FLAT:$SG61774
	DD	0e2H
	DD	FLAT:$SG61775
	DD	090H
	DD	FLAT:$SG61776
	DD	0a1H
	DD	FLAT:$SG61777
	DD	0b2H
	DD	FLAT:$SG61778
	DD	0aaH
	DD	FLAT:$SG61779
	DD	046H
	DD	FLAT:$SG61780
	DD	070H
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:$SG109680		; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:$SG109678		; ATL::szForceRemove
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:$SG109676		; ATL::szValToken
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:$SG109674		; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:$SG109672		; ATL::szDwordVal
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:$SG109670		; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:$SG109668		; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
CONST	SEGMENT
$SG61440 DB	'h', 00H, 'i', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61441 DB	'm', 00H, 't', 00H, '-', 00H, 'M', 00H, 'T', 00H, 00H, 00H
$SG61442 DB	's', 00H, 'e', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H
$SG61443 DB	'm', 00H, 's', 00H, '-', 00H, 'M', 00H, 'Y', 00H, 00H, 00H
$SG61444 DB	'k', 00H, 'k', 00H, '-', 00H, 'K', 00H, 'Z', 00H, 00H, 00H
$SG61445 DB	'k', 00H, 'y', 00H, '-', 00H, 'K', 00H, 'G', 00H, 00H, 00H
$SG61446 DB	's', 00H, 'w', 00H, '-', 00H, 'K', 00H, 'E', 00H, 00H, 00H
$SG61447 DB	'u', 00H, 'z', 00H, '-', 00H, 'U', 00H, 'Z', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61448 DB	't', 00H, 't', 00H, '-', 00H, 'R', 00H, 'U', 00H, 00H, 00H
$SG61449 DB	'b', 00H, 'n', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61450 DB	'p', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61451 DB	'g', 00H, 'u', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61452 DB	't', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61453 DB	't', 00H, 'e', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61454 DB	'k', 00H, 'n', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61455 DB	'm', 00H, 'l', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
?IID_IDataBase@@3U_GUID@@B DD 07fbbbffaH		; IID_IDataBase
	DW	0edf4H
	DW	043d2H
	DB	08aH
	DB	0b7H
	DB	028H
	DB	087H
	DB	03bH
	DB	0d0H
	DB	0f5H
	DB	03fH
$SG61456 DB	'm', 00H, 'r', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61457 DB	's', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H
$SG61458 DB	'm', 00H, 'n', 00H, '-', 00H, 'M', 00H, 'N', 00H, 00H, 00H
$SG61459 DB	'c', 00H, 'y', 00H, '-', 00H, 'G', 00H, 'B', 00H, 00H, 00H
$SG61460 DB	'g', 00H, 'l', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61461 DB	'k', 00H, 'o', 00H, 'k', 00H, '-', 00H, 'I', 00H, 'N', 00H
	DB	00H, 00H
	ORG $+2
$SG61462 DB	's', 00H, 'y', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'Y', 00H
	DB	00H, 00H
	ORG $+2
$SG61463 DB	'd', 00H, 'i', 00H, 'v', 00H, '-', 00H, 'M', 00H, 'V', 00H
	DB	00H, 00H
	ORG $+2
$SG61464 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'B', 00H, 'O', 00H
	DB	00H, 00H
	ORG $+2
$SG61465 DB	'n', 00H, 's', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61466 DB	'm', 00H, 'i', 00H, '-', 00H, 'N', 00H, 'Z', 00H, 00H, 00H
$SG61467 DB	'a', 00H, 'r', 00H, '-', 00H, 'I', 00H, 'Q', 00H, 00H, 00H
$SG61468 DB	'z', 00H, 'h', 00H, '-', 00H, 'C', 00H, 'N', 00H, 00H, 00H
$SG61469 DB	'd', 00H, 'e', 00H, '-', 00H, 'C', 00H, 'H', 00H, 00H, 00H
$SG61470 DB	'e', 00H, 'n', 00H, '-', 00H, 'G', 00H, 'B', 00H, 00H, 00H
$SG61471 DB	'e', 00H, 's', 00H, '-', 00H, 'M', 00H, 'X', 00H, 00H, 00H
$SG61472 DB	'f', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'E', 00H, 00H, 00H
$SG61473 DB	'i', 00H, 't', 00H, '-', 00H, 'C', 00H, 'H', 00H, 00H, 00H
$SG61474 DB	'n', 00H, 'l', 00H, '-', 00H, 'B', 00H, 'E', 00H, 00H, 00H
$SG61475 DB	'n', 00H, 'n', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H
$SG61476 DB	'p', 00H, 't', 00H, '-', 00H, 'P', 00H, 'T', 00H, 00H, 00H
$SG61477 DB	's', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'P', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61478 DB	's', 00H, 'v', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H
$SG61479 DB	'a', 00H, 'z', 00H, '-', 00H, 'A', 00H, 'Z', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61480 DB	's', 00H, 'e', 00H, '-', 00H, 'S', 00H, 'E', 00H, 00H, 00H
$SG61481 DB	'm', 00H, 's', 00H, '-', 00H, 'B', 00H, 'N', 00H, 00H, 00H
$SG61482 DB	'u', 00H, 'z', 00H, '-', 00H, 'U', 00H, 'Z', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61483 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'E', 00H, 'C', 00H
	DB	00H, 00H
	ORG $+2
$SG60459 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61484 DB	'a', 00H, 'r', 00H, '-', 00H, 'E', 00H, 'G', 00H, 00H, 00H
$SG61485 DB	'z', 00H, 'h', 00H, '-', 00H, 'H', 00H, 'K', 00H, 00H, 00H
$SG61486 DB	'd', 00H, 'e', 00H, '-', 00H, 'A', 00H, 'T', 00H, 00H, 00H
$SG61487 DB	'e', 00H, 'n', 00H, '-', 00H, 'A', 00H, 'U', 00H, 00H, 00H
$SG61488 DB	'e', 00H, 's', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61489 DB	'f', 00H, 'r', 00H, '-', 00H, 'C', 00H, 'A', 00H, 00H, 00H
$SG61490 DB	's', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'P', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
?IID_IPlatformResource@@3U_GUID@@B DD 0bcd7ff05H	; IID_IPlatformResource
	DW	0a79H
	DW	04482H
	DB	09bH
	DB	0a6H
	DB	079H
	DB	0dfH
	DB	04bH
	DB	0d9H
	DB	080H
	DB	016H
$SG61491 DB	's', 00H, 'e', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H
$SG61492 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'P', 00H, 'E', 00H
	DB	00H, 00H
	ORG $+2
$SG61493 DB	'a', 00H, 'r', 00H, '-', 00H, 'L', 00H, 'Y', 00H, 00H, 00H
$SG61494 DB	'z', 00H, 'h', 00H, '-', 00H, 'S', 00H, 'G', 00H, 00H, 00H
$SG61495 DB	'd', 00H, 'e', 00H, '-', 00H, 'L', 00H, 'U', 00H, 00H, 00H
$SG61496 DB	'e', 00H, 'n', 00H, '-', 00H, 'C', 00H, 'A', 00H, 00H, 00H
$SG61497 DB	'e', 00H, 's', 00H, '-', 00H, 'G', 00H, 'T', 00H, 00H, 00H
$SG61498 DB	'f', 00H, 'r', 00H, '-', 00H, 'C', 00H, 'H', 00H, 00H, 00H
$SG61499 DB	'h', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, 00H, 00H
$SG61500 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 'N', 00H, 'O', 00H
	DB	00H, 00H
	ORG $+2
$SG61501 DB	'a', 00H, 'r', 00H, '-', 00H, 'D', 00H, 'Z', 00H, 00H, 00H
$SG61502 DB	'z', 00H, 'h', 00H, '-', 00H, 'M', 00H, 'O', 00H, 00H, 00H
$SG61503 DB	'd', 00H, 'e', 00H, '-', 00H, 'L', 00H, 'I', 00H, 00H, 00H
$SG61504 DB	'e', 00H, 'n', 00H, '-', 00H, 'N', 00H, 'Z', 00H, 00H, 00H
$SG61505 DB	'e', 00H, 's', 00H, '-', 00H, 'C', 00H, 'R', 00H, 00H, 00H
$SG313410 DB	'8n', 0fH, 'bLhP[ ', 00H, 'C', 00H, 'T', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 'S', 00H, 'i', 00H, 'n', 00H, 'k', 00H, ' ', 00H, 0e5H
	DB	'g', 0e2H, 08bH, ' ', 00H, 'I', 00H, 'T', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, 0a5H, 'c', 0e3H, 'S1Y%', 08dH, 00H, 00H
	ORG $+2
$SG61506 DB	'f', 00H, 'r', 00H, '-', 00H, 'L', 00H, 'U', 00H, 00H, 00H
$SG61507 DB	'b', 00H, 's', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61508 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 'S', 00H, 'E', 00H
	DB	00H, 00H
	ORG $+2
$SG61509 DB	'a', 00H, 'r', 00H, '-', 00H, 'M', 00H, 'A', 00H, 00H, 00H
$SG61510 DB	'e', 00H, 'n', 00H, '-', 00H, 'I', 00H, 'E', 00H, 00H, 00H
$SG61511 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'A', 00H, 00H, 00H
?IID_IDataBaseEngine@@3U_GUID@@B DD 03c56956dH		; IID_IDataBaseEngine
	DW	01690H
	DW	04c22H
	DB	088H
	DB	034H
	DB	09eH
	DB	0b9H
	DB	0d0H
	DB	093H
	DB	066H
	DB	04cH
$SG61512 DB	'f', 00H, 'r', 00H, '-', 00H, 'M', 00H, 'C', 00H, 00H, 00H
$SG61513 DB	's', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61514 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 'N', 00H, 'O', 00H
	DB	00H, 00H
	ORG $+2
$SG61515 DB	'a', 00H, 'r', 00H, '-', 00H, 'T', 00H, 'N', 00H, 00H, 00H
$SG61516 DB	'e', 00H, 'n', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61517 DB	'e', 00H, 's', 00H, '-', 00H, 'D', 00H, 'O', 00H, 00H, 00H
$SG61518 DB	's', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H
	DB	'C', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61519 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 'S', 00H, 'E', 00H
	DB	00H, 00H
	ORG $+2
$SG61520 DB	'a', 00H, 'r', 00H, '-', 00H, 'O', 00H, 'M', 00H, 00H, 00H
$SG61521 DB	'e', 00H, 'n', 00H, '-', 00H, 'J', 00H, 'M', 00H, 00H, 00H
$SG61522 DB	'e', 00H, 's', 00H, '-', 00H, 'V', 00H, 'E', 00H, 00H, 00H
$SG61523 DB	's', 00H, 'm', 00H, 's', 00H, '-', 00H, 'F', 00H, 'I', 00H
	DB	00H, 00H
	ORG $+2
$SG61524 DB	'a', 00H, 'r', 00H, '-', 00H, 'Y', 00H, 'E', 00H, 00H, 00H
$SG61525 DB	'e', 00H, 'n', 00H, '-', 00H, 'C', 00H, 'B', 00H, 00H, 00H
$SG61526 DB	'e', 00H, 's', 00H, '-', 00H, 'C', 00H, 'O', 00H, 00H, 00H
$SG61527 DB	's', 00H, 'm', 00H, 'n', 00H, '-', 00H, 'F', 00H, 'I', 00H
	DB	00H, 00H
	ORG $+2
$SG61528 DB	'a', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'Y', 00H, 00H, 00H
$SG61529 DB	'e', 00H, 'n', 00H, '-', 00H, 'B', 00H, 'Z', 00H, 00H, 00H
$SG61530 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'E', 00H, 00H, 00H
$SG60506 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG61531 DB	'a', 00H, 'r', 00H, '-', 00H, 'J', 00H, 'O', 00H, 00H, 00H
$SG61532 DB	'e', 00H, 'n', 00H, '-', 00H, 'T', 00H, 'T', 00H, 00H, 00H
$SG61533 DB	'e', 00H, 's', 00H, '-', 00H, 'A', 00H, 'R', 00H, 00H, 00H
$SG61534 DB	'a', 00H, 'r', 00H, '-', 00H, 'L', 00H, 'B', 00H, 00H, 00H
$SG61535 DB	'e', 00H, 'n', 00H, '-', 00H, 'Z', 00H, 'W', 00H, 00H, 00H
$SG61536 DB	'e', 00H, 's', 00H, '-', 00H, 'E', 00H, 'C', 00H, 00H, 00H
$SG61537 DB	'a', 00H, 'r', 00H, '-', 00H, 'K', 00H, 'W', 00H, 00H, 00H
$SG61538 DB	'e', 00H, 'n', 00H, '-', 00H, 'P', 00H, 'H', 00H, 00H, 00H
$SG61539 DB	'e', 00H, 's', 00H, '-', 00H, 'C', 00H, 'L', 00H, 00H, 00H
$SG109668 DB	'S', 00H, 00H, 00H
$SG61540 DB	'a', 00H, 'r', 00H, '-', 00H, 'A', 00H, 'E', 00H, 00H, 00H
$SG61541 DB	'e', 00H, 's', 00H, '-', 00H, 'U', 00H, 'Y', 00H, 00H, 00H
$SG109670 DB	'M', 00H, 00H, 00H
$SG61542 DB	'a', 00H, 'r', 00H, '-', 00H, 'B', 00H, 'H', 00H, 00H, 00H
$SG61543 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'Y', 00H, 00H, 00H
$SG314472 DB	'?b', 0f4H, 095H, 0f7H, 'S%', 00H, 'd', 00H, '-', 00H, '-'
	DB	00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG109672 DB	'D', 00H, 00H, 00H
$SG61544 DB	'a', 00H, 'r', 00H, '-', 00H, 'Q', 00H, 'A', 00H, 00H, 00H
$SG61545 DB	'e', 00H, 's', 00H, '-', 00H, 'B', 00H, 'O', 00H, 00H, 00H
$SG109674 DB	'B', 00H, 00H, 00H
$SG61546 DB	'e', 00H, 's', 00H, '-', 00H, 'S', 00H, 'V', 00H, 00H, 00H
$SG61547 DB	'e', 00H, 's', 00H, '-', 00H, 'H', 00H, 'N', 00H, 00H, 00H
$SG109676 DB	'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG61548 DB	'e', 00H, 's', 00H, '-', 00H, 'N', 00H, 'I', 00H, 00H, 00H
$SG61549 DB	'e', 00H, 's', 00H, '-', 00H, 'P', 00H, 'R', 00H, 00H, 00H
$SG109678 DB	'F', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG61550 DB	'z', 00H, 'h', 00H, '-', 00H, 'C', 00H, 'H', 00H, 'T', 00H
	DB	00H, 00H
	ORG $+2
$SG61551 DB	's', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG109680 DB	'N', 00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'v', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61553 DB	00H, 00H
	ORG $+2
$SG109682 DB	'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG61554 DB	'a', 00H, 'f', 00H, 00H, 00H
	ORG $+2
$SG61555 DB	'a', 00H, 'f', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61556 DB	'a', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61557 DB	'a', 00H, 'r', 00H, '-', 00H, 'a', 00H, 'e', 00H, 00H, 00H
$SG61558 DB	'a', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'h', 00H, 00H, 00H
$SG61559 DB	'a', 00H, 'r', 00H, '-', 00H, 'd', 00H, 'z', 00H, 00H, 00H
$SG61560 DB	'a', 00H, 'r', 00H, '-', 00H, 'e', 00H, 'g', 00H, 00H, 00H
$SG61561 DB	'a', 00H, 'r', 00H, '-', 00H, 'i', 00H, 'q', 00H, 00H, 00H
$SG61562 DB	'a', 00H, 'r', 00H, '-', 00H, 'j', 00H, 'o', 00H, 00H, 00H
$SG61563 DB	'a', 00H, 'r', 00H, '-', 00H, 'k', 00H, 'w', 00H, 00H, 00H
$SG61564 DB	'a', 00H, 'r', 00H, '-', 00H, 'l', 00H, 'b', 00H, 00H, 00H
$SG61565 DB	'a', 00H, 'r', 00H, '-', 00H, 'l', 00H, 'y', 00H, 00H, 00H
$SG61566 DB	'a', 00H, 'r', 00H, '-', 00H, 'm', 00H, 'a', 00H, 00H, 00H
$SG61567 DB	'a', 00H, 'r', 00H, '-', 00H, 'o', 00H, 'm', 00H, 00H, 00H
$SG61568 DB	'a', 00H, 'r', 00H, '-', 00H, 'q', 00H, 'a', 00H, 00H, 00H
$SG61569 DB	'a', 00H, 'r', 00H, '-', 00H, 's', 00H, 'a', 00H, 00H, 00H
$SG61570 DB	'a', 00H, 'r', 00H, '-', 00H, 's', 00H, 'y', 00H, 00H, 00H
$SG61571 DB	'a', 00H, 'r', 00H, '-', 00H, 't', 00H, 'n', 00H, 00H, 00H
$SG61572 DB	'a', 00H, 'r', 00H, '-', 00H, 'y', 00H, 'e', 00H, 00H, 00H
$SG61573 DB	'a', 00H, 'z', 00H, 00H, 00H
	ORG $+2
$SG61574 DB	'a', 00H, 'z', 00H, '-', 00H, 'a', 00H, 'z', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61575 DB	'a', 00H, 'z', 00H, '-', 00H, 'a', 00H, 'z', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61576 DB	'b', 00H, 'e', 00H, 00H, 00H
	ORG $+2
?IID_IUDPNetworkEngine@@3U_GUID@@B DD 0bbbd895aH	; IID_IUDPNetworkEngine
	DW	0a97H
	DW	04faeH
	DB	08eH
	DB	038H
	DB	010H
	DB	076H
	DB	0a7H
	DB	0c7H
	DB	04dH
	DB	07fH
$SG61577 DB	'b', 00H, 'e', 00H, '-', 00H, 'b', 00H, 'y', 00H, 00H, 00H
$SG60553 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG61579 DB	'b', 00H, 'g', 00H, '-', 00H, 'b', 00H, 'g', 00H, 00H, 00H
$SG313482 DB	'8n', 0fH, 'b', 00H, '_', 0cbH, 'Ys', 00H, 'e', 00H, 'r', 00H
	DB	'v', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, '=', 00H, '%', 00H, 'd', 00H, ',', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e', 00H, '=', 00H, '%'
	DB	00H, 'd', 00H, ',', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e'
	DB	00H, '=', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG61578 DB	'b', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG61580 DB	'b', 00H, 'n', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61581 DB	'b', 00H, 's', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61582 DB	'c', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61583 DB	'c', 00H, 'a', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61584 DB	'c', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61585 DB	'c', 00H, 's', 00H, '-', 00H, 'c', 00H, 'z', 00H, 00H, 00H
$SG61586 DB	'c', 00H, 'y', 00H, '-', 00H, 'g', 00H, 'b', 00H, 00H, 00H
$SG61587 DB	'd', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61588 DB	'd', 00H, 'a', 00H, '-', 00H, 'd', 00H, 'k', 00H, 00H, 00H
$SG61589 DB	'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61590 DB	'd', 00H, 'e', 00H, '-', 00H, 'a', 00H, 't', 00H, 00H, 00H
$SG61591 DB	'd', 00H, 'e', 00H, '-', 00H, 'c', 00H, 'h', 00H, 00H, 00H
$SG61592 DB	'd', 00H, 'e', 00H, '-', 00H, 'd', 00H, 'e', 00H, 00H, 00H
$SG313497 DB	'8n', 0fH, 'b', 00H, '_', 0cbH, 'Y1', 00H, ',', 00H, 084H
	DB	'^', 0b6H, '[%', 00H, 'd', 00H, 0efH, 'S', 0a8H, 'R\O%', 00H, 'd'
	DB	00H, 00H, 00H
$SG61593 DB	'd', 00H, 'e', 00H, '-', 00H, 'l', 00H, 'i', 00H, 00H, 00H
$SG61594 DB	'd', 00H, 'e', 00H, '-', 00H, 'l', 00H, 'u', 00H, 00H, 00H
$SG61595 DB	'd', 00H, 'i', 00H, 'v', 00H, 00H, 00H
$SG61596 DB	'd', 00H, 'i', 00H, 'v', 00H, '-', 00H, 'm', 00H, 'v', 00H
	DB	00H, 00H
	ORG $+2
$SG61597 DB	'e', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61598 DB	'e', 00H, 'l', 00H, '-', 00H, 'g', 00H, 'r', 00H, 00H, 00H
$SG61599 DB	'e', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61600 DB	'e', 00H, 'n', 00H, '-', 00H, 'a', 00H, 'u', 00H, 00H, 00H
$SG61601 DB	'e', 00H, 'n', 00H, '-', 00H, 'b', 00H, 'z', 00H, 00H, 00H
$SG61602 DB	'e', 00H, 'n', 00H, '-', 00H, 'c', 00H, 'a', 00H, 00H, 00H
$SG61603 DB	'e', 00H, 'n', 00H, '-', 00H, 'c', 00H, 'b', 00H, 00H, 00H
$SG61604 DB	'e', 00H, 'n', 00H, '-', 00H, 'g', 00H, 'b', 00H, 00H, 00H
$SG61605 DB	'e', 00H, 'n', 00H, '-', 00H, 'i', 00H, 'e', 00H, 00H, 00H
$SG61606 DB	'e', 00H, 'n', 00H, '-', 00H, 'j', 00H, 'm', 00H, 00H, 00H
$SG61607 DB	'e', 00H, 'n', 00H, '-', 00H, 'n', 00H, 'z', 00H, 00H, 00H
$SG61608 DB	'e', 00H, 'n', 00H, '-', 00H, 'p', 00H, 'h', 00H, 00H, 00H
$SG61609 DB	'e', 00H, 'n', 00H, '-', 00H, 't', 00H, 't', 00H, 00H, 00H
$SG61610 DB	'e', 00H, 'n', 00H, '-', 00H, 'u', 00H, 's', 00H, 00H, 00H
$SG61611 DB	'e', 00H, 'n', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
?IID_ITCPNetworkEngine@@3U_GUID@@B DD 09aa6931fH	; IID_ITCPNetworkEngine
	DW	0417fH
	DW	043a7H
	DB	086H
	DB	0abH
	DB	056H
	DB	010H
	DB	0e4H
	DB	034H
	DB	01cH
	DB	017H
$SG61612 DB	'e', 00H, 'n', 00H, '-', 00H, 'z', 00H, 'w', 00H, 00H, 00H
$SG61613 DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61614 DB	'e', 00H, 's', 00H, '-', 00H, 'a', 00H, 'r', 00H, 00H, 00H
$SG61615 DB	'e', 00H, 's', 00H, '-', 00H, 'b', 00H, 'o', 00H, 00H, 00H
$SG61616 DB	'e', 00H, 's', 00H, '-', 00H, 'c', 00H, 'l', 00H, 00H, 00H
$SG61617 DB	'e', 00H, 's', 00H, '-', 00H, 'c', 00H, 'o', 00H, 00H, 00H
$SG61618 DB	'e', 00H, 's', 00H, '-', 00H, 'c', 00H, 'r', 00H, 00H, 00H
$SG61619 DB	'e', 00H, 's', 00H, '-', 00H, 'd', 00H, 'o', 00H, 00H, 00H
$SG61620 DB	'e', 00H, 's', 00H, '-', 00H, 'e', 00H, 'c', 00H, 00H, 00H
$SG61621 DB	'e', 00H, 's', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61622 DB	'e', 00H, 's', 00H, '-', 00H, 'g', 00H, 't', 00H, 00H, 00H
$SG61623 DB	'e', 00H, 's', 00H, '-', 00H, 'h', 00H, 'n', 00H, 00H, 00H
$SG61624 DB	'e', 00H, 's', 00H, '-', 00H, 'm', 00H, 'x', 00H, 00H, 00H
$SG60600 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e'
	DB	00H, 00H, 00H
$SG61625 DB	'e', 00H, 's', 00H, '-', 00H, 'n', 00H, 'i', 00H, 00H, 00H
$SG61626 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'a', 00H, 00H, 00H
$SG61627 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'e', 00H, 00H, 00H
$SG61628 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'r', 00H, 00H, 00H
$SG61629 DB	'e', 00H, 's', 00H, '-', 00H, 'p', 00H, 'y', 00H, 00H, 00H
$SG61630 DB	'e', 00H, 's', 00H, '-', 00H, 's', 00H, 'v', 00H, 00H, 00H
$SG61631 DB	'e', 00H, 's', 00H, '-', 00H, 'u', 00H, 'y', 00H, 00H, 00H
$SG61632 DB	'e', 00H, 's', 00H, '-', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG61633 DB	'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61634 DB	'e', 00H, 't', 00H, '-', 00H, 'e', 00H, 'e', 00H, 00H, 00H
$SG61635 DB	'e', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61636 DB	'e', 00H, 'u', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61637 DB	'f', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61638 DB	'f', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'r', 00H, 00H, 00H
$SG61639 DB	'f', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61640 DB	'f', 00H, 'i', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H
$SG61641 DB	'f', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61642 DB	'f', 00H, 'o', 00H, '-', 00H, 'f', 00H, 'o', 00H, 00H, 00H
$SG61643 DB	'f', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61644 DB	'f', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'e', 00H, 00H, 00H
$SG61645 DB	'f', 00H, 'r', 00H, '-', 00H, 'c', 00H, 'a', 00H, 00H, 00H
$SG61646 DB	'f', 00H, 'r', 00H, '-', 00H, 'c', 00H, 'h', 00H, 00H, 00H
$SG61647 DB	'f', 00H, 'r', 00H, '-', 00H, 'f', 00H, 'r', 00H, 00H, 00H
$SG61648 DB	'f', 00H, 'r', 00H, '-', 00H, 'l', 00H, 'u', 00H, 00H, 00H
$SG61649 DB	'f', 00H, 'r', 00H, '-', 00H, 'm', 00H, 'c', 00H, 00H, 00H
$SG61650 DB	'g', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61651 DB	'g', 00H, 'l', 00H, '-', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG61652 DB	'g', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61653 DB	'g', 00H, 'u', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61654 DB	'h', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61655 DB	'h', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'l', 00H, 00H, 00H
$SG61656 DB	'h', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61657 DB	'h', 00H, 'i', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
?IID_ITCPSocketService@@3U_GUID@@B DD 0f8a5c14H		; IID_ITCPSocketService
	DW	0ab92H
	DW	0467cH
	DB	0b6H
	DB	07bH
	DB	06dH
	DB	08aH
	DB	0cfH
	DB	064H
	DB	052H
	DB	0d7H
$SG61658 DB	'h', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61659 DB	'h', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, 00H, 00H
$SG61660 DB	'h', 00H, 'r', 00H, '-', 00H, 'h', 00H, 'r', 00H, 00H, 00H
$SG61661 DB	'h', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61662 DB	'h', 00H, 'u', 00H, '-', 00H, 'h', 00H, 'u', 00H, 00H, 00H
$SG61663 DB	'h', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61664 DB	'h', 00H, 'y', 00H, '-', 00H, 'a', 00H, 'm', 00H, 00H, 00H
$SG61665 DB	'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG61666 DB	'i', 00H, 'd', 00H, '-', 00H, 'i', 00H, 'd', 00H, 00H, 00H
$SG61667 DB	'i', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61668 DB	'i', 00H, 's', 00H, '-', 00H, 'i', 00H, 's', 00H, 00H, 00H
$SG61669 DB	'i', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61670 DB	'i', 00H, 't', 00H, '-', 00H, 'c', 00H, 'h', 00H, 00H, 00H
$SG61671 DB	'i', 00H, 't', 00H, '-', 00H, 'i', 00H, 't', 00H, 00H, 00H
$SG60647 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'l', 00H, 00H, 00H
$SG61672 DB	'j', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61673 DB	'j', 00H, 'a', 00H, '-', 00H, 'j', 00H, 'p', 00H, 00H, 00H
$SG61674 DB	'k', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61675 DB	'k', 00H, 'a', 00H, '-', 00H, 'g', 00H, 'e', 00H, 00H, 00H
$SG61676 DB	'k', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61677 DB	'k', 00H, 'k', 00H, '-', 00H, 'k', 00H, 'z', 00H, 00H, 00H
$SG61678 DB	'k', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61679 DB	'k', 00H, 'n', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61680 DB	'k', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61681 DB	'k', 00H, 'o', 00H, 'k', 00H, 00H, 00H
$SG61682 DB	'k', 00H, 'o', 00H, 'k', 00H, '-', 00H, 'i', 00H, 'n', 00H
	DB	00H, 00H
	ORG $+2
$SG61683 DB	'k', 00H, 'o', 00H, '-', 00H, 'k', 00H, 'r', 00H, 00H, 00H
$SG61684 DB	'k', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61685 DB	'k', 00H, 'y', 00H, '-', 00H, 'k', 00H, 'g', 00H, 00H, 00H
$SG61686 DB	'l', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61687 DB	'l', 00H, 't', 00H, '-', 00H, 'l', 00H, 't', 00H, 00H, 00H
$SG61688 DB	'l', 00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG61689 DB	'l', 00H, 'v', 00H, '-', 00H, 'l', 00H, 'v', 00H, 00H, 00H
$SG61690 DB	'm', 00H, 'i', 00H, '-', 00H, 'n', 00H, 'z', 00H, 00H, 00H
?IID_IWEBSocketService@@3U_GUID@@B DD 05502d590H	; IID_IWEBSocketService
	DW	0c446H
	DW	0440dH
	DB	0a1H
	DB	095H
	DB	03eH
	DB	0daH
	DB	011H
	DB	0f8H
	DB	0dH
	DB	064H
$SG61691 DB	'm', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61692 DB	'm', 00H, 'k', 00H, '-', 00H, 'm', 00H, 'k', 00H, 00H, 00H
$SG61693 DB	'm', 00H, 'l', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61694 DB	'm', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61695 DB	'm', 00H, 'n', 00H, '-', 00H, 'm', 00H, 'n', 00H, 00H, 00H
$SG61696 DB	'm', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61697 DB	'm', 00H, 'r', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61698 DB	'm', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61699 DB	'm', 00H, 's', 00H, '-', 00H, 'b', 00H, 'n', 00H, 00H, 00H
$SG61700 DB	'm', 00H, 's', 00H, '-', 00H, 'm', 00H, 'y', 00H, 00H, 00H
$SG61701 DB	'm', 00H, 't', 00H, '-', 00H, 'm', 00H, 't', 00H, 00H, 00H
$SG61702 DB	'n', 00H, 'b', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H
$SG61703 DB	'n', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61704 DB	'n', 00H, 'l', 00H, '-', 00H, 'b', 00H, 'e', 00H, 00H, 00H
$SG61705 DB	'n', 00H, 'l', 00H, '-', 00H, 'n', 00H, 'l', 00H, 00H, 00H
$SG61706 DB	'n', 00H, 'n', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H
$SG61707 DB	'n', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61708 DB	'n', 00H, 's', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61709 DB	'p', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61710 DB	'p', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61711 DB	'p', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61712 DB	'p', 00H, 'l', 00H, '-', 00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG61713 DB	'p', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61714 DB	'p', 00H, 't', 00H, '-', 00H, 'b', 00H, 'r', 00H, 00H, 00H
$SG61715 DB	'p', 00H, 't', 00H, '-', 00H, 'p', 00H, 't', 00H, 00H, 00H
$SG61716 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'b', 00H, 'o', 00H
	DB	00H, 00H
	ORG $+2
?IID_ITimerEngine@@3U_GUID@@B DD 0c90cfc81H		; IID_ITimerEngine
	DW	0ee01H
	DW	04654H
	DB	08cH
	DB	09aH
	DB	058H
	DB	0a9H
	DB	04bH
	DB	078H
	DB	076H
	DB	0b6H
$SG61717 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'e', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG61718 DB	'q', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'p', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG60694 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG61719 DB	'r', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61720 DB	'r', 00H, 'o', 00H, '-', 00H, 'r', 00H, 'o', 00H, 00H, 00H
$SG61721 DB	'r', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61722 DB	'r', 00H, 'u', 00H, '-', 00H, 'r', 00H, 'u', 00H, 00H, 00H
$SG61723 DB	's', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61724 DB	's', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61725 DB	's', 00H, 'e', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H
$SG61726 DB	's', 00H, 'e', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H
$SG61727 DB	's', 00H, 'e', 00H, '-', 00H, 's', 00H, 'e', 00H, 00H, 00H
$SG61728 DB	's', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61729 DB	's', 00H, 'k', 00H, '-', 00H, 's', 00H, 'k', 00H, 00H, 00H
$SG61730 DB	's', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61731 DB	's', 00H, 'l', 00H, '-', 00H, 's', 00H, 'i', 00H, 00H, 00H
$SG61732 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 'n', 00H, 'o', 00H
	DB	00H, 00H
	ORG $+2
$SG61733 DB	's', 00H, 'm', 00H, 'a', 00H, '-', 00H, 's', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG61734 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 'n', 00H, 'o', 00H
	DB	00H, 00H
	ORG $+2
$SG61735 DB	's', 00H, 'm', 00H, 'j', 00H, '-', 00H, 's', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG61736 DB	's', 00H, 'm', 00H, 'n', 00H, '-', 00H, 'f', 00H, 'i', 00H
	DB	00H, 00H
	ORG $+2
$SG61737 DB	's', 00H, 'm', 00H, 's', 00H, '-', 00H, 'f', 00H, 'i', 00H
	DB	00H, 00H
	ORG $+2
$SG61738 DB	's', 00H, 'q', 00H, 00H, 00H
	ORG $+2
$SG61739 DB	's', 00H, 'q', 00H, '-', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG61740 DB	's', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61741 DB	's', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61742 DB	's', 00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61743 DB	's', 00H, 'r', 00H, '-', 00H, 's', 00H, 'p', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61744 DB	's', 00H, 'r', 00H, '-', 00H, 's', 00H, 'p', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61745 DB	's', 00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG61746 DB	's', 00H, 'v', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H
$SG61747 DB	's', 00H, 'v', 00H, '-', 00H, 's', 00H, 'e', 00H, 00H, 00H
?IID_IUnknownEx@@3U_GUID@@B DD 05feec21eH		; IID_IUnknownEx
	DW	0dbf3H
	DW	046f0H
	DB	09fH
	DB	057H
	DB	0d1H
	DB	0cdH
	DB	071H
	DB	01cH
	DB	046H
	DB	0deH
$SG61748 DB	's', 00H, 'w', 00H, 00H, 00H
	ORG $+2
$SG61749 DB	's', 00H, 'w', 00H, '-', 00H, 'k', 00H, 'e', 00H, 00H, 00H
$SG61750 DB	's', 00H, 'y', 00H, 'r', 00H, 00H, 00H
$SG61751 DB	's', 00H, 'y', 00H, 'r', 00H, '-', 00H, 's', 00H, 'y', 00H
	DB	00H, 00H
	ORG $+2
$SG61752 DB	't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61753 DB	't', 00H, 'a', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61754 DB	't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61755 DB	't', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG61756 DB	't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG61757 DB	't', 00H, 'h', 00H, '-', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG61758 DB	't', 00H, 'n', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61759 DB	't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
?IID_ITableFrame@@3U_GUID@@B DD 02e577d5fH		; IID_ITableFrame
	DW	01e01H
	DW	044ffH
	DB	09fH
	DB	0f4H
	DB	01H
	DB	016H
	DB	023H
	DB	01bH
	DB	076H
	DB	015H
$SG61760 DB	't', 00H, 'r', 00H, '-', 00H, 't', 00H, 'r', 00H, 00H, 00H
$SG61761 DB	't', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61762 DB	't', 00H, 't', 00H, '-', 00H, 'r', 00H, 'u', 00H, 00H, 00H
$SG61763 DB	'u', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61764 DB	'u', 00H, 'k', 00H, '-', 00H, 'u', 00H, 'a', 00H, 00H, 00H
$SG61765 DB	'u', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG60741 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H
$SG61766 DB	'u', 00H, 'r', 00H, '-', 00H, 'p', 00H, 'k', 00H, 00H, 00H
$SG61767 DB	'u', 00H, 'z', 00H, 00H, 00H
	ORG $+2
$SG61768 DB	'u', 00H, 'z', 00H, '-', 00H, 'u', 00H, 'z', 00H, '-', 00H
	DB	'c', 00H, 'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61769 DB	'u', 00H, 'z', 00H, '-', 00H, 'u', 00H, 'z', 00H, '-', 00H
	DB	'l', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61770 DB	'v', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG60746 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG61771 DB	'v', 00H, 'i', 00H, '-', 00H, 'v', 00H, 'n', 00H, 00H, 00H
$SG313676 DB	0a9H, 's', 0b6H, '[:_', 00H, 090H, ':', 00H, 'w', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'i', 00H, 'r', 00H, '=', 00H, '%', 00H
	DB	'd', 00H, ',', 00H, 'c', 00H, 'b', 00H, 'r', 00H, 'e', 00H, 's'
	DB	00H, 'o', 00H, 'n', 00H, '=', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG61772 DB	'x', 00H, 'h', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG61773 DB	'z', 00H, 'h', 00H, '-', 00H, 'c', 00H, 'h', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG61774 DB	'z', 00H, 'h', 00H, '-', 00H, 'c', 00H, 'h', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG313679 DB	0e3H, 089H, 'ce', 00H, 00H
	ORG $+2
$SG61775 DB	'z', 00H, 'h', 00H, '-', 00H, 'c', 00H, 'n', 00H, 00H, 00H
$SG61776 DB	'z', 00H, 'h', 00H, '-', 00H, 'h', 00H, 'k', 00H, 00H, 00H
$SG61777 DB	'z', 00H, 'h', 00H, '-', 00H, 'm', 00H, 'o', 00H, 00H, 00H
$SG61778 DB	'z', 00H, 'h', 00H, '-', 00H, 's', 00H, 'g', 00H, 00H, 00H
$SG61779 DB	'z', 00H, 'h', 00H, '-', 00H, 't', 00H, 'w', 00H, 00H, 00H
$SG61780 DB	'z', 00H, 'u', 00H, '-', 00H, 'z', 00H, 'a', 00H, 00H, 00H
$SG60793 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG313730 DB	0a9H, 's', 0b6H, '[%', 00H, 'd', 00H, 0adH, 'e', 0bfH, '~'
	DB	0cdH, 091H, 0deH, 08fH, 00H, 00H
	ORG $+2
$SG313753 DB	0faH, 'QLr', 012H, 'P', 0a1H, 08bH, 0f6H, 'e', 0d3H, '~_g'
	DB	0cH, 0ffH, 'S_MR', 0a9H, 's', 0b6H, '[%', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG313757 DB	0cdH, 'd\O', 012H, 'P', 0a1H, 08bH, 0f6H, 'e', 0d3H, '~_g'
	DB	0cH, 0ffH, 0a9H, 's', 0b6H, '[%', 00H, 'd', 00H, 00H, 00H
	ORG $+2
?IID_IAttemperEngine@@3U_GUID@@B DD 04d5d2424H		; IID_IAttemperEngine
	DW	040fdH
	DW	04747H
	DB	086H
	DB	0d8H
	DB	08fH
	DB	0caH
	DB	06bH
	DB	096H
	DB	0eaH
	DB	0bH
$SG60840 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+2
$SG60887 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I'
	DB	00H, 00H, 00H
$SG59871 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG313878 DB	0faH, 'QLre', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	'1', 00H, 00H, 00H
	ORG $+2
$SG313835 DB	0a9H, 's', 0b6H, '[', 0dbH, 08fH, 'eQ:', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'i', 00H, 'r', 00H, '=', 00H, '%', 00H, 'd', 00H
	DB	',', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'i', 00H, 'd'
	DB	00H, '=', 00H, '%', 00H, 'd', 00H, ',', 00H, 'n', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, '=', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG313853 DB	0a9H, 's', 0b6H, '[', 0bbH, 'y', 00H, '_:', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'i', 00H, 'r', 00H, '=', 00H, '%', 00H, 'd'
	DB	00H, ',', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'i', 00H
	DB	'd', 00H, '=', 00H, '%', 00H, 'd', 00H, ',', 00H, 'n', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, '=', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG313876 DB	0a9H, 's', 0b6H, '[%', 00H, 'd', 00H, 0faH, 'QLr%', 00H, '0'
	DB	00H, 'x', 00H, ',', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, '=', 00H, '%', 00H, 'd', 00H, ','
	DB	00H, 's', 00H, 'y', 00H, 's', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	'%', 00H, 'd', 00H, ',', 00H, 't', 00H, 'r', 00H, 'u', 00H, 's'
	DB	00H, 't', 00H, 'e', 00H, 'e', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG313881 DB	0faH, 'QLre', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	'2', 00H, 00H, 00H
	ORG $+2
$SG313884 DB	0faH, 'QLre', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	'3', 00H, 00H, 00H
	ORG $+2
$SG313887 DB	0faH, 'QLre', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	'4', 00H, 00H, 00H
	ORG $+2
$SG59942 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H
?IID_ITableFrameSink@@3U_GUID@@B DD 09476b154H		; IID_ITableFrameSink
	DW	08bebH
	DW	04f7eH
	DB	0afH
	DB	064H
	DB	0d2H
	DB	0b1H
	DB	01aH
	DB	0daH
	DB	05eH
	DB	0c4H
$SG59989 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H
	ORG $+2
?IID_ITableUserAction@@3U_GUID@@B DD 0f9aa3f9H		; IID_ITableUserAction
	DW	0dba4H
	DW	049cbH
	DB	088H
	DB	04fH
	DB	0d9H
	DB	011H
	DB	0afH
	DB	024H
	DB	0fbH
	DB	08dH
$SG313985 DB	0abH, 088H, 0a8H, 'R', 0a8H, 'R\O ', 00H, 0a9H, 's', 0b6H
	DB	'[%', 00H, 'd', 00H, 'gbL', 088H, 0cdH, 'd\O%', 00H, 'd', 00H, 00H
	DB	00H
$SG60036 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H
?IID_IFaceItemControl@@3U_GUID@@B DD 0fc9067a9H		; IID_IFaceItemControl
	DW	0162eH
	DW	04e13H
	DB	0b0H
	DB	01H
	DB	0f7H
	DB	057H
	DB	09eH
	DB	0a4H
	DB	060H
	DB	06bH
$SG60083 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG314038 DB	';N', 0a8H, 'R', 0a8H, 'R\O%', 00H, 'd', 00H, 0a9H, 's', 0b6H
	DB	'[%', 00H, 'd', 00H, '>e', 03H, '_', 00H, 00H
	ORG $+2
$SG82624 DB	'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'T'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG82626 DB	'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'T'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 'S', 00H, 'p', 00H, 'a', 00H
	DB	'n', 00H, 00H, 00H
	ORG $+2
?IID_IFaceSelectControl@@3U_GUID@@B DD 08514020bH	; IID_IFaceSelectControl
	DW	082a2H
	DW	042d9H
	DB	090H
	DB	019H
	DB	032H
	DB	0a4H
	DB	0eaH
	DB	0ceH
	DB	09fH
	DB	075H
$SG60130 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG314091 DB	0a9H, 's', 0b6H, '[%', 00H, 'd', 00H, 'Xb', 0a1H, '{', 00H
	DB	00H
	ORG $+2
$SG314092 DB	0a9H, 's', 0b6H, '[%', 00H, 'd', 00H, 0d6H, 'S', 088H, 'm'
	DB	'Xb', 0a1H, '{', 00H, 00H
	ORG $+2
?IID_ICustomFaceManager@@3U_GUID@@B DD 0bcd7ff05H	; IID_ICustomFaceManager
	DW	0a79H
	DW	04482H
	DB	09bH
	DB	0a6H
	DB	079H
	DB	0dfH
	DB	04bH
	DB	0d9H
	DB	080H
	DB	016H
$SG60177 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r'
	DB	00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG314131 DB	0a9H, 's', 0b6H, '[%', 00H, 'd', 00H, 0efH, 'S', 0a8H, 'R'
	DB	'\O%', 00H, 'd', 00H, 00H, 00H
$SG110357 DB	'A', 00H, 'p', 00H, 'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG110358 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG110359 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG110360 DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110361 DB	'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG110362 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110363 DB	'M', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110364 DB	'S', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG110365 DB	'S', 00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG110366 DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	00H, 00H
	ORG $+2
$SG110367 DB	'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG110368 DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H
	DB	'b', 00H, 00H, 00H
$SG60224 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 00H, 00H
?IID_ITCPSocket@@3U_GUID@@B DD 0a870d592H		; IID_ITCPSocket
	DW	0447aH
	DW	040bdH
	DB	0aeH
	DB	04eH
	DB	05eH
	DB	064H
	DB	0deH
	DB	0ceH
	DB	022H
	DB	0edH
?IID_IPlazaUserManager@@3U_GUID@@B DD 0a2992ab9H	; IID_IPlazaUserManager
	DW	02fddH
	DW	04f9fH
	DB	0bbH
	DB	0acH
	DB	0cfH
	DB	08bH
	DB	060H
	DB	070H
	DB	080H
	DB	0cdH
$SG314205 DB	'R', 083H, 084H, '^', 00H, 00H
	ORG $+2
$SG60271 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
?IID_IAndroidUserItemSink@@3U_GUID@@B DD 0967632cH	; IID_IAndroidUserItemSink
	DW	093daH
	DW	04f7fH
	DB	098H
	DB	0e4H
	DB	06fH
	DB	09fH
	DB	0f2H
	DB	0caH
	DB	07bH
	DB	0c4H
?IID_IGameUserManager@@3U_GUID@@B DD 0b0e334b9H		; IID_IGameUserManager
	DW	0f693H
	DW	04c5fH
	DB	087H
	DB	0fH
	DB	066H
	DB	077H
	DB	0aH
	DB	0b9H
	DB	093H
	DB	0b2H
?IID_IUDPSocket@@3U_GUID@@B DD 011e344d0H		; IID_IUDPSocket
	DW	0ace1H
	DW	04a72H
	DB	0abH
	DB	0acH
	DB	06fH
	DB	031H
	DB	013H
	DB	0bfH
	DB	0c9H
	DB	023H
$SG61324 DB	'a', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61325 DB	'b', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG61326 DB	'c', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61327 DB	'z', 00H, 'h', 00H, '-', 00H, 'C', 00H, 'H', 00H, 'S', 00H
	DB	00H, 00H
	ORG $+2
$SG61328 DB	'c', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61329 DB	'd', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61330 DB	'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61331 DB	'e', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61332 DB	'e', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61333 DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61334 DB	'f', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61335 DB	'f', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61336 DB	'h', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61337 DB	'h', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61338 DB	'i', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61339 DB	'i', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61340 DB	'j', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61341 DB	'k', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61342 DB	'n', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG60318 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o'
	DB	00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61343 DB	'n', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61344 DB	'p', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61345 DB	'p', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61346 DB	'r', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61347 DB	'r', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61348 DB	'h', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61349 DB	's', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61350 DB	's', 00H, 'q', 00H, 00H, 00H
	ORG $+2
$SG61351 DB	's', 00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG61352 DB	't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG61353 DB	't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61354 DB	'u', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG61355 DB	'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG61356 DB	'u', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61357 DB	'b', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61358 DB	's', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61359 DB	'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61360 DB	'l', 00H, 'v', 00H, 00H, 00H
	ORG $+2
?IID_IGameLevelParser@@3U_GUID@@B DD 012823198H		; IID_IGameLevelParser
	DW	027b6H
	DW	046c5H
	DB	09cH
	DB	02cH
	DB	09cH
	DB	037H
	DB	08H
	DB	058H
	DB	0bfH
	DB	0faH
$SG61361 DB	'l', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61362 DB	'f', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61363 DB	'v', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61364 DB	'h', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61365 DB	'a', 00H, 'z', 00H, 00H, 00H
	ORG $+2
$SG61366 DB	'e', 00H, 'u', 00H, 00H, 00H
	ORG $+2
?IID_ITraceServiceManager@@3U_GUID@@B DD 06d14efe6H	; IID_ITraceServiceManager
	DW	0892aH
	DW	04a48H
	DB	092H
	DB	0c9H
	DB	0dbH
	DB	0eaH
	DB	092H
	DB	0ddH
	DB	0d5H
	DB	013H
$SG61367 DB	'm', 00H, 'k', 00H, 00H, 00H
	ORG $+2
?IID_IGameServiceManager@@3U_GUID@@B DD 0a975ccebH	; IID_IGameServiceManager
	DW	0331H
	DW	04553H
	DB	0a1H
	DB	0e0H
	DB	0a7H
	DB	0c7H
	DB	07aH
	DB	07cH
	DB	04eH
	DB	0fdH
$SG61368 DB	'a', 00H, 'f', 00H, 00H, 00H
	ORG $+2
$SG61369 DB	'k', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61370 DB	'f', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG61371 DB	'h', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG61372 DB	'm', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG61373 DB	'k', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG61374 DB	'k', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG61375 DB	's', 00H, 'w', 00H, 00H, 00H
	ORG $+2
$SG61376 DB	'u', 00H, 'z', 00H, 00H, 00H
	ORG $+2
?IID_IWHNetwork@@3U_GUID@@B DD 0e500997bH		; IID_IWHNetwork
	DW	0e45eH
	DW	0474eH
	DB	08aH
	DB	0d4H
	DB	0bcH
	DB	0f3H
	DB	04dH
	DB	089H
	DB	045H
	DB	041H
$SG61377 DB	't', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG61378 DB	'p', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61379 DB	'g', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG61380 DB	't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61381 DB	't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG61382 DB	'k', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61383 DB	'm', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG313288 DB	'S', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'o', 00H
	DB	'w', 00H, 'H', 00H, 'Z', 00H, 'H', 00H, 'G', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG61384 DB	's', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG61385 DB	'm', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG313290 DB	'CreateGameVideo', 00H
$SG61386 DB	'g', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG61387 DB	'k', 00H, 'o', 00H, 'k', 00H, 00H, 00H
$SG61388 DB	's', 00H, 'y', 00H, 'r', 00H, 00H, 00H
$SG61389 DB	'd', 00H, 'i', 00H, 'v', 00H, 00H, 00H
$SG60365 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i'
	DB	00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61390 DB	00H, 00H
	ORG $+2
$SG61391 DB	'a', 00H, 'r', 00H, '-', 00H, 'S', 00H, 'A', 00H, 00H, 00H
?IID_IUserOrderParser@@3U_GUID@@B DD 0eff89495H		; IID_IUserOrderParser
	DW	0e9daH
	DW	04ea3H
	DB	083H
	DB	064H
	DB	0aaH
	DB	0b2H
	DB	0afH
	DB	07fH
	DB	03H
	DB	0ceH
$SG61392 DB	'b', 00H, 'g', 00H, '-', 00H, 'B', 00H, 'G', 00H, 00H, 00H
$SG61393 DB	'c', 00H, 'a', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61394 DB	'z', 00H, 'h', 00H, '-', 00H, 'T', 00H, 'W', 00H, 00H, 00H
$SG61395 DB	'c', 00H, 's', 00H, '-', 00H, 'C', 00H, 'Z', 00H, 00H, 00H
$SG61396 DB	'd', 00H, 'a', 00H, '-', 00H, 'D', 00H, 'K', 00H, 00H, 00H
$SG61397 DB	'd', 00H, 'e', 00H, '-', 00H, 'D', 00H, 'E', 00H, 00H, 00H
$SG61398 DB	'e', 00H, 'l', 00H, '-', 00H, 'G', 00H, 'R', 00H, 00H, 00H
$SG61399 DB	'e', 00H, 'n', 00H, '-', 00H, 'U', 00H, 'S', 00H, 00H, 00H
$SG61400 DB	'f', 00H, 'i', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H
$SG61401 DB	'f', 00H, 'r', 00H, '-', 00H, 'F', 00H, 'R', 00H, 00H, 00H
$SG61402 DB	'h', 00H, 'e', 00H, '-', 00H, 'I', 00H, 'L', 00H, 00H, 00H
$SG61403 DB	'h', 00H, 'u', 00H, '-', 00H, 'H', 00H, 'U', 00H, 00H, 00H
$SG61404 DB	'i', 00H, 's', 00H, '-', 00H, 'I', 00H, 'S', 00H, 00H, 00H
$SG61405 DB	'i', 00H, 't', 00H, '-', 00H, 'I', 00H, 'T', 00H, 00H, 00H
$SG61406 DB	'j', 00H, 'a', 00H, '-', 00H, 'J', 00H, 'P', 00H, 00H, 00H
$SG61407 DB	'k', 00H, 'o', 00H, '-', 00H, 'K', 00H, 'R', 00H, 00H, 00H
$SG61408 DB	'n', 00H, 'l', 00H, '-', 00H, 'N', 00H, 'L', 00H, 00H, 00H
$SG61409 DB	'n', 00H, 'b', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H
?IID_IAsynchronismEngine@@3U_GUID@@B DD 0e03ad33dH	; IID_IAsynchronismEngine
	DW	0b285H
	DW	048eaH
	DB	086H
	DB	070H
	DB	0aH
	DB	095H
	DB	055H
	DB	092H
	DB	07H
	DB	0e1H
$SG61410 DB	'p', 00H, 'l', 00H, '-', 00H, 'P', 00H, 'L', 00H, 00H, 00H
$SG61411 DB	'p', 00H, 't', 00H, '-', 00H, 'B', 00H, 'R', 00H, 00H, 00H
$SG61412 DB	'r', 00H, 'o', 00H, '-', 00H, 'R', 00H, 'O', 00H, 00H, 00H
$SG61413 DB	'r', 00H, 'u', 00H, '-', 00H, 'R', 00H, 'U', 00H, 00H, 00H
$SG61414 DB	'h', 00H, 'r', 00H, '-', 00H, 'H', 00H, 'R', 00H, 00H, 00H
$SG61415 DB	's', 00H, 'k', 00H, '-', 00H, 'S', 00H, 'K', 00H, 00H, 00H
$SG61416 DB	's', 00H, 'q', 00H, '-', 00H, 'A', 00H, 'L', 00H, 00H, 00H
$SG61417 DB	's', 00H, 'v', 00H, '-', 00H, 'S', 00H, 'E', 00H, 00H, 00H
$SG61418 DB	't', 00H, 'h', 00H, '-', 00H, 'T', 00H, 'H', 00H, 00H, 00H
$SG61419 DB	't', 00H, 'r', 00H, '-', 00H, 'T', 00H, 'R', 00H, 00H, 00H
$SG61420 DB	'u', 00H, 'r', 00H, '-', 00H, 'P', 00H, 'K', 00H, 00H, 00H
$SG61421 DB	'i', 00H, 'd', 00H, '-', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG61422 DB	'u', 00H, 'k', 00H, '-', 00H, 'U', 00H, 'A', 00H, 00H, 00H
$SG61423 DB	'b', 00H, 'e', 00H, '-', 00H, 'B', 00H, 'Y', 00H, 00H, 00H
$SG61424 DB	's', 00H, 'l', 00H, '-', 00H, 'S', 00H, 'I', 00H, 00H, 00H
$SG61425 DB	'e', 00H, 't', 00H, '-', 00H, 'E', 00H, 'E', 00H, 00H, 00H
$SG61426 DB	'l', 00H, 'v', 00H, '-', 00H, 'L', 00H, 'V', 00H, 00H, 00H
$SG61427 DB	'l', 00H, 't', 00H, '-', 00H, 'L', 00H, 'T', 00H, 00H, 00H
$SG61428 DB	'f', 00H, 'a', 00H, '-', 00H, 'I', 00H, 'R', 00H, 00H, 00H
$SG61429 DB	'v', 00H, 'i', 00H, '-', 00H, 'V', 00H, 'N', 00H, 00H, 00H
$SG61430 DB	'h', 00H, 'y', 00H, '-', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG61431 DB	'a', 00H, 'z', 00H, '-', 00H, 'A', 00H, 'Z', 00H, '-', 00H
	DB	'L', 00H, 'a', 00H, 't', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG61432 DB	'e', 00H, 'u', 00H, '-', 00H, 'E', 00H, 'S', 00H, 00H, 00H
$SG61433 DB	'm', 00H, 'k', 00H, '-', 00H, 'M', 00H, 'K', 00H, 00H, 00H
$SG61434 DB	't', 00H, 'n', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61435 DB	'x', 00H, 'h', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61436 DB	'z', 00H, 'u', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG60412 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm'
	DB	00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG61437 DB	'a', 00H, 'f', 00H, '-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H
$SG61438 DB	'k', 00H, 'a', 00H, '-', 00H, 'G', 00H, 'E', 00H, 00H, 00H
$SG61439 DB	'f', 00H, 'o', 00H, '-', 00H, 'F', 00H, 'O', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_IsEqualGUID
PUBLIC	_==
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	??$AtlMultiply@K@ATL@@YAJPAKKK@Z		; ATL::AtlMultiply<unsigned long>
PUBLIC	??$AtlAdd@K@ATL@@YAJPAKKK@Z			; ATL::AtlAdd<unsigned long>
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0CWin32Heap@ATL@@QAE@PAX@Z			; ATL::CWin32Heap::CWin32Heap
PUBLIC	??1CWin32Heap@ATL@@UAE@XZ			; ATL::CWin32Heap::~CWin32Heap
PUBLIC	?Allocate@CWin32Heap@ATL@@UAEPAXI@Z		; ATL::CWin32Heap::Allocate
PUBLIC	?Free@CWin32Heap@ATL@@UAEXPAX@Z			; ATL::CWin32Heap::Free
PUBLIC	?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z	; ATL::CWin32Heap::Reallocate
PUBLIC	?GetSize@CWin32Heap@ATL@@UAEIPAX@Z		; ATL::CWin32Heap::GetSize
PUBLIC	??_GCWin32Heap@ATL@@UAEPAXI@Z			; ATL::CWin32Heap::`scalar deleting destructor'
PUBLIC	??$AtlAdd@I@ATL@@YAJPAIII@Z			; ATL::AtlAdd<unsigned int>
PUBLIC	??$AtlAdd@H@ATL@@YAJPAHHH@Z			; ATL::AtlAdd<int>
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
PUBLIC	??0CNilStringData@ATL@@QAE@XZ			; ATL::CNilStringData::CNilStringData
PUBLIC	?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z ; ATL::CNilStringData::SetManager
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z	; ATL::CAtlStringMgr::CAtlStringMgr
PUBLIC	??1CAtlStringMgr@ATL@@UAE@XZ			; ATL::CAtlStringMgr::~CAtlStringMgr
PUBLIC	?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::CAtlStringMgr::GetInstance
PUBLIC	?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z ; ATL::CAtlStringMgr::Allocate
PUBLIC	?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z ; ATL::CAtlStringMgr::Free
PUBLIC	?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z ; ATL::CAtlStringMgr::Reallocate
PUBLIC	?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ ; ATL::CAtlStringMgr::GetNilString
PUBLIC	?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ ; ATL::CAtlStringMgr::Clone
PUBLIC	?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ	; ATL::CAtlStringMgr::StaticInitialize
PUBLIC	??_GCAtlStringMgr@ATL@@UAEPAXI@Z		; ATL::CAtlStringMgr::`scalar deleting destructor'
PUBLIC	??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap''
PUBLIC	??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr''
PUBLIC	??$AtlAlignUp@H@ATL@@YGHHK@Z			; ATL::AtlAlignUp<int>
PUBLIC	??0IUnknownEx@@QAE@XZ				; IUnknownEx::IUnknownEx
PUBLIC	?GetProductVer@@YAEK@Z				; GetProductVer
PUBLIC	?GetMainVer@@YAEK@Z				; GetMainVer
PUBLIC	?GetSubVer@@YAEK@Z				; GetSubVer
PUBLIC	?GetBuildVer@@YAEK@Z				; GetBuildVer
PUBLIC	?InterfaceVersionCompare@@YA_NKK@Z		; InterfaceVersionCompare
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0ITableFrameSink@@QAE@XZ			; ITableFrameSink::ITableFrameSink
PUBLIC	??0ITableUserAction@@QAE@XZ			; ITableUserAction::ITableUserAction
PUBLIC	??0CDCCache@CImage@ATL@@QAE@XZ			; ATL::CImage::CDCCache::CDCCache
PUBLIC	??1CDCCache@CImage@ATL@@QAE@XZ			; ATL::CImage::CDCCache::~CDCCache
PUBLIC	??0CInitGDIPlus@CImage@ATL@@QAE@XZ		; ATL::CImage::CInitGDIPlus::CInitGDIPlus
PUBLIC	??1CInitGDIPlus@CImage@ATL@@QAE@XZ		; ATL::CImage::CInitGDIPlus::~CInitGDIPlus
PUBLIC	?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ	; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus
PUBLIC	?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ ; ATL::CImage::GetInitGDIPlusInstance
PUBLIC	?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ ; ATL::CImage::GetCDCCacheInstance
PUBLIC	?CImageStaticInitialize@CImage@ATL@@CA_NXZ	; ATL::CImage::CImageStaticInitialize
PUBLIC	??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus''
PUBLIC	??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache''
PUBLIC	?GetCardValue@CGameLogic@@QAEEE@Z		; CGameLogic::GetCardValue
PUBLIC	?GetCardColor@CGameLogic@@QAEEE@Z		; CGameLogic::GetCardColor
PUBLIC	?SetMagicIndex@CGameLogic@@QAEXE@Z		; CGameLogic::SetMagicIndex
PUBLIC	??0?$allocator@_J@std@@QAE@XZ			; std::allocator<__int64>::allocator<__int64>
PUBLIC	?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z	; std::allocator<__int64>::deallocate
PUBLIC	?allocate@?$allocator@_J@std@@QAEPA_JI@Z	; std::allocator<__int64>::allocate
PUBLIC	?max_size@?$allocator@_J@std@@QBEIXZ		; std::allocator<__int64>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@_J@std@@@std@@SAIABV?$allocator@_J@2@@Z ; std::allocator_traits<std::allocator<__int64> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<__int64> >::_Wrap_alloc<std::allocator<__int64> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEPA_JI@Z ; std::_Wrap_alloc<std::allocator<__int64> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JI@Z ; std::_Wrap_alloc<std::allocator<__int64> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<__int64> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@_J@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<__int64> >::_Vector_val<std::_Simple_types<__int64> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second
PUBLIC	??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ	; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
PUBLIC	??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
PUBLIC	?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::capacity
PUBLIC	?_Unused_capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::_Unused_capacity
PUBLIC	?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::begin
PUBLIC	?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z ; std::vector<__int64,std::allocator<__int64> >::_Make_iter
PUBLIC	?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
PUBLIC	?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::max_size
PUBLIC	??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ; std::vector<__int64,std::allocator<__int64> >::operator[]
PUBLIC	?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QAEXAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::push_back
PUBLIC	?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z ; std::vector<__int64,std::allocator<__int64> >::erase
PUBLIC	?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ; std::vector<__int64,std::allocator<__int64> >::clear
PUBLIC	?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Destroy
PUBLIC	?_Grow_to@?$vector@_JV?$allocator@_J@std@@@std@@IBEII@Z ; std::vector<__int64,std::allocator<__int64> >::_Grow_to
PUBLIC	?_Inside@?$vector@_JV?$allocator@_J@std@@@std@@IBE_NPB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Inside
PUBLIC	?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::_Reallocate
PUBLIC	?_Reserve@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::_Reserve
PUBLIC	?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ ; std::vector<__int64,std::allocator<__int64> >::_Tidy
PUBLIC	?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@IBEXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@_JV?$allocator@_J@std@@@std@@IBEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Orphan_range
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?deallocate@?$allocator@E@std@@QAEXPAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	??0CTableFrameSink@@QAE@XZ			; CTableFrameSink::CTableFrameSink
PUBLIC	??1CTableFrameSink@@UAE@XZ			; CTableFrameSink::~CTableFrameSink
PUBLIC	?Release@CTableFrameSink@@UAEXXZ		; CTableFrameSink::Release
PUBLIC	?QueryInterface@CTableFrameSink@@UAEPAXABU_GUID@@K@Z ; CTableFrameSink::QueryInterface
PUBLIC	?RepositionSink@CTableFrameSink@@UAEXXZ		; CTableFrameSink::RepositionSink
PUBLIC	?Initialization@CTableFrameSink@@UAE_NPAUIUnknownEx@@@Z ; CTableFrameSink::Initialization
PUBLIC	?QueryConsumeQuota@CTableFrameSink@@UAE_JPAUIServerUserItem@@@Z ; CTableFrameSink::QueryConsumeQuota
PUBLIC	?QueryLessEnterScore@CTableFrameSink@@UAE_JGPAUIServerUserItem@@@Z ; CTableFrameSink::QueryLessEnterScore
PUBLIC	?QueryBuckleServiceCharge@CTableFrameSink@@UAE_NG@Z ; CTableFrameSink::QueryBuckleServiceCharge
PUBLIC	?OnEventGameStart@CTableFrameSink@@UAE_NXZ	; CTableFrameSink::OnEventGameStart
PUBLIC	?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z ; CTableFrameSink::OnEventGameConclude
PUBLIC	?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z ; CTableFrameSink::OnEventSendGameScene
PUBLIC	?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z	; CTableFrameSink::OnTimerMessage
PUBLIC	?OnDataBaseMessage@CTableFrameSink@@UAE_NGPAXG@Z ; CTableFrameSink::OnDataBaseMessage
PUBLIC	?OnUserScroeNotify@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z ; CTableFrameSink::OnUserScroeNotify
PUBLIC	?OnGameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z ; CTableFrameSink::OnGameMessage
PUBLIC	?OnFrameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z ; CTableFrameSink::OnFrameMessage
PUBLIC	?SetGameBaseScore@CTableFrameSink@@UAEXJ@Z	; CTableFrameSink::SetGameBaseScore
PUBLIC	?OnActionUserOffLine@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z ; CTableFrameSink::OnActionUserOffLine
PUBLIC	?OnActionUserConnect@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z ; CTableFrameSink::OnActionUserConnect
PUBLIC	?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z ; CTableFrameSink::OnActionUserSitDown
PUBLIC	?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z ; CTableFrameSink::OnActionUserStandUp
PUBLIC	?OnActionUserOnReady@CTableFrameSink@@UAE_NGPAUIServerUserItem@@PAXG@Z ; CTableFrameSink::OnActionUserOnReady
PUBLIC	?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z	; CTableFrameSink::OnUserOutCard
PUBLIC	?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z ; CTableFrameSink::OnUserOperateCard
PUBLIC	?OnUserListenCard@CTableFrameSink@@IAE_NG_N@Z	; CTableFrameSink::OnUserListenCard
PUBLIC	?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z	; CTableFrameSink::OnUserTrustee
PUBLIC	?OnUserReplaceCard@CTableFrameSink@@IAE_NGE@Z	; CTableFrameSink::OnUserReplaceCard
PUBLIC	?OnUserSendCard@CTableFrameSink@@IAE_NEGQAEE@Z	; CTableFrameSink::OnUserSendCard
PUBLIC	?OnUserFlee@CTableFrameSink@@IAE_NG@Z		; CTableFrameSink::OnUserFlee
PUBLIC	?SendOperateNotify@CTableFrameSink@@IAE_NXZ	; CTableFrameSink::SendOperateNotify
PUBLIC	?GetSendCard@CTableFrameSink@@IAEE_N@Z		; CTableFrameSink::GetSendCard
PUBLIC	?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z	; CTableFrameSink::DispatchCardData
PUBLIC	?EstimateUserRespond@CTableFrameSink@@IAE_NGEW4enEstimatKind@@@Z ; CTableFrameSink::EstimateUserRespond
PUBLIC	?CalHuPaiScore@CTableFrameSink@@IAEXQA_J@Z	; CTableFrameSink::CalHuPaiScore
PUBLIC	?CalGangScore@CTableFrameSink@@IAEXXZ		; CTableFrameSink::CalGangScore
PUBLIC	?FiltrateRight@CTableFrameSink@@IAEXGAAVCChiHuRight@@@Z ; CTableFrameSink::FiltrateRight
PUBLIC	?GetTimes@CTableFrameSink@@IAEEG@Z		; CTableFrameSink::GetTimes
PUBLIC	?GetRemainingCount@CTableFrameSink@@IAEEGE@Z	; CTableFrameSink::GetRemainingCount
PUBLIC	?IsRoomCard@CTableFrameSink@@IAE_NXZ		; CTableFrameSink::IsRoomCard
PUBLIC	?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ	; CTableFrameSink::IsRoomCardScoreType
PUBLIC	?IsRoomCardTreasureType@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::IsRoomCardTreasureType
PUBLIC	?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z	; CTableFrameSink::WriteDebugInfo
PUBLIC	??_GCTableFrameSink@@UAEPAXI@Z			; CTableFrameSink::`scalar deleting destructor'
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >
PUBLIC	??$_Move_unchecked@PA_JPA_J@std@@YAPA_JPA_J00@Z	; std::_Move_unchecked<__int64 *,__int64 *>
PUBLIC	??$addressof@$$CB_J@std@@YAPB_JAB_J@Z		; std::addressof<__int64 const >
PUBLIC	??$_Unfancy@_J@std@@YAPA_JPA_J@Z		; std::_Unfancy<__int64>
PUBLIC	??$construct@_JAA_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAA_J@Z ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 &>
PUBLIC	??$construct@_JAB_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAB_J@Z ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Destroy_range<std::allocator<unsigned char>,unsigned char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ; std::_Destroy_range<std::allocator<__int64>,__int64 *>
PUBLIC	??$_Umove@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Umove<__int64 *>
PUBLIC	??$_Ptr_move_cat@_J_J@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_J0@Z ; std::_Ptr_move_cat<__int64,__int64>
PUBLIC	??$_Move_unchecked1@PA_JPA_J@std@@YAPA_JPA_J00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<__int64 *,__int64 *>
PUBLIC	??$forward@AA_J@std@@YAAA_JAA_J@Z		; std::forward<__int64 &>
PUBLIC	??$construct@_JAA_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAA_J@Z ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 &>
PUBLIC	??$forward@AB_J@std@@YAAB_JAB_J@Z		; std::forward<__int64 const &>
PUBLIC	??$construct@_JAB_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAB_J@Z ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 const &>
PUBLIC	??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned char>,unsigned char *>
PUBLIC	??$_Destroy_range1@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<__int64>,__int64 *>
PUBLIC	??$_Uninitialized_move@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ; std::_Uninitialized_move<__int64 *,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Copy_memmove@PA_JPA_J@std@@YAPA_JPA_J00@Z	; std::_Copy_memmove<__int64 *,__int64 *>
PUBLIC	??$construct@_JAA_J@?$allocator@_J@std@@QAEXPA_JAA_J@Z ; std::allocator<__int64>::construct<__int64,__int64 &>
PUBLIC	??$construct@_JAB_J@?$allocator@_J@std@@QAEXPA_JAB_J@Z ; std::allocator<__int64>::construct<__int64,__int64 const &>
PUBLIC	??$_Unchecked@PA_J@std@@YAPA_JPA_J@Z		; std::_Unchecked<__int64 *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<__int64 *,__int64 *,std::allocator<__int64> >
PUBLIC	??$_Rechecked@PA_JPA_J@std@@YAAAPA_JAAPA_JPA_J@Z ; std::_Rechecked<__int64 *,__int64 *>
PUBLIC	??$_Uninitialized_move_al_unchecked1@_J_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked1<__int64,__int64,std::allocator<__int64> >
PUBLIC	?Release@CTableFrameSink@@W3AEXXZ		; [thunk]:CTableFrameSink::Release`adjustor{4}'
PUBLIC	?QueryInterface@CTableFrameSink@@W3AEPAXABU_GUID@@K@Z ; [thunk]:CTableFrameSink::QueryInterface`adjustor{4}'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	??_7CWin32Heap@ATL@@6B@				; ATL::CWin32Heap::`vftable'
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?isInitialized@CAtlStringMgr@ATL@@0_NA		; ATL::CAtlStringMgr::isInitialized
PUBLIC	??_7CAtlStringMgr@ATL@@6B@			; ATL::CAtlStringMgr::`vftable'
PUBLIC	?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
PUBLIC	?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
PUBLIC	?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
PUBLIC	?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
PUBLIC	??_7IUnknownEx@@6B@				; IUnknownEx::`vftable'
PUBLIC	??_7ITableFrameSink@@6B@			; ITableFrameSink::`vftable'
PUBLIC	??_7ITableUserAction@@6B@			; ITableUserAction::`vftable'
PUBLIC	?isCImageStaticInitialized@CImage@ATL@@0_NA	; ATL::CImage::isCImageStaticInitialized
PUBLIC	?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
PUBLIC	?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
PUBLIC	?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
PUBLIC	?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
PUBLIC	??_7CTableFrameSink@@6BITableFrameSink@@@	; CTableFrameSink::`vftable'
PUBLIC	??_7CTableFrameSink@@6BITableUserAction@@@	; CTableFrameSink::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CWin32Heap@ATL@@6B@			; ATL::CWin32Heap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCWin32Heap@ATL@@@8			; ATL::CWin32Heap `RTTI Type Descriptor'
PUBLIC	??_R3CWin32Heap@ATL@@8				; ATL::CWin32Heap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWin32Heap@ATL@@8				; ATL::CWin32Heap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CWin32Heap@ATL@@8			; ATL::CWin32Heap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IAtlMemMgr@ATL@@8			; ATL::IAtlMemMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIAtlMemMgr@ATL@@@8			; ATL::IAtlMemMgr `RTTI Type Descriptor'
PUBLIC	??_R3IAtlMemMgr@ATL@@8				; ATL::IAtlMemMgr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IAtlMemMgr@ATL@@8				; ATL::IAtlMemMgr::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IAtlStringMgr@ATL@@8		; ATL::IAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIAtlStringMgr@ATL@@@8			; ATL::IAtlStringMgr `RTTI Type Descriptor'
PUBLIC	??_R3IAtlStringMgr@ATL@@8			; ATL::IAtlStringMgr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IAtlStringMgr@ATL@@8			; ATL::IAtlStringMgr::`RTTI Base Class Array'
PUBLIC	??_R4CAtlStringMgr@ATL@@6B@			; ATL::CAtlStringMgr::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAtlStringMgr@ATL@@@8			; ATL::CAtlStringMgr `RTTI Type Descriptor'
PUBLIC	??_R3CAtlStringMgr@ATL@@8			; ATL::CAtlStringMgr::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAtlStringMgr@ATL@@8			; ATL::CAtlStringMgr::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAtlStringMgr@ATL@@8		; ATL::CAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IUnknownEx@@6B@				; IUnknownEx::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUIUnknownEx@@@8				; IUnknownEx `RTTI Type Descriptor'
PUBLIC	??_R3IUnknownEx@@8				; IUnknownEx::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknownEx@@8				; IUnknownEx::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknownEx@@8			; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ITableFrameSink@@6B@			; ITableFrameSink::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUITableFrameSink@@@8			; ITableFrameSink `RTTI Type Descriptor'
PUBLIC	??_R3ITableFrameSink@@8				; ITableFrameSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITableFrameSink@@8				; ITableFrameSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITableFrameSink@@8		; ITableFrameSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ITableUserAction@@6B@			; ITableUserAction::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUITableUserAction@@@8			; ITableUserAction `RTTI Type Descriptor'
PUBLIC	??_R3ITableUserAction@@8			; ITableUserAction::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITableUserAction@@8			; ITableUserAction::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITableUserAction@@8		; ITableUserAction::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTableFrameSink@@6BITableFrameSink@@@	; CTableFrameSink::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTableFrameSink@@@8			; CTableFrameSink `RTTI Type Descriptor'
PUBLIC	??_R3CTableFrameSink@@8				; CTableFrameSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTableFrameSink@@8				; CTableFrameSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTableFrameSink@@8		; CTableFrameSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EC@IUnknownEx@@8			; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,66)'
PUBLIC	??_R13?0A@EA@ITableUserAction@@8		; ITableUserAction::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EC@IUnknownEx@@8			; IUnknownEx::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R4CTableFrameSink@@6BITableUserAction@@@	; CTableFrameSink::`RTTI Complete Object Locator'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp__memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__HeapDestroy@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapReAlloc@16:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__HeapSize@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__lstrcpynW@12:PROC
EXTRN	__imp__LoadLibraryW@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp___time64:PROC
EXTRN	??_ECWin32Heap@ATL@@UAEPAXI@Z:PROC		; ATL::CWin32Heap::`vector deleting destructor'
EXTRN	__imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ:PROC
EXTRN	__imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ:PROC
EXTRN	??_ECAtlStringMgr@ATL@@UAEPAXI@Z:PROC		; ATL::CAtlStringMgr::`vector deleting destructor'
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?TraceString@CTraceService@@SA_NPB_WW4enTraceLevel@@@Z:PROC
EXTRN	_GdiplusShutdown@4:PROC
EXTRN	??0CChiHuRight@@QAE@XZ:PROC			; CChiHuRight::CChiHuRight
EXTRN	??_5CChiHuRight@@QAEAAV0@K@Z:PROC		; CChiHuRight::operator|=
EXTRN	?GetRightData@CChiHuRight@@QAEEQAKE@Z:PROC	; CChiHuRight::GetRightData
EXTRN	??0CGameLogic@@QAE@XZ:PROC			; CGameLogic::CGameLogic
EXTRN	??1CGameLogic@@UAE@XZ:PROC			; CGameLogic::~CGameLogic
EXTRN	?RandCardList@CGameLogic@@QAEXQAEE@Z:PROC	; CGameLogic::RandCardList
EXTRN	?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z:PROC	; CGameLogic::RemoveCard
EXTRN	?RemoveCard@CGameLogic@@QAE_NQAEE@Z:PROC	; CGameLogic::RemoveCard
EXTRN	?GetUserActionRank@CGameLogic@@QAEEE@Z:PROC	; CGameLogic::GetUserActionRank
EXTRN	?EstimatePengCard@CGameLogic@@QAEEQBEE@Z:PROC	; CGameLogic::EstimatePengCard
EXTRN	?EstimateGangCard@CGameLogic@@QAEEQBEE@Z:PROC	; CGameLogic::EstimateGangCard
EXTRN	?AnalyseGangCardEx@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAUtagGangCardResult@@@Z:PROC ; CGameLogic::AnalyseGangCardEx
EXTRN	?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z:PROC ; CGameLogic::AnalyseChiHuCard
EXTRN	?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@E@Z:PROC ; CGameLogic::AnalyseTingCard
EXTRN	?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z:PROC ; CGameLogic::AnalyseTingCard
EXTRN	?GetHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAE@Z:PROC ; CGameLogic::GetHuCard
EXTRN	?SwitchToCardData@CGameLogic@@QAEEE@Z:PROC	; CGameLogic::SwitchToCardData
EXTRN	?SwitchToCardIndex@CGameLogic@@QAEEE@Z:PROC	; CGameLogic::SwitchToCardIndex
EXTRN	?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z:PROC	; CGameLogic::SwitchToCardData
EXTRN	?SwitchToCardIndex@CGameLogic@@QAEEQBEEQAE@Z:PROC ; CGameLogic::SwitchToCardIndex
EXTRN	?IsValidCard@CGameLogic@@QAE_NE@Z:PROC		; CGameLogic::IsValidCard
EXTRN	?GetCardCount@CGameLogic@@QAEEQBE@Z:PROC	; CGameLogic::GetCardCount
EXTRN	??0CHistoryScore@@QAE@XZ:PROC			; CHistoryScore::CHistoryScore
EXTRN	??1CHistoryScore@@UAE@XZ:PROC			; CHistoryScore::~CHistoryScore
EXTRN	?GetHistoryScore@CHistoryScore@@QAEPAUtagHistoryScore@@G@Z:PROC ; CHistoryScore::GetHistoryScore
EXTRN	?OnEventUserEnter@CHistoryScore@@QAEXG@Z:PROC	; CHistoryScore::OnEventUserEnter
EXTRN	?OnEventUserLeave@CHistoryScore@@QAEXG@Z:PROC	; CHistoryScore::OnEventUserLeave
EXTRN	?OnEventUserScore@CHistoryScore@@QAEXG_J@Z:PROC	; CHistoryScore::OnEventUserScore
EXTRN	??_ECTableFrameSink@@UAEPAXI@Z:PROC		; CTableFrameSink::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___ImageBase:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_BSS	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 028H DUP (?)	; ATL::_AtlComModule
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?isInitialized@CAtlStringMgr@ATL@@0_NA
_BSS	SEGMENT
?isInitialized@CAtlStringMgr@ATL@@0_NA DB 01H DUP (?)	; ATL::CAtlStringMgr::isInitialized
_BSS	ENDS
;	COMDAT ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A
_BSS	SEGMENT
?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A DB 0cH DUP (?) ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A
_BSS	SEGMENT
?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A DB 01cH DUP (?) ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
_BSS	ENDS
;	COMDAT ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA
_BSS	SEGMENT
?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA DD 01H DUP (?) ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?isCImageStaticInitialized@CImage@ATL@@0_NA
_BSS	SEGMENT
?isCImageStaticInitialized@CImage@ATL@@0_NA DB 01H DUP (?) ; ATL::CImage::isCImageStaticInitialized
_BSS	ENDS
;	COMDAT ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A
_BSS	SEGMENT
?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A DB 024H DUP (?) ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
_BSS	ENDS
;	COMDAT ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A
_BSS	SEGMENT
?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A DB 010H DUP (?) ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceGeneral$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceGeneral@ATL@@YAXXZ ; ATL::atlTraceGeneral$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R4CTableFrameSink@@6BITableUserAction@@@
rdata$r	SEGMENT
??_R4CTableFrameSink@@6BITableUserAction@@@ DD 00H	; CTableFrameSink::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCTableFrameSink@@@8
	DD	FLAT:??_R3CTableFrameSink@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@IUnknownEx@@8
rdata$r	SEGMENT
??_R13?0A@EC@IUnknownEx@@8 DD FLAT:??_R0?AUIUnknownEx@@@8 ; IUnknownEx::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@ITableUserAction@@8
rdata$r	SEGMENT
??_R13?0A@EA@ITableUserAction@@8 DD FLAT:??_R0?AUITableUserAction@@@8 ; ITableUserAction::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITableUserAction@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EC@IUnknownEx@@8
rdata$r	SEGMENT
??_R1A@?0A@EC@IUnknownEx@@8 DD FLAT:??_R0?AUIUnknownEx@@@8 ; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,66)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTableFrameSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTableFrameSink@@8 DD FLAT:??_R0?AVCTableFrameSink@@@8 ; CTableFrameSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTableFrameSink@@8
rdata$r	ENDS
;	COMDAT ??_R2CTableFrameSink@@8
rdata$r	SEGMENT
??_R2CTableFrameSink@@8 DD FLAT:??_R1A@?0A@EA@CTableFrameSink@@8 ; CTableFrameSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ITableFrameSink@@8
	DD	FLAT:??_R1A@?0A@EC@IUnknownEx@@8
	DD	FLAT:??_R13?0A@EA@ITableUserAction@@8
	DD	FLAT:??_R13?0A@EC@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3CTableFrameSink@@8
rdata$r	SEGMENT
??_R3CTableFrameSink@@8 DD 00H				; CTableFrameSink::`RTTI Class Hierarchy Descriptor'
	DD	05H
	DD	05H
	DD	FLAT:??_R2CTableFrameSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTableFrameSink@@@8
data$r	SEGMENT
??_R0?AVCTableFrameSink@@@8 DD FLAT:??_7type_info@@6B@	; CTableFrameSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTableFrameSink@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTableFrameSink@@6BITableFrameSink@@@
rdata$r	SEGMENT
??_R4CTableFrameSink@@6BITableFrameSink@@@ DD 00H	; CTableFrameSink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTableFrameSink@@@8
	DD	FLAT:??_R3CTableFrameSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITableUserAction@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITableUserAction@@8 DD FLAT:??_R0?AUITableUserAction@@@8 ; ITableUserAction::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITableUserAction@@8
rdata$r	ENDS
;	COMDAT ??_R2ITableUserAction@@8
rdata$r	SEGMENT
??_R2ITableUserAction@@8 DD FLAT:??_R1A@?0A@EA@ITableUserAction@@8 ; ITableUserAction::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3ITableUserAction@@8
rdata$r	SEGMENT
??_R3ITableUserAction@@8 DD 00H				; ITableUserAction::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITableUserAction@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITableUserAction@@@8
data$r	SEGMENT
??_R0?AUITableUserAction@@@8 DD FLAT:??_7type_info@@6B@	; ITableUserAction `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITableUserAction@@', 00H
data$r	ENDS
;	COMDAT ??_R4ITableUserAction@@6B@
rdata$r	SEGMENT
??_R4ITableUserAction@@6B@ DD 00H			; ITableUserAction::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUITableUserAction@@@8
	DD	FLAT:??_R3ITableUserAction@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITableFrameSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITableFrameSink@@8 DD FLAT:??_R0?AUITableFrameSink@@@8 ; ITableFrameSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITableFrameSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITableFrameSink@@8
rdata$r	SEGMENT
??_R2ITableFrameSink@@8 DD FLAT:??_R1A@?0A@EA@ITableFrameSink@@8 ; ITableFrameSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3ITableFrameSink@@8
rdata$r	SEGMENT
??_R3ITableFrameSink@@8 DD 00H				; ITableFrameSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITableFrameSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITableFrameSink@@@8
data$r	SEGMENT
??_R0?AUITableFrameSink@@@8 DD FLAT:??_7type_info@@6B@	; ITableFrameSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITableFrameSink@@', 00H
data$r	ENDS
;	COMDAT ??_R4ITableFrameSink@@6B@
rdata$r	SEGMENT
??_R4ITableFrameSink@@6B@ DD 00H			; ITableFrameSink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUITableFrameSink@@@8
	DD	FLAT:??_R3ITableFrameSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknownEx@@8 DD FLAT:??_R0?AUIUnknownEx@@@8 ; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknownEx@@8
rdata$r	SEGMENT
??_R2IUnknownEx@@8 DD FLAT:??_R1A@?0A@EA@IUnknownEx@@8	; IUnknownEx::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknownEx@@8
rdata$r	SEGMENT
??_R3IUnknownEx@@8 DD 00H				; IUnknownEx::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknownEx@@@8
data$r	SEGMENT
??_R0?AUIUnknownEx@@@8 DD FLAT:??_7type_info@@6B@	; IUnknownEx `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknownEx@@', 00H
data$r	ENDS
;	COMDAT ??_R4IUnknownEx@@6B@
rdata$r	SEGMENT
??_R4IUnknownEx@@6B@ DD 00H				; IUnknownEx::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUIUnknownEx@@@8
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAtlStringMgr@ATL@@8 DD FLAT:??_R0?AVCAtlStringMgr@ATL@@@8 ; ATL::CAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2CAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R2CAtlStringMgr@ATL@@8 DD FLAT:??_R1A@?0A@EA@CAtlStringMgr@ATL@@8 ; ATL::CAtlStringMgr::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R3CAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R3CAtlStringMgr@ATL@@8 DD 00H			; ATL::CAtlStringMgr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAtlStringMgr@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlStringMgr@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlStringMgr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlStringMgr@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R4CAtlStringMgr@ATL@@6B@
rdata$r	SEGMENT
??_R4CAtlStringMgr@ATL@@6B@ DD 00H			; ATL::CAtlStringMgr::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAtlStringMgr@ATL@@@8
	DD	FLAT:??_R3CAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2IAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R2IAtlStringMgr@ATL@@8 DD FLAT:??_R1A@?0A@EA@IAtlStringMgr@ATL@@8 ; ATL::IAtlStringMgr::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R3IAtlStringMgr@ATL@@8 DD 00H			; ATL::IAtlStringMgr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlStringMgr@ATL@@@8
data$r	SEGMENT
??_R0?AUIAtlStringMgr@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::IAtlStringMgr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIAtlStringMgr@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAtlStringMgr@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAtlStringMgr@ATL@@8 DD FLAT:??_R0?AUIAtlStringMgr@ATL@@@8 ; ATL::IAtlStringMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAtlStringMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2IAtlMemMgr@ATL@@8
rdata$r	SEGMENT
??_R2IAtlMemMgr@ATL@@8 DD FLAT:??_R1A@?0A@EA@IAtlMemMgr@ATL@@8 ; ATL::IAtlMemMgr::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IAtlMemMgr@ATL@@8
rdata$r	SEGMENT
??_R3IAtlMemMgr@ATL@@8 DD 00H				; ATL::IAtlMemMgr::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IAtlMemMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIAtlMemMgr@ATL@@@8
data$r	SEGMENT
??_R0?AUIAtlMemMgr@ATL@@@8 DD FLAT:??_7type_info@@6B@	; ATL::IAtlMemMgr `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIAtlMemMgr@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAtlMemMgr@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAtlMemMgr@ATL@@8 DD FLAT:??_R0?AUIAtlMemMgr@ATL@@@8 ; ATL::IAtlMemMgr::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAtlMemMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CWin32Heap@ATL@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWin32Heap@ATL@@8 DD FLAT:??_R0?AVCWin32Heap@ATL@@@8 ; ATL::CWin32Heap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWin32Heap@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R2CWin32Heap@ATL@@8
rdata$r	SEGMENT
??_R2CWin32Heap@ATL@@8 DD FLAT:??_R1A@?0A@EA@CWin32Heap@ATL@@8 ; ATL::CWin32Heap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IAtlMemMgr@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R3CWin32Heap@ATL@@8
rdata$r	SEGMENT
??_R3CWin32Heap@ATL@@8 DD 00H				; ATL::CWin32Heap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CWin32Heap@ATL@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWin32Heap@ATL@@@8
data$r	SEGMENT
??_R0?AVCWin32Heap@ATL@@@8 DD FLAT:??_7type_info@@6B@	; ATL::CWin32Heap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWin32Heap@ATL@@', 00H
data$r	ENDS
;	COMDAT ??_R4CWin32Heap@ATL@@6B@
rdata$r	SEGMENT
??_R4CWin32Heap@ATL@@6B@ DD 00H				; ATL::CWin32Heap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCWin32Heap@ATL@@@8
	DD	FLAT:??_R3CWin32Heap@ATL@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7CTableFrameSink@@6BITableUserAction@@@
CONST	SEGMENT
??_7CTableFrameSink@@6BITableUserAction@@@ DD FLAT:??_R4CTableFrameSink@@6BITableUserAction@@@ ; CTableFrameSink::`vftable'
	DD	FLAT:?Release@CTableFrameSink@@W3AEXXZ
	DD	FLAT:?QueryInterface@CTableFrameSink@@W3AEPAXABU_GUID@@K@Z
	DD	FLAT:?OnActionUserOffLine@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z
	DD	FLAT:?OnActionUserConnect@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z
	DD	FLAT:?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
	DD	FLAT:?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
	DD	FLAT:?OnActionUserOnReady@CTableFrameSink@@UAE_NGPAUIServerUserItem@@PAXG@Z
CONST	ENDS
;	COMDAT ??_7CTableFrameSink@@6BITableFrameSink@@@
CONST	SEGMENT
??_7CTableFrameSink@@6BITableFrameSink@@@ DD FLAT:??_R4CTableFrameSink@@6BITableFrameSink@@@ ; CTableFrameSink::`vftable'
	DD	FLAT:?Release@CTableFrameSink@@UAEXXZ
	DD	FLAT:?QueryInterface@CTableFrameSink@@UAEPAXABU_GUID@@K@Z
	DD	FLAT:?RepositionSink@CTableFrameSink@@UAEXXZ
	DD	FLAT:?Initialization@CTableFrameSink@@UAE_NPAUIUnknownEx@@@Z
	DD	FLAT:?QueryConsumeQuota@CTableFrameSink@@UAE_JPAUIServerUserItem@@@Z
	DD	FLAT:?QueryLessEnterScore@CTableFrameSink@@UAE_JGPAUIServerUserItem@@@Z
	DD	FLAT:?QueryBuckleServiceCharge@CTableFrameSink@@UAE_NG@Z
	DD	FLAT:?OnEventGameStart@CTableFrameSink@@UAE_NXZ
	DD	FLAT:?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z
	DD	FLAT:?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z
	DD	FLAT:?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z
	DD	FLAT:?OnDataBaseMessage@CTableFrameSink@@UAE_NGPAXG@Z
	DD	FLAT:?OnUserScroeNotify@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z
	DD	FLAT:?OnGameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z
	DD	FLAT:?OnFrameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z
	DD	FLAT:?SetGameBaseScore@CTableFrameSink@@UAEXJ@Z
	DD	FLAT:??_ECTableFrameSink@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7ITableUserAction@@6B@
CONST	SEGMENT
??_7ITableUserAction@@6B@ DD FLAT:??_R4ITableUserAction@@6B@ ; ITableUserAction::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7ITableFrameSink@@6B@
CONST	SEGMENT
??_7ITableFrameSink@@6B@ DD FLAT:??_R4ITableFrameSink@@6B@ ; ITableFrameSink::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7IUnknownEx@@6B@
CONST	SEGMENT
??_7IUnknownEx@@6B@ DD FLAT:??_R4IUnknownEx@@6B@	; IUnknownEx::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT
??_7CAtlStringMgr@ATL@@6B@ DD FLAT:??_R4CAtlStringMgr@ATL@@6B@ ; ATL::CAtlStringMgr::`vftable'
	DD	FLAT:?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
	DD	FLAT:?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
	DD	FLAT:?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
	DD	FLAT:?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
	DD	FLAT:?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
	DD	FLAT:??_ECAtlStringMgr@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CWin32Heap@ATL@@6B@
CONST	SEGMENT
??_7CWin32Heap@ATL@@6B@ DD FLAT:??_R4CWin32Heap@ATL@@6B@ ; ATL::CWin32Heap::`vftable'
	DD	FLAT:?Allocate@CWin32Heap@ATL@@UAEPAXI@Z
	DD	FLAT:?Free@CWin32Heap@ATL@@UAEXPAX@Z
	DD	FLAT:?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z
	DD	FLAT:?GetSize@CWin32Heap@ATL@@UAEIPAX@Z
	DD	FLAT:??_ECWin32Heap@ATL@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z$0
__unwindtable$?SendOperateNotify@CTableFrameSink@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendOperateNotify@CTableFrameSink@@IAE_NXZ$0
__unwindtable$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z$0
__unwindtable$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z$0
__unwindtable$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z$0
__unwindtable$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z$0
__unwindtable$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z$0
__unwindtable$?OnEventGameStart@CTableFrameSink@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnEventGameStart@CTableFrameSink@@UAE_NXZ$0
__unwindtable$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z$1
__unwindtable$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z$1
__unwindtable$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z$1
__ehfuncinfo$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SendOperateNotify@CTableFrameSink@@IAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendOperateNotify@CTableFrameSink@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?OnEventGameStart@CTableFrameSink@@UAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnEventGameStart@CTableFrameSink@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1CTableFrameSink@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$??0CTableFrameSink@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CTableFrameSink@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CTableFrameSink@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTableFrameSink@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CTableFrameSink@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CTableFrameSink@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CTableFrameSink@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CTableFrameSink@@QAE@XZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
__ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceCOM$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceCOM@ATL@@YAXXZ ; ATL::atlTraceCOM$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceQI$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceQI@ATL@@YAXXZ ; ATL::atlTraceQI$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceRegistrar$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceRegistrar@ATL@@YAXXZ ; ATL::atlTraceRegistrar$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceRefcount$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceRefcount@ATL@@YAXXZ ; ATL::atlTraceRefcount$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceWindowing$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceWindowing@ATL@@YAXXZ ; ATL::atlTraceWindowing$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceControls$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceControls@ATL@@YAXXZ ; ATL::atlTraceControls$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceHosting$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceHosting@ATL@@YAXXZ ; ATL::atlTraceHosting$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceDBClient$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceDBClient@ATL@@YAXXZ ; ATL::atlTraceDBClient$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceDBProvider$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceDBProvider@ATL@@YAXXZ ; ATL::atlTraceDBProvider$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceSnapin$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceSnapin@ATL@@YAXXZ ; ATL::atlTraceSnapin$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceNotImpl$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceNotImpl@ATL@@YAXXZ ; ATL::atlTraceNotImpl$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceAllocation$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceAllocation@ATL@@YAXXZ ; ATL::atlTraceAllocation$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceException$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceException@ATL@@YAXXZ ; ATL::atlTraceException$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceTime$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceTime@ATL@@YAXXZ ; ATL::atlTraceTime$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceCache$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceCache@ATL@@YAXXZ ; ATL::atlTraceCache$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceStencil$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceStencil@ATL@@YAXXZ ; ATL::atlTraceStencil$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceString$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceString@ATL@@YAXXZ ; ATL::atlTraceString$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceMap$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceMap@ATL@@YAXXZ ; ATL::atlTraceMap$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceUtil$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceUtil@ATL@@YAXXZ ; ATL::atlTraceUtil$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceSecurity$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceSecurity@ATL@@YAXXZ ; ATL::atlTraceSecurity$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceSync$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceSync@ATL@@YAXXZ ; ATL::atlTraceSync$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceISAPI$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceISAPI@ATL@@YAXXZ ; ATL::atlTraceISAPI$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??isInitialized$initializer$@CAtlStringMgr@ATL@@0P6AXXZA@@3P6AXXZA DD FLAT:??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ ; ??isInitialized$initializer$@CAtlStringMgr@ATL@@0P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??isCImageStaticInitialized$initializer$@CImage@ATL@@0P6AXXZA@@3P6AXXZA DD FLAT:??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ ; ??isCImageStaticInitialized$initializer$@CImage@ATL@@0P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@CTableFrameSink@@W3AEPAXABU_GUID@@K@Z
_TEXT	SEGMENT
?QueryInterface@CTableFrameSink@@W3AEPAXABU_GUID@@K@Z PROC ; [thunk]:CTableFrameSink::QueryInterface`adjustor{4}', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?QueryInterface@CTableFrameSink@@UAEPAXABU_GUID@@K@Z ; CTableFrameSink::QueryInterface
?QueryInterface@CTableFrameSink@@W3AEPAXABU_GUID@@K@Z ENDP ; [thunk]:CTableFrameSink::QueryInterface`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@CTableFrameSink@@W3AEXXZ
_TEXT	SEGMENT
?Release@CTableFrameSink@@W3AEXXZ PROC			; [thunk]:CTableFrameSink::Release`adjustor{4}', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?Release@CTableFrameSink@@UAEXXZ ; CTableFrameSink::Release
?Release@CTableFrameSink@@W3AEXXZ ENDP			; [thunk]:CTableFrameSink::Release`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@_J_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@_J_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<__int64,__int64,std::allocator<__int64> >, COMDAT

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	return (_Copy_memmove(_First, _Last, _Dest));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_JPA_J@std@@YAPA_JPA_J00@Z ; std::_Copy_memmove<__int64 *,__int64 *>
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 294  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninitialized_move_al_unchecked1@_J_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<__int64,__int64,std::allocator<__int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PA_JPA_J@std@@YAAAPA_JAAPA_JPA_J@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PA_JPA_J@std@@YAAAPA_JAAPA_JPA_J@Z PROC	; std::_Rechecked<__int64 *,__int64 *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 459  : 	return (_Dest);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]

; 460  : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Rechecked@PA_JPA_J@std@@YAAAPA_JAAPA_JPA_J@Z ENDP	; std::_Rechecked<__int64 *,__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<__int64 *,__int64 *,std::allocator<__int64> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  00004	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00008	50		 push	 eax
  00009	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  0000c	51		 push	 ecx
  0000d	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00010	52		 push	 edx
  00011	8d 45 fe	 lea	 eax, DWORD PTR $T1[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@_J_J@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_J0@Z ; std::_Ptr_move_cat<__int64,__int64>
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8a 08		 mov	 cl, BYTE PTR [eax]
  0001f	0f b6 d1	 movzx	 edx, cl
  00022	52		 push	 edx
  00023	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@_J_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked1<__int64,__int64,std::allocator<__int64> >
  00038	83 c4 18	 add	 esp, 24			; 00000018H

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<__int64 *,__int64 *,std::allocator<__int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PA_J@std@@YAPA_JPA_J@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PA_J@std@@YAPA_JPA_J@Z PROC		; std::_Unchecked<__int64 *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 429  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PA_J@std@@YAPA_JPA_J@Z ENDP		; std::_Unchecked<__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@_JAB_J@?$allocator@_J@std@@QAEXPA_JAB_J@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv73 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@_JAB_J@?$allocator@_J@std@@QAEXPA_JAB_J@Z PROC ; std::allocator<__int64>::construct<__int64,__int64 const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 08		 push	 8
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0001e	74 21		 je	 SHORT $LN3@construct
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$forward@AB_J@std@@YAAB_JAB_J@Z ; std::forward<__int64 const &>
  00029	83 c4 04	 add	 esp, 4
  0002c	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	89 0a		 mov	 DWORD PTR [edx], ecx
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0003c	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  0003f	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00041	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 738  : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
??$construct@_JAB_J@?$allocator@_J@std@@QAEXPA_JAB_J@Z ENDP ; std::allocator<__int64>::construct<__int64,__int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@_JAA_J@?$allocator@_J@std@@QAEXPA_JAA_J@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv73 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@_JAA_J@?$allocator@_J@std@@QAEXPA_JAA_J@Z PROC ; std::allocator<__int64>::construct<__int64,__int64 &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 08		 push	 8
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0001e	74 21		 je	 SHORT $LN3@construct
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$forward@AA_J@std@@YAAA_JAA_J@Z ; std::forward<__int64 &>
  00029	83 c4 04	 add	 esp, 4
  0002c	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	89 0a		 mov	 DWORD PTR [edx], ecx
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0003c	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  0003f	eb 07		 jmp	 SHORT $LN1@construct
$LN3@construct:
  00041	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN1@construct:

; 738  : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
??$construct@_JAA_J@?$allocator@_J@std@@QAEXPA_JAA_J@Z ENDP ; std::allocator<__int64>::construct<__int64,__int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PA_JPA_J@std@@YAPA_JPA_J00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PA_JPA_J@std@@YAPA_JPA_J00@Z PROC	; std::_Copy_memmove<__int64 *,__int64 *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

  00012	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00015	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00028	52		 push	 edx
  00029	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00039	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 2308 : 	}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Copy_memmove@PA_JPA_J@std@@YAPA_JPA_J00@Z ENDP	; std::_Copy_memmove<__int64 *,__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z PROC ; std::_Uninitialized_move<__int64 *,__int64 *,std::allocator<__int64> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

  00003	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Unchecked@PA_J@std@@YAPA_JPA_J@Z ; std::_Unchecked<__int64 *>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??$_Unchecked@PA_J@std@@YAPA_JPA_J@Z ; std::_Unchecked<__int64 *>
  0001d	83 c4 04	 add	 esp, 4
  00020	50		 push	 eax
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Unchecked@PA_J@std@@YAPA_JPA_J@Z ; std::_Unchecked<__int64 *>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<__int64 *,__int64 *,std::allocator<__int64> >
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Rechecked@PA_JPA_J@std@@YAAAPA_JAAPA_JPA_J@Z ; std::_Rechecked<__int64 *,__int64 *>
  00040	83 c4 08	 add	 esp, 8
  00043	8b 00		 mov	 eax, DWORD PTR [eax]

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$_Uninitialized_move@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ENDP ; std::_Uninitialized_move<__int64 *,__int64 *,std::allocator<__int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<__int64>,__int64 *>, COMDAT

; 1107 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1108 : 		// nothing to do
; 1109 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range1@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<__int64>,__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned char>,unsigned char *>, COMDAT

; 1107 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1108 : 		// nothing to do
; 1109 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned char>,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@_JAB_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAB_J@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@_JAB_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAB_J@Z PROC ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AB_J@std@@YAAB_JAB_J@Z ; std::forward<__int64 const &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@_JAB_J@?$allocator@_J@std@@QAEXPA_JAB_J@Z ; std::allocator<__int64>::construct<__int64,__int64 const &>

; 858  : 		}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$construct@_JAB_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAB_J@Z ENDP ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AB_J@std@@YAAB_JAB_J@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AB_J@std@@YAAB_JAB_J@Z PROC			; std::forward<__int64 const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AB_J@std@@YAAB_JAB_J@Z ENDP			; std::forward<__int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@_JAA_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAA_J@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@_JAA_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAA_J@Z PROC ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AA_J@std@@YAAA_JAA_J@Z ; std::forward<__int64 &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@_JAA_J@?$allocator@_J@std@@QAEXPA_JAA_J@Z ; std::allocator<__int64>::construct<__int64,__int64 &>

; 858  : 		}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$construct@_JAA_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAA_J@Z ENDP ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AA_J@std@@YAAA_JAA_J@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AA_J@std@@YAAA_JAA_J@Z PROC			; std::forward<__int64 &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AA_J@std@@YAAA_JAA_J@Z ENDP			; std::forward<__int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked1@PA_JPA_J@std@@YAPA_JPA_J00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_unchecked1@PA_JPA_J@std@@YAPA_JPA_J00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Move_unchecked1<__int64 *,__int64 *>, COMDAT

; 2589 : 	{	// move [_First, _Last) to [_Dest, ...), memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2590 : 	return (_Copy_memmove(_First, _Last, _Dest));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_JPA_J@std@@YAPA_JPA_J00@Z ; std::_Copy_memmove<__int64 *,__int64 *>
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2591 : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Move_unchecked1@PA_JPA_J@std@@YAPA_JPA_J00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Move_unchecked1<__int64 *,__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@_J_J@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_J0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@_J_J@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_J0@Z PROC ; std::_Ptr_move_cat<__int64,__int64>, COMDAT

; 809  : 	{	// return pointer move optimization category for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 810  : 	return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 811  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Ptr_move_cat@_J_J@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_J0@Z ENDP ; std::_Ptr_move_cat<__int64,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Umove<__int64 *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1659 : 		return (_Uninitialized_move(_First, _Last,

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  0000f	50		 push	 eax
  00010	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_JPA_JV?$allocator@_J@std@@@std@@YAPA_JPA_J00AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ; std::_Uninitialized_move<__int64 *,__int64 *,std::allocator<__int64> >
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Umove<__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<__int64>,__int64 *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

  00004	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Destroy_range1@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<__int64>,__int64 *>
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Destroy_range@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<__int64>,__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1><>, COMDAT
; _this$ = ecx

; 280  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<__int64> >::_Wrap_alloc<std::allocator<__int64> >
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@_J@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<__int64> >::_Vector_val<std::_Simple_types<__int64> >

; 281  : 		}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char>,unsigned char *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

  00004	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned char>,unsigned char *>
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char>,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; _this$ = ecx

; 280  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >

; 281  : 		}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@_JAB_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAB_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@_JAB_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAB_J@Z PROC ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00007	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@AB_J@std@@YAAB_JAB_J@Z ; std::forward<__int64 const &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$construct@_JAB_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAB_J@Z ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 const &>
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$construct@_JAB_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAB_J@Z ENDP ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@_JAA_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAA_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@_JAA_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAA_J@Z PROC ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00007	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@AA_J@std@@YAAA_JAA_J@Z ; std::forward<__int64 &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$construct@_JAA_J@?$allocator_traits@V?$allocator@_J@std@@@std@@SAXAAV?$allocator@_J@1@PA_JAA_J@Z ; std::allocator_traits<std::allocator<__int64> >::construct<__int64,__int64 &>
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$construct@_JAA_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAA_J@Z ENDP ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_J@std@@YAPA_JPA_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_J@std@@YAPA_JPA_J@Z PROC			; std::_Unfancy<__int64>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_J@std@@YAPA_JPA_J@Z ENDP			; std::_Unfancy<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CB_J@std@@YAPB_JAB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CB_J@std@@YAPB_JAB_J@Z PROC		; std::addressof<__int64 const >, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CB_J@std@@YAPB_JAB_J@Z ENDP		; std::addressof<__int64 const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked@PA_JPA_J@std@@YAPA_JPA_J00@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PA_JPA_J@std@@YAPA_JPA_J00@Z PROC	; std::_Move_unchecked<__int64 *,__int64 *>, COMDAT

; 2597 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2598 : 	return (_Move_unchecked1(_First, _Last,

  00004	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	8d 55 ff	 lea	 edx, DWORD PTR $T2[ebp]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@_J_J@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_J0@Z ; std::_Ptr_move_cat<__int64,__int64>
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	0f b6 45 fe	 movzx	 eax, BYTE PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00024	52		 push	 edx
  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Move_unchecked1@PA_JPA_J@std@@YAPA_JPA_J00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<__int64 *,__int64 *>
  0002e	83 c4 10	 add	 esp, 16			; 00000010H

; 2599 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2600 : 	}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Move_unchecked@PA_JPA_J@std@@YAPA_JPA_J00@Z ENDP	; std::_Move_unchecked<__int64 *,__int64 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 312  : 		: _Mybase(_Parg, _Pvector)

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >

; 314  : 		}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 46   : 		: _Ptr(_Parg)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 48   : 		this->_Adopt(_Pvector);

  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  00012	52		 push	 edx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 49   : 		}

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<__int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCTableFrameSink@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTableFrameSink@@UAEPAXI@Z PROC			; CTableFrameSink::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTableFrameSink@@UAE@XZ ; CTableFrameSink::~CTableFrameSink
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 11		 je	 SHORT $LN2@scalar
  00017	68 38 09 00 00	 push	 2360			; 00000938H
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00025	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_GCTableFrameSink@@UAEPAXI@Z ENDP			; CTableFrameSink::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv135 = -28						; size = 4
$T2 = -24						; size = 4
_strtip$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pszString$ = 8						; size = 4
?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z PROC	; CTableFrameSink::WriteDebugInfo
; _this$ = ecx

; 2494 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2495 : 	CString strtip;

  00028	8d 4d ec	 lea	 ecx, DWORD PTR _strtip$[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2496 : 	strtip.Format(TEXT("房间号%d--%s\n"), m_pITableFrame->GetTableID(), pszString);

  00038	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00045	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 12		 mov	 edx, DWORD PTR [edx]
  0004a	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00050	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00053	ff d0		 call	 eax
  00055	0f b7 c8	 movzx	 ecx, ax
  00058	51		 push	 ecx
  00059	68 00 00 00 00	 push	 OFFSET $SG314472
  0005e	8d 55 ec	 lea	 edx, DWORD PTR _strtip$[ebp]
  00061	52		 push	 edx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00068	83 c4 10	 add	 esp, 16			; 00000010H

; 2497 : 	m_pITableFrame->SendGameLogData(strtip);

  0006b	51		 push	 ecx
  0006c	8b cc		 mov	 ecx, esp
  0006e	89 65 e8	 mov	 DWORD PTR $T2[ebp], esp
  00071	8d 45 ec	 lea	 eax, DWORD PTR _strtip$[ebp]
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@ABV01@@Z
  0007b	89 45 e4	 mov	 DWORD PTR tv135[ebp], eax
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00087	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	8b 12		 mov	 edx, DWORD PTR [edx]
  0008c	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00092	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00098	ff d0		 call	 eax

; 2498 : }

  0009a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a1	8d 4d ec	 lea	 ecx, DWORD PTR _strtip$[ebp]
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _strtip$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ENDP	; CTableFrameSink::WriteDebugInfo
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
?IsRoomCardTreasureType@CTableFrameSink@@IAE_NXZ PROC	; CTableFrameSink::IsRoomCardTreasureType
; _this$ = ecx

; 2489 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2490 : 	return (m_pITableFrame->GetDataBaseMode() == 1) && (((m_pGameServiceOption->wServerType) & GAME_GENRE_PERSONAL) != 0);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 01		 mov	 eax, DWORD PTR [ecx]
  00017	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0001d	8b 90 34 01 00
	00		 mov	 edx, DWORD PTR [eax+308]
  00023	ff d2		 call	 edx
  00025	0f b6 c0	 movzx	 eax, al
  00028	83 f8 01	 cmp	 eax, 1
  0002b	75 1b		 jne	 SHORT $LN3@IsRoomCard
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 91 30 09 00
	00		 mov	 edx, DWORD PTR [ecx+2352]
  00036	0f b7 42 54	 movzx	 eax, WORD PTR [edx+84]
  0003a	83 e0 10	 and	 eax, 16			; 00000010H
  0003d	74 09		 je	 SHORT $LN3@IsRoomCard
  0003f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  00046	eb 07		 jmp	 SHORT $LN4@IsRoomCard
$LN3@IsRoomCard:
  00048	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN4@IsRoomCard:
  0004f	8a 45 f8	 mov	 al, BYTE PTR tv79[ebp]

; 2491 : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?IsRoomCardTreasureType@CTableFrameSink@@IAE_NXZ ENDP	; CTableFrameSink::IsRoomCardTreasureType
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ PROC	; CTableFrameSink::IsRoomCardScoreType
; _this$ = ecx

; 2484 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2485 : 	return (m_pITableFrame->GetDataBaseMode() == 0) && (((m_pGameServiceOption->wServerType) & GAME_GENRE_PERSONAL) != 0);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 01		 mov	 eax, DWORD PTR [ecx]
  00017	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0001d	8b 90 34 01 00
	00		 mov	 edx, DWORD PTR [eax+308]
  00023	ff d2		 call	 edx
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	75 1b		 jne	 SHORT $LN3@IsRoomCard
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 91 30 09 00
	00		 mov	 edx, DWORD PTR [ecx+2352]
  00035	0f b7 42 54	 movzx	 eax, WORD PTR [edx+84]
  00039	83 e0 10	 and	 eax, 16			; 00000010H
  0003c	74 09		 je	 SHORT $LN3@IsRoomCard
  0003e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  00045	eb 07		 jmp	 SHORT $LN4@IsRoomCard
$LN3@IsRoomCard:
  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN4@IsRoomCard:
  0004e	8a 45 f8	 mov	 al, BYTE PTR tv79[ebp]

; 2486 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ ENDP	; CTableFrameSink::IsRoomCardScoreType
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
?IsRoomCard@CTableFrameSink@@IAE_NXZ PROC		; CTableFrameSink::IsRoomCard
; _this$ = ecx

; 2479 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2480 : 	return ((m_pGameServiceOption->wServerType&GAME_GENRE_PERSONAL) != 0);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 88 30 09 00
	00		 mov	 ecx, DWORD PTR [eax+2352]
  00012	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  00016	83 e2 10	 and	 edx, 16			; 00000010H
  00019	74 09		 je	 SHORT $LN3@IsRoomCard
  0001b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@IsRoomCard
$LN3@IsRoomCard:
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@IsRoomCard:
  0002b	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 2481 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?IsRoomCard@CTableFrameSink@@IAE_NXZ ENDP		; CTableFrameSink::IsRoomCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_i$1 = -16						; size = 4
_this$ = -12						; size = 4
_i$2 = -8						; size = 2
_cbIndex$ = -2						; size = 1
_nCount$ = -1						; size = 1
_wChairID$ = 8						; size = 2
_cbCardData$ = 12					; size = 1
?GetRemainingCount@CTableFrameSink@@IAEEGE@Z PROC	; CTableFrameSink::GetRemainingCount
; _this$ = ecx

; 2364 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2365 : 	BYTE cbIndex = m_GameLogic.SwitchToCardIndex(cbCardData);

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00017	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  0001c	88 45 fe	 mov	 BYTE PTR _cbIndex$[ebp], al

; 2366 : 	BYTE nCount=0;

  0001f	c6 45 ff 00	 mov	 BYTE PTR _nCount$[ebp], 0

; 2367 : 	for(int i=m_cbMinusLastCount;i<MAX_REPERTORY-m_cbMinusHeadCount;i++)

  00023	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	0f b6 91 b0 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1968]
  0002d	89 55 f0	 mov	 DWORD PTR _i$1[ebp], edx
  00030	eb 09		 jmp	 SHORT $LN4@GetRemaini
$LN2@GetRemaini:
  00032	8b 45 f0	 mov	 eax, DWORD PTR _i$1[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	89 45 f0	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@GetRemaini:
  0003b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	0f b6 91 af 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1967]
  00045	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  0004a	2b c2		 sub	 eax, edx
  0004c	39 45 f0	 cmp	 DWORD PTR _i$1[ebp], eax
  0004f	7d 20		 jge	 SHORT $LN3@GetRemaini

; 2368 : 	{
; 2369 : 		if(m_cbRepertoryCard[i] == cbCardData)

  00051	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	03 4d f0	 add	 ecx, DWORD PTR _i$1[ebp]
  00057	0f b6 91 3e 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1854]
  0005e	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  00062	3b d0		 cmp	 edx, eax
  00064	75 09		 jne	 SHORT $LN8@GetRemaini

; 2370 : 			nCount++;

  00066	8a 4d ff	 mov	 cl, BYTE PTR _nCount$[ebp]
  00069	80 c1 01	 add	 cl, 1
  0006c	88 4d ff	 mov	 BYTE PTR _nCount$[ebp], cl
$LN8@GetRemaini:

; 2371 : 	}

  0006f	eb c1		 jmp	 SHORT $LN2@GetRemaini
$LN3@GetRemaini:

; 2372 : 	for(WORD i=0;i<GAME_PLAYER;i++)

  00071	33 d2		 xor	 edx, edx
  00073	66 89 55 f8	 mov	 WORD PTR _i$2[ebp], dx
  00077	eb 0c		 jmp	 SHORT $LN7@GetRemaini
$LN5@GetRemaini:
  00079	66 8b 45 f8	 mov	 ax, WORD PTR _i$2[ebp]
  0007d	66 83 c0 01	 add	 ax, 1
  00081	66 89 45 f8	 mov	 WORD PTR _i$2[ebp], ax
$LN7@GetRemaini:
  00085	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$2[ebp]
  00089	83 f9 04	 cmp	 ecx, 4
  0008c	7d 32		 jge	 SHORT $LN6@GetRemaini

; 2373 : 	{
; 2374 : 		if( i == wChairID)

  0008e	0f b7 55 f8	 movzx	 edx, WORD PTR _i$2[ebp]
  00092	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00096	3b d0		 cmp	 edx, eax
  00098	75 02		 jne	 SHORT $LN9@GetRemaini

; 2375 : 			continue;

  0009a	eb dd		 jmp	 SHORT $LN5@GetRemaini
$LN9@GetRemaini:

; 2376 : 
; 2377 : 		nCount += m_cbCardIndex[i][cbIndex];

  0009c	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$2[ebp]
  000a0	6b d1 22	 imul	 edx, ecx, 34
  000a3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  000ad	0f b6 55 fe	 movzx	 edx, BYTE PTR _cbIndex$[ebp]
  000b1	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000b5	0f b6 4d ff	 movzx	 ecx, BYTE PTR _nCount$[ebp]
  000b9	03 c8		 add	 ecx, eax
  000bb	88 4d ff	 mov	 BYTE PTR _nCount$[ebp], cl

; 2378 : 	}

  000be	eb b9		 jmp	 SHORT $LN5@GetRemaini
$LN6@GetRemaini:

; 2379 : 	return nCount;

  000c0	8a 45 ff	 mov	 al, BYTE PTR _nCount$[ebp]

; 2380 : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
?GetRemainingCount@CTableFrameSink@@IAEEGE@Z ENDP	; CTableFrameSink::GetRemainingCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_this$ = -8						; size = 4
_carddata$2 = -3					; size = 1
_carddata$3 = -2					; size = 1
_cbScore$ = -1						; size = 1
_wChairId$ = 8						; size = 2
?GetTimes@CTableFrameSink@@IAEEG@Z PROC			; CTableFrameSink::GetTimes
; _this$ = ecx

; 2322 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2323 : 	BYTE cbScore = 0;

  00009	c6 45 ff 00	 mov	 BYTE PTR _cbScore$[ebp], 0

; 2324 : 	ASSERT(m_cbMaCount > 0 && m_cbMaCount <= 6);
; 2325 : 	m_cbUserMaCount[wChairId]=m_cbMaCount;

  0000d	0f b7 45 08	 movzx	 eax, WORD PTR _wChairId$[ebp]
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8a 52 08	 mov	 dl, BYTE PTR [edx+8]
  0001a	88 94 01 dc 05
	00 00		 mov	 BYTE PTR [ecx+eax+1500], dl

; 2326 : 
; 2327 : 	if(m_cbMaCount == 1)//一码全中

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00028	83 f9 01	 cmp	 ecx, 1
  0002b	75 72		 jne	 SHORT $LN5@GetTimes

; 2328 : 	{
; 2329 : 		BYTE carddata = m_cbRepertoryCard[MAX_REPERTORY - m_cbMinusHeadCount-1];

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00030	0f b6 82 af 07
	00 00		 movzx	 eax, BYTE PTR [edx+1967]
  00037	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0003c	2b c8		 sub	 ecx, eax
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8a 84 0a 3d 07
	00 00		 mov	 al, BYTE PTR [edx+ecx+1853]
  00048	88 45 fe	 mov	 BYTE PTR _carddata$3[ebp], al

; 2330 : 		if(m_GameLogic.GetCardColor(carddata) < 0x30)

  0004b	0f b6 4d fe	 movzx	 ecx, BYTE PTR _carddata$3[ebp]
  0004f	51		 push	 ecx
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00059	e8 00 00 00 00	 call	 ?GetCardColor@CGameLogic@@QAEEE@Z ; CGameLogic::GetCardColor
  0005e	0f b6 d0	 movzx	 edx, al
  00061	83 fa 30	 cmp	 edx, 48			; 00000030H
  00064	7d 18		 jge	 SHORT $LN7@GetTimes

; 2331 : 		{
; 2332 : 			cbScore = m_GameLogic.GetCardValue(carddata);

  00066	0f b6 45 fe	 movzx	 eax, BYTE PTR _carddata$3[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00074	e8 00 00 00 00	 call	 ?GetCardValue@CGameLogic@@QAEEE@Z ; CGameLogic::GetCardValue
  00079	88 45 ff	 mov	 BYTE PTR _cbScore$[ebp], al

; 2333 : 		}
; 2334 : 		else//红中10分

  0007c	eb 04		 jmp	 SHORT $LN8@GetTimes
$LN7@GetTimes:

; 2335 : 		{
; 2336 : 			cbScore = 10;

  0007e	c6 45 ff 0a	 mov	 BYTE PTR _cbScore$[ebp], 10 ; 0000000aH
$LN8@GetTimes:

; 2337 : 		}
; 2338 : 		//统计中码个数
; 2339 : 		m_stRecord.cbMaCount[wChairId]++;

  00082	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairId$[ebp]
  00086	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8a 44 0a 12	 mov	 al, BYTE PTR [edx+ecx+18]
  0008d	04 01		 add	 al, 1
  0008f	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairId$[ebp]
  00093	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00096	88 44 0a 12	 mov	 BYTE PTR [edx+ecx+18], al

; 2340 : 	}
; 2341 : 	else//2-6码

  0009a	e9 02 01 00 00	 jmp	 $LN6@GetTimes
$LN5@GetTimes:

; 2342 : 	{
; 2343 : 		
; 2344 : 		if(m_cbCardIndex[wChairId][m_cbMagicIndex] == 0 && m_GameLogic.SwitchToCardIndex(m_cbProvideCard) != m_cbMagicIndex)//胡牌手中没红中，加一个码

  0009f	0f b7 45 08	 movzx	 eax, WORD PTR _wChairId$[ebp]
  000a3	6b c8 22	 imul	 ecx, eax, 34
  000a6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	0f b6 91 7c 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1148]
  000ba	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000be	85 c0		 test	 eax, eax
  000c0	75 49		 jne	 SHORT $LN9@GetTimes
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	0f b6 91 c2 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1218]
  000cc	52		 push	 edx
  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  000d6	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  000db	0f b6 c0	 movzx	 eax, al
  000de	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	0f b6 91 7c 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1148]
  000e8	3b c2		 cmp	 eax, edx
  000ea	74 1f		 je	 SHORT $LN9@GetTimes

; 2345 : 			m_cbUserMaCount[wChairId]++;

  000ec	0f b7 45 08	 movzx	 eax, WORD PTR _wChairId$[ebp]
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	8a 94 01 dc 05
	00 00		 mov	 dl, BYTE PTR [ecx+eax+1500]
  000fa	80 c2 01	 add	 dl, 1
  000fd	0f b7 45 08	 movzx	 eax, WORD PTR _wChairId$[ebp]
  00101	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	88 94 01 dc 05
	00 00		 mov	 BYTE PTR [ecx+eax+1500], dl
$LN9@GetTimes:

; 2346 : 
; 2347 : 		for(int i=0;i<m_cbUserMaCount[wChairId];i++)

  0010b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00112	eb 09		 jmp	 SHORT $LN4@GetTimes
$LN2@GetTimes:
  00114	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  00117	83 c2 01	 add	 edx, 1
  0011a	89 55 f4	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@GetTimes:
  0011d	0f b7 45 08	 movzx	 eax, WORD PTR _wChairId$[ebp]
  00121	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	0f b6 94 01 dc
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1500]
  0012c	39 55 f4	 cmp	 DWORD PTR _i$1[ebp], edx
  0012f	7d 70		 jge	 SHORT $LN6@GetTimes

; 2348 : 		{
; 2349 : 			BYTE carddata = m_cbRepertoryCard[MAX_REPERTORY - m_cbMinusHeadCount-i-1];

  00131	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00134	0f b6 88 af 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1967]
  0013b	ba 70 00 00 00	 mov	 edx, 112		; 00000070H
  00140	2b d1		 sub	 edx, ecx
  00142	2b 55 f4	 sub	 edx, DWORD PTR _i$1[ebp]
  00145	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00148	8a 8c 10 3d 07
	00 00		 mov	 cl, BYTE PTR [eax+edx+1853]
  0014f	88 4d fd	 mov	 BYTE PTR _carddata$2[ebp], cl

; 2350 : 
; 2351 : 			if(m_GameLogic.GetCardValue(carddata)%4 == 1)//1,5,9,红中 算中码

  00152	0f b6 55 fd	 movzx	 edx, BYTE PTR _carddata$2[ebp]
  00156	52		 push	 edx
  00157	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00160	e8 00 00 00 00	 call	 ?GetCardValue@CGameLogic@@QAEEE@Z ; CGameLogic::GetCardValue
  00165	0f b6 c0	 movzx	 eax, al
  00168	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0016d	79 05		 jns	 SHORT $LN12@GetTimes
  0016f	48		 dec	 eax
  00170	83 c8 fc	 or	 eax, -4			; fffffffcH
  00173	40		 inc	 eax
$LN12@GetTimes:
  00174	83 f8 01	 cmp	 eax, 1
  00177	75 23		 jne	 SHORT $LN10@GetTimes

; 2352 : 			{
; 2353 : 				cbScore += 2;

  00179	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cbScore$[ebp]
  0017d	83 c1 02	 add	 ecx, 2
  00180	88 4d ff	 mov	 BYTE PTR _cbScore$[ebp], cl

; 2354 : 				//统计中码个数
; 2355 : 				m_stRecord.cbMaCount[wChairId]++;

  00183	0f b7 55 08	 movzx	 edx, WORD PTR _wChairId$[ebp]
  00187	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0018a	8a 4c 10 12	 mov	 cl, BYTE PTR [eax+edx+18]
  0018e	80 c1 01	 add	 cl, 1
  00191	0f b7 55 08	 movzx	 edx, WORD PTR _wChairId$[ebp]
  00195	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00198	88 4c 10 12	 mov	 BYTE PTR [eax+edx+18], cl
$LN10@GetTimes:

; 2356 : 			}
; 2357 : 		}

  0019c	e9 73 ff ff ff	 jmp	 $LN2@GetTimes
$LN6@GetTimes:

; 2358 : 	}
; 2359 : 
; 2360 : 	return cbScore+2;//基础倍数+2

  001a1	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbScore$[ebp]
  001a5	83 c0 02	 add	 eax, 2

; 2361 : }

  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c2 04 00	 ret	 4
?GetTimes@CTableFrameSink@@IAEEG@Z ENDP			; CTableFrameSink::GetTimes
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wWinner$ = 8						; size = 2
_chr$ = 12						; size = 4
?FiltrateRight@CTableFrameSink@@IAEXGAAVCChiHuRight@@@Z PROC ; CTableFrameSink::FiltrateRight
; _this$ = ecx

; 2295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2296 : 	//自摸
; 2297 : 	if(wWinner == m_wProvideUser)

  00007	0f b7 45 08	 movzx	 eax, WORD PTR _wWinner$[ebp]
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	0f b7 91 c0 04
	00 00		 movzx	 edx, WORD PTR [ecx+1216]
  00015	3b c2		 cmp	 eax, edx
  00017	75 0f		 jne	 SHORT $LN2@FiltrateRi

; 2298 : 	{
; 2299 : 		chr |= CHR_ZI_MO;

  00019	68 00 00 00 08	 push	 134217728		; 08000000H
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _chr$[ebp]
  00021	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=
  00026	eb 1c		 jmp	 SHORT $LN1@FiltrateRi
$LN2@FiltrateRi:

; 2300 : 
; 2301 : 	}
; 2302 : 	else if(m_cbGangStatus == WIK_MING_GANG)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	0f b6 88 cc 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1228]
  00032	83 f9 01	 cmp	 ecx, 1
  00035	75 0d		 jne	 SHORT $LN1@FiltrateRi

; 2303 : 	{
; 2304 : 		chr |= CHR_QIANG_GANG_HU;

  00037	68 00 00 00 02	 push	 33554432		; 02000000H
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _chr$[ebp]
  0003f	e8 00 00 00 00	 call	 ??_5CChiHuRight@@QAEAAV0@K@Z ; CChiHuRight::operator|=
$LN1@FiltrateRi:

; 2305 : 	}
; 2306 : 	else
; 2307 : 	{
; 2308 : 		ASSERT(false);
; 2309 : 	}
; 2310 : 
; 2311 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
?FiltrateRight@CTableFrameSink@@IAEXGAAVCChiHuRight@@@Z ENDP ; CTableFrameSink::FiltrateRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_lcell$ = -24						; size = 8
_i$1 = -16						; size = 4
_i$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
?CalGangScore@CTableFrameSink@@IAEXXZ PROC		; CTableFrameSink::CalGangScore
; _this$ = ecx

; 2245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2246 : 	SCORE lcell = m_pITableFrame->GetCellScore();

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0001f	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00022	ff d2		 call	 edx
  00024	99		 cdq
  00025	89 45 e8	 mov	 DWORD PTR _lcell$[ebp], eax
  00028	89 55 ec	 mov	 DWORD PTR _lcell$[ebp+4], edx

; 2247 : 	if(m_cbGangStatus == WIK_FANG_GANG)//放杠一家扣分

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 88 cc 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1228]
  00035	83 f9 02	 cmp	 ecx, 2
  00038	0f 85 e5 00 00
	00		 jne	 $LN11@CalGangSco

; 2248 : 	{
; 2249 : 		for(int i=0;i<GAME_PLAYER;i++)

  0003e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00045	eb 09		 jmp	 SHORT $LN4@CalGangSco
$LN2@CalGangSco:
  00047	8b 55 f0	 mov	 edx, DWORD PTR _i$1[ebp]
  0004a	83 c2 01	 add	 edx, 1
  0004d	89 55 f0	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@CalGangSco:
  00050	83 7d f0 04	 cmp	 DWORD PTR _i$1[ebp], 4
  00054	0f 8d 9f 00 00
	00		 jge	 $LN3@CalGangSco

; 2250 : 		{
; 2251 : 			if(!m_bPlayStatus[i])

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	03 45 f0	 add	 eax, DWORD PTR _i$1[ebp]
  00060	0f b6 88 7d 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1149]
  00067	85 c9		 test	 ecx, ecx
  00069	75 02		 jne	 SHORT $LN13@CalGangSco

; 2252 : 				continue;

  0006b	eb da		 jmp	 SHORT $LN2@CalGangSco
$LN13@CalGangSco:

; 2253 : 			if(i != m_wCurrentUser)

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00070	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  00077	39 45 f0	 cmp	 DWORD PTR _i$1[ebp], eax
  0007a	74 78		 je	 SHORT $LN14@CalGangSco

; 2254 : 			{
; 2255 : 				m_lUserGangScore[m_wProvideGangUser] -= lcell;

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	0f b7 91 ce 04
	00 00		 movzx	 edx, WORD PTR [ecx+1230]
  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 8c d0 f8 05
	00 00		 mov	 ecx, DWORD PTR [eax+edx*8+1528]
  00090	2b 4d e8	 sub	 ecx, DWORD PTR _lcell$[ebp]
  00093	8b 94 d0 fc 05
	00 00		 mov	 edx, DWORD PTR [eax+edx*8+1532]
  0009a	1b 55 ec	 sbb	 edx, DWORD PTR _lcell$[ebp+4]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	0f b7 80 ce 04
	00 00		 movzx	 eax, WORD PTR [eax+1230]
  000a7	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  000aa	89 8c c6 f8 05
	00 00		 mov	 DWORD PTR [esi+eax*8+1528], ecx
  000b1	89 94 c6 fc 05
	00 00		 mov	 DWORD PTR [esi+eax*8+1532], edx

; 2256 : 				m_lUserGangScore[m_wCurrentUser] += lcell;

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  000c2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 8c d0 f8 05
	00 00		 mov	 ecx, DWORD PTR [eax+edx*8+1528]
  000cc	03 4d e8	 add	 ecx, DWORD PTR _lcell$[ebp]
  000cf	8b 94 d0 fc 05
	00 00		 mov	 edx, DWORD PTR [eax+edx*8+1532]
  000d6	13 55 ec	 adc	 edx, DWORD PTR _lcell$[ebp+4]
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	0f b7 80 be 04
	00 00		 movzx	 eax, WORD PTR [eax+1214]
  000e3	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  000e6	89 8c c6 f8 05
	00 00		 mov	 DWORD PTR [esi+eax*8+1528], ecx
  000ed	89 94 c6 fc 05
	00 00		 mov	 DWORD PTR [esi+eax*8+1532], edx
$LN14@CalGangSco:

; 2257 : 			}
; 2258 : 		}

  000f4	e9 4e ff ff ff	 jmp	 $LN2@CalGangSco
$LN3@CalGangSco:

; 2259 : 		//记录明杠次数
; 2260 : 		m_stRecord.cbMingGang[m_wCurrentUser]++;

  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  00103	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00106	8a 4c 10 1a	 mov	 cl, BYTE PTR [eax+edx+26]
  0010a	80 c1 01	 add	 cl, 1
  0010d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00110	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  00117	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0011a	88 4c 02 1a	 mov	 BYTE PTR [edx+eax+26], cl
  0011e	e9 ec 01 00 00	 jmp	 $LN1@CalGangSco
$LN11@CalGangSco:

; 2261 : 	}
; 2262 : 	else if(m_cbGangStatus == WIK_MING_GANG)//明杠每家出1倍

  00123	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00126	0f b6 88 cc 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1228]
  0012d	83 f9 01	 cmp	 ecx, 1
  00130	0f 85 d6 00 00
	00		 jne	 $LN15@CalGangSco

; 2263 : 	{
; 2264 : 		for(int i=0;i<GAME_PLAYER;i++)

  00136	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  0013d	eb 09		 jmp	 SHORT $LN7@CalGangSco
$LN5@CalGangSco:
  0013f	8b 55 f8	 mov	 edx, DWORD PTR _i$3[ebp]
  00142	83 c2 01	 add	 edx, 1
  00145	89 55 f8	 mov	 DWORD PTR _i$3[ebp], edx
$LN7@CalGangSco:
  00148	83 7d f8 04	 cmp	 DWORD PTR _i$3[ebp], 4
  0014c	0f 8d 91 00 00
	00		 jge	 $LN6@CalGangSco

; 2265 : 		{
; 2266 : 			if(!m_bPlayStatus[i])

  00152	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00155	03 45 f8	 add	 eax, DWORD PTR _i$3[ebp]
  00158	0f b6 88 7d 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1149]
  0015f	85 c9		 test	 ecx, ecx
  00161	75 02		 jne	 SHORT $LN17@CalGangSco

; 2267 : 				continue;

  00163	eb da		 jmp	 SHORT $LN5@CalGangSco
$LN17@CalGangSco:

; 2268 : 			if(i != m_wCurrentUser)

  00165	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00168	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  0016f	39 45 f8	 cmp	 DWORD PTR _i$3[ebp], eax
  00172	74 6a		 je	 SHORT $LN18@CalGangSco

; 2269 : 			{
; 2270 : 				m_lUserGangScore[i] -= lcell;

  00174	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  00177	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0017a	8b 84 ca f8 05
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+1528]
  00181	2b 45 e8	 sub	 eax, DWORD PTR _lcell$[ebp]
  00184	8b 8c ca fc 05
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*8+1532]
  0018b	1b 4d ec	 sbb	 ecx, DWORD PTR _lcell$[ebp+4]
  0018e	8b 55 f8	 mov	 edx, DWORD PTR _i$3[ebp]
  00191	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00194	89 84 d6 f8 05
	00 00		 mov	 DWORD PTR [esi+edx*8+1528], eax
  0019b	89 8c d6 fc 05
	00 00		 mov	 DWORD PTR [esi+edx*8+1532], ecx

; 2271 : 				m_lUserGangScore[m_wCurrentUser] += lcell;

  001a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  001ac	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001af	8b 84 ca f8 05
	00 00		 mov	 eax, DWORD PTR [edx+ecx*8+1528]
  001b6	03 45 e8	 add	 eax, DWORD PTR _lcell$[ebp]
  001b9	8b 8c ca fc 05
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*8+1532]
  001c0	13 4d ec	 adc	 ecx, DWORD PTR _lcell$[ebp+4]
  001c3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001c6	0f b7 92 be 04
	00 00		 movzx	 edx, WORD PTR [edx+1214]
  001cd	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001d0	89 84 d6 f8 05
	00 00		 mov	 DWORD PTR [esi+edx*8+1528], eax
  001d7	89 8c d6 fc 05
	00 00		 mov	 DWORD PTR [esi+edx*8+1532], ecx
$LN18@CalGangSco:

; 2272 : 			}
; 2273 : 		}

  001de	e9 5c ff ff ff	 jmp	 $LN5@CalGangSco
$LN6@CalGangSco:

; 2274 : 		//记录明杠次数
; 2275 : 		m_stRecord.cbMingGang[m_wCurrentUser]++;

  001e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  001ed	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f0	8a 44 0a 1a	 mov	 al, BYTE PTR [edx+ecx+26]
  001f4	04 01		 add	 al, 1
  001f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f9	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  00200	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00203	88 44 11 1a	 mov	 BYTE PTR [ecx+edx+26], al
  00207	e9 03 01 00 00	 jmp	 $LN1@CalGangSco
$LN15@CalGangSco:

; 2276 : 	}
; 2277 : 	else if(m_cbGangStatus == WIK_AN_GANG)//暗杠每家出2倍

  0020c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0020f	0f b6 82 cc 04
	00 00		 movzx	 eax, BYTE PTR [edx+1228]
  00216	83 f8 03	 cmp	 eax, 3
  00219	0f 85 f0 00 00
	00		 jne	 $LN1@CalGangSco

; 2278 : 	{
; 2279 : 		for(int i=0;i<GAME_PLAYER;i++)

  0021f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00226	eb 09		 jmp	 SHORT $LN10@CalGangSco
$LN8@CalGangSco:
  00228	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  0022b	83 c1 01	 add	 ecx, 1
  0022e	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN10@CalGangSco:
  00231	83 7d f4 04	 cmp	 DWORD PTR _i$2[ebp], 4
  00235	0f 8d af 00 00
	00		 jge	 $LN9@CalGangSco

; 2280 : 		{
; 2281 : 			if(!m_bPlayStatus[i])

  0023b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0023e	03 55 f4	 add	 edx, DWORD PTR _i$2[ebp]
  00241	0f b6 82 7d 04
	00 00		 movzx	 eax, BYTE PTR [edx+1149]
  00248	85 c0		 test	 eax, eax
  0024a	75 02		 jne	 SHORT $LN20@CalGangSco

; 2282 : 				continue;

  0024c	eb da		 jmp	 SHORT $LN8@CalGangSco
$LN20@CalGangSco:

; 2283 : 			if(i != m_wCurrentUser)

  0024e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00251	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  00258	39 55 f4	 cmp	 DWORD PTR _i$2[ebp], edx
  0025b	0f 84 84 00 00
	00		 je	 $LN21@CalGangSco

; 2284 : 			{
; 2285 : 				m_lUserGangScore[i] -= 2*lcell;

  00261	6a 00		 push	 0
  00263	6a 02		 push	 2
  00265	8b 45 ec	 mov	 eax, DWORD PTR _lcell$[ebp+4]
  00268	50		 push	 eax
  00269	8b 4d e8	 mov	 ecx, DWORD PTR _lcell$[ebp]
  0026c	51		 push	 ecx
  0026d	e8 00 00 00 00	 call	 __allmul
  00272	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  00275	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00278	8b bc ce f8 05
	00 00		 mov	 edi, DWORD PTR [esi+ecx*8+1528]
  0027f	2b f8		 sub	 edi, eax
  00281	8b 84 ce fc 05
	00 00		 mov	 eax, DWORD PTR [esi+ecx*8+1532]
  00288	1b c2		 sbb	 eax, edx
  0028a	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  0028d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00290	89 bc ca f8 05
	00 00		 mov	 DWORD PTR [edx+ecx*8+1528], edi
  00297	89 84 ca fc 05
	00 00		 mov	 DWORD PTR [edx+ecx*8+1532], eax

; 2286 : 				m_lUserGangScore[m_wCurrentUser] += 2*lcell;

  0029e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a1	0f b7 b0 be 04
	00 00		 movzx	 esi, WORD PTR [eax+1214]
  002a8	6a 00		 push	 0
  002aa	6a 02		 push	 2
  002ac	8b 4d ec	 mov	 ecx, DWORD PTR _lcell$[ebp+4]
  002af	51		 push	 ecx
  002b0	8b 55 e8	 mov	 edx, DWORD PTR _lcell$[ebp]
  002b3	52		 push	 edx
  002b4	e8 00 00 00 00	 call	 __allmul
  002b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bc	03 84 f1 f8 05
	00 00		 add	 eax, DWORD PTR [ecx+esi*8+1528]
  002c3	13 94 f1 fc 05
	00 00		 adc	 edx, DWORD PTR [ecx+esi*8+1532]
  002ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	0f b7 89 be 04
	00 00		 movzx	 ecx, WORD PTR [ecx+1214]
  002d4	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  002d7	89 84 ce f8 05
	00 00		 mov	 DWORD PTR [esi+ecx*8+1528], eax
  002de	89 94 ce fc 05
	00 00		 mov	 DWORD PTR [esi+ecx*8+1532], edx
$LN21@CalGangSco:

; 2287 : 			}
; 2288 : 		}

  002e5	e9 3e ff ff ff	 jmp	 $LN8@CalGangSco
$LN9@CalGangSco:

; 2289 : 		//记录暗杠次数
; 2290 : 		m_stRecord.cbAnGang[m_wCurrentUser]++;

  002ea	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ed	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  002f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f7	8a 54 01 16	 mov	 dl, BYTE PTR [ecx+eax+22]
  002fb	80 c2 01	 add	 dl, 1
  002fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00301	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  00308	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0030b	88 54 08 16	 mov	 BYTE PTR [eax+ecx+22], dl
$LN1@CalGangSco:

; 2291 : 	}
; 2292 : }

  0030f	5f		 pop	 edi
  00310	5e		 pop	 esi
  00311	8b e5		 mov	 esp, ebp
  00313	5d		 pop	 ebp
  00314	c3		 ret	 0
?CalGangScore@CTableFrameSink@@IAEXXZ ENDP		; CTableFrameSink::CalGangScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_lTempAllScore$ = -120					; size = 8
_lTempScore$ = -112					; size = 8
tv209 = -104						; size = 4
tv81 = -100						; size = 4
_lCellScore$ = -96					; size = 8
_pIServerUserItem$1 = -88				; size = 4
_bNoNegative$ = -81					; size = 1
_j$2 = -80						; size = 4
_i$3 = -76						; size = 4
_i$4 = -72						; size = 4
_i$5 = -68						; size = 4
_cbTimes$6 = -62					; size = 1
_bZiMo$7 = -61						; size = 1
_i$8 = -60						; size = 4
_cbTimes$9 = -53					; size = 1
_this$ = -52						; size = 4
_cbWinCount$ = -45					; size = 1
_lUserScore$ = -44					; size = 32
_wWinUser$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lEndScore$ = 8						; size = 4
?CalHuPaiScore@CTableFrameSink@@IAEXQA_J@Z PROC		; CTableFrameSink::CalHuPaiScore
; _this$ = ecx

; 2157 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 2158 : 	//初始化
; 2159 : 	ZeroMemory(lEndScore,sizeof(LONGLONG)*GAME_PLAYER);

  00015	6a 20		 push	 32			; 00000020H
  00017	6a 00		 push	 0
  00019	8b 45 08	 mov	 eax, DWORD PTR _lEndScore$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2160 : 	ZeroMemory(m_cbUserMaCount,sizeof(m_cbUserMaCount));

  00025	6a 04		 push	 4
  00027	6a 00		 push	 0
  00029	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 dc 05 00
	00		 add	 ecx, 1500		; 000005dcH
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _memset
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2161 : 
; 2162 : 	bool bNoNegative = (m_pGameServiceOption->wServerType & GAME_GENRE_GOLD) != 0 || (m_pGameServiceOption->wServerType & SCORE_GENRE_POSITIVE) != 0;

  0003b	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 82 30 09 00
	00		 mov	 eax, DWORD PTR [edx+2352]
  00044	0f b7 48 54	 movzx	 ecx, WORD PTR [eax+84]
  00048	83 e1 01	 and	 ecx, 1
  0004b	75 1e		 jne	 SHORT $LN30@CalHuPaiSc
  0004d	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00050	8b 82 30 09 00
	00		 mov	 eax, DWORD PTR [edx+2352]
  00056	0f b7 48 54	 movzx	 ecx, WORD PTR [eax+84]
  0005a	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00060	75 09		 jne	 SHORT $LN30@CalHuPaiSc
  00062	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  00069	eb 07		 jmp	 SHORT $LN31@CalHuPaiSc
$LN30@CalHuPaiSc:
  0006b	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
$LN31@CalHuPaiSc:
  00072	8a 55 9c	 mov	 dl, BYTE PTR tv81[ebp]
  00075	88 55 af	 mov	 BYTE PTR _bNoNegative$[ebp], dl

; 2163 : 
; 2164 : 	SCORE lCellScore = m_pITableFrame->GetCellScore();

  00078	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00081	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00084	8b 01		 mov	 eax, DWORD PTR [ecx]
  00086	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0008c	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  0008f	ff d2		 call	 edx
  00091	99		 cdq
  00092	89 45 a0	 mov	 DWORD PTR _lCellScore$[ebp], eax
  00095	89 55 a4	 mov	 DWORD PTR _lCellScore$[ebp+4], edx

; 2165 : 
; 2166 : 	SCORE lUserScore[GAME_PLAYER] = {0};//玩家手上分

  00098	0f 57 c0	 xorps	 xmm0, xmm0
  0009b	66 0f 13 45 d4	 movlpd	 QWORD PTR _lUserScore$[ebp], xmm0
  000a0	33 c0		 xor	 eax, eax
  000a2	89 45 dc	 mov	 DWORD PTR _lUserScore$[ebp+8], eax
  000a5	89 45 e0	 mov	 DWORD PTR _lUserScore$[ebp+12], eax
  000a8	89 45 e4	 mov	 DWORD PTR _lUserScore$[ebp+16], eax
  000ab	89 45 e8	 mov	 DWORD PTR _lUserScore$[ebp+20], eax
  000ae	89 45 ec	 mov	 DWORD PTR _lUserScore$[ebp+24], eax
  000b1	89 45 f0	 mov	 DWORD PTR _lUserScore$[ebp+28], eax

; 2167 : 	SCORE lTempScore = 0;

  000b4	0f 57 c0	 xorps	 xmm0, xmm0
  000b7	66 0f 13 45 90	 movlpd	 QWORD PTR _lTempScore$[ebp], xmm0

; 2168 : 	SCORE lTempAllScore = 0;

  000bc	0f 57 c0	 xorps	 xmm0, xmm0
  000bf	66 0f 13 45 88	 movlpd	 QWORD PTR _lTempAllScore$[ebp], xmm0

; 2169 : 	for(int i = 0; i < GAME_PLAYER; i++)

  000c4	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  000cb	eb 09		 jmp	 SHORT $LN4@CalHuPaiSc
$LN2@CalHuPaiSc:
  000cd	8b 4d b4	 mov	 ecx, DWORD PTR _i$3[ebp]
  000d0	83 c1 01	 add	 ecx, 1
  000d3	89 4d b4	 mov	 DWORD PTR _i$3[ebp], ecx
$LN4@CalHuPaiSc:
  000d6	83 7d b4 04	 cmp	 DWORD PTR _i$3[ebp], 4
  000da	7d 5a		 jge	 SHORT $LN3@CalHuPaiSc

; 2170 : 	{
; 2171 : 		if(!m_bPlayStatus[i])

  000dc	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000df	03 55 b4	 add	 edx, DWORD PTR _i$3[ebp]
  000e2	0f b6 82 7d 04
	00 00		 movzx	 eax, BYTE PTR [edx+1149]
  000e9	85 c0		 test	 eax, eax
  000eb	75 02		 jne	 SHORT $LN17@CalHuPaiSc

; 2172 : 			continue;

  000ed	eb de		 jmp	 SHORT $LN2@CalHuPaiSc
$LN17@CalHuPaiSc:

; 2173 : 		IServerUserItem * pIServerUserItem = m_pITableFrame->GetTableUserItem(i);

  000ef	0f b7 4d b4	 movzx	 ecx, WORD PTR _i$3[ebp]
  000f3	51		 push	 ecx
  000f4	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000f7	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  000fd	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 10		 mov	 edx, DWORD PTR [eax]
  00102	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00108	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  0010e	ff d0		 call	 eax
  00110	89 45 a8	 mov	 DWORD PTR _pIServerUserItem$1[ebp], eax

; 2174 : 		ASSERT(pIServerUserItem);
; 2175 : 		if(pIServerUserItem)

  00113	83 7d a8 00	 cmp	 DWORD PTR _pIServerUserItem$1[ebp], 0
  00117	74 1b		 je	 SHORT $LN18@CalHuPaiSc

; 2176 : 		{
; 2177 : 			lUserScore[i] = pIServerUserItem->GetUserScore();

  00119	8b 4d a8	 mov	 ecx, DWORD PTR _pIServerUserItem$1[ebp]
  0011c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011e	8b 4d a8	 mov	 ecx, DWORD PTR _pIServerUserItem$1[ebp]
  00121	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00127	ff d0		 call	 eax
  00129	8b 4d b4	 mov	 ecx, DWORD PTR _i$3[ebp]
  0012c	89 44 cd d4	 mov	 DWORD PTR _lUserScore$[ebp+ecx*8], eax
  00130	89 54 cd d8	 mov	 DWORD PTR _lUserScore$[ebp+ecx*8+4], edx
$LN18@CalHuPaiSc:

; 2178 : 		}		
; 2179 : 	}

  00134	eb 97		 jmp	 SHORT $LN2@CalHuPaiSc
$LN3@CalHuPaiSc:

; 2180 : 
; 2181 : 	WORD wWinUser[GAME_PLAYER] = {0};

  00136	33 d2		 xor	 edx, edx
  00138	66 89 55 f4	 mov	 WORD PTR _wWinUser$[ebp], dx
  0013c	33 c0		 xor	 eax, eax
  0013e	89 45 f6	 mov	 DWORD PTR _wWinUser$[ebp+2], eax
  00141	66 89 45 fa	 mov	 WORD PTR _wWinUser$[ebp+6], ax

; 2182 : 	BYTE cbWinCount = 0;

  00145	c6 45 d3 00	 mov	 BYTE PTR _cbWinCount$[ebp], 0

; 2183 : 
; 2184 : 	for(int i = 0; i < GAME_PLAYER; i++)

  00149	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00150	eb 09		 jmp	 SHORT $LN7@CalHuPaiSc
$LN5@CalHuPaiSc:
  00152	8b 4d bc	 mov	 ecx, DWORD PTR _i$5[ebp]
  00155	83 c1 01	 add	 ecx, 1
  00158	89 4d bc	 mov	 DWORD PTR _i$5[ebp], ecx
$LN7@CalHuPaiSc:
  0015b	83 7d bc 04	 cmp	 DWORD PTR _i$5[ebp], 4
  0015f	0f 8d 9a 00 00
	00		 jge	 $LN6@CalHuPaiSc

; 2185 : 	{
; 2186 : 		if(WIK_CHI_HU == m_dwChiHuKind[(m_wBankerUser + i) % GAME_PLAYER])

  00165	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00168	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  0016f	03 45 bc	 add	 eax, DWORD PTR _i$5[ebp]
  00172	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00177	79 05		 jns	 SHORT $LN34@CalHuPaiSc
  00179	48		 dec	 eax
  0017a	83 c8 fc	 or	 eax, -4			; fffffffcH
  0017d	40		 inc	 eax
$LN34@CalHuPaiSc:
  0017e	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	83 bc 81 1c 06
	00 00 40	 cmp	 DWORD PTR [ecx+eax*4+1564], 64 ; 00000040H
  00189	75 6f		 jne	 SHORT $LN19@CalHuPaiSc

; 2187 : 		{
; 2188 : 			wWinUser[cbWinCount++] = (m_wBankerUser + i) % GAME_PLAYER;

  0018b	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0018e	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  00195	03 45 bc	 add	 eax, DWORD PTR _i$5[ebp]
  00198	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0019d	79 05		 jns	 SHORT $LN35@CalHuPaiSc
  0019f	48		 dec	 eax
  001a0	83 c8 fc	 or	 eax, -4			; fffffffcH
  001a3	40		 inc	 eax
$LN35@CalHuPaiSc:
  001a4	0f b6 4d d3	 movzx	 ecx, BYTE PTR _cbWinCount$[ebp]
  001a8	66 89 44 4d f4	 mov	 WORD PTR _wWinUser$[ebp+ecx*2], ax
  001ad	8a 55 d3	 mov	 dl, BYTE PTR _cbWinCount$[ebp]
  001b0	80 c2 01	 add	 dl, 1
  001b3	88 55 d3	 mov	 BYTE PTR _cbWinCount$[ebp], dl

; 2189 : 
; 2190 : 			//统计胡牌次数
; 2191 : 			m_stRecord.cbHuCount[(m_wBankerUser + i) % GAME_PLAYER]++;

  001b6	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  001b9	0f b7 88 72 04
	00 00		 movzx	 ecx, WORD PTR [eax+1138]
  001c0	03 4d bc	 add	 ecx, DWORD PTR _i$5[ebp]
  001c3	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  001c9	79 05		 jns	 SHORT $LN36@CalHuPaiSc
  001cb	49		 dec	 ecx
  001cc	83 c9 fc	 or	 ecx, -4			; fffffffcH
  001cf	41		 inc	 ecx
$LN36@CalHuPaiSc:
  001d0	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  001d3	8a 44 0a 0e	 mov	 al, BYTE PTR [edx+ecx+14]
  001d7	04 01		 add	 al, 1
  001d9	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  001e3	03 55 bc	 add	 edx, DWORD PTR _i$5[ebp]
  001e6	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  001ec	79 05		 jns	 SHORT $LN37@CalHuPaiSc
  001ee	4a		 dec	 edx
  001ef	83 ca fc	 or	 edx, -4			; fffffffcH
  001f2	42		 inc	 edx
$LN37@CalHuPaiSc:
  001f3	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	88 44 11 0e	 mov	 BYTE PTR [ecx+edx+14], al
$LN19@CalHuPaiSc:

; 2192 : 		}
; 2193 : 	}

  001fa	e9 53 ff ff ff	 jmp	 $LN5@CalHuPaiSc
$LN6@CalHuPaiSc:

; 2194 : 
; 2195 : 	if(cbWinCount > 0)//有人胡牌

  001ff	0f b6 55 d3	 movzx	 edx, BYTE PTR _cbWinCount$[ebp]
  00203	85 d2		 test	 edx, edx
  00205	0f 8e 2f 02 00
	00		 jle	 $LN20@CalHuPaiSc

; 2196 : 	{
; 2197 : 		bool bZiMo= (m_wProvideUser == wWinUser[0]);

  0020b	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0020e	0f b7 88 c0 04
	00 00		 movzx	 ecx, WORD PTR [eax+1216]
  00215	ba 02 00 00 00	 mov	 edx, 2
  0021a	6b c2 00	 imul	 eax, edx, 0
  0021d	0f b7 54 05 f4	 movzx	 edx, WORD PTR _wWinUser$[ebp+eax]
  00222	3b ca		 cmp	 ecx, edx
  00224	75 09		 jne	 SHORT $LN32@CalHuPaiSc
  00226	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv209[ebp], 1
  0022d	eb 07		 jmp	 SHORT $LN33@CalHuPaiSc
$LN32@CalHuPaiSc:
  0022f	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv209[ebp], 0
$LN33@CalHuPaiSc:
  00236	8a 45 98	 mov	 al, BYTE PTR tv209[ebp]
  00239	88 45 c3	 mov	 BYTE PTR _bZiMo$7[ebp], al

; 2198 : 		if(bZiMo)//自摸

  0023c	0f b6 4d c3	 movzx	 ecx, BYTE PTR _bZiMo$7[ebp]
  00240	85 c9		 test	 ecx, ecx
  00242	0f 84 d8 00 00
	00		 je	 $LN22@CalHuPaiSc

; 2199 : 		{
; 2200 : 			BYTE cbTimes = GetTimes(wWinUser[0]);

  00248	ba 02 00 00 00	 mov	 edx, 2
  0024d	6b c2 00	 imul	 eax, edx, 0
  00250	0f b7 4c 05 f4	 movzx	 ecx, WORD PTR _wWinUser$[ebp+eax]
  00255	51		 push	 ecx
  00256	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00259	e8 00 00 00 00	 call	 ?GetTimes@CTableFrameSink@@IAEEG@Z ; CTableFrameSink::GetTimes
  0025e	88 45 cb	 mov	 BYTE PTR _cbTimes$9[ebp], al

; 2201 : 			for(int i=0;i<GAME_PLAYER;i++)

  00261	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00268	eb 09		 jmp	 SHORT $LN10@CalHuPaiSc
$LN8@CalHuPaiSc:
  0026a	8b 55 b8	 mov	 edx, DWORD PTR _i$4[ebp]
  0026d	83 c2 01	 add	 edx, 1
  00270	89 55 b8	 mov	 DWORD PTR _i$4[ebp], edx
$LN10@CalHuPaiSc:
  00273	83 7d b8 04	 cmp	 DWORD PTR _i$4[ebp], 4
  00277	0f 8d 9e 00 00
	00		 jge	 $LN9@CalHuPaiSc

; 2202 : 			{
; 2203 : 				if(!m_bPlayStatus[i])

  0027d	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00280	03 45 b8	 add	 eax, DWORD PTR _i$4[ebp]
  00283	0f b6 88 7d 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1149]
  0028a	85 c9		 test	 ecx, ecx
  0028c	75 02		 jne	 SHORT $LN24@CalHuPaiSc

; 2204 : 					continue;

  0028e	eb da		 jmp	 SHORT $LN8@CalHuPaiSc
$LN24@CalHuPaiSc:

; 2205 : 				if(i != wWinUser[0])

  00290	ba 02 00 00 00	 mov	 edx, 2
  00295	6b c2 00	 imul	 eax, edx, 0
  00298	0f b7 4c 05 f4	 movzx	 ecx, WORD PTR _wWinUser$[ebp+eax]
  0029d	39 4d b8	 cmp	 DWORD PTR _i$4[ebp], ecx
  002a0	74 74		 je	 SHORT $LN25@CalHuPaiSc

; 2206 : 				{
; 2207 : 					lEndScore[i] -= cbTimes*lCellScore;

  002a2	0f b6 45 cb	 movzx	 eax, BYTE PTR _cbTimes$9[ebp]
  002a6	99		 cdq
  002a7	8b 4d a4	 mov	 ecx, DWORD PTR _lCellScore$[ebp+4]
  002aa	51		 push	 ecx
  002ab	8b 4d a0	 mov	 ecx, DWORD PTR _lCellScore$[ebp]
  002ae	51		 push	 ecx
  002af	52		 push	 edx
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 __allmul
  002b6	8b 4d b8	 mov	 ecx, DWORD PTR _i$4[ebp]
  002b9	8b 75 08	 mov	 esi, DWORD PTR _lEndScore$[ebp]
  002bc	8b 3c ce	 mov	 edi, DWORD PTR [esi+ecx*8]
  002bf	2b f8		 sub	 edi, eax
  002c1	8b 44 ce 04	 mov	 eax, DWORD PTR [esi+ecx*8+4]
  002c5	1b c2		 sbb	 eax, edx
  002c7	8b 4d b8	 mov	 ecx, DWORD PTR _i$4[ebp]
  002ca	8b 55 08	 mov	 edx, DWORD PTR _lEndScore$[ebp]
  002cd	89 3c ca	 mov	 DWORD PTR [edx+ecx*8], edi
  002d0	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 2208 : 					lEndScore[wWinUser[0]] += cbTimes*lCellScore;

  002d4	b8 02 00 00 00	 mov	 eax, 2
  002d9	6b c8 00	 imul	 ecx, eax, 0
  002dc	0f b7 74 0d f4	 movzx	 esi, WORD PTR _wWinUser$[ebp+ecx]
  002e1	0f b6 45 cb	 movzx	 eax, BYTE PTR _cbTimes$9[ebp]
  002e5	99		 cdq
  002e6	8b 4d a4	 mov	 ecx, DWORD PTR _lCellScore$[ebp+4]
  002e9	51		 push	 ecx
  002ea	8b 4d a0	 mov	 ecx, DWORD PTR _lCellScore$[ebp]
  002ed	51		 push	 ecx
  002ee	52		 push	 edx
  002ef	50		 push	 eax
  002f0	e8 00 00 00 00	 call	 __allmul
  002f5	8b 4d 08	 mov	 ecx, DWORD PTR _lEndScore$[ebp]
  002f8	03 04 f1	 add	 eax, DWORD PTR [ecx+esi*8]
  002fb	13 54 f1 04	 adc	 edx, DWORD PTR [ecx+esi*8+4]
  002ff	b9 02 00 00 00	 mov	 ecx, 2
  00304	6b c9 00	 imul	 ecx, ecx, 0
  00307	0f b7 4c 0d f4	 movzx	 ecx, WORD PTR _wWinUser$[ebp+ecx]
  0030c	8b 75 08	 mov	 esi, DWORD PTR _lEndScore$[ebp]
  0030f	89 04 ce	 mov	 DWORD PTR [esi+ecx*8], eax
  00312	89 54 ce 04	 mov	 DWORD PTR [esi+ecx*8+4], edx
$LN25@CalHuPaiSc:

; 2209 : 				}
; 2210 : 			}

  00316	e9 4f ff ff ff	 jmp	 $LN8@CalHuPaiSc
$LN9@CalHuPaiSc:

; 2211 : 		}
; 2212 : 		else//抢杠

  0031b	e9 e4 00 00 00	 jmp	 $LN23@CalHuPaiSc
$LN22@CalHuPaiSc:

; 2213 : 		{
; 2214 : 			for(int i=0;i<cbWinCount;i++)

  00320	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00327	eb 09		 jmp	 SHORT $LN13@CalHuPaiSc
$LN11@CalHuPaiSc:
  00329	8b 55 c4	 mov	 edx, DWORD PTR _i$8[ebp]
  0032c	83 c2 01	 add	 edx, 1
  0032f	89 55 c4	 mov	 DWORD PTR _i$8[ebp], edx
$LN13@CalHuPaiSc:
  00332	0f b6 45 d3	 movzx	 eax, BYTE PTR _cbWinCount$[ebp]
  00336	39 45 c4	 cmp	 DWORD PTR _i$8[ebp], eax
  00339	0f 8d c5 00 00
	00		 jge	 $LN23@CalHuPaiSc

; 2215 : 			{
; 2216 : 				BYTE cbTimes=GetTimes(wWinUser[i]);

  0033f	8b 4d c4	 mov	 ecx, DWORD PTR _i$8[ebp]
  00342	0f b7 54 4d f4	 movzx	 edx, WORD PTR _wWinUser$[ebp+ecx*2]
  00347	52		 push	 edx
  00348	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0034b	e8 00 00 00 00	 call	 ?GetTimes@CTableFrameSink@@IAEEG@Z ; CTableFrameSink::GetTimes
  00350	88 45 c2	 mov	 BYTE PTR _cbTimes$6[ebp], al

; 2217 : 
; 2218 : 				for(int j=0;j<GAME_PLAYER;j++)

  00353	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _j$2[ebp], 0
  0035a	eb 09		 jmp	 SHORT $LN16@CalHuPaiSc
$LN14@CalHuPaiSc:
  0035c	8b 45 b0	 mov	 eax, DWORD PTR _j$2[ebp]
  0035f	83 c0 01	 add	 eax, 1
  00362	89 45 b0	 mov	 DWORD PTR _j$2[ebp], eax
$LN16@CalHuPaiSc:
  00365	83 7d b0 04	 cmp	 DWORD PTR _j$2[ebp], 4
  00369	7d 5a		 jge	 SHORT $LN15@CalHuPaiSc

; 2219 : 				{
; 2220 : 					if(!m_bPlayStatus[j])

  0036b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0036e	03 4d b0	 add	 ecx, DWORD PTR _j$2[ebp]
  00371	0f b6 91 7d 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1149]
  00378	85 d2		 test	 edx, edx
  0037a	75 02		 jne	 SHORT $LN26@CalHuPaiSc

; 2221 : 						continue;

  0037c	eb de		 jmp	 SHORT $LN14@CalHuPaiSc
$LN26@CalHuPaiSc:

; 2222 : 					if(j != wWinUser[i])

  0037e	8b 45 c4	 mov	 eax, DWORD PTR _i$8[ebp]
  00381	0f b7 4c 45 f4	 movzx	 ecx, WORD PTR _wWinUser$[ebp+eax*2]
  00386	39 4d b0	 cmp	 DWORD PTR _j$2[ebp], ecx
  00389	74 38		 je	 SHORT $LN27@CalHuPaiSc

; 2223 : 					{
; 2224 : 						lEndScore[wWinUser[i]] += cbTimes*lCellScore;

  0038b	8b 55 c4	 mov	 edx, DWORD PTR _i$8[ebp]
  0038e	0f b7 74 55 f4	 movzx	 esi, WORD PTR _wWinUser$[ebp+edx*2]
  00393	0f b6 45 c2	 movzx	 eax, BYTE PTR _cbTimes$6[ebp]
  00397	99		 cdq
  00398	8b 4d a4	 mov	 ecx, DWORD PTR _lCellScore$[ebp+4]
  0039b	51		 push	 ecx
  0039c	8b 4d a0	 mov	 ecx, DWORD PTR _lCellScore$[ebp]
  0039f	51		 push	 ecx
  003a0	52		 push	 edx
  003a1	50		 push	 eax
  003a2	e8 00 00 00 00	 call	 __allmul
  003a7	8b 4d 08	 mov	 ecx, DWORD PTR _lEndScore$[ebp]
  003aa	03 04 f1	 add	 eax, DWORD PTR [ecx+esi*8]
  003ad	13 54 f1 04	 adc	 edx, DWORD PTR [ecx+esi*8+4]
  003b1	8b 4d c4	 mov	 ecx, DWORD PTR _i$8[ebp]
  003b4	0f b7 4c 4d f4	 movzx	 ecx, WORD PTR _wWinUser$[ebp+ecx*2]
  003b9	8b 75 08	 mov	 esi, DWORD PTR _lEndScore$[ebp]
  003bc	89 04 ce	 mov	 DWORD PTR [esi+ecx*8], eax
  003bf	89 54 ce 04	 mov	 DWORD PTR [esi+ecx*8+4], edx
$LN27@CalHuPaiSc:

; 2225 : 					}
; 2226 : 				}

  003c3	eb 97		 jmp	 SHORT $LN14@CalHuPaiSc
$LN15@CalHuPaiSc:

; 2227 : 				lEndScore[m_wProvideUser] -= lEndScore[wWinUser[i]];

  003c5	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  003c8	0f b7 82 c0 04
	00 00		 movzx	 eax, WORD PTR [edx+1216]
  003cf	8b 4d c4	 mov	 ecx, DWORD PTR _i$8[ebp]
  003d2	0f b7 54 4d f4	 movzx	 edx, WORD PTR _wWinUser$[ebp+ecx*2]
  003d7	8b 4d 08	 mov	 ecx, DWORD PTR _lEndScore$[ebp]
  003da	8b 75 08	 mov	 esi, DWORD PTR _lEndScore$[ebp]
  003dd	8b 3c c1	 mov	 edi, DWORD PTR [ecx+eax*8]
  003e0	2b 3c d6	 sub	 edi, DWORD PTR [esi+edx*8]
  003e3	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  003e7	1b 44 d6 04	 sbb	 eax, DWORD PTR [esi+edx*8+4]
  003eb	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ee	0f b7 91 c0 04
	00 00		 movzx	 edx, WORD PTR [ecx+1216]
  003f5	8b 4d 08	 mov	 ecx, DWORD PTR _lEndScore$[ebp]
  003f8	89 3c d1	 mov	 DWORD PTR [ecx+edx*8], edi
  003fb	89 44 d1 04	 mov	 DWORD PTR [ecx+edx*8+4], eax

; 2228 : 			}

  003ff	e9 25 ff ff ff	 jmp	 $LN11@CalHuPaiSc
$LN23@CalHuPaiSc:

; 2229 : 		}
; 2230 : 		
; 2231 : 
; 2232 : 		//谁胡谁当庄
; 2233 : 		m_wBankerUser = wWinUser[0];

  00404	ba 02 00 00 00	 mov	 edx, 2
  00409	6b c2 00	 imul	 eax, edx, 0
  0040c	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0040f	66 8b 54 05 f4	 mov	 dx, WORD PTR _wWinUser$[ebp+eax]
  00414	66 89 91 72 04
	00 00		 mov	 WORD PTR [ecx+1138], dx

; 2234 : 		if(cbWinCount > 1)//多个玩家胡牌，放炮者当庄

  0041b	0f b6 45 d3	 movzx	 eax, BYTE PTR _cbWinCount$[ebp]
  0041f	83 f8 01	 cmp	 eax, 1
  00422	7e 14		 jle	 SHORT $LN28@CalHuPaiSc

; 2235 : 			m_wBankerUser = m_wProvideUser;

  00424	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00427	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0042a	66 8b 82 c0 04
	00 00		 mov	 ax, WORD PTR [edx+1216]
  00431	66 89 81 72 04
	00 00		 mov	 WORD PTR [ecx+1138], ax
$LN28@CalHuPaiSc:

; 2236 : 	}
; 2237 : 	else//荒庄

  00438	eb 14		 jmp	 SHORT $LN1@CalHuPaiSc
$LN20@CalHuPaiSc:

; 2238 : 	{
; 2239 : 		m_wBankerUser = m_wLastCatchCardUser;//最后一个摸牌的人当庄

  0043a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0043d	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  00440	66 8b 82 c4 04
	00 00		 mov	 ax, WORD PTR [edx+1220]
  00447	66 89 81 72 04
	00 00		 mov	 WORD PTR [ecx+1138], ax
$LN1@CalHuPaiSc:

; 2240 : 	}
; 2241 : 
; 2242 : }

  0044e	5f		 pop	 edi
  0044f	5e		 pop	 esi
  00450	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00453	33 cd		 xor	 ecx, ebp
  00455	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045a	8b e5		 mov	 esp, ebp
  0045c	5d		 pop	 ebp
  0045d	c2 04 00	 ret	 4
?CalHuPaiScore@CTableFrameSink@@IAEXQA_J@Z ENDP		; CTableFrameSink::CalHuPaiScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_chr$1 = -28						; size = 4
_j$2 = -24						; size = 4
_j$3 = -20						; size = 4
_this$ = -16						; size = 4
_i$4 = -12						; size = 2
_cbAction$5 = -6					; size = 1
_cbWeaveCount$6 = -5					; size = 1
_cbCardCount$7 = -4					; size = 1
_bAroseAction$ = -3					; size = 1
_bChiHu$8 = -2						; size = 1
_bPeng$9 = -1						; size = 1
_wCenterUser$ = 8					; size = 2
_cbCenterCard$ = 12					; size = 1
_EstimatKind$ = 16					; size = 4
?EstimateUserRespond@CTableFrameSink@@IAE_NGEW4enEstimatKind@@@Z PROC ; CTableFrameSink::EstimateUserRespond
; _this$ = ecx

; 2055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2056 : 	//变量定义
; 2057 : 	bool bAroseAction = false;

  0000a	c6 45 fd 00	 mov	 BYTE PTR _bAroseAction$[ebp], 0

; 2058 : 
; 2059 : 	//用户状态
; 2060 : 	ZeroMemory(m_bResponse, sizeof(m_bResponse));

  0000e	6a 04		 push	 4
  00010	6a 00		 push	 0
  00012	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00015	05 e0 05 00 00	 add	 eax, 1504		; 000005e0H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2061 : 	ZeroMemory(m_cbUserAction, sizeof(m_cbUserAction));

  00023	6a 04		 push	 4
  00025	6a 00		 push	 0
  00027	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	81 c1 e4 05 00
	00		 add	 ecx, 1508		; 000005e4H
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _memset
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2062 : 	ZeroMemory(m_cbPerformAction, sizeof(m_cbPerformAction));

  00039	6a 04		 push	 4
  0003b	6a 00		 push	 0
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	81 c2 f4 05 00
	00		 add	 edx, 1524		; 000005f4H
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _memset
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2063 : 
; 2064 : 	//动作判断
; 2065 : 	for (WORD i = 0; i < m_cbPlayerCount; i++)

  0004f	33 c0		 xor	 eax, eax
  00051	66 89 45 f4	 mov	 WORD PTR _i$4[ebp], ax
  00055	eb 0c		 jmp	 SHORT $LN4@EstimateUs
$LN2@EstimateUs:
  00057	66 8b 4d f4	 mov	 cx, WORD PTR _i$4[ebp]
  0005b	66 83 c1 01	 add	 cx, 1
  0005f	66 89 4d f4	 mov	 WORD PTR _i$4[ebp], cx
$LN4@EstimateUs:
  00063	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  0006e	3b d1		 cmp	 edx, ecx
  00070	0f 8d 50 03 00
	00		 jge	 $LN3@EstimateUs

; 2066 : 	{
; 2067 : 		//用户过滤
; 2068 : 		if (wCenterUser == i || !m_bPlayStatus[i] || m_bTrustee[i]) continue;

  00076	0f b7 55 08	 movzx	 edx, WORD PTR _wCenterUser$[ebp]
  0007a	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  0007e	3b d0		 cmp	 edx, eax
  00080	74 26		 je	 SHORT $LN12@EstimateUs
  00082	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  00086	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00089	0f b6 84 0a 7d
	04 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1149]
  00091	85 c0		 test	 eax, eax
  00093	74 13		 je	 SHORT $LN12@EstimateUs
  00095	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  00099	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0009c	0f b6 84 0a 78
	04 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1144]
  000a4	85 c0		 test	 eax, eax
  000a6	74 02		 je	 SHORT $LN11@EstimateUs
$LN12@EstimateUs:
  000a8	eb ad		 jmp	 SHORT $LN2@EstimateUs
$LN11@EstimateUs:

; 2069 : 
; 2070 : 		//出牌类型
; 2071 : 		if (EstimatKind == EstimatKind_OutCard )

  000aa	83 7d 10 00	 cmp	 DWORD PTR _EstimatKind$[ebp], 0
  000ae	0f 85 b7 01 00
	00		 jne	 $LN13@EstimateUs

; 2072 : 		{
; 2073 : 			//吃碰判断
; 2074 : 			if(!m_bEnjoinChiPeng[i])

  000b4	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  000b8	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	0f b6 84 0a d4
	04 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1236]
  000c3	85 c0		 test	 eax, eax
  000c5	0f 85 a0 01 00
	00		 jne	 $LN13@EstimateUs

; 2075 : 			{
; 2076 : 				bool bPeng = true;

  000cb	c6 45 ff 01	 mov	 BYTE PTR _bPeng$9[ebp], 1

; 2077 : 				for(UINT j = 0; j < m_vecEnjoinChiPeng[i].size(); j++)

  000cf	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$3[ebp], 0
  000d6	eb 09		 jmp	 SHORT $LN7@EstimateUs
$LN5@EstimateUs:
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR _j$3[ebp]
  000db	83 c1 01	 add	 ecx, 1
  000de	89 4d ec	 mov	 DWORD PTR _j$3[ebp], ecx
$LN7@EstimateUs:
  000e1	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  000e5	6b c2 0c	 imul	 eax, edx, 12
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	8d 8c 01 1c 05
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1308]
  000f2	e8 00 00 00 00	 call	 ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
  000f7	39 45 ec	 cmp	 DWORD PTR _j$3[ebp], eax
  000fa	73 2b		 jae	 SHORT $LN6@EstimateUs

; 2078 : 				{
; 2079 : 					if(m_vecEnjoinChiPeng[i][j] == cbCenterCard)

  000fc	8b 55 ec	 mov	 edx, DWORD PTR _j$3[ebp]
  000ff	52		 push	 edx
  00100	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  00104	6b c8 0c	 imul	 ecx, eax, 12
  00107	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	8d 8c 0a 1c 05
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1308]
  00111	e8 00 00 00 00	 call	 ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
  00116	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00119	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCenterCard$[ebp]
  0011d	3b c1		 cmp	 eax, ecx
  0011f	75 04		 jne	 SHORT $LN15@EstimateUs

; 2080 : 					{
; 2081 : 						bPeng = false;

  00121	c6 45 ff 00	 mov	 BYTE PTR _bPeng$9[ebp], 0
$LN15@EstimateUs:

; 2082 : 					}
; 2083 : 				}

  00125	eb b1		 jmp	 SHORT $LN5@EstimateUs
$LN6@EstimateUs:

; 2084 : 				if(bPeng)

  00127	0f b6 55 ff	 movzx	 edx, BYTE PTR _bPeng$9[ebp]
  0012b	85 d2		 test	 edx, edx
  0012d	0f 84 c6 00 00
	00		 je	 $LN16@EstimateUs

; 2085 : 				{
; 2086 : 					//碰牌判断
; 2087 : 					m_cbUserAction[i] |= m_GameLogic.EstimatePengCard(m_cbCardIndex[i], cbCenterCard);

  00133	0f b7 75 f4	 movzx	 esi, WORD PTR _i$4[ebp]
  00137	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCenterCard$[ebp]
  0013b	50		 push	 eax
  0013c	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  00140	6b d1 22	 imul	 edx, ecx, 34
  00143	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00146	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  0014d	51		 push	 ecx
  0014e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00157	e8 00 00 00 00	 call	 ?EstimatePengCard@CGameLogic@@QAEEQBEE@Z ; CGameLogic::EstimatePengCard
  0015c	0f b6 d0	 movzx	 edx, al
  0015f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00162	0f b6 8c 30 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+esi+1508]
  0016a	0b ca		 or	 ecx, edx
  0016c	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  00170	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00173	88 8c 10 e4 05
	00 00		 mov	 BYTE PTR [eax+edx+1508], cl

; 2088 : 					if (m_cbUserAction[i] & WIK_PENG)//碰牌后只剩红中则不能碰

  0017a	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  0017e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00181	0f b6 84 0a e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1508]
  00189	83 e0 08	 and	 eax, 8
  0018c	74 6b		 je	 SHORT $LN16@EstimateUs

; 2089 : 					{
; 2090 : 						BYTE cbCardCount = m_GameLogic.GetCardCount(m_cbCardIndex[i]);

  0018e	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  00192	6b d1 22	 imul	 edx, ecx, 34
  00195	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00198	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  0019f	51		 push	 ecx
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  001a9	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  001ae	88 45 fc	 mov	 BYTE PTR _cbCardCount$7[ebp], al

; 2091 : 						if (cbCardCount == (2 + m_cbCardIndex[i][31]))

  001b1	0f b6 55 fc	 movzx	 edx, BYTE PTR _cbCardCount$7[ebp]
  001b5	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  001b9	6b c8 22	 imul	 ecx, eax, 34
  001bc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001bf	8d 8c 08 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+1970]
  001c6	b8 01 00 00 00	 mov	 eax, 1
  001cb	6b c0 1f	 imul	 eax, eax, 31
  001ce	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  001d2	83 c1 02	 add	 ecx, 2
  001d5	3b d1		 cmp	 edx, ecx
  001d7	75 20		 jne	 SHORT $LN16@EstimateUs

; 2092 : 						{
; 2093 : 							m_cbUserAction[i] &= (~WIK_PENG);

  001d9	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  001dd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001e0	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  001e8	83 e1 f7	 and	 ecx, -9			; fffffff7H
  001eb	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  001ef	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001f2	88 8c 10 e4 05
	00 00		 mov	 BYTE PTR [eax+edx+1508], cl
$LN16@EstimateUs:

; 2094 : 						}
; 2095 : 					}
; 2096 : 				}
; 2097 : 
; 2098 : 				//杠牌判断
; 2099 : 				if(m_cbLeftCardCount > m_cbEndLeftCount && !m_bEnjoinGang[i]) 

  001f9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001fc	0f b6 91 b1 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1969]
  00203	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00206	0f b6 88 ae 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1966]
  0020d	3b d1		 cmp	 edx, ecx
  0020f	7e 5a		 jle	 SHORT $LN13@EstimateUs
  00211	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  00215	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00218	0f b6 8c 10 d8
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1240]
  00220	85 c9		 test	 ecx, ecx
  00222	75 47		 jne	 SHORT $LN13@EstimateUs

; 2100 : 				{
; 2101 : 					m_cbUserAction[i] |= m_GameLogic.EstimateGangCard(m_cbCardIndex[i], cbCenterCard);

  00224	0f b7 75 f4	 movzx	 esi, WORD PTR _i$4[ebp]
  00228	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCenterCard$[ebp]
  0022c	52		 push	 edx
  0022d	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  00231	6b c8 22	 imul	 ecx, eax, 34
  00234	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00237	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  0023e	50		 push	 eax
  0023f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00242	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00248	e8 00 00 00 00	 call	 ?EstimateGangCard@CGameLogic@@QAEEQBEE@Z ; CGameLogic::EstimateGangCard
  0024d	0f b6 c8	 movzx	 ecx, al
  00250	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00253	0f b6 84 32 e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+esi+1508]
  0025b	0b c1		 or	 eax, ecx
  0025d	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  00261	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00264	88 84 0a e4 05
	00 00		 mov	 BYTE PTR [edx+ecx+1508], al
$LN13@EstimateUs:

; 2102 : 				}
; 2103 : 			}
; 2104 : 		}
; 2105 : 
; 2106 : 		//检查抢杠胡
; 2107 :    		if (EstimatKind == EstimatKind_GangCard)

  0026b	83 7d 10 01	 cmp	 DWORD PTR _EstimatKind$[ebp], 1
  0026f	0f 85 35 01 00
	00		 jne	 $LN20@EstimateUs

; 2108 :    		{
; 2109 : 			//只有庄家和闲家之间才能放炮
; 2110 : 			if(m_cbMagicIndex == MAX_INDEX || (m_cbMagicIndex != MAX_INDEX && cbCenterCard != m_GameLogic.SwitchToCardData(m_cbMagicIndex)))

  00275	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00278	0f b6 88 7c 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1148]
  0027f	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00282	74 3b		 je	 SHORT $LN22@EstimateUs
  00284	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00287	0f b6 82 7c 04
	00 00		 movzx	 eax, BYTE PTR [edx+1148]
  0028e	83 f8 22	 cmp	 eax, 34			; 00000022H
  00291	0f 84 13 01 00
	00		 je	 $LN20@EstimateUs
  00297	0f b6 75 0c	 movzx	 esi, BYTE PTR _cbCenterCard$[ebp]
  0029b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	0f b6 91 7c 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1148]
  002a5	52		 push	 edx
  002a6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002a9	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  002af	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  002b4	0f b6 c0	 movzx	 eax, al
  002b7	3b f0		 cmp	 esi, eax
  002b9	0f 84 eb 00 00
	00		 je	 $LN20@EstimateUs
$LN22@EstimateUs:

; 2111 : 			{
; 2112 : 				bool bChiHu = true;

  002bf	c6 45 fe 01	 mov	 BYTE PTR _bChiHu$8[ebp], 1

; 2113 : 				for(UINT j = 0; j < m_vecEnjoinChiHu[i].size(); j++)

  002c3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$2[ebp], 0
  002ca	eb 09		 jmp	 SHORT $LN10@EstimateUs
$LN8@EstimateUs:
  002cc	8b 4d e8	 mov	 ecx, DWORD PTR _j$2[ebp]
  002cf	83 c1 01	 add	 ecx, 1
  002d2	89 4d e8	 mov	 DWORD PTR _j$2[ebp], ecx
$LN10@EstimateUs:
  002d5	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  002d9	6b c2 0c	 imul	 eax, edx, 12
  002dc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002df	8d 8c 01 ec 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1260]
  002e6	e8 00 00 00 00	 call	 ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
  002eb	39 45 e8	 cmp	 DWORD PTR _j$2[ebp], eax
  002ee	73 2d		 jae	 SHORT $LN9@EstimateUs

; 2114 : 				{
; 2115 : 					if(m_vecEnjoinChiHu[i][j] == cbCenterCard)

  002f0	8b 55 e8	 mov	 edx, DWORD PTR _j$2[ebp]
  002f3	52		 push	 edx
  002f4	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  002f8	6b c8 0c	 imul	 ecx, eax, 12
  002fb	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  002fe	8d 8c 0a ec 04
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1260]
  00305	e8 00 00 00 00	 call	 ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
  0030a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0030d	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCenterCard$[ebp]
  00311	3b c1		 cmp	 eax, ecx
  00313	75 06		 jne	 SHORT $LN23@EstimateUs

; 2116 : 					{
; 2117 : 						bChiHu = false;

  00315	c6 45 fe 00	 mov	 BYTE PTR _bChiHu$8[ebp], 0

; 2118 : 						break;

  00319	eb 02		 jmp	 SHORT $LN9@EstimateUs
$LN23@EstimateUs:

; 2119 : 					}
; 2120 : 				}

  0031b	eb af		 jmp	 SHORT $LN8@EstimateUs
$LN9@EstimateUs:

; 2121 : 				if(bChiHu)

  0031d	0f b6 55 fe	 movzx	 edx, BYTE PTR _bChiHu$8[ebp]
  00321	85 d2		 test	 edx, edx
  00323	0f 84 81 00 00
	00		 je	 $LN20@EstimateUs

; 2122 : 				{
; 2123 : 					//吃胡判断
; 2124 : 					CChiHuRight chr;

  00329	8d 4d e4	 lea	 ecx, DWORD PTR _chr$1[ebp]
  0032c	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 2125 : 					BYTE cbWeaveCount = m_cbWeaveItemCount[i];

  00331	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  00335	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00338	8a 94 01 3e 08
	00 00		 mov	 dl, BYTE PTR [ecx+eax+2110]
  0033f	88 55 fb	 mov	 BYTE PTR _cbWeaveCount$6[ebp], dl

; 2126 : 					BYTE cbAction = m_GameLogic.AnalyseChiHuCard(m_cbCardIndex[i], m_WeaveItemArray[i], cbWeaveCount, cbCenterCard, chr);

  00342	6a 00		 push	 0
  00344	8d 45 e4	 lea	 eax, DWORD PTR _chr$1[ebp]
  00347	50		 push	 eax
  00348	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCenterCard$[ebp]
  0034c	51		 push	 ecx
  0034d	0f b6 55 fb	 movzx	 edx, BYTE PTR _cbWeaveCount$6[ebp]
  00351	52		 push	 edx
  00352	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  00356	6b c8 24	 imul	 ecx, eax, 36
  00359	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0035c	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  00363	50		 push	 eax
  00364	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$4[ebp]
  00368	6b d1 22	 imul	 edx, ecx, 34
  0036b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0036e	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  00375	51		 push	 ecx
  00376	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00379	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0037f	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  00384	88 45 fa	 mov	 BYTE PTR _cbAction$5[ebp], al

; 2127 : 					m_cbUserAction[i] |= cbAction;

  00387	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  0038b	0f b6 45 fa	 movzx	 eax, BYTE PTR _cbAction$5[ebp]
  0038f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00392	0f b6 94 11 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+edx+1508]
  0039a	0b d0		 or	 edx, eax
  0039c	0f b7 45 f4	 movzx	 eax, WORD PTR _i$4[ebp]
  003a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003a3	88 94 01 e4 05
	00 00		 mov	 BYTE PTR [ecx+eax+1508], dl
$LN20@EstimateUs:

; 2128 : 				}
; 2129 : 			}
; 2130 :    		}
; 2131 : 
; 2132 : 		//结果判断
; 2133 : 		if (m_cbUserAction[i] != WIK_NULL) 

  003aa	0f b7 55 f4	 movzx	 edx, WORD PTR _i$4[ebp]
  003ae	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  003b1	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  003b9	85 c9		 test	 ecx, ecx
  003bb	74 04		 je	 SHORT $LN25@EstimateUs

; 2134 : 			bAroseAction = true;

  003bd	c6 45 fd 01	 mov	 BYTE PTR _bAroseAction$[ebp], 1
$LN25@EstimateUs:

; 2135 : 	}

  003c1	e9 91 fc ff ff	 jmp	 $LN2@EstimateUs
$LN3@EstimateUs:

; 2136 : 
; 2137 : 	//结果处理
; 2138 : 	if (bAroseAction) 

  003c6	0f b6 55 fd	 movzx	 edx, BYTE PTR _bAroseAction$[ebp]
  003ca	85 d2		 test	 edx, edx
  003cc	74 49		 je	 SHORT $LN26@EstimateUs

; 2139 : 	{
; 2140 : 		//设置变量
; 2141 : 		m_wProvideUser = wCenterUser;

  003ce	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  003d1	66 8b 4d 08	 mov	 cx, WORD PTR _wCenterUser$[ebp]
  003d5	66 89 88 c0 04
	00 00		 mov	 WORD PTR [eax+1216], cx

; 2142 : 		m_cbProvideCard = cbCenterCard;

  003dc	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  003df	8a 45 0c	 mov	 al, BYTE PTR _cbCenterCard$[ebp]
  003e2	88 82 c2 04 00
	00		 mov	 BYTE PTR [edx+1218], al

; 2143 : 		m_wResumeUser = m_wCurrentUser;

  003e8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003eb	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  003ee	66 8b 82 be 04
	00 00		 mov	 ax, WORD PTR [edx+1214]
  003f5	66 89 81 bc 04
	00 00		 mov	 WORD PTR [ecx+1212], ax

; 2144 : 		m_wCurrentUser = INVALID_CHAIR;

  003fc	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00401	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00404	66 89 8a be 04
	00 00		 mov	 WORD PTR [edx+1214], cx

; 2145 : 
; 2146 : 		//发送提示
; 2147 : 		SendOperateNotify();

  0040b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0040e	e8 00 00 00 00	 call	 ?SendOperateNotify@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::SendOperateNotify

; 2148 : 
; 2149 : 		return true;

  00413	b0 01		 mov	 al, 1
  00415	eb 02		 jmp	 SHORT $LN1@EstimateUs
$LN26@EstimateUs:

; 2150 : 	}
; 2151 : 
; 2152 : 	return false;

  00417	32 c0		 xor	 al, al
$LN1@EstimateUs:

; 2153 : }

  00419	5e		 pop	 esi
  0041a	8b e5		 mov	 esp, ebp
  0041c	5d		 pop	 ebp
  0041d	c2 0c 00	 ret	 12			; 0000000cH
?EstimateUserRespond@CTableFrameSink@@IAE_NGEW4enEstimatKind@@@Z ENDP ; CTableFrameSink::EstimateUserRespond
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_chr$ = -884						; size = 4
tv304 = -880						; size = 4
tv254 = -876						; size = 4
tv224 = -872						; size = 4
tv156 = -868						; size = 4
_cbOperateCard$1 = -864					; size = 3
_j$2 = -860						; size = 4
_i$3 = -856						; size = 4
_cbCount$ = -849					; size = 1
_wCurrentUser$ = -848					; size = 2
_this$ = -844						; size = 4
_HuData$ = -840						; size = 813
_GangCardResult$4 = -24					; size = 5
_SendCard$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_wSendCardUser$ = 8					; size = 2
_bTail$ = 12						; size = 1
?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z PROC	; CTableFrameSink::DispatchCardData
; _this$ = ecx

; 1916 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 03 00
	00		 sub	 esp, 884		; 00000374H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	89 8d b4 fc ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1917 : 	//状态效验
; 1918 : 	ASSERT(wSendCardUser != INVALID_CHAIR);
; 1919 : 	if (wSendCardUser == INVALID_CHAIR) return false;

  0001a	0f b7 45 08	 movzx	 eax, WORD PTR _wSendCardUser$[ebp]
  0001e	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00023	75 07		 jne	 SHORT $LN8@DispatchCa
  00025	32 c0		 xor	 al, al
  00027	e9 bd 09 00 00	 jmp	 $LN1@DispatchCa
$LN8@DispatchCa:

; 1920 : 
; 1921 : 	ASSERT(m_enSendStatus != Not_Send);
; 1922 : 	if(m_enSendStatus == Not_Send) return false;

  0002c	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 b9 c8 04 00
	00 00		 cmp	 DWORD PTR [ecx+1224], 0
  00039	75 07		 jne	 SHORT $LN9@DispatchCa
  0003b	32 c0		 xor	 al, al
  0003d	e9 a7 09 00 00	 jmp	 $LN1@DispatchCa
$LN9@DispatchCa:

; 1923 : 
; 1924 : 	WORD wCurrentUser = wSendCardUser;

  00042	66 8b 55 08	 mov	 dx, WORD PTR _wSendCardUser$[ebp]
  00046	66 89 95 b0 fc
	ff ff		 mov	 WORD PTR _wCurrentUser$[ebp], dx

; 1925 : 
; 1926 : 	//丢弃扑克
; 1927 : 	if ((m_wOutCardUser != INVALID_CHAIR) && (m_cbOutCardData != 0))

  0004d	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00053	0f b7 88 44 06
	00 00		 movzx	 ecx, WORD PTR [eax+1604]
  0005a	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00060	0f 84 ae 00 00
	00		 je	 $LN10@DispatchCa
  00066	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0006c	0f b6 82 46 06
	00 00		 movzx	 eax, BYTE PTR [edx+1606]
  00073	85 c0		 test	 eax, eax
  00075	0f 84 99 00 00
	00		 je	 $LN10@DispatchCa

; 1928 : 	{
; 1929 : 		m_cbOutCardCount++;

  0007b	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8a 91 47 06 00
	00		 mov	 dl, BYTE PTR [ecx+1607]
  00087	80 c2 01	 add	 dl, 1
  0008a	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00090	88 90 47 06 00
	00		 mov	 BYTE PTR [eax+1607], dl

; 1930 : 		m_cbDiscardCard[m_wOutCardUser][m_cbDiscardCount[m_wOutCardUser]] = m_cbOutCardData;

  00096	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	0f b7 91 44 06
	00 00		 movzx	 edx, WORD PTR [ecx+1604]
  000a3	6b c2 3c	 imul	 eax, edx, 60
  000a6	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	8d 94 01 4c 06
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1612]
  000b3	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b9	0f b7 88 44 06
	00 00		 movzx	 ecx, WORD PTR [eax+1604]
  000c0	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000c6	0f b6 8c 08 48
	06 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+1608]
  000ce	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8a 80 46 06 00
	00		 mov	 al, BYTE PTR [eax+1606]
  000da	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1931 : 		m_cbDiscardCount[m_wOutCardUser]++;

  000dd	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	0f b7 91 44 06
	00 00		 movzx	 edx, WORD PTR [ecx+1604]
  000ea	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8a 8c 10 48 06
	00 00		 mov	 cl, BYTE PTR [eax+edx+1608]
  000f7	80 c1 01	 add	 cl, 1
  000fa	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00100	0f b7 82 44 06
	00 00		 movzx	 eax, WORD PTR [edx+1604]
  00107	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0010d	88 8c 02 48 06
	00 00		 mov	 BYTE PTR [edx+eax+1608], cl
$LN10@DispatchCa:

; 1932 : 	}
; 1933 : 
; 1934 : 	//荒庄结束
; 1935 : 	if (m_cbLeftCardCount <= (m_cbMaCount>1?m_cbMaCount+1:m_cbMaCount) )//2-6码要多留一颗，一码全中不用

  00114	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011a	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0011e	83 f9 01	 cmp	 ecx, 1
  00121	7e 15		 jle	 SHORT $LN24@DispatchCa
  00123	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00129	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  0012d	83 c0 01	 add	 eax, 1
  00130	89 85 9c fc ff
	ff		 mov	 DWORD PTR tv156[ebp], eax
  00136	eb 10		 jmp	 SHORT $LN25@DispatchCa
$LN24@DispatchCa:
  00138	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0013e	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00142	89 95 9c fc ff
	ff		 mov	 DWORD PTR tv156[ebp], edx
$LN25@DispatchCa:
  00148	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0014e	0f b6 88 b1 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1969]
  00155	3b 8d 9c fc ff
	ff		 cmp	 ecx, DWORD PTR tv156[ebp]
  0015b	7f 5b		 jg	 SHORT $LN11@DispatchCa

; 1936 : 	{
; 1937 : 		WriteDebugInfo(_T("荒庄"));

  0015d	68 00 00 00 00	 push	 OFFSET $SG314205
  00162	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00168	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1938 : 		m_cbChiHuCard = 0;

  0016d	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00173	c6 82 18 06 00
	00 00		 mov	 BYTE PTR [edx+1560], 0

; 1939 : 		m_wProvideUser = INVALID_CHAIR;

  0017a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0017f	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00185	66 89 81 c0 04
	00 00		 mov	 WORD PTR [ecx+1216], ax

; 1940 : 		OnEventGameConclude(m_wProvideUser, NULL, GER_NORMAL);

  0018c	6a 00		 push	 0
  0018e	6a 00		 push	 0
  00190	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00196	0f b7 82 c0 04
	00 00		 movzx	 eax, WORD PTR [edx+1216]
  0019d	50		 push	 eax
  0019e	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a6	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  001af	ff d0		 call	 eax

; 1941 : 
; 1942 : 		return true;

  001b1	b0 01		 mov	 al, 1
  001b3	e9 31 08 00 00	 jmp	 $LN1@DispatchCa
$LN11@DispatchCa:

; 1943 : 	}
; 1944 : 
; 1945 : 	//发送扑克
; 1946 : 	m_cbProvideCard = GetSendCard(bTail);	

  001b8	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bTail$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	e8 00 00 00 00	 call	 ?GetSendCard@CTableFrameSink@@IAEE_N@Z ; CTableFrameSink::GetSendCard
  001c8	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ce	88 82 c2 04 00
	00		 mov	 BYTE PTR [edx+1218], al

; 1947 : 	m_cbSendCardData = m_cbProvideCard;

  001d4	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001da	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	8a 91 c2 04 00
	00		 mov	 dl, BYTE PTR [ecx+1218]
  001e6	88 90 3c 07 00
	00		 mov	 BYTE PTR [eax+1852], dl

; 1948 : 	m_wLastCatchCardUser = wSendCardUser;

  001ec	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001f2	66 8b 4d 08	 mov	 cx, WORD PTR _wSendCardUser$[ebp]
  001f6	66 89 88 c4 04
	00 00		 mov	 WORD PTR [eax+1220], cx

; 1949 : 
; 1950 : 	//清除禁止胡牌的牌
; 1951 : 	m_bEnjoinChiHu[wCurrentUser] = false;

  001fd	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  00204	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0020a	c6 84 10 d0 04
	00 00 00	 mov	 BYTE PTR [eax+edx+1232], 0

; 1952 : 	m_vecEnjoinChiHu[wCurrentUser].clear();

  00212	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  00219	6b d1 0c	 imul	 edx, ecx, 12
  0021c	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00222	8d 8c 10 ec 04
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1260]
  00229	e8 00 00 00 00	 call	 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear

; 1953 : 	m_bEnjoinChiPeng[wCurrentUser] = false;		

  0022e	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  00235	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0023b	c6 84 0a d4 04
	00 00 00	 mov	 BYTE PTR [edx+ecx+1236], 0

; 1954 : 	m_vecEnjoinChiPeng[wCurrentUser].clear();

  00243	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _wCurrentUser$[ebp]
  0024a	6b c8 0c	 imul	 ecx, eax, 12
  0024d	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00253	8d 8c 0a 1c 05
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1308]
  0025a	e8 00 00 00 00	 call	 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear

; 1955 : 	m_bEnjoinGang[wCurrentUser] = false;

  0025f	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _wCurrentUser$[ebp]
  00266	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0026c	c6 84 01 d8 04
	00 00 00	 mov	 BYTE PTR [ecx+eax+1240], 0

; 1956 : 	
; 1957 : 	//设置变量	
; 1958 : 	m_wOutCardUser = INVALID_CHAIR;

  00274	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00279	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0027f	66 89 90 44 06
	00 00		 mov	 WORD PTR [eax+1604], dx

; 1959 : 	m_cbOutCardData = 0;	

  00286	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0028c	c6 81 46 06 00
	00 00		 mov	 BYTE PTR [ecx+1606], 0

; 1960 : 	m_wCurrentUser = wCurrentUser;

  00293	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00299	66 8b 85 b0 fc
	ff ff		 mov	 ax, WORD PTR _wCurrentUser$[ebp]
  002a0	66 89 82 be 04
	00 00		 mov	 WORD PTR [edx+1214], ax

; 1961 : 	m_wProvideUser = wCurrentUser;		

  002a7	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ad	66 8b 95 b0 fc
	ff ff		 mov	 dx, WORD PTR _wCurrentUser$[ebp]
  002b4	66 89 91 c0 04
	00 00		 mov	 WORD PTR [ecx+1216], dx

; 1962 : 	m_bGangOutCard = false;

  002bb	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002c1	c6 80 c6 04 00
	00 00		 mov	 BYTE PTR [eax+1222], 0

; 1963 : 	
; 1964 : 	if(bTail)//从尾部取牌，说明玩家杠牌了,计算分数

  002c8	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bTail$[ebp]
  002cc	85 c9		 test	 ecx, ecx
  002ce	74 0b		 je	 SHORT $LN12@DispatchCa

; 1965 : 	{
; 1966 : 		CalGangScore();

  002d0	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	e8 00 00 00 00	 call	 ?CalGangScore@CTableFrameSink@@IAEXXZ ; CTableFrameSink::CalGangScore
$LN12@DispatchCa:

; 1967 : 	}
; 1968 : 
; 1969 : 	//加牌
; 1970 : 	m_cbCardIndex[wCurrentUser][m_GameLogic.SwitchToCardIndex(m_cbProvideCard)]++;

  002db	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  002e2	6b c2 22	 imul	 eax, edx, 34
  002e5	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002eb	8d b4 01 b2 07
	00 00		 lea	 esi, DWORD PTR [ecx+eax+1970]
  002f2	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002f8	0f b6 82 c2 04
	00 00		 movzx	 eax, BYTE PTR [edx+1218]
  002ff	50		 push	 eax
  00300	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00306	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0030c	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00311	0f b6 c8	 movzx	 ecx, al
  00314	03 f1		 add	 esi, ecx
  00316	89 b5 98 fc ff
	ff		 mov	 DWORD PTR tv224[ebp], esi
  0031c	8b 95 98 fc ff
	ff		 mov	 edx, DWORD PTR tv224[ebp]
  00322	8a 02		 mov	 al, BYTE PTR [edx]
  00324	04 01		 add	 al, 1
  00326	8b 8d 98 fc ff
	ff		 mov	 ecx, DWORD PTR tv224[ebp]
  0032c	88 01		 mov	 BYTE PTR [ecx], al

; 1971 : 	m_cbUserCatchCardCount[wCurrentUser]++;

  0032e	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  00335	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0033b	8a 8c 10 4c 05
	00 00		 mov	 cl, BYTE PTR [eax+edx+1356]
  00342	80 c1 01	 add	 cl, 1
  00345	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  0034c	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00352	88 8c 10 4c 05
	00 00		 mov	 BYTE PTR [eax+edx+1356], cl

; 1972 : 
; 1973 : 	//胡牌判断
; 1974 : 	CChiHuRight chr;

  00359	8d 8d 8c fc ff
	ff		 lea	 ecx, DWORD PTR _chr$[ebp]
  0035f	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 1975 : 	m_cbCardIndex[wCurrentUser][m_GameLogic.SwitchToCardIndex(m_cbSendCardData)]--;

  00364	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  0036b	6b d1 22	 imul	 edx, ecx, 34
  0036e	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00374	8d b4 10 b2 07
	00 00		 lea	 esi, DWORD PTR [eax+edx+1970]
  0037b	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00381	0f b6 91 3c 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1852]
  00388	52		 push	 edx
  00389	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0038f	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00395	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  0039a	0f b6 c0	 movzx	 eax, al
  0039d	03 f0		 add	 esi, eax
  0039f	89 b5 94 fc ff
	ff		 mov	 DWORD PTR tv254[ebp], esi
  003a5	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR tv254[ebp]
  003ab	8a 11		 mov	 dl, BYTE PTR [ecx]
  003ad	80 ea 01	 sub	 dl, 1
  003b0	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR tv254[ebp]
  003b6	88 10		 mov	 BYTE PTR [eax], dl

; 1976 : 	m_cbUserAction[wCurrentUser] |= m_GameLogic.AnalyseChiHuCard(m_cbCardIndex[wCurrentUser], m_WeaveItemArray[wCurrentUser],m_cbWeaveItemCount[wCurrentUser], m_cbSendCardData, chr);

  003b8	0f b7 b5 b0 fc
	ff ff		 movzx	 esi, WORD PTR _wCurrentUser$[ebp]
  003bf	6a 00		 push	 0
  003c1	8d 8d 8c fc ff
	ff		 lea	 ecx, DWORD PTR _chr$[ebp]
  003c7	51		 push	 ecx
  003c8	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003ce	0f b6 82 3c 07
	00 00		 movzx	 eax, BYTE PTR [edx+1852]
  003d5	50		 push	 eax
  003d6	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  003dd	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003e3	0f b6 84 0a 3e
	08 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2110]
  003eb	50		 push	 eax
  003ec	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  003f3	6b d1 24	 imul	 edx, ecx, 36
  003f6	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003fc	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  00403	51		 push	 ecx
  00404	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  0040b	6b c2 22	 imul	 eax, edx, 34
  0040e	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00414	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  0041b	52		 push	 edx
  0041c	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00422	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00428	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  0042d	0f b6 c0	 movzx	 eax, al
  00430	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00436	0f b6 94 31 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+esi+1508]
  0043e	0b d0		 or	 edx, eax
  00440	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _wCurrentUser$[ebp]
  00447	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0044d	88 94 01 e4 05
	00 00		 mov	 BYTE PTR [ecx+eax+1508], dl

; 1977 : 	m_cbCardIndex[wCurrentUser][m_GameLogic.SwitchToCardIndex(m_cbSendCardData)]++;

  00454	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  0045b	6b c2 22	 imul	 eax, edx, 34
  0045e	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00464	8d b4 01 b2 07
	00 00		 lea	 esi, DWORD PTR [ecx+eax+1970]
  0046b	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00471	0f b6 82 3c 07
	00 00		 movzx	 eax, BYTE PTR [edx+1852]
  00478	50		 push	 eax
  00479	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0047f	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00485	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  0048a	0f b6 c8	 movzx	 ecx, al
  0048d	03 f1		 add	 esi, ecx
  0048f	89 b5 90 fc ff
	ff		 mov	 DWORD PTR tv304[ebp], esi
  00495	8b 95 90 fc ff
	ff		 mov	 edx, DWORD PTR tv304[ebp]
  0049b	8a 02		 mov	 al, BYTE PTR [edx]
  0049d	04 01		 add	 al, 1
  0049f	8b 8d 90 fc ff
	ff		 mov	 ecx, DWORD PTR tv304[ebp]
  004a5	88 01		 mov	 BYTE PTR [ecx], al

; 1978 : 
; 1979 : 	//杠牌判断
; 1980 : 	if ((!m_bEnjoinGang[wCurrentUser]) && (m_cbLeftCardCount > m_cbEndLeftCount) && !m_bTing[wCurrentUser])

  004a7	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  004ae	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004b4	0f b6 8c 10 d8
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1240]
  004bc	85 c9		 test	 ecx, ecx
  004be	0f 85 d6 00 00
	00		 jne	 $LN13@DispatchCa
  004c4	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004ca	0f b6 82 b1 07
	00 00		 movzx	 eax, BYTE PTR [edx+1969]
  004d1	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004d7	0f b6 91 ae 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1966]
  004de	3b c2		 cmp	 eax, edx
  004e0	0f 8e b4 00 00
	00		 jle	 $LN13@DispatchCa
  004e6	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _wCurrentUser$[ebp]
  004ed	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004f3	0f b6 94 01 74
	04 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1140]
  004fb	85 d2		 test	 edx, edx
  004fd	0f 85 97 00 00
	00		 jne	 $LN13@DispatchCa

; 1981 : 	{
; 1982 : 		tagGangCardResult GangCardResult;
; 1983 : 		m_cbUserAction[wCurrentUser] |= m_GameLogic.AnalyseGangCardEx(m_cbCardIndex[wCurrentUser],m_WeaveItemArray[wCurrentUser], m_cbWeaveItemCount[wCurrentUser],m_cbProvideCard ,GangCardResult);

  00503	0f b7 b5 b0 fc
	ff ff		 movzx	 esi, WORD PTR _wCurrentUser$[ebp]
  0050a	8d 45 e8	 lea	 eax, DWORD PTR _GangCardResult$4[ebp]
  0050d	50		 push	 eax
  0050e	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00514	0f b6 91 c2 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1218]
  0051b	52		 push	 edx
  0051c	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _wCurrentUser$[ebp]
  00523	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00529	0f b6 94 01 3e
	08 00 00	 movzx	 edx, BYTE PTR [ecx+eax+2110]
  00531	52		 push	 edx
  00532	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _wCurrentUser$[ebp]
  00539	6b c8 24	 imul	 ecx, eax, 36
  0053c	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00542	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  00549	50		 push	 eax
  0054a	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  00551	6b d1 22	 imul	 edx, ecx, 34
  00554	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0055a	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  00561	51		 push	 ecx
  00562	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00568	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0056e	e8 00 00 00 00	 call	 ?AnalyseGangCardEx@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAUtagGangCardResult@@@Z ; CGameLogic::AnalyseGangCardEx
  00573	0f b6 d0	 movzx	 edx, al
  00576	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0057c	0f b6 8c 30 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+esi+1508]
  00584	0b ca		 or	 ecx, edx
  00586	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  0058d	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00593	88 8c 10 e4 05
	00 00		 mov	 BYTE PTR [eax+edx+1508], cl
$LN13@DispatchCa:

; 1984 : 	}
; 1985 : 
; 1986 : 	//构造数据
; 1987 : 	CMD_S_SendCard SendCard;
; 1988 : 	ZeroMemory(&SendCard,sizeof(SendCard));

  0059a	6a 09		 push	 9
  0059c	6a 00		 push	 0
  0059e	8d 4d f0	 lea	 ecx, DWORD PTR _SendCard$[ebp]
  005a1	51		 push	 ecx
  005a2	e8 00 00 00 00	 call	 _memset
  005a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1989 : 
; 1990 : 	//听牌判断
; 1991 : 	CMD_S_Hu_Data HuData;
; 1992 : 	ZeroMemory(&HuData,sizeof(HuData));

  005aa	68 2d 03 00 00	 push	 813			; 0000032dH
  005af	6a 00		 push	 0
  005b1	8d 95 b8 fc ff
	ff		 lea	 edx, DWORD PTR _HuData$[ebp]
  005b7	52		 push	 edx
  005b8	e8 00 00 00 00	 call	 _memset
  005bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1993 : 
; 1994 : 	BYTE cbCount = 0;

  005c0	c6 85 af fc ff
	ff 00		 mov	 BYTE PTR _cbCount$[ebp], 0

; 1995 : 	if(m_bTing[wCurrentUser] == false)

  005c7	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _wCurrentUser$[ebp]
  005ce	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005d4	0f b6 94 01 74
	04 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1140]
  005dc	85 d2		 test	 edx, edx
  005de	0f 85 aa 01 00
	00		 jne	 $LN14@DispatchCa

; 1996 : 	{
; 1997 : 		cbCount =m_GameLogic.AnalyseTingCard(m_cbCardIndex[wCurrentUser],m_WeaveItemArray[wCurrentUser],m_cbWeaveItemCount[wCurrentUser],HuData.cbOutCardCount,HuData.cbOutCardData,HuData.cbHuCardCount,HuData.cbHuCardData);

  005e4	8d 85 d5 fc ff
	ff		 lea	 eax, DWORD PTR _HuData$[ebp+29]
  005ea	50		 push	 eax
  005eb	8d 8d c7 fc ff
	ff		 lea	 ecx, DWORD PTR _HuData$[ebp+15]
  005f1	51		 push	 ecx
  005f2	8d 95 b9 fc ff
	ff		 lea	 edx, DWORD PTR _HuData$[ebp+1]
  005f8	52		 push	 edx
  005f9	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _HuData$[ebp]
  005ff	50		 push	 eax
  00600	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  00607	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0060d	0f b6 84 0a 3e
	08 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2110]
  00615	50		 push	 eax
  00616	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  0061d	6b d1 24	 imul	 edx, ecx, 36
  00620	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00626	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  0062d	51		 push	 ecx
  0062e	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  00635	6b c2 22	 imul	 eax, edx, 34
  00638	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0063e	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00645	52		 push	 edx
  00646	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0064c	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00652	e8 00 00 00 00	 call	 ?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z ; CGameLogic::AnalyseTingCard
  00657	88 85 af fc ff
	ff		 mov	 BYTE PTR _cbCount$[ebp], al

; 1998 : 		if(cbCount >0)

  0065d	0f b6 85 af fc
	ff ff		 movzx	 eax, BYTE PTR _cbCount$[ebp]
  00664	85 c0		 test	 eax, eax
  00666	0f 8e 22 01 00
	00		 jle	 $LN14@DispatchCa

; 1999 : 		{
; 2000 : 			m_cbUserAction[wCurrentUser] |= WIK_LISTEN; 

  0066c	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  00673	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00679	0f b6 84 0a e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1508]
  00681	83 c8 20	 or	 eax, 32			; 00000020H
  00684	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  0068b	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00691	88 84 0a e4 05
	00 00		 mov	 BYTE PTR [edx+ecx+1508], al

; 2001 : 			
; 2002 : 			for(int i=0;i<MAX_COUNT;i++)

  00698	c7 85 a8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$3[ebp], 0
  006a2	eb 0f		 jmp	 SHORT $LN4@DispatchCa
$LN2@DispatchCa:
  006a4	8b 85 a8 fc ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  006aa	83 c0 01	 add	 eax, 1
  006ad	89 85 a8 fc ff
	ff		 mov	 DWORD PTR _i$3[ebp], eax
$LN4@DispatchCa:
  006b3	83 bd a8 fc ff
	ff 0e		 cmp	 DWORD PTR _i$3[ebp], 14	; 0000000eH
  006ba	0f 8d 91 00 00
	00		 jge	 $LN3@DispatchCa

; 2003 : 			{
; 2004 : 				if(HuData.cbHuCardCount[i]>0)

  006c0	8b 8d a8 fc ff
	ff		 mov	 ecx, DWORD PTR _i$3[ebp]
  006c6	0f b6 94 0d c7
	fc ff ff	 movzx	 edx, BYTE PTR _HuData$[ebp+ecx+15]
  006ce	85 d2		 test	 edx, edx
  006d0	7e 78		 jle	 SHORT $LN16@DispatchCa

; 2005 : 				{
; 2006 : 					for(int j=0;j<HuData.cbHuCardCount[i];j++)

  006d2	c7 85 a4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$2[ebp], 0
  006dc	eb 0f		 jmp	 SHORT $LN7@DispatchCa
$LN5@DispatchCa:
  006de	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  006e4	83 c0 01	 add	 eax, 1
  006e7	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax
$LN7@DispatchCa:
  006ed	8b 8d a8 fc ff
	ff		 mov	 ecx, DWORD PTR _i$3[ebp]
  006f3	0f b6 94 0d c7
	fc ff ff	 movzx	 edx, BYTE PTR _HuData$[ebp+ecx+15]
  006fb	39 95 a4 fc ff
	ff		 cmp	 DWORD PTR _j$2[ebp], edx
  00701	7d 45		 jge	 SHORT $LN6@DispatchCa

; 2007 : 					{
; 2008 : 						HuData.cbHuCardRemainingCount[i][j] = GetRemainingCount(wCurrentUser,HuData.cbHuCardData[i][j]);

  00703	6b 85 a8 fc ff
	ff 1c		 imul	 eax, DWORD PTR _i$3[ebp], 28
  0070a	8d 8c 05 d5 fc
	ff ff		 lea	 ecx, DWORD PTR _HuData$[ebp+eax+29]
  00711	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _j$2[ebp]
  00717	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  0071b	50		 push	 eax
  0071c	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  00723	51		 push	 ecx
  00724	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0072a	e8 00 00 00 00	 call	 ?GetRemainingCount@CTableFrameSink@@IAEEGE@Z ; CTableFrameSink::GetRemainingCount
  0072f	6b 95 a8 fc ff
	ff 1c		 imul	 edx, DWORD PTR _i$3[ebp], 28
  00736	8d 8c 15 5d fe
	ff ff		 lea	 ecx, DWORD PTR _HuData$[ebp+edx+421]
  0073d	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _j$2[ebp]
  00743	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 2009 : 					}

  00746	eb 96		 jmp	 SHORT $LN5@DispatchCa
$LN6@DispatchCa:

; 2010 : 				}
; 2011 : 				else

  00748	eb 02		 jmp	 SHORT $LN17@DispatchCa
$LN16@DispatchCa:

; 2012 : 					break;

  0074a	eb 05		 jmp	 SHORT $LN3@DispatchCa
$LN17@DispatchCa:

; 2013 : 			}

  0074c	e9 53 ff ff ff	 jmp	 $LN2@DispatchCa
$LN3@DispatchCa:

; 2014 : 			m_pITableFrame->SendTableData(wCurrentUser,SUB_S_HU_CARD,&HuData,sizeof(HuData));

  00751	68 c8 00 00 00	 push	 200			; 000000c8H
  00756	68 2d 03 00 00	 push	 813			; 0000032dH
  0075b	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _HuData$[ebp]
  00761	50		 push	 eax
  00762	6a 6e		 push	 110			; 0000006eH
  00764	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  0076b	51		 push	 ecx
  0076c	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00772	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00778	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0077e	8b 10		 mov	 edx, DWORD PTR [eax]
  00780	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00786	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  0078c	ff d0		 call	 eax
$LN14@DispatchCa:

; 2015 : 		}
; 2016 : 	}
; 2017 : 
; 2018 : 
; 2019 : 	SendCard.wSendCardUser = wSendCardUser;

  0078e	66 8b 4d 08	 mov	 cx, WORD PTR _wSendCardUser$[ebp]
  00792	66 89 4d f4	 mov	 WORD PTR _SendCard$[ebp+4], cx

; 2020 : 	SendCard.wCurrentUser = wCurrentUser;

  00796	66 8b 95 b0 fc
	ff ff		 mov	 dx, WORD PTR _wCurrentUser$[ebp]
  0079d	66 89 55 f2	 mov	 WORD PTR _SendCard$[ebp+2], dx

; 2021 : 	SendCard.bTail = bTail;

  007a1	8a 45 0c	 mov	 al, BYTE PTR _bTail$[ebp]
  007a4	88 45 f8	 mov	 BYTE PTR _SendCard$[ebp+8], al

; 2022 : 	SendCard.cbActionMask = m_cbUserAction[wCurrentUser];

  007a7	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  007ae	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007b4	8a 84 0a e4 05
	00 00		 mov	 al, BYTE PTR [edx+ecx+1508]
  007bb	88 45 f1	 mov	 BYTE PTR _SendCard$[ebp+1], al

; 2023 : 	SendCard.cbCardData = m_cbProvideCard;

  007be	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007c4	8a 91 c2 04 00
	00		 mov	 dl, BYTE PTR [ecx+1218]
  007ca	88 55 f0	 mov	 BYTE PTR _SendCard$[ebp], dl

; 2024 : 	
; 2025 : 	//发送数据
; 2026 : 	m_pITableFrame->SendTableData(INVALID_CHAIR,SUB_S_SEND_CARD, &SendCard, sizeof(SendCard));

  007cd	68 c8 00 00 00	 push	 200			; 000000c8H
  007d2	6a 09		 push	 9
  007d4	8d 45 f0	 lea	 eax, DWORD PTR _SendCard$[ebp]
  007d7	50		 push	 eax
  007d8	6a 66		 push	 102			; 00000066H
  007da	68 ff ff 00 00	 push	 65535			; 0000ffffH
  007df	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007e5	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  007eb	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007f1	8b 12		 mov	 edx, DWORD PTR [edx]
  007f3	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  007f9	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  007ff	ff d0		 call	 eax

; 2027 : 	m_pITableFrame->SendLookonData(INVALID_CHAIR,SUB_S_SEND_CARD, &SendCard, sizeof(SendCard));

  00801	6a 09		 push	 9
  00803	8d 4d f0	 lea	 ecx, DWORD PTR _SendCard$[ebp]
  00806	51		 push	 ecx
  00807	6a 66		 push	 102			; 00000066H
  00809	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0080e	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00814	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  0081a	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00820	8b 10		 mov	 edx, DWORD PTR [eax]
  00822	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00828	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  0082e	ff d0		 call	 eax

; 2028 : 
; 2029 : 	if(m_pGameVideo)

  00830	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00836	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  0083d	74 2d		 je	 SHORT $LN18@DispatchCa

; 2030 : 	{
; 2031 : 		m_pGameVideo->AddVideoData(SUB_S_SEND_CARD,&SendCard,sizeof(SendCard),true);

  0083f	6a 01		 push	 1
  00841	6a 09		 push	 9
  00843	8d 55 f0	 lea	 edx, DWORD PTR _SendCard$[ebp]
  00846	52		 push	 edx
  00847	6a 66		 push	 102			; 00000066H
  00849	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0084f	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  00855	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0085b	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00861	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00863	50		 push	 eax
  00864	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00867	ff d2		 call	 edx
  00869	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@DispatchCa:

; 2032 : 	}
; 2033 : 
; 2034 : 	if (m_cbProvideCard == 0x35 && (m_cbUserAction[wCurrentUser] & WIK_CHI_HU))//只剩两个红中自动胡牌

  0086c	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00872	0f b6 88 c2 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1218]
  00879	83 f9 35	 cmp	 ecx, 53			; 00000035H
  0087c	0f 85 ad 00 00
	00		 jne	 $LN19@DispatchCa
  00882	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  00889	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0088f	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  00897	83 e1 40	 and	 ecx, 64			; 00000040H
  0089a	0f 84 8f 00 00
	00		 je	 $LN19@DispatchCa

; 2035 : 	{
; 2036 : 		if (m_GameLogic.GetCardCount(m_cbCardIndex[wCurrentUser]) == m_cbCardIndex[wCurrentUser][31])

  008a0	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  008a7	6b c2 22	 imul	 eax, edx, 34
  008aa	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008b0	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  008b7	52		 push	 edx
  008b8	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008be	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  008c4	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  008c9	0f b6 c0	 movzx	 eax, al
  008cc	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  008d3	6b d1 22	 imul	 edx, ecx, 34
  008d6	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008dc	8d 94 11 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+edx+1970]
  008e3	b9 01 00 00 00	 mov	 ecx, 1
  008e8	6b c9 1f	 imul	 ecx, ecx, 31
  008eb	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  008ef	3b c2		 cmp	 eax, edx
  008f1	75 3c		 jne	 SHORT $LN19@DispatchCa

; 2037 : 		{
; 2038 : 			BYTE cbOperateCard[3] = { m_cbProvideCard };

  008f3	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008f9	8a 88 c2 04 00
	00		 mov	 cl, BYTE PTR [eax+1218]
  008ff	88 8d a0 fc ff
	ff		 mov	 BYTE PTR _cbOperateCard$1[ebp], cl
  00905	33 d2		 xor	 edx, edx
  00907	66 89 95 a1 fc
	ff ff		 mov	 WORD PTR _cbOperateCard$1[ebp+1], dx

; 2039 : 			return OnUserOperateCard(wCurrentUser, WIK_CHI_HU, cbOperateCard);

  0090e	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _cbOperateCard$1[ebp]
  00914	50		 push	 eax
  00915	6a 40		 push	 64			; 00000040H
  00917	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _wCurrentUser$[ebp]
  0091e	51		 push	 ecx
  0091f	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00925	e8 00 00 00 00	 call	 ?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z ; CTableFrameSink::OnUserOperateCard
  0092a	e9 ba 00 00 00	 jmp	 $LN1@DispatchCa
$LN19@DispatchCa:

; 2040 : 		}
; 2041 : 	}
; 2042 : 
; 2043 : 
; 2044 : 	if (m_bTrustee[wCurrentUser])

  0092f	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _wCurrentUser$[ebp]
  00936	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0093c	0f b6 8c 10 78
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1144]
  00944	85 c9		 test	 ecx, ecx
  00946	74 41		 je	 SHORT $LN21@DispatchCa

; 2045 : 		m_pITableFrame->SetGameTimer(IDI_OUT_CARD, m_pGameCustomRule->cbTimeTrustee * 1000, 1, 0);

  00948	6a 00		 push	 0
  0094a	6a 01		 push	 1
  0094c	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00952	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  00958	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0095c	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  00962	52		 push	 edx
  00963	6a 03		 push	 3
  00965	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0096b	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00971	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00977	8b 01		 mov	 eax, DWORD PTR [ecx]
  00979	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0097f	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  00985	ff d2		 call	 edx

; 2046 : 	else

  00987	eb 42		 jmp	 SHORT $LN22@DispatchCa
$LN21@DispatchCa:

; 2047 : 		m_pITableFrame->SetGameTimer(IDI_OUT_CARD, (m_pGameCustomRule->cbTimeOutCard + 2) * 1000, 1, 0);

  00989	6a 00		 push	 0
  0098b	6a 01		 push	 1
  0098d	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00993	8b 88 2c 09 00
	00		 mov	 ecx, DWORD PTR [eax+2348]
  00999	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  0099d	83 c2 02	 add	 edx, 2
  009a0	69 c2 e8 03 00
	00		 imul	 eax, edx, 1000
  009a6	50		 push	 eax
  009a7	6a 03		 push	 3
  009a9	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009af	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  009b5	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009bb	8b 12		 mov	 edx, DWORD PTR [edx]
  009bd	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  009c3	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  009c9	ff d0		 call	 eax
$LN22@DispatchCa:

; 2048 : 
; 2049 : 	m_tActionStartTime = time(0);

  009cb	6a 00		 push	 0
  009cd	e8 00 00 00 00	 call	 _time
  009d2	83 c4 04	 add	 esp, 4
  009d5	8b 8d b4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009db	89 81 a8 04 00
	00		 mov	 DWORD PTR [ecx+1192], eax
  009e1	89 91 ac 04 00
	00		 mov	 DWORD PTR [ecx+1196], edx

; 2050 : 	return true;

  009e7	b0 01		 mov	 al, 1
$LN1@DispatchCa:

; 2051 : }

  009e9	5e		 pop	 esi
  009ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009ed	33 cd		 xor	 ecx, ebp
  009ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009f4	8b e5		 mov	 esp, ebp
  009f6	5d		 pop	 ebp
  009f7	c2 08 00	 ret	 8
?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z ENDP	; CTableFrameSink::DispatchCardData
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbHeapCount$1 = -4					; size = 1
_cbHeapCount$2 = -3					; size = 1
_cbIndexCard$ = -2					; size = 1
_cbSendCardData$ = -1					; size = 1
_bTail$ = 8						; size = 1
?GetSendCard@CTableFrameSink@@IAEE_N@Z PROC		; CTableFrameSink::GetSendCard
; _this$ = ecx

; 1868 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1869 : 	//发送扑克
; 1870 : 	m_cbSendCardCount++;

  0000a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8a 88 3d 07 00
	00		 mov	 cl, BYTE PTR [eax+1853]
  00013	80 c1 01	 add	 cl, 1
  00016	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00019	88 8a 3d 07 00
	00		 mov	 BYTE PTR [edx+1853], cl

; 1871 : 	m_cbLeftCardCount--;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8a 88 b1 07 00
	00		 mov	 cl, BYTE PTR [eax+1969]
  00028	80 e9 01	 sub	 cl, 1
  0002b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	88 8a b1 07 00
	00		 mov	 BYTE PTR [edx+1969], cl

; 1872 : 
; 1873 : 	BYTE cbSendCardData = 0;

  00034	c6 45 ff 00	 mov	 BYTE PTR _cbSendCardData$[ebp], 0

; 1874 : 	
; 1875 : 	BYTE cbIndexCard;
; 1876 : 	if(bTail)

  00038	0f b6 45 08	 movzx	 eax, BYTE PTR _bTail$[ebp]
  0003c	85 c0		 test	 eax, eax
  0003e	74 2d		 je	 SHORT $LN2@GetSendCar

; 1877 : 	{	
; 1878 : 		cbSendCardData = m_cbRepertoryCard[m_cbMinusLastCount];

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	0f b6 91 b0 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1968]
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8a 8c 10 3e 07
	00 00		 mov	 cl, BYTE PTR [eax+edx+1854]
  00054	88 4d ff	 mov	 BYTE PTR _cbSendCardData$[ebp], cl

; 1879 : 		m_cbMinusLastCount++;

  00057	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8a 82 b0 07 00
	00		 mov	 al, BYTE PTR [edx+1968]
  00060	04 01		 add	 al, 1
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	88 81 b0 07 00
	00		 mov	 BYTE PTR [ecx+1968], al

; 1880 : 	}
; 1881 : 	else

  0006b	eb 39		 jmp	 SHORT $LN3@GetSendCar
$LN2@GetSendCar:

; 1882 : 	{
; 1883 : 		m_cbMinusHeadCount++;

  0006d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00070	8a 82 af 07 00
	00		 mov	 al, BYTE PTR [edx+1967]
  00076	04 01		 add	 al, 1
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	88 81 af 07 00
	00		 mov	 BYTE PTR [ecx+1967], al

; 1884 : 		cbIndexCard = MAX_REPERTORY - m_cbMinusHeadCount;

  00081	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00084	0f b6 82 af 07
	00 00		 movzx	 eax, BYTE PTR [edx+1967]
  0008b	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00090	2b c8		 sub	 ecx, eax
  00092	88 4d fe	 mov	 BYTE PTR _cbIndexCard$[ebp], cl

; 1885 : 		cbSendCardData=m_cbRepertoryCard[cbIndexCard];

  00095	0f b6 55 fe	 movzx	 edx, BYTE PTR _cbIndexCard$[ebp]
  00099	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8a 8c 10 3e 07
	00 00		 mov	 cl, BYTE PTR [eax+edx+1854]
  000a3	88 4d ff	 mov	 BYTE PTR _cbSendCardData$[ebp], cl
$LN3@GetSendCar:

; 1886 : 	}	
; 1887 : 
; 1888 : 	//堆立信息
; 1889 : 	ASSERT(m_wHeapHead != INVALID_CHAIR && m_wHeapTail != INVALID_CHAIR);
; 1890 : 	if(!bTail)

  000a6	0f b6 55 08	 movzx	 edx, BYTE PTR _bTail$[ebp]
  000aa	85 d2		 test	 edx, edx
  000ac	0f 85 b4 00 00
	00		 jne	 $LN4@GetSendCar

; 1891 : 	{
; 1892 : 		//切换索引
; 1893 : 		BYTE cbHeapCount = m_cbHeapCardInfo[m_wHeapHead][0] + m_cbHeapCardInfo[m_wHeapHead][1];

  000b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	0f b7 88 b0 04
	00 00		 movzx	 ecx, WORD PTR [eax+1200]
  000bc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000bf	8d 84 4a b4 04
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+1204]
  000c6	b9 01 00 00 00	 mov	 ecx, 1
  000cb	6b d1 00	 imul	 edx, ecx, 0
  000ce	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000d2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	0f b7 91 b0 04
	00 00		 movzx	 edx, WORD PTR [ecx+1200]
  000dc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	8d 94 51 b4 04
	00 00		 lea	 edx, DWORD PTR [ecx+edx*2+1204]
  000e6	b9 01 00 00 00	 mov	 ecx, 1
  000eb	c1 e1 00	 shl	 ecx, 0
  000ee	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  000f2	03 c2		 add	 eax, edx
  000f4	88 45 fd	 mov	 BYTE PTR _cbHeapCount$2[ebp], al

; 1894 : 		if (cbHeapCount == HEAP_FULL_COUNT) 

  000f7	0f b6 45 fd	 movzx	 eax, BYTE PTR _cbHeapCount$2[ebp]
  000fb	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  000fe	75 20		 jne	 SHORT $LN6@GetSendCar

; 1895 : 		{
; 1896 : 			m_wHeapHead = (m_wHeapHead + GAME_PLAYER - 1) % CountArray(m_cbHeapCardInfo);

  00100	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	0f b7 81 b0 04
	00 00		 movzx	 eax, WORD PTR [ecx+1200]
  0010a	83 c0 03	 add	 eax, 3
  0010d	33 d2		 xor	 edx, edx
  0010f	b9 04 00 00 00	 mov	 ecx, 4
  00114	f7 f1		 div	 ecx
  00116	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00119	66 89 90 b0 04
	00 00		 mov	 WORD PTR [eax+1200], dx
$LN6@GetSendCar:

; 1897 : 		}
; 1898 : 		m_cbHeapCardInfo[m_wHeapHead][0]++;

  00120	b9 01 00 00 00	 mov	 ecx, 1
  00125	6b d1 00	 imul	 edx, ecx, 0
  00128	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0012b	0f b7 88 b0 04
	00 00		 movzx	 ecx, WORD PTR [eax+1200]
  00132	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00135	8d 8c 48 b4 04
	00 00		 lea	 ecx, DWORD PTR [eax+ecx*2+1204]
  0013c	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0013f	80 c2 01	 add	 dl, 1
  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	6b c8 00	 imul	 ecx, eax, 0
  0014a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	0f b7 80 b0 04
	00 00		 movzx	 eax, WORD PTR [eax+1200]
  00154	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00157	8d 84 46 b4 04
	00 00		 lea	 eax, DWORD PTR [esi+eax*2+1204]
  0015e	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1899 : 	}
; 1900 : 	else

  00161	e9 af 00 00 00	 jmp	 $LN5@GetSendCar
$LN4@GetSendCar:

; 1901 : 	{
; 1902 : 		//切换索引
; 1903 : 		BYTE cbHeapCount = m_cbHeapCardInfo[m_wHeapTail][0] + m_cbHeapCardInfo[m_wHeapTail][1];

  00166	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	0f b7 91 b2 04
	00 00		 movzx	 edx, WORD PTR [ecx+1202]
  00170	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00173	8d 8c 50 b4 04
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+1204]
  0017a	ba 01 00 00 00	 mov	 edx, 1
  0017f	6b c2 00	 imul	 eax, edx, 0
  00182	0f b6 0c 01	 movzx	 ecx, BYTE PTR [ecx+eax]
  00186	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00189	0f b7 82 b2 04
	00 00		 movzx	 eax, WORD PTR [edx+1202]
  00190	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00193	8d 84 42 b4 04
	00 00		 lea	 eax, DWORD PTR [edx+eax*2+1204]
  0019a	ba 01 00 00 00	 mov	 edx, 1
  0019f	c1 e2 00	 shl	 edx, 0
  001a2	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  001a6	03 c8		 add	 ecx, eax
  001a8	88 4d fc	 mov	 BYTE PTR _cbHeapCount$1[ebp], cl

; 1904 : 		if (cbHeapCount == HEAP_FULL_COUNT) 

  001ab	0f b6 4d fc	 movzx	 ecx, BYTE PTR _cbHeapCount$1[ebp]
  001af	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  001b2	75 20		 jne	 SHORT $LN7@GetSendCar

; 1905 : 		{
; 1906 : 			m_wHeapTail = (m_wHeapTail + 1) % CountArray(m_cbHeapCardInfo);

  001b4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001b7	0f b7 82 b2 04
	00 00		 movzx	 eax, WORD PTR [edx+1202]
  001be	83 c0 01	 add	 eax, 1
  001c1	33 d2		 xor	 edx, edx
  001c3	b9 04 00 00 00	 mov	 ecx, 4
  001c8	f7 f1		 div	 ecx
  001ca	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001cd	66 89 90 b2 04
	00 00		 mov	 WORD PTR [eax+1202], dx
$LN7@GetSendCar:

; 1907 : 		}
; 1908 : 		m_cbHeapCardInfo[m_wHeapTail][1]++;

  001d4	b9 01 00 00 00	 mov	 ecx, 1
  001d9	c1 e1 00	 shl	 ecx, 0
  001dc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001df	0f b7 82 b2 04
	00 00		 movzx	 eax, WORD PTR [edx+1202]
  001e6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001e9	8d 84 42 b4 04
	00 00		 lea	 eax, DWORD PTR [edx+eax*2+1204]
  001f0	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  001f3	80 c1 01	 add	 cl, 1
  001f6	ba 01 00 00 00	 mov	 edx, 1
  001fb	c1 e2 00	 shl	 edx, 0
  001fe	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00201	0f b7 80 b2 04
	00 00		 movzx	 eax, WORD PTR [eax+1202]
  00208	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0020b	8d 84 46 b4 04
	00 00		 lea	 eax, DWORD PTR [esi+eax*2+1204]
  00212	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
$LN5@GetSendCar:

; 1909 : 	}
; 1910 : 
; 1911 : 	return cbSendCardData;

  00215	8a 45 ff	 mov	 al, BYTE PTR _cbSendCardData$[ebp]

; 1912 : }

  00218	5e		 pop	 esi
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c2 04 00	 ret	 4
?GetSendCard@CTableFrameSink@@IAEE_N@Z ENDP		; CTableFrameSink::GetSendCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_cc$2 = -28						; size = 4
_this$ = -24						; size = 4
_OperateNotify$3 = -20					; size = 2
_i$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
?SendOperateNotify@CTableFrameSink@@IAE_NXZ PROC	; CTableFrameSink::SendOperateNotify
; _this$ = ecx

; 1832 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendOperateNotify@CTableFrameSink@@IAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1833 : 	//发送提示
; 1834 : 	for (WORD i=0;i<m_cbPlayerCount;i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f0	 mov	 WORD PTR _i$4[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN4@SendOperat
$LN2@SendOperat:
  00030	66 8b 4d f0	 mov	 cx, WORD PTR _i$4[ebp]
  00034	66 83 c1 01	 add	 cx, 1
  00038	66 89 4d f0	 mov	 WORD PTR _i$4[ebp], cx
$LN4@SendOperat:
  0003c	0f b7 55 f0	 movzx	 edx, WORD PTR _i$4[ebp]
  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00047	3b d1		 cmp	 edx, ecx
  00049	0f 8d 24 01 00
	00		 jge	 $LN3@SendOperat

; 1835 : 	{
; 1836 : 		if (m_cbUserAction[i]!=WIK_NULL)

  0004f	0f b7 55 f0	 movzx	 edx, WORD PTR _i$4[ebp]
  00053	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  0005e	85 c9		 test	 ecx, ecx
  00060	0f 84 08 01 00
	00		 je	 $LN5@SendOperat

; 1837 : 		{
; 1838 : 			//构造数据
; 1839 : 			CMD_S_OperateNotify OperateNotify;
; 1840 : 			OperateNotify.cbActionCard=m_cbProvideCard;

  00066	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00069	8a 82 c2 04 00
	00		 mov	 al, BYTE PTR [edx+1218]
  0006f	88 45 ed	 mov	 BYTE PTR _OperateNotify$3[ebp+1], al

; 1841 : 			OperateNotify.cbActionMask=m_cbUserAction[i];

  00072	0f b7 4d f0	 movzx	 ecx, WORD PTR _i$4[ebp]
  00076	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00079	8a 84 0a e4 05
	00 00		 mov	 al, BYTE PTR [edx+ecx+1508]
  00080	88 45 ec	 mov	 BYTE PTR _OperateNotify$3[ebp], al

; 1842 : 
; 1843 : 			//发送数据
; 1844 : 			m_pITableFrame->SendTableData(i,SUB_S_OPERATE_NOTIFY,&OperateNotify,sizeof(OperateNotify));

  00083	68 c8 00 00 00	 push	 200			; 000000c8H
  00088	6a 02		 push	 2
  0008a	8d 4d ec	 lea	 ecx, DWORD PTR _OperateNotify$3[ebp]
  0008d	51		 push	 ecx
  0008e	6a 67		 push	 103			; 00000067H
  00090	0f b7 55 f0	 movzx	 edx, WORD PTR _i$4[ebp]
  00094	52		 push	 edx
  00095	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  0009e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a3	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  000a9	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  000af	ff d2		 call	 edx

; 1845 : 			m_pITableFrame->SendLookonData(i,SUB_S_OPERATE_NOTIFY,&OperateNotify,sizeof(OperateNotify));

  000b1	6a 02		 push	 2
  000b3	8d 45 ec	 lea	 eax, DWORD PTR _OperateNotify$3[ebp]
  000b6	50		 push	 eax
  000b7	6a 67		 push	 103			; 00000067H
  000b9	0f b7 4d f0	 movzx	 ecx, WORD PTR _i$4[ebp]
  000bd	51		 push	 ecx
  000be	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  000c7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 10		 mov	 edx, DWORD PTR [eax]
  000cc	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  000d2	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  000d8	ff d0		 call	 eax

; 1846 : 			if(m_pGameVideo)

  000da	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  000e4	74 27		 je	 SHORT $LN6@SendOperat

; 1847 : 			{
; 1848 : 				m_pGameVideo->AddVideoData(SUB_S_OPERATE_NOTIFY,&OperateNotify,sizeof(OperateNotify),true);

  000e6	6a 01		 push	 1
  000e8	6a 02		 push	 2
  000ea	8d 55 ec	 lea	 edx, DWORD PTR _OperateNotify$3[ebp]
  000ed	52		 push	 edx
  000ee	6a 67		 push	 103			; 00000067H
  000f0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  000f9	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000fc	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00102	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00104	50		 push	 eax
  00105	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00108	ff d2		 call	 edx
  0010a	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@SendOperat:

; 1849 : 			}
; 1850 : 			if (OperateNotify.cbActionMask != WIK_NULL)

  0010d	0f b6 45 ec	 movzx	 eax, BYTE PTR _OperateNotify$3[ebp]
  00111	85 c0		 test	 eax, eax
  00113	74 59		 je	 SHORT $LN5@SendOperat

; 1851 : 			{
; 1852 : 				CString cc;

  00115	8d 4d e4	 lea	 ecx, DWORD PTR _cc$2[ebp]
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  0011e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1853 : 				cc.Format(_T("玩家%d可动作%d"), i, m_cbUserAction[i]);

  00125	0f b7 4d f0	 movzx	 ecx, WORD PTR _i$4[ebp]
  00129	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0012c	0f b6 84 0a e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1508]
  00134	50		 push	 eax
  00135	0f b7 4d f0	 movzx	 ecx, WORD PTR _i$4[ebp]
  00139	51		 push	 ecx
  0013a	68 00 00 00 00	 push	 OFFSET $SG314131
  0013f	8d 55 e4	 lea	 edx, DWORD PTR _cc$2[ebp]
  00142	52		 push	 edx
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00149	83 c4 10	 add	 esp, 16			; 00000010H

; 1854 : 				WriteDebugInfo(cc);

  0014c	8d 4d e4	 lea	 ecx, DWORD PTR _cc$2[ebp]
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00155	50		 push	 eax
  00156	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00159	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1855 : 			}

  0015e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00165	8d 4d e4	 lea	 ecx, DWORD PTR _cc$2[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
$LN5@SendOperat:

; 1856 : 		}
; 1857 : 	}

  0016e	e9 bd fe ff ff	 jmp	 $LN2@SendOperat
$LN3@SendOperat:

; 1858 : 
; 1859 : 
; 1860 : 	m_pITableFrame->SetGameTimer(IDI_OPERATE_CARD, (m_pGameCustomRule->cbTimeOperateCard + 2) * 1000, 1, 0);

  00173	6a 00		 push	 0
  00175	6a 01		 push	 1
  00177	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	8b 88 2c 09 00
	00		 mov	 ecx, DWORD PTR [eax+2348]
  00180	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00184	83 c2 02	 add	 edx, 2
  00187	69 c2 e8 03 00
	00		 imul	 eax, edx, 1000
  0018d	50		 push	 eax
  0018e	6a 04		 push	 4
  00190	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00199	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0019c	8b 12		 mov	 edx, DWORD PTR [edx]
  0019e	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  001a4	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  001aa	ff d0		 call	 eax

; 1861 : 	m_tActionStartTime = time(0);

  001ac	6a 00		 push	 0
  001ae	e8 00 00 00 00	 call	 _time
  001b3	83 c4 04	 add	 esp, 4
  001b6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	89 81 a8 04 00
	00		 mov	 DWORD PTR [ecx+1192], eax
  001bf	89 91 ac 04 00
	00		 mov	 DWORD PTR [ecx+1196], edx

; 1862 : 
; 1863 : 	return true;

  001c5	b0 01		 mov	 al, 1

; 1864 : }

  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b e5		 mov	 esp, ebp
  001d4	5d		 pop	 ebp
  001d5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SendOperateNotify@CTableFrameSink@@IAE_NXZ$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _cc$2[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?SendOperateNotify@CTableFrameSink@@IAE_NXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendOperateNotify@CTableFrameSink@@IAE_NXZ
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendOperateNotify@CTableFrameSink@@IAE_NXZ ENDP	; CTableFrameSink::SendOperateNotify
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv484 = -692						; size = 8
tv321 = -684						; size = 4
tv591 = -680						; size = 4
tv553 = -676						; size = 4
tv182 = -672						; size = 4
tv167 = -668						; size = 4
_lLoseScore$1 = -664					; size = 8
_nCount$2 = -656					; size = 4
_i$3 = -652						; size = 2
_i$4 = -648						; size = 2
_i$5 = -644						; size = 2
_this$ = -640						; size = 4
_GameConclude$6 = -636					; size = 472
_ScoreInfoArray$7 = -164				; size = 160
__$ArrayPad$ = -4					; size = 4
_wChairID$ = 8						; size = 2
?OnUserFlee@CTableFrameSink@@IAE_NG@Z PROC		; CTableFrameSink::OnUserFlee
; _this$ = ecx

; 2389 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 02 00
	00		 sub	 esp, 692		; 000002b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	89 8d 80 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2390 : 	if( (m_pGameServiceOption->wServerType&GAME_GENRE_PERSONAL) != 0)//房卡模式

  0001a	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 88 30 09 00
	00		 mov	 ecx, DWORD PTR [eax+2352]
  00026	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  0002a	83 e2 10	 and	 edx, 16			; 00000010H
  0002d	74 07		 je	 SHORT $LN11@OnUserFlee

; 2391 : 		return true;

  0002f	b0 01		 mov	 al, 1
  00031	e9 68 07 00 00	 jmp	 $LN1@OnUserFlee
$LN11@OnUserFlee:

; 2392 : 
; 2393 : 	if(m_pITableFrame->GetGameStatus() == GAME_SCENE_PLAY)

  00036	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00042	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004a	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00050	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  00053	ff d2		 call	 edx
  00055	0f b6 c0	 movzx	 eax, al
  00058	83 f8 64	 cmp	 eax, 100		; 00000064H
  0005b	0f 85 3b 07 00
	00		 jne	 $LN12@OnUserFlee

; 2394 : 	{
; 2395 : 		m_pITableFrame->KillGameTimer(IDI_OUT_CARD);

  00061	6a 03		 push	 3
  00063	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00069	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  0006f	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 12		 mov	 edx, DWORD PTR [edx]
  00077	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  0007d	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00083	ff d0		 call	 eax

; 2396 : 		m_pITableFrame->KillGameTimer(IDI_OPERATE_CARD);

  00085	6a 04		 push	 4
  00087	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00093	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00099	8b 12		 mov	 edx, DWORD PTR [edx]
  0009b	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  000a1	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000a7	ff d0		 call	 eax

; 2397 : 		//逃跑，赔其他玩家小胡自摸分
; 2398 : 
; 2399 : 		CMD_S_GameConclude GameConclude;
; 2400 : 		ZeroMemory(&GameConclude, sizeof(GameConclude));

  000a9	68 d8 01 00 00	 push	 472			; 000001d8H
  000ae	6a 00		 push	 0
  000b0	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR _GameConclude$6[ebp]
  000b6	51		 push	 ecx
  000b7	e8 00 00 00 00	 call	 _memset
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2401 : 		GameConclude.cbSendCardData=m_cbSendCardData;

  000bf	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000c5	8a 82 3c 07 00
	00		 mov	 al, BYTE PTR [edx+1852]
  000cb	88 85 eb fd ff
	ff		 mov	 BYTE PTR _GameConclude$6[ebp+103], al

; 2402 : 		GameConclude.wLeftUser = wChairID;

  000d1	66 8b 4d 08	 mov	 cx, WORD PTR _wChairID$[ebp]
  000d5	66 89 8d 0c fe
	ff ff		 mov	 WORD PTR _GameConclude$6[ebp+136], cx

; 2403 : 		GameConclude.wProvideUser=INVALID_CHAIR;

  000dc	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000e1	66 89 95 e8 fd
	ff ff		 mov	 WORD PTR _GameConclude$6[ebp+100], dx

; 2404 : 
; 2405 : 		int nCount = 0;

  000e8	c7 85 70 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _nCount$2[ebp], 0

; 2406 : 		for(WORD i=0;i<m_cbPlayerCount;i++)

  000f2	33 c0		 xor	 eax, eax
  000f4	66 89 85 74 fd
	ff ff		 mov	 WORD PTR _i$3[ebp], ax
  000fb	eb 12		 jmp	 SHORT $LN4@OnUserFlee
$LN2@OnUserFlee:
  000fd	66 8b 8d 74 fd
	ff ff		 mov	 cx, WORD PTR _i$3[ebp]
  00104	66 83 c1 01	 add	 cx, 1
  00108	66 89 8d 74 fd
	ff ff		 mov	 WORD PTR _i$3[ebp], cx
$LN4@OnUserFlee:
  0010f	0f b7 95 74 fd
	ff ff		 movzx	 edx, WORD PTR _i$3[ebp]
  00116	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011c	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00120	3b d1		 cmp	 edx, ecx
  00122	7d 2c		 jge	 SHORT $LN3@OnUserFlee

; 2407 : 		{
; 2408 : 			if(!m_bPlayStatus[i])

  00124	0f b7 95 74 fd
	ff ff		 movzx	 edx, WORD PTR _i$3[ebp]
  0012b	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00131	0f b6 8c 10 7d
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1149]
  00139	85 c9		 test	 ecx, ecx
  0013b	75 02		 jne	 SHORT $LN13@OnUserFlee

; 2409 : 				continue;

  0013d	eb be		 jmp	 SHORT $LN2@OnUserFlee
$LN13@OnUserFlee:

; 2410 : 			nCount++;

  0013f	8b 95 70 fd ff
	ff		 mov	 edx, DWORD PTR _nCount$2[ebp]
  00145	83 c2 01	 add	 edx, 1
  00148	89 95 70 fd ff
	ff		 mov	 DWORD PTR _nCount$2[ebp], edx

; 2411 : 		}

  0014e	eb ad		 jmp	 SHORT $LN2@OnUserFlee
$LN3@OnUserFlee:

; 2412 : 
; 2413 : 		SCORE lLoseScore = (nCount-1)*m_pITableFrame->GetCellScore()*2*(nCount-1);

  00150	8b b5 70 fd ff
	ff		 mov	 esi, DWORD PTR _nCount$2[ebp]
  00156	83 ee 01	 sub	 esi, 1
  00159	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0015f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00165	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0016b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016d	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00173	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00176	ff d2		 call	 edx
  00178	0f af f0	 imul	 esi, eax
  0017b	d1 e6		 shl	 esi, 1
  0017d	8b 85 70 fd ff
	ff		 mov	 eax, DWORD PTR _nCount$2[ebp]
  00183	83 e8 01	 sub	 eax, 1
  00186	0f af c6	 imul	 eax, esi
  00189	99		 cdq
  0018a	89 85 68 fd ff
	ff		 mov	 DWORD PTR _lLoseScore$1[ebp], eax
  00190	89 95 6c fd ff
	ff		 mov	 DWORD PTR _lLoseScore$1[ebp+4], edx

; 2414 : 		if(lLoseScore > m_pITableFrame->GetTableUserItem(wChairID)->GetUserScore())

  00196	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001a1	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  001a7	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	8b 10		 mov	 edx, DWORD PTR [eax]
  001af	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  001b5	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  001bb	ff d0		 call	 eax
  001bd	89 85 64 fd ff
	ff		 mov	 DWORD PTR tv167[ebp], eax
  001c3	8b 8d 64 fd ff
	ff		 mov	 ecx, DWORD PTR tv167[ebp]
  001c9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001cb	8b 8d 64 fd ff
	ff		 mov	 ecx, DWORD PTR tv167[ebp]
  001d1	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  001d7	ff d0		 call	 eax
  001d9	89 85 4c fd ff
	ff		 mov	 DWORD PTR tv484[ebp], eax
  001df	89 95 50 fd ff
	ff		 mov	 DWORD PTR tv484[ebp+4], edx
  001e5	8b 8d 6c fd ff
	ff		 mov	 ecx, DWORD PTR _lLoseScore$1[ebp+4]
  001eb	3b 8d 50 fd ff
	ff		 cmp	 ecx, DWORD PTR tv484[ebp+4]
  001f1	7c 5f		 jl	 SHORT $LN14@OnUserFlee
  001f3	7f 0e		 jg	 SHORT $LN23@OnUserFlee
  001f5	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR _lLoseScore$1[ebp]
  001fb	3b 95 4c fd ff
	ff		 cmp	 edx, DWORD PTR tv484[ebp]
  00201	76 4f		 jbe	 SHORT $LN14@OnUserFlee
$LN23@OnUserFlee:

; 2415 : 			lLoseScore = m_pITableFrame->GetTableUserItem(wChairID)->GetUserScore();

  00203	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00207	50		 push	 eax
  00208	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00214	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 12		 mov	 edx, DWORD PTR [edx]
  0021c	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00222	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  00228	ff d0		 call	 eax
  0022a	89 85 60 fd ff
	ff		 mov	 DWORD PTR tv182[ebp], eax
  00230	8b 8d 60 fd ff
	ff		 mov	 ecx, DWORD PTR tv182[ebp]
  00236	8b 11		 mov	 edx, DWORD PTR [ecx]
  00238	8b 8d 60 fd ff
	ff		 mov	 ecx, DWORD PTR tv182[ebp]
  0023e	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  00244	ff d0		 call	 eax
  00246	89 85 68 fd ff
	ff		 mov	 DWORD PTR _lLoseScore$1[ebp], eax
  0024c	89 95 6c fd ff
	ff		 mov	 DWORD PTR _lLoseScore$1[ebp+4], edx
$LN14@OnUserFlee:

; 2416 : 
; 2417 : 		GameConclude.lGameScore[wChairID] -= lLoseScore;

  00252	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00256	8b 94 cd 88 fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$6[ebp+ecx*8+4]
  0025d	2b 95 68 fd ff
	ff		 sub	 edx, DWORD PTR _lLoseScore$1[ebp]
  00263	8b 84 cd 8c fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$6[ebp+ecx*8+8]
  0026a	1b 85 6c fd ff
	ff		 sbb	 eax, DWORD PTR _lLoseScore$1[ebp+4]
  00270	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00274	89 94 cd 88 fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+ecx*8+4], edx
  0027b	89 84 cd 8c fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+ecx*8+8], eax

; 2418 : 		for(WORD i=0;i<m_cbPlayerCount;i++)

  00282	33 d2		 xor	 edx, edx
  00284	66 89 95 78 fd
	ff ff		 mov	 WORD PTR _i$4[ebp], dx
  0028b	eb 12		 jmp	 SHORT $LN7@OnUserFlee
$LN5@OnUserFlee:
  0028d	66 8b 85 78 fd
	ff ff		 mov	 ax, WORD PTR _i$4[ebp]
  00294	66 83 c0 01	 add	 ax, 1
  00298	66 89 85 78 fd
	ff ff		 mov	 WORD PTR _i$4[ebp], ax
$LN7@OnUserFlee:
  0029f	0f b7 8d 78 fd
	ff ff		 movzx	 ecx, WORD PTR _i$4[ebp]
  002a6	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002ac	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  002b0	3b c8		 cmp	 ecx, eax
  002b2	0f 8d 17 01 00
	00		 jge	 $LN6@OnUserFlee

; 2419 : 		{
; 2420 : 			if(!m_bPlayStatus[i])

  002b8	0f b7 8d 78 fd
	ff ff		 movzx	 ecx, WORD PTR _i$4[ebp]
  002bf	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002c5	0f b6 84 0a 7d
	04 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1149]
  002cd	85 c0		 test	 eax, eax
  002cf	75 02		 jne	 SHORT $LN15@OnUserFlee

; 2421 : 				continue;

  002d1	eb ba		 jmp	 SHORT $LN5@OnUserFlee
$LN15@OnUserFlee:

; 2422 : 
; 2423 : 			if(i != wChairID)

  002d3	0f b7 8d 78 fd
	ff ff		 movzx	 ecx, WORD PTR _i$4[ebp]
  002da	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  002de	3b ca		 cmp	 ecx, edx
  002e0	74 49		 je	 SHORT $LN16@OnUserFlee

; 2424 : 			{
; 2425 : 				GameConclude.lGameScore[i] += ( lLoseScore/(nCount-1) );

  002e2	0f b7 b5 78 fd
	ff ff		 movzx	 esi, WORD PTR _i$4[ebp]
  002e9	8b 85 70 fd ff
	ff		 mov	 eax, DWORD PTR _nCount$2[ebp]
  002ef	83 e8 01	 sub	 eax, 1
  002f2	99		 cdq
  002f3	52		 push	 edx
  002f4	50		 push	 eax
  002f5	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR _lLoseScore$1[ebp+4]
  002fb	50		 push	 eax
  002fc	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR _lLoseScore$1[ebp]
  00302	51		 push	 ecx
  00303	e8 00 00 00 00	 call	 __alldiv
  00308	03 84 f5 88 fd
	ff ff		 add	 eax, DWORD PTR _GameConclude$6[ebp+esi*8+4]
  0030f	13 94 f5 8c fd
	ff ff		 adc	 edx, DWORD PTR _GameConclude$6[ebp+esi*8+8]
  00316	0f b7 8d 78 fd
	ff ff		 movzx	 ecx, WORD PTR _i$4[ebp]
  0031d	89 84 cd 88 fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+ecx*8+4], eax
  00324	89 94 cd 8c fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+ecx*8+8], edx
$LN16@OnUserFlee:

; 2426 : 
; 2427 : 			}
; 2428 : 			GameConclude.cbCardCount[i] = m_GameLogic.SwitchToCardData(m_cbCardIndex[i], GameConclude.cbHandCardData[i]);

  0032b	0f b7 95 78 fd
	ff ff		 movzx	 edx, WORD PTR _i$4[ebp]
  00332	6b c2 0e	 imul	 eax, edx, 14
  00335	8d 8c 05 14 fe
	ff ff		 lea	 ecx, DWORD PTR _GameConclude$6[ebp+eax+144]
  0033c	51		 push	 ecx
  0033d	0f b7 95 78 fd
	ff ff		 movzx	 edx, WORD PTR _i$4[ebp]
  00344	6b c2 22	 imul	 eax, edx, 34
  00347	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0034d	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00354	52		 push	 edx
  00355	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0035b	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00361	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z ; CGameLogic::SwitchToCardData
  00366	0f b7 8d 78 fd
	ff ff		 movzx	 ecx, WORD PTR _i$4[ebp]
  0036d	88 84 0d 10 fe
	ff ff		 mov	 BYTE PTR _GameConclude$6[ebp+ecx+140], al

; 2429 : 			GameConclude.cbWeaveItemCount[i] = m_cbWeaveItemCount[i];

  00374	0f b7 95 78 fd
	ff ff		 movzx	 edx, WORD PTR _i$4[ebp]
  0037b	0f b7 85 78 fd
	ff ff		 movzx	 eax, WORD PTR _i$4[ebp]
  00382	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00388	8a 94 11 3e 08
	00 00		 mov	 dl, BYTE PTR [ecx+edx+2110]
  0038f	88 94 05 c8 fe
	ff ff		 mov	 BYTE PTR _GameConclude$6[ebp+eax+324], dl

; 2430 : 			memcpy(GameConclude.WeaveItemArray[i], m_WeaveItemArray[i], sizeof(GameConclude.WeaveItemArray[i]));

  00396	6a 24		 push	 36			; 00000024H
  00398	0f b7 85 78 fd
	ff ff		 movzx	 eax, WORD PTR _i$4[ebp]
  0039f	6b c8 24	 imul	 ecx, eax, 36
  003a2	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003a8	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  003af	50		 push	 eax
  003b0	0f b7 8d 78 fd
	ff ff		 movzx	 ecx, WORD PTR _i$4[ebp]
  003b7	6b d1 24	 imul	 edx, ecx, 36
  003ba	8d 84 15 cc fe
	ff ff		 lea	 eax, DWORD PTR _GameConclude$6[ebp+edx+328]
  003c1	50		 push	 eax
  003c2	e8 00 00 00 00	 call	 _memcpy
  003c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2431 : 		}

  003ca	e9 be fe ff ff	 jmp	 $LN5@OnUserFlee
$LN6@OnUserFlee:

; 2432 : 
; 2433 : 		//积分变量
; 2434 : 		tagScoreInfo ScoreInfoArray[GAME_PLAYER];
; 2435 : 		ZeroMemory(&ScoreInfoArray, sizeof(ScoreInfoArray));

  003cf	68 a0 00 00 00	 push	 160			; 000000a0H
  003d4	6a 00		 push	 0
  003d6	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _ScoreInfoArray$7[ebp]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 _memset
  003e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2436 : 
; 2437 : 		//统计积分
; 2438 : 		for (WORD i = 0; i < m_cbPlayerCount; i++)

  003e5	33 d2		 xor	 edx, edx
  003e7	66 89 95 7c fd
	ff ff		 mov	 WORD PTR _i$5[ebp], dx
  003ee	eb 12		 jmp	 SHORT $LN10@OnUserFlee
$LN8@OnUserFlee:
  003f0	66 8b 85 7c fd
	ff ff		 mov	 ax, WORD PTR _i$5[ebp]
  003f7	66 83 c0 01	 add	 ax, 1
  003fb	66 89 85 7c fd
	ff ff		 mov	 WORD PTR _i$5[ebp], ax
$LN10@OnUserFlee:
  00402	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  00409	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0040f	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  00413	3b c8		 cmp	 ecx, eax
  00415	0f 8d ee 01 00
	00		 jge	 $LN9@OnUserFlee

; 2439 : 		{
; 2440 : 			if(!m_bPlayStatus[i])

  0041b	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  00422	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00428	0f b6 84 0a 7d
	04 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1149]
  00430	85 c0		 test	 eax, eax
  00432	75 02		 jne	 SHORT $LN17@OnUserFlee

; 2441 : 				continue;

  00434	eb ba		 jmp	 SHORT $LN8@OnUserFlee
$LN17@OnUserFlee:

; 2442 : 
; 2443 : 			//收税
; 2444 : 			if (GameConclude.lGameScore[i]>0 && (m_pGameServiceOption->wServerType&GAME_GENRE_GOLD)!=0)

  00436	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  0043d	89 8d 5c fd ff
	ff		 mov	 DWORD PTR tv553[ebp], ecx
  00443	8b 95 5c fd ff
	ff		 mov	 edx, DWORD PTR tv553[ebp]
  00449	83 bc d5 8c fd
	ff ff 00	 cmp	 DWORD PTR _GameConclude$6[ebp+edx*8+8], 0
  00451	0f 8c c4 00 00
	00		 jl	 $LN18@OnUserFlee
  00457	7f 14		 jg	 SHORT $LN24@OnUserFlee
  00459	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR tv553[ebp]
  0045f	83 bc c5 88 fd
	ff ff 00	 cmp	 DWORD PTR _GameConclude$6[ebp+eax*8+4], 0
  00467	0f 86 ae 00 00
	00		 jbe	 $LN18@OnUserFlee
$LN24@OnUserFlee:
  0046d	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00473	8b 91 30 09 00
	00		 mov	 edx, DWORD PTR [ecx+2352]
  00479	0f b7 42 54	 movzx	 eax, WORD PTR [edx+84]
  0047d	83 e0 01	 and	 eax, 1
  00480	0f 84 95 00 00
	00		 je	 $LN18@OnUserFlee

; 2445 : 			{
; 2446 : 				GameConclude.lRevenue[i] = m_pITableFrame->CalculateRevenue(i,GameConclude.lGameScore[i]);

  00486	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  0048d	8b 94 cd 8c fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$6[ebp+ecx*8+8]
  00494	52		 push	 edx
  00495	8b 84 cd 88 fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$6[ebp+ecx*8+4]
  0049c	50		 push	 eax
  0049d	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  004a4	51		 push	 ecx
  004a5	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004ab	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  004b1	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004b7	8b 10		 mov	 edx, DWORD PTR [eax]
  004b9	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  004bf	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  004c5	ff d0		 call	 eax
  004c7	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  004ce	89 84 cd a8 fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+ecx*8+36], eax
  004d5	89 94 cd ac fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+ecx*8+40], edx

; 2447 : 				GameConclude.lGameScore[i] -= GameConclude.lRevenue[i];

  004dc	0f b7 95 7c fd
	ff ff		 movzx	 edx, WORD PTR _i$5[ebp]
  004e3	0f b7 85 7c fd
	ff ff		 movzx	 eax, WORD PTR _i$5[ebp]
  004ea	8b 8c d5 88 fd
	ff ff		 mov	 ecx, DWORD PTR _GameConclude$6[ebp+edx*8+4]
  004f1	2b 8c c5 a8 fd
	ff ff		 sub	 ecx, DWORD PTR _GameConclude$6[ebp+eax*8+36]
  004f8	8b 94 d5 8c fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$6[ebp+edx*8+8]
  004ff	1b 94 c5 ac fd
	ff ff		 sbb	 edx, DWORD PTR _GameConclude$6[ebp+eax*8+40]
  00506	0f b7 85 7c fd
	ff ff		 movzx	 eax, WORD PTR _i$5[ebp]
  0050d	89 8c c5 88 fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+eax*8+4], ecx
  00514	89 94 c5 8c fd
	ff ff		 mov	 DWORD PTR _GameConclude$6[ebp+eax*8+8], edx
$LN18@OnUserFlee:

; 2448 : 			}
; 2449 : 
; 2450 : 			ScoreInfoArray[i].lScore = GameConclude.lGameScore[i];

  0051b	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  00522	0f b7 95 7c fd
	ff ff		 movzx	 edx, WORD PTR _i$5[ebp]
  00529	6b c2 28	 imul	 eax, edx, 40
  0052c	8b 94 cd 88 fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$6[ebp+ecx*8+4]
  00533	89 94 05 64 ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$7[ebp+eax+8], edx
  0053a	8b 8c cd 8c fd
	ff ff		 mov	 ecx, DWORD PTR _GameConclude$6[ebp+ecx*8+8]
  00541	89 8c 05 68 ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$7[ebp+eax+12], ecx

; 2451 : 			ScoreInfoArray[i].lRevenue = GameConclude.lRevenue[i];

  00548	0f b7 95 7c fd
	ff ff		 movzx	 edx, WORD PTR _i$5[ebp]
  0054f	0f b7 85 7c fd
	ff ff		 movzx	 eax, WORD PTR _i$5[ebp]
  00556	6b c8 28	 imul	 ecx, eax, 40
  00559	8b 84 d5 a8 fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$6[ebp+edx*8+36]
  00560	89 84 0d 74 ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$7[ebp+ecx+24], eax
  00567	8b 94 d5 ac fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$6[ebp+edx*8+40]
  0056e	89 94 0d 78 ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$7[ebp+ecx+28], edx

; 2452 : 			ScoreInfoArray[i].cbType = ScoreInfoArray[i].lScore > 0 ? SCORE_TYPE_WIN : SCORE_TYPE_FLEE;

  00575	0f b7 85 7c fd
	ff ff		 movzx	 eax, WORD PTR _i$5[ebp]
  0057c	6b c8 28	 imul	 ecx, eax, 40
  0057f	89 8d 58 fd ff
	ff		 mov	 DWORD PTR tv591[ebp], ecx
  00585	8b 95 58 fd ff
	ff		 mov	 edx, DWORD PTR tv591[ebp]
  0058b	83 bc 15 68 ff
	ff ff 00	 cmp	 DWORD PTR _ScoreInfoArray$7[ebp+edx+12], 0
  00593	7c 1e		 jl	 SHORT $LN21@OnUserFlee
  00595	7f 10		 jg	 SHORT $LN25@OnUserFlee
  00597	8b 85 58 fd ff
	ff		 mov	 eax, DWORD PTR tv591[ebp]
  0059d	83 bc 05 64 ff
	ff ff 00	 cmp	 DWORD PTR _ScoreInfoArray$7[ebp+eax+8], 0
  005a5	76 0c		 jbe	 SHORT $LN21@OnUserFlee
$LN25@OnUserFlee:
  005a7	c7 85 54 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv321[ebp], 1
  005b1	eb 0a		 jmp	 SHORT $LN22@OnUserFlee
$LN21@OnUserFlee:
  005b3	c7 85 54 fd ff
	ff 04 00 00 00	 mov	 DWORD PTR tv321[ebp], 4
$LN22@OnUserFlee:
  005bd	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  005c4	6b d1 28	 imul	 edx, ecx, 40
  005c7	8a 85 54 fd ff
	ff		 mov	 al, BYTE PTR tv321[ebp]
  005cd	88 84 15 5c ff
	ff ff		 mov	 BYTE PTR _ScoreInfoArray$7[ebp+edx], al

; 2453 : 
; 2454 : 			//历史积分
; 2455 : 			m_HistoryScore.OnEventUserScore(i, GameConclude.lGameScore[i]);

  005d4	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  005db	8b 94 cd 8c fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$6[ebp+ecx*8+8]
  005e2	52		 push	 edx
  005e3	8b 84 cd 88 fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$6[ebp+ecx*8+4]
  005ea	50		 push	 eax
  005eb	0f b7 8d 7c fd
	ff ff		 movzx	 ecx, WORD PTR _i$5[ebp]
  005f2	51		 push	 ecx
  005f3	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005f9	81 c1 e0 08 00
	00		 add	 ecx, 2272		; 000008e0H
  005ff	e8 00 00 00 00	 call	 ?OnEventUserScore@CHistoryScore@@QAEXG_J@Z ; CHistoryScore::OnEventUserScore

; 2456 : 
; 2457 : 		}

  00604	e9 e7 fd ff ff	 jmp	 $LN8@OnUserFlee
$LN9@OnUserFlee:

; 2458 : 
; 2459 : 		//发送数据
; 2460 : 		m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_GAME_CONCLUDE, &GameConclude, sizeof(GameConclude));

  00609	68 c8 00 00 00	 push	 200			; 000000c8H
  0060e	68 d8 01 00 00	 push	 472			; 000001d8H
  00613	8d 95 84 fd ff
	ff		 lea	 edx, DWORD PTR _GameConclude$6[ebp]
  00619	52		 push	 edx
  0061a	6a 6c		 push	 108			; 0000006cH
  0061c	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00621	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00627	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  0062d	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00633	8b 01		 mov	 eax, DWORD PTR [ecx]
  00635	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0063b	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00641	ff d2		 call	 edx

; 2461 : 		m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_GAME_CONCLUDE, &GameConclude, sizeof(GameConclude));

  00643	68 d8 01 00 00	 push	 472			; 000001d8H
  00648	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _GameConclude$6[ebp]
  0064e	50		 push	 eax
  0064f	6a 6c		 push	 108			; 0000006cH
  00651	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00656	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0065c	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00662	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00668	8b 12		 mov	 edx, DWORD PTR [edx]
  0066a	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00670	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  00676	ff d0		 call	 eax

; 2462 : 		if (m_pGameVideo)

  00678	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0067e	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  00685	0f 84 95 00 00
	00		 je	 $LN19@OnUserFlee

; 2463 : 		{
; 2464 : 			m_pGameVideo->AddVideoData(SUB_S_GAME_CONCLUDE,&GameConclude,sizeof(GameConclude),true);

  0068b	6a 01		 push	 1
  0068d	68 d8 01 00 00	 push	 472			; 000001d8H
  00692	8d 95 84 fd ff
	ff		 lea	 edx, DWORD PTR _GameConclude$6[ebp]
  00698	52		 push	 edx
  00699	6a 6c		 push	 108			; 0000006cH
  0069b	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006a1	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  006a7	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006ad	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  006b3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  006b5	50		 push	 eax
  006b6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  006b9	ff d2		 call	 edx
  006bb	83 c4 14	 add	 esp, 20			; 00000014H

; 2465 : 			m_pGameVideo->StopAndSaveVideo(m_pGameServiceOption->wServerID,m_pITableFrame->GetTableID(),m_cbPlayerCount);

  006be	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006c4	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  006c8	51		 push	 ecx
  006c9	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006cf	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  006d5	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006db	8b 10		 mov	 edx, DWORD PTR [eax]
  006dd	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  006e3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  006e6	ff d0		 call	 eax
  006e8	0f b7 c8	 movzx	 ecx, ax
  006eb	51		 push	 ecx
  006ec	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006f2	8b 82 30 09 00
	00		 mov	 eax, DWORD PTR [edx+2352]
  006f8	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  006fc	51		 push	 ecx
  006fd	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00703	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00709	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0070f	8b 91 40 06 00
	00		 mov	 edx, DWORD PTR [ecx+1600]
  00715	8b 00		 mov	 eax, DWORD PTR [eax]
  00717	52		 push	 edx
  00718	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0071b	ff d1		 call	 ecx
  0071d	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@OnUserFlee:

; 2466 : 		}
; 2467 : 		//写入积分
; 2468 : 		m_pITableFrame->WriteTableScore(ScoreInfoArray, m_cbPlayerCount);

  00720	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00726	66 0f b6 42 09	 movzx	 ax, BYTE PTR [edx+9]
  0072b	0f b7 c8	 movzx	 ecx, ax
  0072e	51		 push	 ecx
  0072f	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _ScoreInfoArray$7[ebp]
  00735	52		 push	 edx
  00736	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0073c	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00742	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00748	8b 01		 mov	 eax, DWORD PTR [ecx]
  0074a	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00750	8b 90 84 00 00
	00		 mov	 edx, DWORD PTR [eax+132]
  00756	ff d2		 call	 edx

; 2469 : 
; 2470 : 		//结束游戏
; 2471 : 		m_pITableFrame->ConcludeGame(GAME_SCENE_FREE);

  00758	6a 00		 push	 0
  0075a	6a 00		 push	 0
  0075c	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00762	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00768	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0076e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00770	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00776	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  00779	ff d2		 call	 edx

; 2472 : 		m_pITableFrame->SetGameStatus(GAME_STATUS_FREE);

  0077b	6a 00		 push	 0
  0077d	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00783	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00789	8b 95 80 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0078f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00791	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00797	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  0079a	ff d2		 call	 edx
$LN12@OnUserFlee:

; 2473 : 	}
; 2474 : 
; 2475 : 	return true;

  0079c	b0 01		 mov	 al, 1
$LN1@OnUserFlee:

; 2476 : }

  0079e	5e		 pop	 esi
  0079f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007a2	33 cd		 xor	 ecx, ebp
  007a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007a9	8b e5		 mov	 esp, ebp
  007ab	5d		 pop	 ebp
  007ac	c2 04 00	 ret	 4
?OnUserFlee@CTableFrameSink@@IAE_NG@Z ENDP		; CTableFrameSink::OnUserFlee
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cbCardCount$ = 8					; size = 1
_wBankerUser$ = 12					; size = 2
_cbCardData$ = 16					; size = 4
_cbControlGameCount$ = 20				; size = 1
?OnUserSendCard@CTableFrameSink@@IAE_NEGQAEE@Z PROC	; CTableFrameSink::OnUserSendCard
; _this$ = ecx

; 1814 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1815 : #ifdef  CARD_DISPATCHER_CONTROL
; 1816 : 	ASSERT(cbCardCount == MAX_REPERTORY && wBankerUser < GAME_PLAYER);
; 1817 : 	if(cbCardCount != MAX_REPERTORY || wBankerUser >= GAME_PLAYER) return false;
; 1818 : 
; 1819 : 	//设置控制局数
; 1820 : 	m_cbControlGameCount = cbControlGameCount;
; 1821 : 
; 1822 : 	m_wControBankerUser = wBankerUser;
; 1823 : 
; 1824 : 	//拷贝控制扑克
; 1825 : 	CopyMemory(m_cbControlRepertoryCard, cbCardData, sizeof(m_cbControlRepertoryCard));
; 1826 : #endif
; 1827 : 	return true;

  00007	b0 01		 mov	 al, 1

; 1828 : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 10 00	 ret	 16			; 00000010H
?OnUserSendCard@CTableFrameSink@@IAE_NEGQAEE@Z ENDP	; CTableFrameSink::OnUserSendCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ReplaceCard$ = -4					; size = 3
_wChairID$ = 8						; size = 2
_cbCardData$ = 12					; size = 1
?OnUserReplaceCard@CTableFrameSink@@IAE_NGE@Z PROC	; CTableFrameSink::OnUserReplaceCard
; _this$ = ecx

; 1779 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1780 : 	//错误断言
; 1781 : 	ASSERT(m_GameLogic.IsValidCard(cbCardData));
; 1782 : 	//效验参数
; 1783 : 	if(!m_GameLogic.IsValidCard(cbCardData))  return false;

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00017	e8 00 00 00 00	 call	 ?IsValidCard@CGameLogic@@QAE_NE@Z ; CGameLogic::IsValidCard
  0001c	0f b6 c8	 movzx	 ecx, al
  0001f	85 c9		 test	 ecx, ecx
  00021	75 07		 jne	 SHORT $LN2@OnUserRepl
  00023	32 c0		 xor	 al, al
  00025	e9 cf 00 00 00	 jmp	 $LN1@OnUserRepl
$LN2@OnUserRepl:

; 1784 : 
; 1785 : 	//删除扑克
; 1786 : 	if (m_GameLogic.RemoveCard(m_cbCardIndex[wChairID], cbCardData)==false)

  0002a	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCardData$[ebp]
  0002e	52		 push	 edx
  0002f	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00033	6b c8 22	 imul	 ecx, eax, 34
  00036	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00039	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  00040	50		 push	 eax
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0004a	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEE@Z ; CGameLogic::RemoveCard
  0004f	0f b6 c8	 movzx	 ecx, al
  00052	85 c9		 test	 ecx, ecx
  00054	75 07		 jne	 SHORT $LN3@OnUserRepl

; 1787 : 	{
; 1788 : 		ASSERT(FALSE);
; 1789 : 		return false;

  00056	32 c0		 xor	 al, al
  00058	e9 9c 00 00 00	 jmp	 $LN1@OnUserRepl
$LN3@OnUserRepl:

; 1790 : 	}
; 1791 : 
; 1792 : 	//状态变量
; 1793 : 	m_enSendStatus = BuHua_Send;

  0005d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00060	c7 82 c8 04 00
	00 03 00 00 00	 mov	 DWORD PTR [edx+1224], 3

; 1794 : 	m_cbGangStatus = WIK_GANERAL;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	c6 80 cc 04 00
	00 00		 mov	 BYTE PTR [eax+1228], 0

; 1795 : 	m_wProvideGangUser = INVALID_CHAIR;

  00074	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	66 89 8a ce 04
	00 00		 mov	 WORD PTR [edx+1230], cx

; 1796 : 
; 1797 : 	//构造数据
; 1798 : 	CMD_S_ReplaceCard ReplaceCard;
; 1799 : 	ReplaceCard.wReplaceUser = wChairID;

  00083	66 8b 45 08	 mov	 ax, WORD PTR _wChairID$[ebp]
  00087	66 89 45 fc	 mov	 WORD PTR _ReplaceCard$[ebp], ax

; 1800 : 	ReplaceCard.cbReplaceCard = cbCardData;

  0008b	8a 4d 0c	 mov	 cl, BYTE PTR _cbCardData$[ebp]
  0008e	88 4d fe	 mov	 BYTE PTR _ReplaceCard$[ebp+2], cl

; 1801 : 
; 1802 : 	//发送消息
; 1803 : 	m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_REPLACE_CARD, &ReplaceCard, sizeof(ReplaceCard));

  00091	68 c8 00 00 00	 push	 200			; 000000c8H
  00096	6a 03		 push	 3
  00098	8d 55 fc	 lea	 edx, DWORD PTR _ReplaceCard$[ebp]
  0009b	52		 push	 edx
  0009c	6a 6b		 push	 107			; 0000006bH
  0009e	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  000ac	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  000b7	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  000bd	ff d2		 call	 edx

; 1804 : 	m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_REPLACE_CARD, &ReplaceCard, sizeof(ReplaceCard));

  000bf	6a 03		 push	 3
  000c1	8d 45 fc	 lea	 eax, DWORD PTR _ReplaceCard$[ebp]
  000c4	50		 push	 eax
  000c5	6a 6b		 push	 107			; 0000006bH
  000c7	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  000d5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 12		 mov	 edx, DWORD PTR [edx]
  000da	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  000e0	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  000e6	ff d0		 call	 eax

; 1805 : 
; 1806 : 	//派发扑克
; 1807 : 	DispatchCardData(wChairID, true);

  000e8	6a 01		 push	 1
  000ea	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  000ee	51		 push	 ecx
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	e8 00 00 00 00	 call	 ?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::DispatchCardData

; 1808 : 
; 1809 : 	return true;

  000f7	b0 01		 mov	 al, 1
$LN1@OnUserRepl:

; 1810 : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 08 00	 ret	 8
?OnUserReplaceCard@CTableFrameSink@@IAE_NGE@Z ENDP	; CTableFrameSink::OnUserReplaceCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_cc$2 = -40						; size = 4
_cc$3 = -36						; size = 4
_i$4 = -32						; size = 4
_this$ = -28						; size = 4
_operatecard$5 = -24					; size = 3
_Trustee$6 = -20					; size = 3
_bChange$ = -14						; size = 1
_cardindex$7 = -13					; size = 1
__$EHRec$ = -12						; size = 12
_wChairID$ = 8						; size = 2
_bTrustee$ = 12						; size = 1
?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z PROC		; CTableFrameSink::OnUserTrustee
; _this$ = ecx

; 1705 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1706 : 	//效验状态
; 1707 : 	ASSERT((wChairID < m_cbPlayerCount));
; 1708 : 	if ((wChairID>=m_cbPlayerCount)) return false;

  00028	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  0002c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	0f b6 51 09	 movzx	 edx, BYTE PTR [ecx+9]
  00033	3b c2		 cmp	 eax, edx
  00035	7c 07		 jl	 SHORT $LN5@OnUserTrus
  00037	32 c0		 xor	 al, al
  00039	e9 f1 02 00 00	 jmp	 $LN1@OnUserTrus
$LN5@OnUserTrus:

; 1709 : 
; 1710 : 	if (IsRoomCardScoreType()) return true;

  0003e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::IsRoomCardScoreType
  00046	0f b6 c0	 movzx	 eax, al
  00049	85 c0		 test	 eax, eax
  0004b	74 07		 je	 SHORT $LN6@OnUserTrus
  0004d	b0 01		 mov	 al, 1
  0004f	e9 db 02 00 00	 jmp	 $LN1@OnUserTrus
$LN6@OnUserTrus:

; 1711 : 
; 1712 : 	bool bChange = false;

  00054	c6 45 f2 00	 mov	 BYTE PTR _bChange$[ebp], 0

; 1713 : 	if (m_bTrustee[wChairID] != bTrustee)

  00058	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0005c	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	0f b6 84 0a 78
	04 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1144]
  00067	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bTrustee$[ebp]
  0006b	3b c1		 cmp	 eax, ecx
  0006d	0f 84 16 01 00
	00		 je	 $LN7@OnUserTrus

; 1714 : 	{
; 1715 : 		m_bTrustee[wChairID] = bTrustee;

  00073	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00077	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8a 4d 0c	 mov	 cl, BYTE PTR _bTrustee$[ebp]
  0007d	88 8c 10 78 04
	00 00		 mov	 BYTE PTR [eax+edx+1144], cl

; 1716 : 		bChange = true;

  00084	c6 45 f2 01	 mov	 BYTE PTR _bChange$[ebp], 1

; 1717 : 		CMD_S_Trustee Trustee;
; 1718 : 		Trustee.bTrustee = bTrustee;

  00088	8a 55 0c	 mov	 dl, BYTE PTR _bTrustee$[ebp]
  0008b	88 55 ec	 mov	 BYTE PTR _Trustee$6[ebp], dl

; 1719 : 		Trustee.wChairID = wChairID;

  0008e	66 8b 45 08	 mov	 ax, WORD PTR _wChairID$[ebp]
  00092	66 89 45 ed	 mov	 WORD PTR _Trustee$6[ebp+1], ax

; 1720 : 		m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_TRUSTEE, &Trustee, sizeof(Trustee));

  00096	68 c8 00 00 00	 push	 200			; 000000c8H
  0009b	6a 03		 push	 3
  0009d	8d 4d ec	 lea	 ecx, DWORD PTR _Trustee$6[ebp]
  000a0	51		 push	 ecx
  000a1	6a 6a		 push	 106			; 0000006aH
  000a3	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000a8	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  000b1	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8b 10		 mov	 edx, DWORD PTR [eax]
  000b6	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  000bc	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  000c2	ff d0		 call	 eax

; 1721 : 		m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_TRUSTEE, &Trustee, sizeof(Trustee));

  000c4	6a 03		 push	 3
  000c6	8d 4d ec	 lea	 ecx, DWORD PTR _Trustee$6[ebp]
  000c9	51		 push	 ecx
  000ca	6a 6a		 push	 106			; 0000006aH
  000cc	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000d1	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  000da	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	8b 10		 mov	 edx, DWORD PTR [eax]
  000df	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  000e5	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  000eb	ff d0		 call	 eax

; 1722 : 
; 1723 : 		if (bTrustee)

  000ed	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _bTrustee$[ebp]
  000f1	85 c9		 test	 ecx, ecx
  000f3	74 4b		 je	 SHORT $LN8@OnUserTrus

; 1724 : 		{
; 1725 : 			CString cc;

  000f5	8d 4d dc	 lea	 ecx, DWORD PTR _cc$3[ebp]
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  000fe	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1726 : 			cc.Format(_T("玩家%d托管"), wChairID);

  00105	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00109	52		 push	 edx
  0010a	68 00 00 00 00	 push	 OFFSET $SG314091
  0010f	8d 45 dc	 lea	 eax, DWORD PTR _cc$3[ebp]
  00112	50		 push	 eax
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1727 : 			WriteDebugInfo(cc);

  0011c	8d 4d dc	 lea	 ecx, DWORD PTR _cc$3[ebp]
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00125	50		 push	 eax
  00126	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1728 : 		}

  0012e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00135	8d 4d dc	 lea	 ecx, DWORD PTR _cc$3[ebp]
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ

; 1729 : 		else

  0013e	eb 49		 jmp	 SHORT $LN7@OnUserTrus
$LN8@OnUserTrus:

; 1730 : 		{
; 1731 : 			CString cc;

  00140	8d 4d d8	 lea	 ecx, DWORD PTR _cc$2[ebp]
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00149	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1732 : 			cc.Format(_T("玩家%d取消托管"), wChairID);

  00150	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00154	51		 push	 ecx
  00155	68 00 00 00 00	 push	 OFFSET $SG314092
  0015a	8d 55 d8	 lea	 edx, DWORD PTR _cc$2[ebp]
  0015d	52		 push	 edx
  0015e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 : 			WriteDebugInfo(cc);

  00167	8d 4d d8	 lea	 ecx, DWORD PTR _cc$2[ebp]
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00170	50		 push	 eax
  00171	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1734 : 		}

  00179	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00180	8d 4d d8	 lea	 ecx, DWORD PTR _cc$2[ebp]
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
$LN7@OnUserTrus:

; 1735 : 	}
; 1736 : 
; 1737 : 	if(bTrustee)

  00189	0f b6 45 0c	 movzx	 eax, BYTE PTR _bTrustee$[ebp]
  0018d	85 c0		 test	 eax, eax
  0018f	0f 84 2f 01 00
	00		 je	 $LN10@OnUserTrus

; 1738 : 	{
; 1739 : 		if(wChairID == m_wCurrentUser)

  00195	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00199	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0019c	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  001a3	3b c8		 cmp	 ecx, eax
  001a5	0f 85 d4 00 00
	00		 jne	 $LN12@OnUserTrus

; 1740 : 		{
; 1741 : 			BYTE cardindex=MAX_INDEX;

  001ab	c6 45 f3 22	 mov	 BYTE PTR _cardindex$7[ebp], 34 ; 00000022H

; 1742 : 			if(m_cbSendCardData != 0 && m_GameLogic.SwitchToCardIndex(m_cbSendCardData) != m_cbMagicIndex)

  001af	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	0f b6 91 3c 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1852]
  001b9	85 d2		 test	 edx, edx
  001bb	74 48		 je	 SHORT $LN14@OnUserTrus
  001bd	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  001c0	0f b6 88 3c 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1852]
  001c7	51		 push	 ecx
  001c8	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  001d1	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  001d6	0f b6 d0	 movzx	 edx, al
  001d9	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  001dc	0f b6 88 7c 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1148]
  001e3	3b d1		 cmp	 edx, ecx
  001e5	74 1e		 je	 SHORT $LN14@OnUserTrus

; 1743 : 				cardindex = m_GameLogic.SwitchToCardIndex(m_cbSendCardData);

  001e7	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  001ea	0f b6 82 3c 07
	00 00		 movzx	 eax, BYTE PTR [edx+1852]
  001f1	50		 push	 eax
  001f2	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001f5	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  001fb	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00200	88 45 f3	 mov	 BYTE PTR _cardindex$7[ebp], al

; 1744 : 			else

  00203	eb 4d		 jmp	 SHORT $LN15@OnUserTrus
$LN14@OnUserTrus:

; 1745 : 			{
; 1746 : 				for(int i=0;i<MAX_INDEX;i++)

  00205	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  0020c	eb 09		 jmp	 SHORT $LN4@OnUserTrus
$LN2@OnUserTrus:
  0020e	8b 4d e0	 mov	 ecx, DWORD PTR _i$4[ebp]
  00211	83 c1 01	 add	 ecx, 1
  00214	89 4d e0	 mov	 DWORD PTR _i$4[ebp], ecx
$LN4@OnUserTrus:
  00217	83 7d e0 22	 cmp	 DWORD PTR _i$4[ebp], 34	; 00000022H
  0021b	7d 35		 jge	 SHORT $LN15@OnUserTrus

; 1747 : 				{
; 1748 : 					if(m_cbCardIndex[wChairID][i]>0 && i !=m_cbMagicIndex)

  0021d	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00221	6b c2 22	 imul	 eax, edx, 34
  00224	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00227	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  0022e	8b 45 e0	 mov	 eax, DWORD PTR _i$4[ebp]
  00231	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00235	85 c9		 test	 ecx, ecx
  00237	7e 17		 jle	 SHORT $LN16@OnUserTrus
  00239	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0023c	0f b6 82 7c 04
	00 00		 movzx	 eax, BYTE PTR [edx+1148]
  00243	39 45 e0	 cmp	 DWORD PTR _i$4[ebp], eax
  00246	74 08		 je	 SHORT $LN16@OnUserTrus

; 1749 : 					{
; 1750 : 						cardindex = i;

  00248	8a 4d e0	 mov	 cl, BYTE PTR _i$4[ebp]
  0024b	88 4d f3	 mov	 BYTE PTR _cardindex$7[ebp], cl

; 1751 : 						break;

  0024e	eb 02		 jmp	 SHORT $LN15@OnUserTrus
$LN16@OnUserTrus:

; 1752 : 					}
; 1753 : 				}

  00250	eb bc		 jmp	 SHORT $LN2@OnUserTrus
$LN15@OnUserTrus:

; 1754 : 			}
; 1755 : 
; 1756 : 			ASSERT(cardindex != MAX_INDEX);
; 1757 : 			return OnUserOutCard(wChairID,m_GameLogic.SwitchToCardData(cardindex),true);

  00252	6a 01		 push	 1
  00254	0f b6 55 f3	 movzx	 edx, BYTE PTR _cardindex$7[ebp]
  00258	52		 push	 edx
  00259	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0025c	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00262	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardData
  00267	0f b6 c0	 movzx	 eax, al
  0026a	50		 push	 eax
  0026b	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0026f	51		 push	 ecx
  00270	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00273	e8 00 00 00 00	 call	 ?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z ; CTableFrameSink::OnUserOutCard
  00278	e9 b2 00 00 00	 jmp	 $LN1@OnUserTrus
  0027d	eb 43		 jmp	 SHORT $LN13@OnUserTrus
$LN12@OnUserTrus:

; 1758 : 		}
; 1759 : 		else if(m_wCurrentUser == INVALID_CHAIR && m_cbUserAction[wChairID] != WIK_NULL)

  0027f	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00282	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  00289	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0028e	75 32		 jne	 SHORT $LN13@OnUserTrus
  00290	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00294	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00297	0f b6 84 0a e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1508]
  0029f	85 c0		 test	 eax, eax
  002a1	74 1f		 je	 SHORT $LN13@OnUserTrus

; 1760 : 		{
; 1761 : 			BYTE operatecard[3]={0};

  002a3	c6 45 e8 00	 mov	 BYTE PTR _operatecard$5[ebp], 0
  002a7	33 c9		 xor	 ecx, ecx
  002a9	66 89 4d e9	 mov	 WORD PTR _operatecard$5[ebp+1], cx

; 1762 : 			return OnUserOperateCard(wChairID,WIK_NULL,operatecard);

  002ad	8d 55 e8	 lea	 edx, DWORD PTR _operatecard$5[ebp]
  002b0	52		 push	 edx
  002b1	6a 00		 push	 0
  002b3	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  002b7	50		 push	 eax
  002b8	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  002bb	e8 00 00 00 00	 call	 ?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z ; CTableFrameSink::OnUserOperateCard
  002c0	eb 6d		 jmp	 SHORT $LN1@OnUserTrus
$LN13@OnUserTrus:

; 1763 : 		}
; 1764 : 	}
; 1765 : 	else

  002c2	eb 69		 jmp	 SHORT $LN11@OnUserTrus
$LN10@OnUserTrus:

; 1766 : 	{
; 1767 : 		if (m_wCurrentUser == wChairID && bChange)

  002c4	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  002ce	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  002d2	3b d0		 cmp	 edx, eax
  002d4	75 57		 jne	 SHORT $LN11@OnUserTrus
  002d6	0f b6 4d f2	 movzx	 ecx, BYTE PTR _bChange$[ebp]
  002da	85 c9		 test	 ecx, ecx
  002dc	74 4f		 je	 SHORT $LN11@OnUserTrus

; 1768 : 		{
; 1769 : 			m_pITableFrame->SetGameTimer(IDI_OUT_CARD, m_pGameCustomRule->cbTimeOutCard*1000, 1, 0);

  002de	6a 00		 push	 0
  002e0	6a 01		 push	 1
  002e2	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  002e5	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  002eb	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  002ef	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  002f5	52		 push	 edx
  002f6	6a 03		 push	 3
  002f8	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  002fb	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00301	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00304	8b 01		 mov	 eax, DWORD PTR [ecx]
  00306	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0030c	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  00312	ff d2		 call	 edx

; 1770 : 			m_tActionStartTime = time(0);

  00314	6a 00		 push	 0
  00316	e8 00 00 00 00	 call	 _time
  0031b	83 c4 04	 add	 esp, 4
  0031e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00321	89 81 a8 04 00
	00		 mov	 DWORD PTR [ecx+1192], eax
  00327	89 91 ac 04 00
	00		 mov	 DWORD PTR [ecx+1196], edx
$LN11@OnUserTrus:

; 1771 : 		}
; 1772 : 	}
; 1773 : 
; 1774 : 	return true;

  0032d	b0 01		 mov	 al, 1
$LN1@OnUserTrus:

; 1775 : }

  0032f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00332	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00339	59		 pop	 ecx
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _cc$3[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR _cc$2[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z ENDP		; CTableFrameSink::OnUserTrustee
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_i$1 = -92						; size = 4
_this$ = -88						; size = 4
_ListenCard$2 = -84					; size = 38
_ListenCard$3 = -44					; size = 38
__$ArrayPad$ = -4					; size = 4
_wChairID$ = 8						; size = 2
_bListenCard$ = 12					; size = 1
?OnUserListenCard@CTableFrameSink@@IAE_NG_N@Z PROC	; CTableFrameSink::OnUserListenCard
; _this$ = ecx

; 1649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 1650 : 	if(bListenCard)

  00013	0f b6 45 0c	 movzx	 eax, BYTE PTR _bListenCard$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	0f 84 c6 01 00
	00		 je	 $LN5@OnUserList

; 1651 : 	{
; 1652 : 		ASSERT(!m_bTing[wChairID]);
; 1653 : 		if(WIK_LISTEN == m_GameLogic.AnalyseTingCard(m_cbCardIndex[wChairID], m_WeaveItemArray[wChairID], m_cbWeaveItemCount[wChairID]))

  0001f	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00023	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	0f b6 84 0a 3e
	08 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2110]
  0002e	50		 push	 eax
  0002f	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00033	6b d1 24	 imul	 edx, ecx, 36
  00036	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  00040	51		 push	 ecx
  00041	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00045	6b c2 22	 imul	 eax, edx, 34
  00048	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00052	52		 push	 edx
  00053	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0005c	e8 00 00 00 00	 call	 ?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@E@Z ; CGameLogic::AnalyseTingCard
  00061	0f b6 c0	 movzx	 eax, al
  00064	83 f8 20	 cmp	 eax, 32			; 00000020H
  00067	0f 85 72 01 00
	00		 jne	 $LN7@OnUserList

; 1654 : 		{
; 1655 : 			m_bTing[wChairID] = true;

  0006d	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00071	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00074	c6 84 0a 74 04
	00 00 01	 mov	 BYTE PTR [edx+ecx+1140], 1

; 1656 : 			CMD_S_ListenCard ListenCard;
; 1657 : 			ZeroMemory(&ListenCard,sizeof(ListenCard));

  0007c	6a 26		 push	 38			; 00000026H
  0007e	6a 00		 push	 0
  00080	8d 45 d4	 lea	 eax, DWORD PTR _ListenCard$3[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _memset
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1658 : 
; 1659 : 			ListenCard.wListenUser = wChairID;

  0008c	66 8b 4d 08	 mov	 cx, WORD PTR _wChairID$[ebp]
  00090	66 89 4d d4	 mov	 WORD PTR _ListenCard$3[ebp], cx

; 1660 : 			ListenCard.bListen = true;

  00094	c6 45 d6 01	 mov	 BYTE PTR _ListenCard$3[ebp+2], 1

; 1661 : 			//发给消息
; 1662 : 			m_pITableFrame->SendLookonData(INVALID_CHAIR,SUB_S_LISTEN_CARD,&ListenCard,sizeof(ListenCard));

  00098	6a 26		 push	 38			; 00000026H
  0009a	8d 55 d4	 lea	 edx, DWORD PTR _ListenCard$3[ebp]
  0009d	52		 push	 edx
  0009e	6a 69		 push	 105			; 00000069H
  000a0	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000a5	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  000ae	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  000b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b3	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  000b9	8b 90 b8 00 00
	00		 mov	 edx, DWORD PTR [eax+184]
  000bf	ff d2		 call	 edx

; 1663 : 
; 1664 : 			for(int i=0;i<m_cbPlayerCount;i++)

  000c1	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  000c8	eb 09		 jmp	 SHORT $LN4@OnUserList
$LN2@OnUserList:
  000ca	8b 45 a4	 mov	 eax, DWORD PTR _i$1[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 a4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@OnUserList:
  000d3	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	0f b6 51 09	 movzx	 edx, BYTE PTR [ecx+9]
  000da	39 55 a4	 cmp	 DWORD PTR _i$1[ebp], edx
  000dd	7d 39		 jge	 SHORT $LN3@OnUserList

; 1665 : 			{
; 1666 : 				if( i != wChairID)

  000df	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  000e3	39 45 a4	 cmp	 DWORD PTR _i$1[ebp], eax
  000e6	74 2e		 je	 SHORT $LN9@OnUserList

; 1667 : 					m_pITableFrame->SendTableData(i,SUB_S_LISTEN_CARD,&ListenCard,sizeof(ListenCard));

  000e8	68 c8 00 00 00	 push	 200			; 000000c8H
  000ed	6a 26		 push	 38			; 00000026H
  000ef	8d 4d d4	 lea	 ecx, DWORD PTR _ListenCard$3[ebp]
  000f2	51		 push	 ecx
  000f3	6a 69		 push	 105			; 00000069H
  000f5	0f b7 55 a4	 movzx	 edx, WORD PTR _i$1[ebp]
  000f9	52		 push	 edx
  000fa	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00103	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00106	8b 01		 mov	 eax, DWORD PTR [ecx]
  00108	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0010e	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00114	ff d2		 call	 edx
$LN9@OnUserList:

; 1668 : 			}

  00116	eb b2		 jmp	 SHORT $LN2@OnUserList
$LN3@OnUserList:

; 1669 : 
; 1670 : 			//计算胡几张字
; 1671 : 			m_cbHuCardCount[wChairID] = m_GameLogic.GetHuCard(m_cbCardIndex[wChairID],m_WeaveItemArray[wChairID],m_cbWeaveItemCount[wChairID],m_cbHuCardData[wChairID]);

  00118	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  0011c	6b c8 22	 imul	 ecx, eax, 34
  0011f	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00122	8d 84 0a 54 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1364]
  00129	50		 push	 eax
  0012a	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0012e	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00131	0f b6 84 0a 3e
	08 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2110]
  00139	50		 push	 eax
  0013a	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0013e	6b d1 24	 imul	 edx, ecx, 36
  00141	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00144	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  0014b	51		 push	 ecx
  0014c	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00150	6b c2 22	 imul	 eax, edx, 34
  00153	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  0015d	52		 push	 edx
  0015e	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00167	e8 00 00 00 00	 call	 ?GetHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EQAE@Z ; CGameLogic::GetHuCard
  0016c	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00170	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00173	88 84 0a 50 05
	00 00		 mov	 BYTE PTR [edx+ecx+1360], al

; 1672 : 			ASSERT(m_cbHuCardCount[wChairID]>0);
; 1673 : 			ListenCard.cbHuCardCount = m_cbHuCardCount[wChairID];

  0017a	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  0017e	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	8a 94 01 50 05
	00 00		 mov	 dl, BYTE PTR [ecx+eax+1360]
  00188	88 55 d7	 mov	 BYTE PTR _ListenCard$3[ebp+3], dl

; 1674 : 			CopyMemory(ListenCard.cbHuCardData,m_cbHuCardData[wChairID],sizeof(ListenCard.cbHuCardData));

  0018b	6a 22		 push	 34			; 00000022H
  0018d	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00191	6b c8 22	 imul	 ecx, eax, 34
  00194	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00197	8d 84 0a 54 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1364]
  0019e	50		 push	 eax
  0019f	8d 4d d8	 lea	 ecx, DWORD PTR _ListenCard$3[ebp+4]
  001a2	51		 push	 ecx
  001a3	e8 00 00 00 00	 call	 _memcpy
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1675 : 
; 1676 : 			m_pITableFrame->SendTableData(wChairID,SUB_S_LISTEN_CARD,&ListenCard,sizeof(ListenCard));

  001ab	68 c8 00 00 00	 push	 200			; 000000c8H
  001b0	6a 26		 push	 38			; 00000026H
  001b2	8d 55 d4	 lea	 edx, DWORD PTR _ListenCard$3[ebp]
  001b5	52		 push	 edx
  001b6	6a 69		 push	 105			; 00000069H
  001b8	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  001bc	50		 push	 eax
  001bd	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c0	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  001c6	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001c9	8b 12		 mov	 edx, DWORD PTR [edx]
  001cb	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  001d1	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  001d7	ff d0		 call	 eax

; 1677 : 			
; 1678 : 
; 1679 : 			return true;

  001d9	b0 01		 mov	 al, 1
  001db	eb 7c		 jmp	 SHORT $LN1@OnUserList

; 1680 : 		}
; 1681 : 		else

  001dd	eb 04		 jmp	 SHORT $LN8@OnUserList
$LN7@OnUserList:

; 1682 : 		{
; 1683 : 			return false;

  001df	32 c0		 xor	 al, al
  001e1	eb 76		 jmp	 SHORT $LN1@OnUserList
$LN8@OnUserList:

; 1684 : 		}
; 1685 : 	}
; 1686 : 	else

  001e3	eb 74		 jmp	 SHORT $LN1@OnUserList
$LN5@OnUserList:

; 1687 : 	{
; 1688 : 
; 1689 : 		ASSERT(m_bTing[wChairID]);
; 1690 : 		m_bTing[wChairID] = false;

  001e5	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  001e9	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  001ec	c6 84 0a 74 04
	00 00 00	 mov	 BYTE PTR [edx+ecx+1140], 0

; 1691 : 
; 1692 : 		CMD_S_ListenCard ListenCard;
; 1693 : 		ListenCard.wListenUser = wChairID;

  001f4	66 8b 45 08	 mov	 ax, WORD PTR _wChairID$[ebp]
  001f8	66 89 45 ac	 mov	 WORD PTR _ListenCard$2[ebp], ax

; 1694 : 		ListenCard.bListen = false;

  001fc	c6 45 ae 00	 mov	 BYTE PTR _ListenCard$2[ebp+2], 0

; 1695 : 
; 1696 : 		//发送消息
; 1697 : 		m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_LISTEN_CARD, &ListenCard, sizeof(ListenCard));

  00200	68 c8 00 00 00	 push	 200			; 000000c8H
  00205	6a 26		 push	 38			; 00000026H
  00207	8d 4d ac	 lea	 ecx, DWORD PTR _ListenCard$2[ebp]
  0020a	51		 push	 ecx
  0020b	6a 69		 push	 105			; 00000069H
  0020d	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00212	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  00215	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  0021b	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	8b 10		 mov	 edx, DWORD PTR [eax]
  00220	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00226	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  0022c	ff d0		 call	 eax

; 1698 : 		m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_LISTEN_CARD, &ListenCard, sizeof(ListenCard));

  0022e	6a 26		 push	 38			; 00000026H
  00230	8d 4d ac	 lea	 ecx, DWORD PTR _ListenCard$2[ebp]
  00233	51		 push	 ecx
  00234	6a 69		 push	 105			; 00000069H
  00236	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0023b	8b 55 a8	 mov	 edx, DWORD PTR _this$[ebp]
  0023e	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00244	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00247	8b 10		 mov	 edx, DWORD PTR [eax]
  00249	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  0024f	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  00255	ff d0		 call	 eax

; 1699 : 		return true;

  00257	b0 01		 mov	 al, 1
$LN1@OnUserList:

; 1700 : 	}
; 1701 : }

  00259	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025c	33 cd		 xor	 ecx, ebp
  0025e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c2 08 00	 ret	 8
?OnUserListenCard@CTableFrameSink@@IAE_NG_N@Z ENDP	; CTableFrameSink::OnUserListenCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_pWeaveItem$2 = -984					; size = 4
_pWeaveItem$3 = -980					; size = 4
tv990 = -976						; size = 4
_cc$4 = -972						; size = 4
tv493 = -968						; size = 4
_i$5 = -964						; size = 4
_cbRemoveCard$6 = -960					; size = 3
tv633 = -954						; size = 2
_cbRemoveCard$7 = -952					; size = 2
tv405 = -948						; size = 2
tv873 = -946						; size = 2
_j$8 = -944						; size = 4
$T9 = -940						; size = 1
$T10 = -939						; size = 1
$T11 = -938						; size = 1
$T12 = -937						; size = 1
_i$13 = -936						; size = 4
$T14 = -929						; size = 1
_wProvideUser$15 = -928					; size = 2
_cbWeaveKind$16 = -924					; size = 1
$T17 = -923						; size = 1
$T18 = -922						; size = 1
$T19 = -921						; size = 1
_cbCenterCard$20 = -920					; size = 1
_cbWeaveItemCount$21 = -919				; size = 1
_cbWeaveItemCount$22 = -918				; size = 1
$T23 = -917						; size = 1
$T24 = -916						; size = 1
$T25 = -915						; size = 1
_cbTargetActionRank$26 = -914				; size = 1
_cbUserActionRank$27 = -913				; size = 1
_i$28 = -912						; size = 2
_bAroseAction$29 = -905					; size = 1
_cbCount$30 = -904					; size = 1
tv273 = -903						; size = 1
_cbUserAction$31 = -902					; size = 1
tv206 = -901						; size = 1
_cc$32 = -900						; size = 4
_i$33 = -896						; size = 2
_cbCardIndex$34 = -889					; size = 1
_wChiHuUser$35 = -888					; size = 2
_cbGangKind$36 = -882					; size = 1
_j$37 = -881						; size = 1
_wIndex$38 = -880					; size = 2
_i$39 = -876						; size = 1
_cbWeaveIndex$40 = -875					; size = 1
_cbTargetCard$41 = -874					; size = 1
_cbTargetAction$42 = -873				; size = 1
_wTargetUser$43 = -872					; size = 2
_this$ = -868						; size = 4
_HuData$44 = -864					; size = 813
_gcr$45 = -48						; size = 5
_OperateResult$46 = -40					; size = 9
_OperateResult$47 = -28					; size = 9
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wChairID$ = 8						; size = 2
_cbOperateCode$ = 12					; size = 1
_cbOperateCard$ = 16					; size = 4
?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z PROC	; CTableFrameSink::OnUserOperateCard
; _this$ = ecx

; 1161 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 03 00
	00		 sub	 esp, 972		; 000003ccH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 8d 9c fc ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1162 : 	//效验状态
; 1163 : 	ASSERT(m_pITableFrame->GetGameStatus() == GAME_SCENE_PLAY);
; 1164 : 	if (m_pITableFrame->GetGameStatus() != GAME_SCENE_PLAY) return true;

  00032	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  0003e	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 01		 mov	 eax, DWORD PTR [ecx]
  00046	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  0004c	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  0004f	ff d2		 call	 edx
  00051	0f b6 c0	 movzx	 eax, al
  00054	83 f8 64	 cmp	 eax, 100		; 00000064H
  00057	74 07		 je	 SHORT $LN27@OnUserOper
  00059	b0 01		 mov	 al, 1
  0005b	e9 48 1b 00 00	 jmp	 $LN1@OnUserOper
$LN27@OnUserOper:

; 1165 : 
; 1166 : 	//效验用户 注意：AI有可能发生此断言
; 1167 : 	ASSERT((wChairID == m_wCurrentUser) || (m_wCurrentUser == INVALID_CHAIR));
; 1168 : 	if ((wChairID != m_wCurrentUser) && (m_wCurrentUser != INVALID_CHAIR))  return true;

  00060	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00064	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0006a	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  00071	3b c8		 cmp	 ecx, eax
  00073	74 1c		 je	 SHORT $LN28@OnUserOper
  00075	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  00082	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00088	74 07		 je	 SHORT $LN28@OnUserOper
  0008a	b0 01		 mov	 al, 1
  0008c	e9 17 1b 00 00	 jmp	 $LN1@OnUserOper
$LN28@OnUserOper:

; 1169 : 
; 1170 :  	//被动动作
; 1171 :  	if (m_wCurrentUser == INVALID_CHAIR)

  00091	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00097	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  0009e	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  000a4	0f 85 36 13 00
	00		 jne	 $LN29@OnUserOper

; 1172 :  	{
; 1173 :  		//效验状态
; 1174 :  		ASSERT(!m_bResponse[wChairID]);
; 1175 :  		ASSERT(m_cbUserAction[wChairID] != WIK_NULL);
; 1176 :  		ASSERT((cbOperateCode == WIK_NULL) || ((m_cbUserAction[wChairID]&cbOperateCode) != 0));
; 1177 :  
; 1178 :  		//效验状态
; 1179 :  		if (m_bResponse[wChairID]) return true;

  000aa	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  000ae	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b4	0f b6 8c 10 e0
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1504]
  000bc	85 c9		 test	 ecx, ecx
  000be	74 07		 je	 SHORT $LN30@OnUserOper
  000c0	b0 01		 mov	 al, 1
  000c2	e9 e1 1a 00 00	 jmp	 $LN1@OnUserOper
$LN30@OnUserOper:

; 1180 :  		if(m_cbUserAction[wChairID] == WIK_NULL) return true;

  000c7	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  000cb	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000d1	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  000d9	85 c9		 test	 ecx, ecx
  000db	75 07		 jne	 SHORT $LN31@OnUserOper
  000dd	b0 01		 mov	 al, 1
  000df	e9 c4 1a 00 00	 jmp	 $LN1@OnUserOper
$LN31@OnUserOper:

; 1181 :  		if ((cbOperateCode!=WIK_NULL) && ((m_cbUserAction[wChairID]&cbOperateCode) == 0)) return true;

  000e4	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbOperateCode$[ebp]
  000e8	85 d2		 test	 edx, edx
  000ea	74 21		 je	 SHORT $LN32@OnUserOper
  000ec	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  000f0	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	0f b6 94 01 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1508]
  000fe	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbOperateCode$[ebp]
  00102	23 d0		 and	 edx, eax
  00104	75 07		 jne	 SHORT $LN32@OnUserOper
  00106	b0 01		 mov	 al, 1
  00108	e9 9b 1a 00 00	 jmp	 $LN1@OnUserOper
$LN32@OnUserOper:

; 1182 :  
; 1183 : 		CString cc;

  0010d	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00119	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1184 : 		cc.Format(_T("被动动作 玩家%d执行操作%d"), wChairID, cbOperateCode);

  00120	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbOperateCode$[ebp]
  00124	51		 push	 ecx
  00125	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00129	52		 push	 edx
  0012a	68 00 00 00 00	 push	 OFFSET $SG313985
  0012f	8d 85 7c fc ff
	ff		 lea	 eax, DWORD PTR _cc$32[ebp]
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  0013c	83 c4 10	 add	 esp, 16			; 00000010H

; 1185 : 		WriteDebugInfo(cc);

  0013f	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  0014b	50		 push	 eax
  0014c	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00152	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1186 :  		//变量定义
; 1187 :  		WORD wTargetUser = wChairID;

  00157	66 8b 4d 08	 mov	 cx, WORD PTR _wChairID$[ebp]
  0015b	66 89 8d 98 fc
	ff ff		 mov	 WORD PTR _wTargetUser$43[ebp], cx

; 1188 :  		BYTE cbTargetAction = cbOperateCode;

  00162	8a 55 0c	 mov	 dl, BYTE PTR _cbOperateCode$[ebp]
  00165	88 95 97 fc ff
	ff		 mov	 BYTE PTR _cbTargetAction$42[ebp], dl

; 1189 :  
; 1190 :  		//设置变量
; 1191 : 		m_bEnjoinGang[wTargetUser] = false;

  0016b	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00172	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00178	c6 84 01 d8 04
	00 00 00	 mov	 BYTE PTR [ecx+eax+1240], 0

; 1192 :  		m_bResponse[wTargetUser] = true;

  00180	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00187	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0018d	c6 84 10 e0 05
	00 00 01	 mov	 BYTE PTR [eax+edx+1504], 1

; 1193 :  		m_cbPerformAction[wTargetUser] = cbOperateCode;

  00195	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  0019c	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001a2	8a 45 0c	 mov	 al, BYTE PTR _cbOperateCode$[ebp]
  001a5	88 84 0a f4 05
	00 00		 mov	 BYTE PTR [edx+ecx+1524], al

; 1194 :  		if(cbOperateCard[0] == 0)

  001ac	b9 01 00 00 00	 mov	 ecx, 1
  001b1	6b d1 00	 imul	 edx, ecx, 0
  001b4	8b 45 10	 mov	 eax, DWORD PTR _cbOperateCard$[ebp]
  001b7	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  001bb	85 c9		 test	 ecx, ecx
  001bd	75 30		 jne	 SHORT $LN33@OnUserOper

; 1195 : 		{
; 1196 : 			m_cbOperateCard[wTargetUser][0] = m_cbProvideCard;

  001bf	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  001c6	6b c2 03	 imul	 eax, edx, 3
  001c9	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	8d 94 01 e8 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1512]
  001d6	b8 01 00 00 00	 mov	 eax, 1
  001db	6b c8 00	 imul	 ecx, eax, 0
  001de	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001e4	8a 80 c2 04 00
	00		 mov	 al, BYTE PTR [eax+1218]
  001ea	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1197 : 		}
; 1198 :  		else 

  001ed	eb 26		 jmp	 SHORT $LN35@OnUserOper
$LN33@OnUserOper:

; 1199 : 		{
; 1200 : 			CopyMemory(m_cbOperateCard[wTargetUser], cbOperateCard, sizeof(m_cbOperateCard[wTargetUser]));

  001ef	6a 03		 push	 3
  001f1	8b 4d 10	 mov	 ecx, DWORD PTR _cbOperateCard$[ebp]
  001f4	51		 push	 ecx
  001f5	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  001fc	6b c2 03	 imul	 eax, edx, 3
  001ff	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00205	8d 94 01 e8 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1512]
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 _memcpy
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@OnUserOper:

; 1201 : 		}
; 1202 :  
; 1203 : 		//放弃操作
; 1204 : 		if (cbTargetAction == WIK_NULL)
; 1205 : 		{
; 1206 : 			////禁止这轮吃胡
; 1207 : 			//if((m_cbUserAction[wTargetUser] & WIK_CHI_HU) != 0)
; 1208 : 			//{
; 1209 : 			//	m_bEnjoinChiHu[wTargetUser]=true;
; 1210 : 			//	m_vecEnjoinChiHu[wTargetUser].push_back(m_cbProvideCard);
; 1211 : 			//}
; 1212 : 			////禁止吃碰杠这张牌
; 1213 : 			//if((m_cbUserAction[wTargetUser] & WIK_PENG) != 0)
; 1214 : 			//{
; 1215 : 			//	m_vecEnjoinChiPeng[wTargetUser].push_back(m_cbProvideCard);
; 1216 : 			//}
; 1217 : 		}
; 1218 : 
; 1219 :  		//执行判断
; 1220 :  		for (WORD i = 0; i < m_cbPlayerCount; i++)

  00215	33 c9		 xor	 ecx, ecx
  00217	66 89 8d 80 fc
	ff ff		 mov	 WORD PTR _i$33[ebp], cx
  0021e	eb 12		 jmp	 SHORT $LN4@OnUserOper
$LN2@OnUserOper:
  00220	66 8b 95 80 fc
	ff ff		 mov	 dx, WORD PTR _i$33[ebp]
  00227	66 83 c2 01	 add	 dx, 1
  0022b	66 89 95 80 fc
	ff ff		 mov	 WORD PTR _i$33[ebp], dx
$LN4@OnUserOper:
  00232	0f b7 85 80 fc
	ff ff		 movzx	 eax, WORD PTR _i$33[ebp]
  00239	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0023f	0f b6 51 09	 movzx	 edx, BYTE PTR [ecx+9]
  00243	3b c2		 cmp	 eax, edx
  00245	0f 8d ca 00 00
	00		 jge	 $LN3@OnUserOper

; 1221 :  		{
; 1222 :  			//获取动作
; 1223 :  			BYTE cbUserAction = (!m_bResponse[i]) ? m_cbUserAction[i] : m_cbPerformAction[i];

  0024b	0f b7 85 80 fc
	ff ff		 movzx	 eax, WORD PTR _i$33[ebp]
  00252	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00258	0f b6 94 01 e0
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1504]
  00260	85 d2		 test	 edx, edx
  00262	75 1c		 jne	 SHORT $LN86@OnUserOper
  00264	0f b7 85 80 fc
	ff ff		 movzx	 eax, WORD PTR _i$33[ebp]
  0026b	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00271	8a 94 01 e4 05
	00 00		 mov	 dl, BYTE PTR [ecx+eax+1508]
  00278	88 95 7b fc ff
	ff		 mov	 BYTE PTR tv206[ebp], dl
  0027e	eb 1a		 jmp	 SHORT $LN87@OnUserOper
$LN86@OnUserOper:
  00280	0f b7 85 80 fc
	ff ff		 movzx	 eax, WORD PTR _i$33[ebp]
  00287	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0028d	8a 94 01 f4 05
	00 00		 mov	 dl, BYTE PTR [ecx+eax+1524]
  00294	88 95 7b fc ff
	ff		 mov	 BYTE PTR tv206[ebp], dl
$LN87@OnUserOper:
  0029a	8a 85 7b fc ff
	ff		 mov	 al, BYTE PTR tv206[ebp]
  002a0	88 85 7a fc ff
	ff		 mov	 BYTE PTR _cbUserAction$31[ebp], al

; 1224 : 
; 1225 :  			//优先级别
; 1226 :  			BYTE cbUserActionRank = m_GameLogic.GetUserActionRank(cbUserAction);

  002a6	0f b6 8d 7a fc
	ff ff		 movzx	 ecx, BYTE PTR _cbUserAction$31[ebp]
  002ad	51		 push	 ecx
  002ae	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002b4	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  002ba	e8 00 00 00 00	 call	 ?GetUserActionRank@CGameLogic@@QAEEE@Z ; CGameLogic::GetUserActionRank
  002bf	88 85 6f fc ff
	ff		 mov	 BYTE PTR _cbUserActionRank$27[ebp], al

; 1227 :  			BYTE cbTargetActionRank = m_GameLogic.GetUserActionRank(cbTargetAction);

  002c5	0f b6 95 97 fc
	ff ff		 movzx	 edx, BYTE PTR _cbTargetAction$42[ebp]
  002cc	52		 push	 edx
  002cd	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  002d9	e8 00 00 00 00	 call	 ?GetUserActionRank@CGameLogic@@QAEEE@Z ; CGameLogic::GetUserActionRank
  002de	88 85 6e fc ff
	ff		 mov	 BYTE PTR _cbTargetActionRank$26[ebp], al

; 1228 :  
; 1229 :  			//动作判断
; 1230 :  			if (cbUserActionRank > cbTargetActionRank)

  002e4	0f b6 85 6f fc
	ff ff		 movzx	 eax, BYTE PTR _cbUserActionRank$27[ebp]
  002eb	0f b6 8d 6e fc
	ff ff		 movzx	 ecx, BYTE PTR _cbTargetActionRank$26[ebp]
  002f2	3b c1		 cmp	 eax, ecx
  002f4	7e 1a		 jle	 SHORT $LN36@OnUserOper

; 1231 :  			{
; 1232 :  				wTargetUser = i;

  002f6	66 8b 95 80 fc
	ff ff		 mov	 dx, WORD PTR _i$33[ebp]
  002fd	66 89 95 98 fc
	ff ff		 mov	 WORD PTR _wTargetUser$43[ebp], dx

; 1233 :  				cbTargetAction = cbUserAction;

  00304	8a 85 7a fc ff
	ff		 mov	 al, BYTE PTR _cbUserAction$31[ebp]
  0030a	88 85 97 fc ff
	ff		 mov	 BYTE PTR _cbTargetAction$42[ebp], al
$LN36@OnUserOper:

; 1234 :  			}
; 1235 :  		}

  00310	e9 0b ff ff ff	 jmp	 $LN2@OnUserOper
$LN3@OnUserOper:

; 1236 :  		if (!m_bResponse[wTargetUser]) 

  00315	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  0031c	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00322	0f b6 84 0a e0
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1504]
  0032a	85 c0		 test	 eax, eax
  0032c	75 25		 jne	 SHORT $LN37@OnUserOper

; 1237 :  			return true;

  0032e	c6 85 6d fc ff
	ff 01		 mov	 BYTE PTR $T25[ebp], 1
  00335	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0033c	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00348	8a 85 6d fc ff
	ff		 mov	 al, BYTE PTR $T25[ebp]
  0034e	e9 55 18 00 00	 jmp	 $LN1@OnUserOper
$LN37@OnUserOper:

; 1238 :  
; 1239 :  		//吃胡等待
; 1240 :  		if (cbTargetAction == WIK_CHI_HU)

  00353	0f b6 8d 97 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbTargetAction$42[ebp]
  0035a	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0035d	0f 85 83 00 00
	00		 jne	 $LN38@OnUserOper

; 1241 :  		{
; 1242 :  			for (WORD i = 0; i < GAME_PLAYER; i++)

  00363	33 d2		 xor	 edx, edx
  00365	66 89 95 70 fc
	ff ff		 mov	 WORD PTR _i$28[ebp], dx
  0036c	eb 12		 jmp	 SHORT $LN7@OnUserOper
$LN5@OnUserOper:
  0036e	66 8b 85 70 fc
	ff ff		 mov	 ax, WORD PTR _i$28[ebp]
  00375	66 83 c0 01	 add	 ax, 1
  00379	66 89 85 70 fc
	ff ff		 mov	 WORD PTR _i$28[ebp], ax
$LN7@OnUserOper:
  00380	0f b7 8d 70 fc
	ff ff		 movzx	 ecx, WORD PTR _i$28[ebp]
  00387	83 f9 04	 cmp	 ecx, 4
  0038a	7d 5a		 jge	 SHORT $LN38@OnUserOper

; 1243 :  			{
; 1244 :  				if (!m_bResponse[i] && (m_cbUserAction[i]&WIK_CHI_HU))

  0038c	0f b7 95 70 fc
	ff ff		 movzx	 edx, WORD PTR _i$28[ebp]
  00393	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00399	0f b6 8c 10 e0
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1504]
  003a1	85 c9		 test	 ecx, ecx
  003a3	75 3f		 jne	 SHORT $LN39@OnUserOper
  003a5	0f b7 95 70 fc
	ff ff		 movzx	 edx, WORD PTR _i$28[ebp]
  003ac	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003b2	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  003ba	83 e1 40	 and	 ecx, 64			; 00000040H
  003bd	74 25		 je	 SHORT $LN39@OnUserOper

; 1245 :  					return true;

  003bf	c6 85 6c fc ff
	ff 01		 mov	 BYTE PTR $T24[ebp], 1
  003c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003cd	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  003d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  003d9	8a 85 6c fc ff
	ff		 mov	 al, BYTE PTR $T24[ebp]
  003df	e9 c4 17 00 00	 jmp	 $LN1@OnUserOper
$LN39@OnUserOper:

; 1246 :  			}

  003e4	eb 88		 jmp	 SHORT $LN5@OnUserOper
$LN38@OnUserOper:

; 1247 :  		}
; 1248 :  
; 1249 : 		//关闭定时器
; 1250 : 		m_pITableFrame->KillGameTimer(IDI_OPERATE_CARD);

  003e6	6a 04		 push	 4
  003e8	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003ee	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  003f4	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003fa	8b 10		 mov	 edx, DWORD PTR [eax]
  003fc	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00402	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00408	ff d0		 call	 eax

; 1251 : 
; 1252 :  		//放弃操作
; 1253 :  		if (cbTargetAction == WIK_NULL)

  0040a	0f b6 8d 97 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbTargetAction$42[ebp]
  00411	85 c9		 test	 ecx, ecx
  00413	0f 85 ca 00 00
	00		 jne	 $LN40@OnUserOper

; 1254 :  		{
; 1255 : 			//用户状态
; 1256 :  			ZeroMemory(m_bResponse, sizeof(m_bResponse));

  00419	6a 04		 push	 4
  0041b	6a 00		 push	 0
  0041d	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00423	81 c2 e0 05 00
	00		 add	 edx, 1504		; 000005e0H
  00429	52		 push	 edx
  0042a	e8 00 00 00 00	 call	 _memset
  0042f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1257 :  			ZeroMemory(m_cbUserAction, sizeof(m_cbUserAction));

  00432	6a 04		 push	 4
  00434	6a 00		 push	 0
  00436	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0043c	05 e4 05 00 00	 add	 eax, 1508		; 000005e4H
  00441	50		 push	 eax
  00442	e8 00 00 00 00	 call	 _memset
  00447	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1258 :  			ZeroMemory(m_cbOperateCard, sizeof(m_cbOperateCard));

  0044a	6a 0c		 push	 12			; 0000000cH
  0044c	6a 00		 push	 0
  0044e	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00454	81 c1 e8 05 00
	00		 add	 ecx, 1512		; 000005e8H
  0045a	51		 push	 ecx
  0045b	e8 00 00 00 00	 call	 _memset
  00460	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1259 :  			ZeroMemory(m_cbPerformAction, sizeof(m_cbPerformAction));

  00463	6a 04		 push	 4
  00465	6a 00		 push	 0
  00467	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0046d	81 c2 f4 05 00
	00		 add	 edx, 1524		; 000005f4H
  00473	52		 push	 edx
  00474	e8 00 00 00 00	 call	 _memset
  00479	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1260 :  
; 1261 : 			DispatchCardData(m_wResumeUser,m_cbGangStatus != WIK_GANERAL);

  0047c	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00482	0f b6 88 cc 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1228]
  00489	85 c9		 test	 ecx, ecx
  0048b	74 09		 je	 SHORT $LN88@OnUserOper
  0048d	c6 85 79 fc ff
	ff 01		 mov	 BYTE PTR tv273[ebp], 1
  00494	eb 07		 jmp	 SHORT $LN89@OnUserOper
$LN88@OnUserOper:
  00496	c6 85 79 fc ff
	ff 00		 mov	 BYTE PTR tv273[ebp], 0
$LN89@OnUserOper:
  0049d	0f b6 95 79 fc
	ff ff		 movzx	 edx, BYTE PTR tv273[ebp]
  004a4	52		 push	 edx
  004a5	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004ab	0f b7 88 bc 04
	00 00		 movzx	 ecx, WORD PTR [eax+1212]
  004b2	51		 push	 ecx
  004b3	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004b9	e8 00 00 00 00	 call	 ?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::DispatchCardData

; 1262 :  			return true;

  004be	c6 85 6b fc ff
	ff 01		 mov	 BYTE PTR $T23[ebp], 1
  004c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004cc	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  004d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  004d8	8a 85 6b fc ff
	ff		 mov	 al, BYTE PTR $T23[ebp]
  004de	e9 c5 16 00 00	 jmp	 $LN1@OnUserOper
$LN40@OnUserOper:

; 1263 :  		}
; 1264 :  
; 1265 :  		//变量定义
; 1266 :  		BYTE cbTargetCard = m_cbOperateCard[wTargetUser][0];

  004e3	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  004ea	6b c2 03	 imul	 eax, edx, 3
  004ed	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004f3	8d 94 01 e8 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1512]
  004fa	b8 01 00 00 00	 mov	 eax, 1
  004ff	6b c8 00	 imul	 ecx, eax, 0
  00502	8a 14 0a	 mov	 dl, BYTE PTR [edx+ecx]
  00505	88 95 96 fc ff
	ff		 mov	 BYTE PTR _cbTargetCard$41[ebp], dl

; 1267 :  
; 1268 :  		//出牌变量
; 1269 :  		m_enSendStatus = Gang_Send;

  0050b	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00511	c7 80 c8 04 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+1224], 2

; 1270 : 		m_cbSendCardData = 0;

  0051b	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00521	c6 81 3c 07 00
	00 00		 mov	 BYTE PTR [ecx+1852], 0

; 1271 :  		m_wOutCardUser = INVALID_CHAIR;

  00528	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0052d	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00533	66 89 90 44 06
	00 00		 mov	 WORD PTR [eax+1604], dx

; 1272 : 		m_cbOutCardData = 0;

  0053a	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00540	c6 81 46 06 00
	00 00		 mov	 BYTE PTR [ecx+1606], 0

; 1273 :  
; 1274 :  		//胡牌操作
; 1275 :  		if (cbTargetAction == WIK_CHI_HU)

  00547	0f b6 95 97 fc
	ff ff		 movzx	 edx, BYTE PTR _cbTargetAction$42[ebp]
  0054e	83 fa 40	 cmp	 edx, 64			; 00000040H
  00551	0f 85 b9 01 00
	00		 jne	 $LN41@OnUserOper

; 1276 :  		{
; 1277 :  			//结束信息
; 1278 :  			m_cbChiHuCard = cbTargetCard;

  00557	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0055d	8a 8d 96 fc ff
	ff		 mov	 cl, BYTE PTR _cbTargetCard$41[ebp]
  00563	88 88 18 06 00
	00		 mov	 BYTE PTR [eax+1560], cl

; 1279 :  
; 1280 : 			WORD wChiHuUser = m_wBankerUser;

  00569	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0056f	66 8b 82 72 04
	00 00		 mov	 ax, WORD PTR [edx+1138]
  00576	66 89 85 88 fc
	ff ff		 mov	 WORD PTR _wChiHuUser$35[ebp], ax

; 1281 : 			for(int i = 0; i < m_cbPlayerCount; i++)

  0057d	c7 85 3c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$5[ebp], 0
  00587	eb 0f		 jmp	 SHORT $LN10@OnUserOper
$LN8@OnUserOper:
  00589	8b 8d 3c fc ff
	ff		 mov	 ecx, DWORD PTR _i$5[ebp]
  0058f	83 c1 01	 add	 ecx, 1
  00592	89 8d 3c fc ff
	ff		 mov	 DWORD PTR _i$5[ebp], ecx
$LN10@OnUserOper:
  00598	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0059e	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  005a2	39 85 3c fc ff
	ff		 cmp	 DWORD PTR _i$5[ebp], eax
  005a8	0f 8d 18 01 00
	00		 jge	 $LN9@OnUserOper

; 1282 :  			{
; 1283 :  				wChiHuUser = (m_wBankerUser + i) % m_cbPlayerCount;

  005ae	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005b4	0f b7 81 72 04
	00 00		 movzx	 eax, WORD PTR [ecx+1138]
  005bb	03 85 3c fc ff
	ff		 add	 eax, DWORD PTR _i$5[ebp]
  005c1	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  005c7	0f b6 4a 09	 movzx	 ecx, BYTE PTR [edx+9]
  005cb	99		 cdq
  005cc	f7 f9		 idiv	 ecx
  005ce	66 89 95 88 fc
	ff ff		 mov	 WORD PTR _wChiHuUser$35[ebp], dx

; 1284 : 				//过虑判断
; 1285 :  				if ((m_cbPerformAction[wChiHuUser]&WIK_CHI_HU) == 0)

  005d5	0f b7 95 88 fc
	ff ff		 movzx	 edx, WORD PTR _wChiHuUser$35[ebp]
  005dc	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005e2	0f b6 8c 10 f4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1524]
  005ea	83 e1 40	 and	 ecx, 64			; 00000040H
  005ed	75 02		 jne	 SHORT $LN42@OnUserOper

; 1286 :  					continue;

  005ef	eb 98		 jmp	 SHORT $LN8@OnUserOper
$LN42@OnUserOper:

; 1287 :  
; 1288 :  				//胡牌判断
; 1289 :  				BYTE cbWeaveItemCount = m_cbWeaveItemCount[wChiHuUser];

  005f1	0f b7 95 88 fc
	ff ff		 movzx	 edx, WORD PTR _wChiHuUser$35[ebp]
  005f8	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005fe	8a 8c 10 3e 08
	00 00		 mov	 cl, BYTE PTR [eax+edx+2110]
  00605	88 8d 6a fc ff
	ff		 mov	 BYTE PTR _cbWeaveItemCount$22[ebp], cl

; 1290 :  				tagWeaveItem * pWeaveItem = m_WeaveItemArray[wChiHuUser];

  0060b	0f b7 95 88 fc
	ff ff		 movzx	 edx, WORD PTR _wChiHuUser$35[ebp]
  00612	6b c2 24	 imul	 eax, edx, 36
  00615	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0061b	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  00622	89 95 2c fc ff
	ff		 mov	 DWORD PTR _pWeaveItem$3[ebp], edx

; 1291 :  				m_dwChiHuKind[wChiHuUser] = m_GameLogic.AnalyseChiHuCard(m_cbCardIndex[wChiHuUser], pWeaveItem, cbWeaveItemCount, m_cbChiHuCard, m_ChiHuRight[wChiHuUser]);

  00628	6a 00		 push	 0
  0062a	0f b7 85 88 fc
	ff ff		 movzx	 eax, WORD PTR _wChiHuUser$35[ebp]
  00631	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00637	8d 94 81 2c 06
	00 00		 lea	 edx, DWORD PTR [ecx+eax*4+1580]
  0063e	52		 push	 edx
  0063f	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00645	0f b6 88 18 06
	00 00		 movzx	 ecx, BYTE PTR [eax+1560]
  0064c	51		 push	 ecx
  0064d	0f b6 95 6a fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveItemCount$22[ebp]
  00654	52		 push	 edx
  00655	8b 85 2c fc ff
	ff		 mov	 eax, DWORD PTR _pWeaveItem$3[ebp]
  0065b	50		 push	 eax
  0065c	0f b7 8d 88 fc
	ff ff		 movzx	 ecx, WORD PTR _wChiHuUser$35[ebp]
  00663	6b d1 22	 imul	 edx, ecx, 34
  00666	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0066c	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  00673	51		 push	 ecx
  00674	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0067a	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00680	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  00685	0f b6 d0	 movzx	 edx, al
  00688	0f b7 85 88 fc
	ff ff		 movzx	 eax, WORD PTR _wChiHuUser$35[ebp]
  0068f	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00695	89 94 81 1c 06
	00 00		 mov	 DWORD PTR [ecx+eax*4+1564], edx

; 1292 : 
; 1293 :  				//插入扑克
; 1294 :  				if (m_dwChiHuKind[wChiHuUser] != WIK_NULL) 

  0069c	0f b7 95 88 fc
	ff ff		 movzx	 edx, WORD PTR _wChiHuUser$35[ebp]
  006a3	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006a9	83 bc 90 1c 06
	00 00 00	 cmp	 DWORD PTR [eax+edx*4+1564], 0
  006b1	74 0e		 je	 SHORT $LN43@OnUserOper

; 1295 :  				{
; 1296 :  					wTargetUser = wChiHuUser;

  006b3	66 8b 8d 88 fc
	ff ff		 mov	 cx, WORD PTR _wChiHuUser$35[ebp]
  006ba	66 89 8d 98 fc
	ff ff		 mov	 WORD PTR _wTargetUser$43[ebp], cx
$LN43@OnUserOper:

; 1297 : 					//break;
; 1298 :  				}				
; 1299 :  			}

  006c1	e9 c3 fe ff ff	 jmp	 $LN8@OnUserOper
$LN9@OnUserOper:

; 1300 :  
; 1301 :  			//结束游戏
; 1302 :  			ASSERT(m_dwChiHuKind[wTargetUser] != WIK_NULL);
; 1303 :  			OnEventGameConclude(m_wProvideUser, NULL, GER_NORMAL);

  006c6	6a 00		 push	 0
  006c8	6a 00		 push	 0
  006ca	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006d0	0f b7 82 c0 04
	00 00		 movzx	 eax, WORD PTR [edx+1216]
  006d7	50		 push	 eax
  006d8	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006de	8b 11		 mov	 edx, DWORD PTR [ecx]
  006e0	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006e6	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  006e9	ff d0		 call	 eax

; 1304 :  
; 1305 :  			return true;

  006eb	c6 85 54 fc ff
	ff 01		 mov	 BYTE PTR $T9[ebp], 1
  006f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  006f9	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  006ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00705	8a 85 54 fc ff
	ff		 mov	 al, BYTE PTR $T9[ebp]
  0070b	e9 98 14 00 00	 jmp	 $LN1@OnUserOper
$LN41@OnUserOper:

; 1306 :  		}
; 1307 :  
; 1308 :  		//组合扑克
; 1309 :  		ASSERT(m_cbWeaveItemCount[wTargetUser] < MAX_WEAVE);
; 1310 :  		WORD wIndex = m_cbWeaveItemCount[wTargetUser]++;

  00710	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00717	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0071d	66 0f b6 84 0a
	3e 08 00 00	 movzx	 ax, BYTE PTR [edx+ecx+2110]
  00726	66 89 85 90 fc
	ff ff		 mov	 WORD PTR _wIndex$38[ebp], ax
  0072d	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00734	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0073a	8a 84 0a 3e 08
	00 00		 mov	 al, BYTE PTR [edx+ecx+2110]
  00741	04 01		 add	 al, 1
  00743	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  0074a	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00750	88 84 0a 3e 08
	00 00		 mov	 BYTE PTR [edx+ecx+2110], al

; 1311 :  		m_WeaveItemArray[wTargetUser][wIndex].cbParam = WIK_GANERAL;

  00757	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  0075e	6b c8 24	 imul	 ecx, eax, 36
  00761	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00767	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  0076e	0f b7 8d 90 fc
	ff ff		 movzx	 ecx, WORD PTR _wIndex$38[ebp]
  00775	6b d1 09	 imul	 edx, ecx, 9
  00778	c6 44 10 02 00	 mov	 BYTE PTR [eax+edx+2], 0

; 1312 :  		m_WeaveItemArray[wTargetUser][wIndex].cbCenterCard = cbTargetCard;

  0077d	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00784	6b c8 24	 imul	 ecx, eax, 36
  00787	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0078d	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  00794	0f b7 8d 90 fc
	ff ff		 movzx	 ecx, WORD PTR _wIndex$38[ebp]
  0079b	6b d1 09	 imul	 edx, ecx, 9
  0079e	8a 8d 96 fc ff
	ff		 mov	 cl, BYTE PTR _cbTargetCard$41[ebp]
  007a4	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 1313 :  		m_WeaveItemArray[wTargetUser][wIndex].cbWeaveKind = cbTargetAction;

  007a8	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  007af	6b c2 24	 imul	 eax, edx, 36
  007b2	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007b8	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  007bf	0f b7 85 90 fc
	ff ff		 movzx	 eax, WORD PTR _wIndex$38[ebp]
  007c6	6b c8 09	 imul	 ecx, eax, 9
  007c9	8a 85 97 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetAction$42[ebp]
  007cf	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1314 :  		m_WeaveItemArray[wTargetUser][wIndex].wProvideUser = (m_wProvideUser == INVALID_CHAIR) ? wTargetUser : m_wProvideUser;

  007d2	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007d8	0f b7 91 c0 04
	00 00		 movzx	 edx, WORD PTR [ecx+1216]
  007df	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  007e5	75 10		 jne	 SHORT $LN90@OnUserOper
  007e7	66 8b 85 98 fc
	ff ff		 mov	 ax, WORD PTR _wTargetUser$43[ebp]
  007ee	66 89 85 4c fc
	ff ff		 mov	 WORD PTR tv405[ebp], ax
  007f5	eb 14		 jmp	 SHORT $LN91@OnUserOper
$LN90@OnUserOper:
  007f7	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007fd	66 8b 91 c0 04
	00 00		 mov	 dx, WORD PTR [ecx+1216]
  00804	66 89 95 4c fc
	ff ff		 mov	 WORD PTR tv405[ebp], dx
$LN91@OnUserOper:
  0080b	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00812	6b c8 24	 imul	 ecx, eax, 36
  00815	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0081b	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  00822	0f b7 8d 90 fc
	ff ff		 movzx	 ecx, WORD PTR _wIndex$38[ebp]
  00829	6b d1 09	 imul	 edx, ecx, 9
  0082c	66 8b 8d 4c fc
	ff ff		 mov	 cx, WORD PTR tv405[ebp]
  00833	66 89 4c 10 03	 mov	 WORD PTR [eax+edx+3], cx

; 1315 :  		m_WeaveItemArray[wTargetUser][wIndex].cbCardData[0] = cbTargetCard;

  00838	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  0083f	6b c2 24	 imul	 eax, edx, 36
  00842	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00848	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  0084f	0f b7 85 90 fc
	ff ff		 movzx	 eax, WORD PTR _wIndex$38[ebp]
  00856	6b c8 09	 imul	 ecx, eax, 9
  00859	03 d1		 add	 edx, ecx
  0085b	b8 01 00 00 00	 mov	 eax, 1
  00860	6b c8 00	 imul	 ecx, eax, 0
  00863	8a 85 96 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetCard$41[ebp]
  00869	88 44 0a 05	 mov	 BYTE PTR [edx+ecx+5], al

; 1316 :  		if(cbTargetAction&(WIK_LEFT | WIK_CENTER | WIK_RIGHT))

  0086d	0f b6 8d 97 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbTargetAction$42[ebp]
  00874	83 e1 07	 and	 ecx, 7
  00877	0f 84 a5 00 00
	00		 je	 $LN44@OnUserOper

; 1317 :  		{
; 1318 :  			m_WeaveItemArray[wTargetUser][wIndex].cbCardData[1] = m_cbOperateCard[wTargetUser][1];

  0087d	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00884	6b c2 03	 imul	 eax, edx, 3
  00887	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0088d	8d 94 01 e8 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1512]
  00894	b8 01 00 00 00	 mov	 eax, 1
  00899	c1 e0 00	 shl	 eax, 0
  0089c	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  008a3	6b c9 24	 imul	 ecx, ecx, 36
  008a6	8b b5 9c fc ff
	ff		 mov	 esi, DWORD PTR _this$[ebp]
  008ac	8d 8c 0e 42 08
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+2114]
  008b3	0f b7 b5 90 fc
	ff ff		 movzx	 esi, WORD PTR _wIndex$38[ebp]
  008ba	6b f6 09	 imul	 esi, esi, 9
  008bd	03 ce		 add	 ecx, esi
  008bf	be 01 00 00 00	 mov	 esi, 1
  008c4	c1 e6 00	 shl	 esi, 0
  008c7	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  008ca	88 54 31 05	 mov	 BYTE PTR [ecx+esi+5], dl

; 1319 :  			m_WeaveItemArray[wTargetUser][wIndex].cbCardData[2] = m_cbOperateCard[wTargetUser][2];

  008ce	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  008d5	6b c8 03	 imul	 ecx, eax, 3
  008d8	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008de	8d 84 0a e8 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1512]
  008e5	b9 01 00 00 00	 mov	 ecx, 1
  008ea	d1 e1		 shl	 ecx, 1
  008ec	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  008f3	6b d2 24	 imul	 edx, edx, 36
  008f6	8b b5 9c fc ff
	ff		 mov	 esi, DWORD PTR _this$[ebp]
  008fc	8d 94 16 42 08
	00 00		 lea	 edx, DWORD PTR [esi+edx+2114]
  00903	0f b7 b5 90 fc
	ff ff		 movzx	 esi, WORD PTR _wIndex$38[ebp]
  0090a	6b f6 09	 imul	 esi, esi, 9
  0090d	03 d6		 add	 edx, esi
  0090f	be 01 00 00 00	 mov	 esi, 1
  00914	d1 e6		 shl	 esi, 1
  00916	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00919	88 44 32 05	 mov	 BYTE PTR [edx+esi+5], al

; 1320 :  		}
; 1321 :  		else

  0091d	e9 d0 00 00 00	 jmp	 $LN45@OnUserOper
$LN44@OnUserOper:

; 1322 :  		{
; 1323 :  			m_WeaveItemArray[wTargetUser][wIndex].cbCardData[1] = cbTargetCard;

  00922	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00929	6b d1 24	 imul	 edx, ecx, 36
  0092c	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00932	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  00939	0f b7 95 90 fc
	ff ff		 movzx	 edx, WORD PTR _wIndex$38[ebp]
  00940	6b c2 09	 imul	 eax, edx, 9
  00943	03 c8		 add	 ecx, eax
  00945	ba 01 00 00 00	 mov	 edx, 1
  0094a	c1 e2 00	 shl	 edx, 0
  0094d	8a 85 96 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetCard$41[ebp]
  00953	88 44 11 05	 mov	 BYTE PTR [ecx+edx+5], al

; 1324 :  			m_WeaveItemArray[wTargetUser][wIndex].cbCardData[2] = cbTargetCard;

  00957	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  0095e	6b d1 24	 imul	 edx, ecx, 36
  00961	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00967	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  0096e	0f b7 95 90 fc
	ff ff		 movzx	 edx, WORD PTR _wIndex$38[ebp]
  00975	6b c2 09	 imul	 eax, edx, 9
  00978	03 c8		 add	 ecx, eax
  0097a	ba 01 00 00 00	 mov	 edx, 1
  0097f	d1 e2		 shl	 edx, 1
  00981	8a 85 96 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetCard$41[ebp]
  00987	88 44 11 05	 mov	 BYTE PTR [ecx+edx+5], al

; 1325 :  			if(cbTargetAction & WIK_GANG)

  0098b	0f b6 8d 97 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbTargetAction$42[ebp]
  00992	83 e1 10	 and	 ecx, 16			; 00000010H
  00995	74 5b		 je	 SHORT $LN45@OnUserOper

; 1326 : 			{
; 1327 : 				m_WeaveItemArray[wTargetUser][wIndex].cbParam = WIK_FANG_GANG;

  00997	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  0099e	6b c2 24	 imul	 eax, edx, 36
  009a1	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009a7	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  009ae	0f b7 85 90 fc
	ff ff		 movzx	 eax, WORD PTR _wIndex$38[ebp]
  009b5	6b c8 09	 imul	 ecx, eax, 9
  009b8	c6 44 0a 02 02	 mov	 BYTE PTR [edx+ecx+2], 2

; 1328 : 				m_WeaveItemArray[wTargetUser][wIndex].cbCardData[3] = cbTargetCard;

  009bd	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  009c4	6b c2 24	 imul	 eax, edx, 36
  009c7	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009cd	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  009d4	0f b7 85 90 fc
	ff ff		 movzx	 eax, WORD PTR _wIndex$38[ebp]
  009db	6b c8 09	 imul	 ecx, eax, 9
  009de	03 d1		 add	 edx, ecx
  009e0	b8 01 00 00 00	 mov	 eax, 1
  009e5	6b c8 03	 imul	 ecx, eax, 3
  009e8	8a 85 96 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetCard$41[ebp]
  009ee	88 44 0a 05	 mov	 BYTE PTR [edx+ecx+5], al
$LN45@OnUserOper:

; 1329 : 			}
; 1330 :  		}
; 1331 :  
; 1332 :  		//删除扑克
; 1333 :  		switch (cbTargetAction)

  009f2	0f b6 8d 97 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbTargetAction$42[ebp]
  009f9	89 8d 38 fc ff
	ff		 mov	 DWORD PTR tv493[ebp], ecx
  009ff	8b 95 38 fc ff
	ff		 mov	 edx, DWORD PTR tv493[ebp]
  00a05	83 ea 01	 sub	 edx, 1
  00a08	89 95 38 fc ff
	ff		 mov	 DWORD PTR tv493[ebp], edx
  00a0e	83 bd 38 fc ff
	ff 0f		 cmp	 DWORD PTR tv493[ebp], 15 ; 0000000fH
  00a15	0f 87 38 03 00
	00		 ja	 $LN57@OnUserOper
  00a1b	8b 85 38 fc ff
	ff		 mov	 eax, DWORD PTR tv493[ebp]
  00a21	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN98@OnUserOper[eax]
  00a28	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN100@OnUserOper[ecx*4]
$LN47@OnUserOper:

; 1334 :  		{
; 1335 :  		case WIK_LEFT:		//上牌操作
; 1336 :  			{
; 1337 :  				//删除扑克
; 1338 :  				if(!m_GameLogic.RemoveCard(m_cbCardIndex[wTargetUser], &m_cbOperateCard[wTargetUser][1], 2))

  00a2f	6a 02		 push	 2
  00a31	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00a38	6b c2 03	 imul	 eax, edx, 3
  00a3b	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a41	8d 94 01 e8 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1512]
  00a48	b8 01 00 00 00	 mov	 eax, 1
  00a4d	c1 e0 00	 shl	 eax, 0
  00a50	03 d0		 add	 edx, eax
  00a52	52		 push	 edx
  00a53	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00a5a	6b d1 22	 imul	 edx, ecx, 34
  00a5d	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a63	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  00a6a	51		 push	 ecx
  00a6b	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a71	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00a77	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z ; CGameLogic::RemoveCard
  00a7c	0f b6 d0	 movzx	 edx, al
  00a7f	85 d2		 test	 edx, edx
  00a81	75 25		 jne	 SHORT $LN48@OnUserOper

; 1339 :  				{
; 1340 :  					ASSERT(FALSE);
; 1341 :  					return false;

  00a83	c6 85 55 fc ff
	ff 00		 mov	 BYTE PTR $T10[ebp], 0
  00a8a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a91	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00a97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00a9d	8a 85 55 fc ff
	ff		 mov	 al, BYTE PTR $T10[ebp]
  00aa3	e9 00 11 00 00	 jmp	 $LN1@OnUserOper
$LN48@OnUserOper:

; 1342 :  				}
; 1343 : 				m_cbChiPengCount[wTargetUser]++;

  00aa8	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00aaf	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ab5	8a 94 01 e6 04
	00 00		 mov	 dl, BYTE PTR [ecx+eax+1254]
  00abc	80 c2 01	 add	 dl, 1
  00abf	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00ac6	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00acc	88 94 01 e6 04
	00 00		 mov	 BYTE PTR [ecx+eax+1254], dl

; 1344 :  
; 1345 :  				break;

  00ad3	e9 a0 02 00 00	 jmp	 $LN11@OnUserOper
$LN49@OnUserOper:

; 1346 :  			}
; 1347 :  		case WIK_RIGHT:		//上牌操作
; 1348 :  			{
; 1349 :  				//删除扑克
; 1350 :  				if(!m_GameLogic.RemoveCard(m_cbCardIndex[wTargetUser], &m_cbOperateCard[wTargetUser][1], 2))

  00ad8	6a 02		 push	 2
  00ada	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00ae1	6b c2 03	 imul	 eax, edx, 3
  00ae4	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00aea	8d 94 01 e8 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1512]
  00af1	b8 01 00 00 00	 mov	 eax, 1
  00af6	c1 e0 00	 shl	 eax, 0
  00af9	03 d0		 add	 edx, eax
  00afb	52		 push	 edx
  00afc	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00b03	6b d1 22	 imul	 edx, ecx, 34
  00b06	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b0c	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  00b13	51		 push	 ecx
  00b14	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b1a	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00b20	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z ; CGameLogic::RemoveCard
  00b25	0f b6 d0	 movzx	 edx, al
  00b28	85 d2		 test	 edx, edx
  00b2a	75 25		 jne	 SHORT $LN50@OnUserOper

; 1351 :  				{
; 1352 :  					ASSERT(FALSE);
; 1353 :  					return false;

  00b2c	c6 85 56 fc ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  00b33	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00b3a	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00b40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00b46	8a 85 56 fc ff
	ff		 mov	 al, BYTE PTR $T11[ebp]
  00b4c	e9 57 10 00 00	 jmp	 $LN1@OnUserOper
$LN50@OnUserOper:

; 1354 :  				}
; 1355 : 				m_cbChiPengCount[wTargetUser]++;

  00b51	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00b58	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b5e	8a 94 01 e6 04
	00 00		 mov	 dl, BYTE PTR [ecx+eax+1254]
  00b65	80 c2 01	 add	 dl, 1
  00b68	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00b6f	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b75	88 94 01 e6 04
	00 00		 mov	 BYTE PTR [ecx+eax+1254], dl

; 1356 :  
; 1357 :  				break;

  00b7c	e9 f7 01 00 00	 jmp	 $LN11@OnUserOper
$LN51@OnUserOper:

; 1358 :  			}
; 1359 :  		case WIK_CENTER:	//上牌操作
; 1360 :  			{
; 1361 :  				//删除扑克
; 1362 :  				if(!m_GameLogic.RemoveCard(m_cbCardIndex[wTargetUser], &m_cbOperateCard[wTargetUser][1], 2))

  00b81	6a 02		 push	 2
  00b83	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00b8a	6b c2 03	 imul	 eax, edx, 3
  00b8d	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b93	8d 94 01 e8 05
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1512]
  00b9a	b8 01 00 00 00	 mov	 eax, 1
  00b9f	c1 e0 00	 shl	 eax, 0
  00ba2	03 d0		 add	 edx, eax
  00ba4	52		 push	 edx
  00ba5	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00bac	6b d1 22	 imul	 edx, ecx, 34
  00baf	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00bb5	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  00bbc	51		 push	 ecx
  00bbd	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00bc3	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00bc9	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z ; CGameLogic::RemoveCard
  00bce	0f b6 d0	 movzx	 edx, al
  00bd1	85 d2		 test	 edx, edx
  00bd3	75 25		 jne	 SHORT $LN52@OnUserOper

; 1363 :  				{
; 1364 :  					ASSERT(FALSE);
; 1365 :  					return false;

  00bd5	c6 85 57 fc ff
	ff 00		 mov	 BYTE PTR $T12[ebp], 0
  00bdc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00be3	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00be9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00bef	8a 85 57 fc ff
	ff		 mov	 al, BYTE PTR $T12[ebp]
  00bf5	e9 ae 0f 00 00	 jmp	 $LN1@OnUserOper
$LN52@OnUserOper:

; 1366 :  				}
; 1367 : 				m_cbChiPengCount[wTargetUser]++;

  00bfa	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00c01	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c07	8a 94 01 e6 04
	00 00		 mov	 dl, BYTE PTR [ecx+eax+1254]
  00c0e	80 c2 01	 add	 dl, 1
  00c11	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00c18	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c1e	88 94 01 e6 04
	00 00		 mov	 BYTE PTR [ecx+eax+1254], dl

; 1368 :  
; 1369 :  				break;

  00c25	e9 4e 01 00 00	 jmp	 $LN11@OnUserOper
$LN53@OnUserOper:

; 1370 :  			}
; 1371 :  		case WIK_PENG:		//碰牌操作
; 1372 :  			{
; 1373 :  				//删除扑克
; 1374 :  				BYTE cbRemoveCard[] = {cbTargetCard,cbTargetCard};

  00c2a	8a 95 96 fc ff
	ff		 mov	 dl, BYTE PTR _cbTargetCard$41[ebp]
  00c30	88 95 48 fc ff
	ff		 mov	 BYTE PTR _cbRemoveCard$7[ebp], dl
  00c36	8a 85 96 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetCard$41[ebp]
  00c3c	88 85 49 fc ff
	ff		 mov	 BYTE PTR _cbRemoveCard$7[ebp+1], al

; 1375 :  				if(!m_GameLogic.RemoveCard(m_cbCardIndex[wTargetUser], cbRemoveCard, 2))

  00c42	6a 02		 push	 2
  00c44	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR _cbRemoveCard$7[ebp]
  00c4a	51		 push	 ecx
  00c4b	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00c52	6b c2 22	 imul	 eax, edx, 34
  00c55	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c5b	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00c62	52		 push	 edx
  00c63	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c69	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00c6f	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z ; CGameLogic::RemoveCard
  00c74	0f b6 c0	 movzx	 eax, al
  00c77	85 c0		 test	 eax, eax
  00c79	75 25		 jne	 SHORT $LN54@OnUserOper

; 1376 :  				{
; 1377 :  					ASSERT(FALSE);
; 1378 :  					return false;

  00c7b	c6 85 5f fc ff
	ff 00		 mov	 BYTE PTR $T14[ebp], 0
  00c82	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00c89	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00c8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00c95	8a 85 5f fc ff
	ff		 mov	 al, BYTE PTR $T14[ebp]
  00c9b	e9 08 0f 00 00	 jmp	 $LN1@OnUserOper
$LN54@OnUserOper:

; 1379 :  				}
; 1380 : 				m_cbChiPengCount[wTargetUser]++;

  00ca0	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00ca7	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00cad	8a 84 0a e6 04
	00 00		 mov	 al, BYTE PTR [edx+ecx+1254]
  00cb4	04 01		 add	 al, 1
  00cb6	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00cbd	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00cc3	88 84 0a e6 04
	00 00		 mov	 BYTE PTR [edx+ecx+1254], al

; 1381 : 
; 1382 :  				break;

  00cca	e9 a9 00 00 00	 jmp	 $LN11@OnUserOper
$LN55@OnUserOper:

; 1383 :  			}
; 1384 :  		case WIK_GANG:		//杠牌操作
; 1385 :  			{
; 1386 :  				//删除扑克,被动动作只存在放杠
; 1387 :  				BYTE cbRemoveCard[] = {cbTargetCard, cbTargetCard, cbTargetCard};

  00ccf	8a 85 96 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetCard$41[ebp]
  00cd5	88 85 40 fc ff
	ff		 mov	 BYTE PTR _cbRemoveCard$6[ebp], al
  00cdb	8a 8d 96 fc ff
	ff		 mov	 cl, BYTE PTR _cbTargetCard$41[ebp]
  00ce1	88 8d 41 fc ff
	ff		 mov	 BYTE PTR _cbRemoveCard$6[ebp+1], cl
  00ce7	8a 95 96 fc ff
	ff		 mov	 dl, BYTE PTR _cbTargetCard$41[ebp]
  00ced	88 95 42 fc ff
	ff		 mov	 BYTE PTR _cbRemoveCard$6[ebp+2], dl

; 1388 :  				if(!m_GameLogic.RemoveCard(m_cbCardIndex[wTargetUser], cbRemoveCard, CountArray(cbRemoveCard)))

  00cf3	6a 03		 push	 3
  00cf5	8d 85 40 fc ff
	ff		 lea	 eax, DWORD PTR _cbRemoveCard$6[ebp]
  00cfb	50		 push	 eax
  00cfc	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00d03	6b d1 22	 imul	 edx, ecx, 34
  00d06	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d0c	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  00d13	51		 push	 ecx
  00d14	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d1a	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00d20	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z ; CGameLogic::RemoveCard
  00d25	0f b6 d0	 movzx	 edx, al
  00d28	85 d2		 test	 edx, edx
  00d2a	75 25		 jne	 SHORT $LN56@OnUserOper

; 1389 :  				{
; 1390 :  					ASSERT(FALSE);
; 1391 :  					return false;

  00d2c	c6 85 65 fc ff
	ff 00		 mov	 BYTE PTR $T17[ebp], 0
  00d33	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d3a	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00d40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00d46	8a 85 65 fc ff
	ff		 mov	 al, BYTE PTR $T17[ebp]
  00d4c	e9 57 0e 00 00	 jmp	 $LN1@OnUserOper
$LN56@OnUserOper:

; 1392 :  				}
; 1393 :  
; 1394 :  				break;

  00d51	eb 25		 jmp	 SHORT $LN11@OnUserOper
$LN57@OnUserOper:

; 1395 :  			}
; 1396 :  		default:
; 1397 :  			ASSERT(FALSE);
; 1398 :  			return false;

  00d53	c6 85 66 fc ff
	ff 00		 mov	 BYTE PTR $T18[ebp], 0
  00d5a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d61	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00d67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00d6d	8a 85 66 fc ff
	ff		 mov	 al, BYTE PTR $T18[ebp]
  00d73	e9 30 0e 00 00	 jmp	 $LN1@OnUserOper
$LN11@OnUserOper:

; 1399 :  		}
; 1400 :  
; 1401 :  		//构造结果
; 1402 :  		CMD_S_OperateResult OperateResult;
; 1403 :  		ZeroMemory(&OperateResult, sizeof(OperateResult));

  00d78	6a 09		 push	 9
  00d7a	6a 00		 push	 0
  00d7c	8d 45 e4	 lea	 eax, DWORD PTR _OperateResult$47[ebp]
  00d7f	50		 push	 eax
  00d80	e8 00 00 00 00	 call	 _memset
  00d85	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1404 :  		OperateResult.wOperateUser = wTargetUser;

  00d88	66 8b 8d 98 fc
	ff ff		 mov	 cx, WORD PTR _wTargetUser$43[ebp]
  00d8f	66 89 4d e4	 mov	 WORD PTR _OperateResult$47[ebp], cx

; 1405 :  		OperateResult.cbOperateCode = cbTargetAction;

  00d93	8a 95 97 fc ff
	ff		 mov	 dl, BYTE PTR _cbTargetAction$42[ebp]
  00d99	88 55 e9	 mov	 BYTE PTR _OperateResult$47[ebp+5], dl

; 1406 :  		OperateResult.wProvideUser = (m_wProvideUser == INVALID_CHAIR) ? wTargetUser : m_wProvideUser;

  00d9c	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00da2	0f b7 88 c0 04
	00 00		 movzx	 ecx, WORD PTR [eax+1216]
  00da9	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00daf	75 10		 jne	 SHORT $LN92@OnUserOper
  00db1	66 8b 95 98 fc
	ff ff		 mov	 dx, WORD PTR _wTargetUser$43[ebp]
  00db8	66 89 95 46 fc
	ff ff		 mov	 WORD PTR tv633[ebp], dx
  00dbf	eb 14		 jmp	 SHORT $LN93@OnUserOper
$LN92@OnUserOper:
  00dc1	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00dc7	66 8b 88 c0 04
	00 00		 mov	 cx, WORD PTR [eax+1216]
  00dce	66 89 8d 46 fc
	ff ff		 mov	 WORD PTR tv633[ebp], cx
$LN93@OnUserOper:
  00dd5	66 8b 95 46 fc
	ff ff		 mov	 dx, WORD PTR tv633[ebp]
  00ddc	66 89 55 e7	 mov	 WORD PTR _OperateResult$47[ebp+3], dx

; 1407 :  		OperateResult.cbOperateCard[0] = cbTargetCard;

  00de0	b8 01 00 00 00	 mov	 eax, 1
  00de5	6b c8 00	 imul	 ecx, eax, 0
  00de8	8a 95 96 fc ff
	ff		 mov	 dl, BYTE PTR _cbTargetCard$41[ebp]
  00dee	88 54 0d ea	 mov	 BYTE PTR _OperateResult$47[ebp+ecx+6], dl

; 1408 :  		if(cbTargetAction & (WIK_LEFT | WIK_CENTER | WIK_RIGHT))

  00df2	0f b6 85 97 fc
	ff ff		 movzx	 eax, BYTE PTR _cbTargetAction$42[ebp]
  00df9	83 e0 07	 and	 eax, 7
  00dfc	74 3b		 je	 SHORT $LN58@OnUserOper

; 1409 : 		{
; 1410 : 			CopyMemory(&OperateResult.cbOperateCard[1], &m_cbOperateCard[wTargetUser][1], 2 * sizeof(BYTE));

  00dfe	6a 02		 push	 2
  00e00	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00e07	6b d1 03	 imul	 edx, ecx, 3
  00e0a	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e10	8d 8c 10 e8 05
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1512]
  00e17	ba 01 00 00 00	 mov	 edx, 1
  00e1c	c1 e2 00	 shl	 edx, 0
  00e1f	03 ca		 add	 ecx, edx
  00e21	51		 push	 ecx
  00e22	b8 01 00 00 00	 mov	 eax, 1
  00e27	c1 e0 00	 shl	 eax, 0
  00e2a	8d 4c 05 ea	 lea	 ecx, DWORD PTR _OperateResult$47[ebp+eax+6]
  00e2e	51		 push	 ecx
  00e2f	e8 00 00 00 00	 call	 _memcpy
  00e34	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e37	eb 2f		 jmp	 SHORT $LN59@OnUserOper
$LN58@OnUserOper:

; 1411 : 		}
; 1412 :  		else if(cbTargetAction&WIK_PENG)

  00e39	0f b6 95 97 fc
	ff ff		 movzx	 edx, BYTE PTR _cbTargetAction$42[ebp]
  00e40	83 e2 08	 and	 edx, 8
  00e43	74 23		 je	 SHORT $LN59@OnUserOper

; 1413 :  		{
; 1414 :  			OperateResult.cbOperateCard[1] = cbTargetCard;

  00e45	b8 01 00 00 00	 mov	 eax, 1
  00e4a	c1 e0 00	 shl	 eax, 0
  00e4d	8a 8d 96 fc ff
	ff		 mov	 cl, BYTE PTR _cbTargetCard$41[ebp]
  00e53	88 4c 05 ea	 mov	 BYTE PTR _OperateResult$47[ebp+eax+6], cl

; 1415 :  			OperateResult.cbOperateCard[2] = cbTargetCard;

  00e57	ba 01 00 00 00	 mov	 edx, 1
  00e5c	d1 e2		 shl	 edx, 1
  00e5e	8a 85 96 fc ff
	ff		 mov	 al, BYTE PTR _cbTargetCard$41[ebp]
  00e64	88 44 15 ea	 mov	 BYTE PTR _OperateResult$47[ebp+edx+6], al
$LN59@OnUserOper:

; 1416 :  		}
; 1417 :  
; 1418 :  		//用户状态
; 1419 :  		ZeroMemory(m_bResponse, sizeof(m_bResponse));

  00e68	6a 04		 push	 4
  00e6a	6a 00		 push	 0
  00e6c	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e72	81 c1 e0 05 00
	00		 add	 ecx, 1504		; 000005e0H
  00e78	51		 push	 ecx
  00e79	e8 00 00 00 00	 call	 _memset
  00e7e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1420 :  		ZeroMemory(m_cbUserAction, sizeof(m_cbUserAction));

  00e81	6a 04		 push	 4
  00e83	6a 00		 push	 0
  00e85	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00e8b	81 c2 e4 05 00
	00		 add	 edx, 1508		; 000005e4H
  00e91	52		 push	 edx
  00e92	e8 00 00 00 00	 call	 _memset
  00e97	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1421 :  		ZeroMemory(m_cbOperateCard, sizeof(m_cbOperateCard));

  00e9a	6a 0c		 push	 12			; 0000000cH
  00e9c	6a 00		 push	 0
  00e9e	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ea4	05 e8 05 00 00	 add	 eax, 1512		; 000005e8H
  00ea9	50		 push	 eax
  00eaa	e8 00 00 00 00	 call	 _memset
  00eaf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1422 :  		ZeroMemory(m_cbPerformAction, sizeof(m_cbPerformAction));

  00eb2	6a 04		 push	 4
  00eb4	6a 00		 push	 0
  00eb6	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ebc	81 c1 f4 05 00
	00		 add	 ecx, 1524		; 000005f4H
  00ec2	51		 push	 ecx
  00ec3	e8 00 00 00 00	 call	 _memset
  00ec8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1423 :  
; 1424 :  		//如果非杠牌
; 1425 :  		if(cbTargetAction != WIK_GANG)

  00ecb	0f b6 95 97 fc
	ff ff		 movzx	 edx, BYTE PTR _cbTargetAction$42[ebp]
  00ed2	83 fa 10	 cmp	 edx, 16			; 00000010H
  00ed5	0f 84 ac 02 00
	00		 je	 $LN61@OnUserOper

; 1426 :  		{
; 1427 : 			m_wProvideUser = INVALID_CHAIR;

  00edb	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00ee0	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ee6	66 89 81 c0 04
	00 00		 mov	 WORD PTR [ecx+1216], ax

; 1428 : 			m_cbProvideCard = 0;

  00eed	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ef3	c6 82 c2 04 00
	00 00		 mov	 BYTE PTR [edx+1218], 0

; 1429 : 
; 1430 :  			tagGangCardResult gcr;
; 1431 :  			m_cbUserAction[wTargetUser] |= m_GameLogic.AnalyseGangCardEx(m_cbCardIndex[wTargetUser], m_WeaveItemArray[wTargetUser], m_cbWeaveItemCount[wTargetUser],0, gcr);

  00efa	0f b7 b5 98 fc
	ff ff		 movzx	 esi, WORD PTR _wTargetUser$43[ebp]
  00f01	8d 45 d0	 lea	 eax, DWORD PTR _gcr$45[ebp]
  00f04	50		 push	 eax
  00f05	6a 00		 push	 0
  00f07	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00f0e	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00f14	0f b6 84 0a 3e
	08 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2110]
  00f1c	50		 push	 eax
  00f1d	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00f24	6b d1 24	 imul	 edx, ecx, 36
  00f27	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f2d	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  00f34	51		 push	 ecx
  00f35	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00f3c	6b c2 22	 imul	 eax, edx, 34
  00f3f	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f45	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00f4c	52		 push	 edx
  00f4d	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f53	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00f59	e8 00 00 00 00	 call	 ?AnalyseGangCardEx@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAUtagGangCardResult@@@Z ; CGameLogic::AnalyseGangCardEx
  00f5e	0f b6 c0	 movzx	 eax, al
  00f61	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f67	0f b6 94 31 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+esi+1508]
  00f6f	0b d0		 or	 edx, eax
  00f71	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  00f78	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f7e	88 94 01 e4 05
	00 00		 mov	 BYTE PTR [ecx+eax+1508], dl

; 1432 : 
; 1433 : 			if(m_bTing[wTargetUser] == false)

  00f85	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  00f8c	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f92	0f b6 8c 10 74
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1140]
  00f9a	85 c9		 test	 ecx, ecx
  00f9c	0f 85 c7 01 00
	00		 jne	 $LN62@OnUserOper

; 1434 : 			{
; 1435 : 				BYTE cbCount = 0;

  00fa2	c6 85 78 fc ff
	ff 00		 mov	 BYTE PTR _cbCount$30[ebp], 0

; 1436 : 				CMD_S_Hu_Data HuData;
; 1437 : 				ZeroMemory(&HuData,sizeof(HuData));

  00fa9	68 2d 03 00 00	 push	 813			; 0000032dH
  00fae	6a 00		 push	 0
  00fb0	8d 95 a0 fc ff
	ff		 lea	 edx, DWORD PTR _HuData$44[ebp]
  00fb6	52		 push	 edx
  00fb7	e8 00 00 00 00	 call	 _memset
  00fbc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1438 : 				cbCount =m_GameLogic.AnalyseTingCard(m_cbCardIndex[wTargetUser],m_WeaveItemArray[wTargetUser],m_cbWeaveItemCount[wTargetUser],HuData.cbOutCardCount,HuData.cbOutCardData,HuData.cbHuCardCount,HuData.cbHuCardData);

  00fbf	8d 85 bd fc ff
	ff		 lea	 eax, DWORD PTR _HuData$44[ebp+29]
  00fc5	50		 push	 eax
  00fc6	8d 8d af fc ff
	ff		 lea	 ecx, DWORD PTR _HuData$44[ebp+15]
  00fcc	51		 push	 ecx
  00fcd	8d 95 a1 fc ff
	ff		 lea	 edx, DWORD PTR _HuData$44[ebp+1]
  00fd3	52		 push	 edx
  00fd4	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _HuData$44[ebp]
  00fda	50		 push	 eax
  00fdb	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00fe2	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00fe8	0f b6 84 0a 3e
	08 00 00	 movzx	 eax, BYTE PTR [edx+ecx+2110]
  00ff0	50		 push	 eax
  00ff1	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  00ff8	6b d1 24	 imul	 edx, ecx, 36
  00ffb	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01001	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  01008	51		 push	 ecx
  01009	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  01010	6b c2 22	 imul	 eax, edx, 34
  01013	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01019	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  01020	52		 push	 edx
  01021	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01027	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0102d	e8 00 00 00 00	 call	 ?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z ; CGameLogic::AnalyseTingCard
  01032	88 85 78 fc ff
	ff		 mov	 BYTE PTR _cbCount$30[ebp], al

; 1439 : 				if(cbCount >0)

  01038	0f b6 85 78 fc
	ff ff		 movzx	 eax, BYTE PTR _cbCount$30[ebp]
  0103f	85 c0		 test	 eax, eax
  01041	0f 8e 22 01 00
	00		 jle	 $LN62@OnUserOper

; 1440 : 				{
; 1441 : 					m_cbUserAction[wTargetUser] |= WIK_LISTEN; 

  01047	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  0104e	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01054	0f b6 84 0a e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1508]
  0105c	83 c8 20	 or	 eax, 32			; 00000020H
  0105f	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  01066	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0106c	88 84 0a e4 05
	00 00		 mov	 BYTE PTR [edx+ecx+1508], al

; 1442 : 
; 1443 : 					for(int i=0;i<MAX_COUNT;i++)

  01073	c7 85 58 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$13[ebp], 0
  0107d	eb 0f		 jmp	 SHORT $LN15@OnUserOper
$LN13@OnUserOper:
  0107f	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _i$13[ebp]
  01085	83 c0 01	 add	 eax, 1
  01088	89 85 58 fc ff
	ff		 mov	 DWORD PTR _i$13[ebp], eax
$LN15@OnUserOper:
  0108e	83 bd 58 fc ff
	ff 0e		 cmp	 DWORD PTR _i$13[ebp], 14 ; 0000000eH
  01095	0f 8d 91 00 00
	00		 jge	 $LN14@OnUserOper

; 1444 : 					{
; 1445 : 						if(HuData.cbHuCardCount[i]>0)

  0109b	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR _i$13[ebp]
  010a1	0f b6 94 0d af
	fc ff ff	 movzx	 edx, BYTE PTR _HuData$44[ebp+ecx+15]
  010a9	85 d2		 test	 edx, edx
  010ab	7e 78		 jle	 SHORT $LN64@OnUserOper

; 1446 : 						{
; 1447 : 							for(int j=0;j<HuData.cbHuCardCount[i];j++)

  010ad	c7 85 50 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$8[ebp], 0
  010b7	eb 0f		 jmp	 SHORT $LN18@OnUserOper
$LN16@OnUserOper:
  010b9	8b 85 50 fc ff
	ff		 mov	 eax, DWORD PTR _j$8[ebp]
  010bf	83 c0 01	 add	 eax, 1
  010c2	89 85 50 fc ff
	ff		 mov	 DWORD PTR _j$8[ebp], eax
$LN18@OnUserOper:
  010c8	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR _i$13[ebp]
  010ce	0f b6 94 0d af
	fc ff ff	 movzx	 edx, BYTE PTR _HuData$44[ebp+ecx+15]
  010d6	39 95 50 fc ff
	ff		 cmp	 DWORD PTR _j$8[ebp], edx
  010dc	7d 45		 jge	 SHORT $LN17@OnUserOper

; 1448 : 							{
; 1449 : 								HuData.cbHuCardRemainingCount[i][j] = GetRemainingCount(wTargetUser,HuData.cbHuCardData[i][j]);

  010de	6b 85 58 fc ff
	ff 1c		 imul	 eax, DWORD PTR _i$13[ebp], 28
  010e5	8d 8c 05 bd fc
	ff ff		 lea	 ecx, DWORD PTR _HuData$44[ebp+eax+29]
  010ec	8b 95 50 fc ff
	ff		 mov	 edx, DWORD PTR _j$8[ebp]
  010f2	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  010f6	50		 push	 eax
  010f7	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  010fe	51		 push	 ecx
  010ff	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01105	e8 00 00 00 00	 call	 ?GetRemainingCount@CTableFrameSink@@IAEEGE@Z ; CTableFrameSink::GetRemainingCount
  0110a	6b 95 58 fc ff
	ff 1c		 imul	 edx, DWORD PTR _i$13[ebp], 28
  01111	8d 8c 15 45 fe
	ff ff		 lea	 ecx, DWORD PTR _HuData$44[ebp+edx+421]
  01118	8b 95 50 fc ff
	ff		 mov	 edx, DWORD PTR _j$8[ebp]
  0111e	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1450 : 							}

  01121	eb 96		 jmp	 SHORT $LN16@OnUserOper
$LN17@OnUserOper:

; 1451 : 						}
; 1452 : 						else

  01123	eb 02		 jmp	 SHORT $LN65@OnUserOper
$LN64@OnUserOper:

; 1453 : 							break;

  01125	eb 05		 jmp	 SHORT $LN14@OnUserOper
$LN65@OnUserOper:

; 1454 : 					}

  01127	e9 53 ff ff ff	 jmp	 $LN13@OnUserOper
$LN14@OnUserOper:

; 1455 : 					m_pITableFrame->SendTableData(wTargetUser,SUB_S_HU_CARD,&HuData,sizeof(HuData));

  0112c	68 c8 00 00 00	 push	 200			; 000000c8H
  01131	68 2d 03 00 00	 push	 813			; 0000032dH
  01136	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _HuData$44[ebp]
  0113c	50		 push	 eax
  0113d	6a 6e		 push	 110			; 0000006eH
  0113f	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  01146	51		 push	 ecx
  01147	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0114d	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  01153	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01159	8b 10		 mov	 edx, DWORD PTR [eax]
  0115b	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  01161	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  01167	ff d0		 call	 eax
$LN62@OnUserOper:

; 1456 : 				}
; 1457 : 
; 1458 : 			}
; 1459 :  			OperateResult.cbActionMask |= m_cbUserAction[wTargetUser];

  01169	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  01170	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01176	0f b6 84 0a e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1508]
  0117e	0f b6 4d e6	 movzx	 ecx, BYTE PTR _OperateResult$47[ebp+2]
  01182	0b c8		 or	 ecx, eax
  01184	88 4d e6	 mov	 BYTE PTR _OperateResult$47[ebp+2], cl
$LN61@OnUserOper:

; 1460 :  		}
; 1461 :  
; 1462 :  		//发送消息
; 1463 :  		m_pITableFrame->SendTableData(INVALID_CHAIR,SUB_S_OPERATE_RESULT, &OperateResult, sizeof(OperateResult));

  01187	68 c8 00 00 00	 push	 200			; 000000c8H
  0118c	6a 09		 push	 9
  0118e	8d 55 e4	 lea	 edx, DWORD PTR _OperateResult$47[ebp]
  01191	52		 push	 edx
  01192	6a 68		 push	 104			; 00000068H
  01194	68 ff ff 00 00	 push	 65535			; 0000ffffH
  01199	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0119f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  011a5	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  011ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  011ad	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  011b3	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  011b9	ff d2		 call	 edx

; 1464 :  		m_pITableFrame->SendLookonData(INVALID_CHAIR,SUB_S_OPERATE_RESULT, &OperateResult, sizeof(OperateResult));

  011bb	6a 09		 push	 9
  011bd	8d 45 e4	 lea	 eax, DWORD PTR _OperateResult$47[ebp]
  011c0	50		 push	 eax
  011c1	6a 68		 push	 104			; 00000068H
  011c3	68 ff ff 00 00	 push	 65535			; 0000ffffH
  011c8	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  011ce	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  011d4	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  011da	8b 12		 mov	 edx, DWORD PTR [edx]
  011dc	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  011e2	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  011e8	ff d0		 call	 eax

; 1465 :  
; 1466 : 		if(m_pGameVideo)

  011ea	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  011f0	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  011f7	74 2d		 je	 SHORT $LN66@OnUserOper

; 1467 : 		{
; 1468 : 			m_pGameVideo->AddVideoData(SUB_S_OPERATE_RESULT,&OperateResult,sizeof(OperateResult),true);

  011f9	6a 01		 push	 1
  011fb	6a 09		 push	 9
  011fd	8d 55 e4	 lea	 edx, DWORD PTR _OperateResult$47[ebp]
  01200	52		 push	 edx
  01201	6a 68		 push	 104			; 00000068H
  01203	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01209	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  0120f	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01215	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  0121b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0121d	50		 push	 eax
  0121e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01221	ff d2		 call	 edx
  01223	83 c4 14	 add	 esp, 20			; 00000014H
$LN66@OnUserOper:

; 1469 : 		}
; 1470 :  		//设置用户
; 1471 :  		m_wCurrentUser = wTargetUser;

  01226	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0122c	66 8b 8d 98 fc
	ff ff		 mov	 cx, WORD PTR _wTargetUser$43[ebp]
  01233	66 89 88 be 04
	00 00		 mov	 WORD PTR [eax+1214], cx

; 1472 :  
; 1473 :  		//杠牌处理
; 1474 :  		if (cbTargetAction == WIK_GANG)

  0123a	0f b6 95 97 fc
	ff ff		 movzx	 edx, BYTE PTR _cbTargetAction$42[ebp]
  01241	83 fa 10	 cmp	 edx, 16			; 00000010H
  01244	0f 85 b3 00 00
	00		 jne	 $LN67@OnUserOper

; 1475 :  		{
; 1476 :  			m_cbGangStatus = WIK_FANG_GANG;

  0124a	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01250	c6 80 cc 04 00
	00 02		 mov	 BYTE PTR [eax+1228], 2

; 1477 : 			m_wProvideGangUser = (m_wProvideUser == INVALID_CHAIR) ? wTargetUser : m_wProvideUser;

  01257	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0125d	0f b7 91 c0 04
	00 00		 movzx	 edx, WORD PTR [ecx+1216]
  01264	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0126a	75 10		 jne	 SHORT $LN94@OnUserOper
  0126c	66 8b 85 98 fc
	ff ff		 mov	 ax, WORD PTR _wTargetUser$43[ebp]
  01273	66 89 85 4e fc
	ff ff		 mov	 WORD PTR tv873[ebp], ax
  0127a	eb 14		 jmp	 SHORT $LN95@OnUserOper
$LN94@OnUserOper:
  0127c	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01282	66 8b 91 c0 04
	00 00		 mov	 dx, WORD PTR [ecx+1216]
  01289	66 89 95 4e fc
	ff ff		 mov	 WORD PTR tv873[ebp], dx
$LN95@OnUserOper:
  01290	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01296	66 8b 8d 4e fc
	ff ff		 mov	 cx, WORD PTR tv873[ebp]
  0129d	66 89 88 ce 04
	00 00		 mov	 WORD PTR [eax+1230], cx

; 1478 : 			m_bGangCard[wTargetUser] = true;

  012a4	0f b7 95 98 fc
	ff ff		 movzx	 edx, WORD PTR _wTargetUser$43[ebp]
  012ab	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  012b1	c6 84 10 dc 04
	00 00 01	 mov	 BYTE PTR [eax+edx+1244], 1

; 1479 : 			m_cbGangCount[wTargetUser]++;

  012b9	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  012c0	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  012c6	8a 84 0a e2 04
	00 00		 mov	 al, BYTE PTR [edx+ecx+1250]
  012cd	04 01		 add	 al, 1
  012cf	0f b7 8d 98 fc
	ff ff		 movzx	 ecx, WORD PTR _wTargetUser$43[ebp]
  012d6	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  012dc	88 84 0a e2 04
	00 00		 mov	 BYTE PTR [edx+ecx+1250], al

; 1480 :  			DispatchCardData(wTargetUser, true);

  012e3	6a 01		 push	 1
  012e5	0f b7 85 98 fc
	ff ff		 movzx	 eax, WORD PTR _wTargetUser$43[ebp]
  012ec	50		 push	 eax
  012ed	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  012f3	e8 00 00 00 00	 call	 ?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::DispatchCardData

; 1481 :  		}
; 1482 : 		else//吃碰

  012f8	e9 be 00 00 00	 jmp	 $LN68@OnUserOper
$LN67@OnUserOper:

; 1483 : 		{
; 1484 : 
; 1485 : 			if (m_bTrustee[m_wCurrentUser])

  012fd	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01303	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  0130a	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01310	0f b6 8c 10 78
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1144]
  01318	85 c9		 test	 ecx, ecx
  0131a	74 41		 je	 SHORT $LN69@OnUserOper

; 1486 : 				m_pITableFrame->SetGameTimer(IDI_OUT_CARD, m_pGameCustomRule->cbTimeTrustee * 1000, 1, 0);

  0131c	6a 00		 push	 0
  0131e	6a 01		 push	 1
  01320	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01326	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  0132c	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  01330	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  01336	52		 push	 edx
  01337	6a 03		 push	 3
  01339	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0133f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  01345	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0134b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0134d	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  01353	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  01359	ff d2		 call	 edx

; 1487 : 			else

  0135b	eb 42		 jmp	 SHORT $LN70@OnUserOper
$LN69@OnUserOper:

; 1488 : 				m_pITableFrame->SetGameTimer(IDI_OUT_CARD, (m_pGameCustomRule->cbTimeOutCard + 2) * 1000, 1, 0);

  0135d	6a 00		 push	 0
  0135f	6a 01		 push	 1
  01361	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01367	8b 88 2c 09 00
	00		 mov	 ecx, DWORD PTR [eax+2348]
  0136d	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  01371	83 c2 02	 add	 edx, 2
  01374	69 c2 e8 03 00
	00		 imul	 eax, edx, 1000
  0137a	50		 push	 eax
  0137b	6a 03		 push	 3
  0137d	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01383	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  01389	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0138f	8b 12		 mov	 edx, DWORD PTR [edx]
  01391	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  01397	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0139d	ff d0		 call	 eax
$LN70@OnUserOper:

; 1489 : 
; 1490 : 			m_tActionStartTime = time(0);

  0139f	6a 00		 push	 0
  013a1	e8 00 00 00 00	 call	 _time
  013a6	83 c4 04	 add	 esp, 4
  013a9	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  013af	89 81 a8 04 00
	00		 mov	 DWORD PTR [ecx+1192], eax
  013b5	89 91 ac 04 00
	00		 mov	 DWORD PTR [ecx+1196], edx
$LN68@OnUserOper:

; 1491 : 		}
; 1492 :  
; 1493 :  		return true;

  013bb	c6 85 67 fc ff
	ff 01		 mov	 BYTE PTR $T19[ebp], 1
  013c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  013c9	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  013cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  013d5	8a 85 67 fc ff
	ff		 mov	 al, BYTE PTR $T19[ebp]
  013db	e9 c8 07 00 00	 jmp	 $LN1@OnUserOper
$LN29@OnUserOper:

; 1494 :  	}
; 1495 :  
; 1496 :  	//主动动作
; 1497 :  	if (m_wCurrentUser == wChairID)

  013e0	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  013e6	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  013ed	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  013f1	3b c1		 cmp	 eax, ecx
  013f3	0f 85 ad 07 00
	00		 jne	 $LN71@OnUserOper

; 1498 :  	{
; 1499 :  		//效验操作
; 1500 :  		//ASSERT((cbOperateCode != WIK_NULL) && ((m_cbUserAction[wChairID]&cbOperateCode) != 0));
; 1501 :  		//if ((cbOperateCode == WIK_NULL) || ((m_cbUserAction[wChairID]&cbOperateCode) == 0)) return false;
; 1502 :  
; 1503 :  		//扑克效验
; 1504 :  		ASSERT((cbOperateCode == WIK_NULL) || (cbOperateCode == WIK_CHI_HU) || (m_GameLogic.IsValidCard(cbOperateCard[0])));
; 1505 :  		if ((cbOperateCode != WIK_NULL) && (cbOperateCode != WIK_CHI_HU) && (!m_GameLogic.IsValidCard(cbOperateCard[0]))) return false;

  013f9	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbOperateCode$[ebp]
  013fd	85 d2		 test	 edx, edx
  013ff	74 38		 je	 SHORT $LN72@OnUserOper
  01401	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbOperateCode$[ebp]
  01405	83 f8 40	 cmp	 eax, 64			; 00000040H
  01408	74 2f		 je	 SHORT $LN72@OnUserOper
  0140a	b9 01 00 00 00	 mov	 ecx, 1
  0140f	6b d1 00	 imul	 edx, ecx, 0
  01412	8b 45 10	 mov	 eax, DWORD PTR _cbOperateCard$[ebp]
  01415	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  01419	51		 push	 ecx
  0141a	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01420	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  01426	e8 00 00 00 00	 call	 ?IsValidCard@CGameLogic@@QAE_NE@Z ; CGameLogic::IsValidCard
  0142b	0f b6 d0	 movzx	 edx, al
  0142e	85 d2		 test	 edx, edx
  01430	75 07		 jne	 SHORT $LN72@OnUserOper
  01432	32 c0		 xor	 al, al
  01434	e9 6f 07 00 00	 jmp	 $LN1@OnUserOper
$LN72@OnUserOper:

; 1506 :  
; 1507 : 		if (cbOperateCode == WIK_NULL)

  01439	0f b6 45 0c	 movzx	 eax, BYTE PTR _cbOperateCode$[ebp]
  0143d	85 c0		 test	 eax, eax
  0143f	75 74		 jne	 SHORT $LN73@OnUserOper

; 1508 : 		{
; 1509 : 			CString cc;

  01441	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _cc$4[ebp]
  01447	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  0144d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1510 : 			cc.Format(_T("主动动作%d玩家%d放弃"), m_cbUserAction[m_wCurrentUser], wChairID);

  01454	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  01458	51		 push	 ecx
  01459	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0145f	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  01466	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0146c	0f b6 94 01 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1508]
  01474	52		 push	 edx
  01475	68 00 00 00 00	 push	 OFFSET $SG314038
  0147a	8d 85 34 fc ff
	ff		 lea	 eax, DWORD PTR _cc$4[ebp]
  01480	50		 push	 eax
  01481	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  01487	83 c4 10	 add	 esp, 16			; 00000010H

; 1511 : 			WriteDebugInfo(cc);

  0148a	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _cc$4[ebp]
  01490	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  01496	50		 push	 eax
  01497	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0149d	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1512 : 		}

  014a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  014a9	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _cc$4[ebp]
  014af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
$LN73@OnUserOper:

; 1513 :  		//设置变量
; 1514 :  		m_cbUserAction[m_wCurrentUser] = WIK_NULL;

  014b5	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  014bb	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  014c2	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  014c8	c6 84 10 e4 05
	00 00 00	 mov	 BYTE PTR [eax+edx+1508], 0

; 1515 :  		m_cbPerformAction[m_wCurrentUser] = WIK_NULL;

  014d0	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  014d6	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  014dd	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  014e3	c6 84 10 f4 05
	00 00 00	 mov	 BYTE PTR [eax+edx+1524], 0

; 1516 :  
; 1517 :  		//执行动作
; 1518 :  		switch (cbOperateCode)

  014eb	8a 4d 0c	 mov	 cl, BYTE PTR _cbOperateCode$[ebp]
  014ee	88 8d 30 fc ff
	ff		 mov	 BYTE PTR tv990[ebp], cl
  014f4	80 bd 30 fc ff
	ff 10		 cmp	 BYTE PTR tv990[ebp], 16	; 00000010H
  014fb	74 12		 je	 SHORT $LN74@OnUserOper
  014fd	80 bd 30 fc ff
	ff 40		 cmp	 BYTE PTR tv990[ebp], 64	; 00000040H
  01504	0f 84 61 05 00
	00		 je	 $LN83@OnUserOper
  0150a	e9 93 06 00 00	 jmp	 $LN19@OnUserOper
$LN74@OnUserOper:

; 1519 :  		{
; 1520 :  		case WIK_GANG:			//杠牌操作
; 1521 :  			{
; 1522 : 				m_enSendStatus = Gang_Send;

  0150f	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01515	c7 82 c8 04 00
	00 02 00 00 00	 mov	 DWORD PTR [edx+1224], 2

; 1523 : 
; 1524 :  				//变量定义
; 1525 :  				BYTE cbWeaveIndex = 0xFF;

  0151f	c6 85 95 fc ff
	ff ff		 mov	 BYTE PTR _cbWeaveIndex$40[ebp], 255 ; 000000ffH

; 1526 :  				BYTE cbCardIndex = m_GameLogic.SwitchToCardIndex(cbOperateCard[0]);

  01526	b8 01 00 00 00	 mov	 eax, 1
  0152b	6b c8 00	 imul	 ecx, eax, 0
  0152e	8b 55 10	 mov	 edx, DWORD PTR _cbOperateCard$[ebp]
  01531	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  01535	50		 push	 eax
  01536	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0153c	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  01542	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  01547	88 85 87 fc ff
	ff		 mov	 BYTE PTR _cbCardIndex$34[ebp], al

; 1527 : 				WORD wProvideUser = wChairID;

  0154d	66 8b 4d 08	 mov	 cx, WORD PTR _wChairID$[ebp]
  01551	66 89 8d 60 fc
	ff ff		 mov	 WORD PTR _wProvideUser$15[ebp], cx

; 1528 : 				BYTE cbGangKind = WIK_MING_GANG;

  01558	c6 85 8e fc ff
	ff 01		 mov	 BYTE PTR _cbGangKind$36[ebp], 1

; 1529 :  				//杠牌处理
; 1530 :  				if (m_cbCardIndex[wChairID][cbCardIndex] == 1)

  0155f	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  01563	6b c2 22	 imul	 eax, edx, 34
  01566	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0156c	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  01573	0f b6 85 87 fc
	ff ff		 movzx	 eax, BYTE PTR _cbCardIndex$34[ebp]
  0157a	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0157e	83 f9 01	 cmp	 ecx, 1
  01581	0f 85 bd 01 00
	00		 jne	 $LN75@OnUserOper

; 1531 :  				{
; 1532 :  					//寻找组合
; 1533 :  					for (BYTE i = 0; i < m_cbWeaveItemCount[wChairID]; i++)

  01587	c6 85 94 fc ff
	ff 00		 mov	 BYTE PTR _i$39[ebp], 0
  0158e	eb 0f		 jmp	 SHORT $LN23@OnUserOper
$LN21@OnUserOper:
  01590	8a 95 94 fc ff
	ff		 mov	 dl, BYTE PTR _i$39[ebp]
  01596	80 c2 01	 add	 dl, 1
  01599	88 95 94 fc ff
	ff		 mov	 BYTE PTR _i$39[ebp], dl
$LN23@OnUserOper:
  0159f	0f b6 85 94 fc
	ff ff		 movzx	 eax, BYTE PTR _i$39[ebp]
  015a6	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  015aa	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  015b0	0f b6 8c 0a 3e
	08 00 00	 movzx	 ecx, BYTE PTR [edx+ecx+2110]
  015b8	3b c1		 cmp	 eax, ecx
  015ba	0f 8d 88 00 00
	00		 jge	 $LN22@OnUserOper

; 1534 :  					{
; 1535 :  						BYTE cbWeaveKind = m_WeaveItemArray[wChairID][i].cbWeaveKind;

  015c0	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  015c4	6b c2 24	 imul	 eax, edx, 36
  015c7	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  015cd	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  015d4	0f b6 85 94 fc
	ff ff		 movzx	 eax, BYTE PTR _i$39[ebp]
  015db	6b c8 09	 imul	 ecx, eax, 9
  015de	8a 14 0a	 mov	 dl, BYTE PTR [edx+ecx]
  015e1	88 95 64 fc ff
	ff		 mov	 BYTE PTR _cbWeaveKind$16[ebp], dl

; 1536 :  						BYTE cbCenterCard = m_WeaveItemArray[wChairID][i].cbCenterCard;

  015e7	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  015eb	6b c8 24	 imul	 ecx, eax, 36
  015ee	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  015f4	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  015fb	0f b6 8d 94 fc
	ff ff		 movzx	 ecx, BYTE PTR _i$39[ebp]
  01602	6b d1 09	 imul	 edx, ecx, 9
  01605	8a 44 10 01	 mov	 al, BYTE PTR [eax+edx+1]
  01609	88 85 68 fc ff
	ff		 mov	 BYTE PTR _cbCenterCard$20[ebp], al

; 1537 :  						if ((cbCenterCard == cbOperateCard[0]) && (cbWeaveKind == WIK_PENG))

  0160f	0f b6 8d 68 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbCenterCard$20[ebp]
  01616	ba 01 00 00 00	 mov	 edx, 1
  0161b	6b c2 00	 imul	 eax, edx, 0
  0161e	8b 55 10	 mov	 edx, DWORD PTR _cbOperateCard$[ebp]
  01621	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  01625	3b c8		 cmp	 ecx, eax
  01627	75 1a		 jne	 SHORT $LN77@OnUserOper
  01629	0f b6 8d 64 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbWeaveKind$16[ebp]
  01630	83 f9 08	 cmp	 ecx, 8
  01633	75 0e		 jne	 SHORT $LN77@OnUserOper

; 1538 :  						{
; 1539 :  							cbWeaveIndex = i;

  01635	8a 95 94 fc ff
	ff		 mov	 dl, BYTE PTR _i$39[ebp]
  0163b	88 95 95 fc ff
	ff		 mov	 BYTE PTR _cbWeaveIndex$40[ebp], dl

; 1540 :  							break;

  01641	eb 05		 jmp	 SHORT $LN22@OnUserOper
$LN77@OnUserOper:

; 1541 :  						}
; 1542 :  					}

  01643	e9 48 ff ff ff	 jmp	 $LN21@OnUserOper
$LN22@OnUserOper:

; 1543 :  
; 1544 :  					//效验动作
; 1545 :  					ASSERT(cbWeaveIndex != 0xFF);
; 1546 :  					if (cbWeaveIndex == 0xFF) return false;

  01648	0f b6 85 95 fc
	ff ff		 movzx	 eax, BYTE PTR _cbWeaveIndex$40[ebp]
  0164f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01654	75 07		 jne	 SHORT $LN78@OnUserOper
  01656	32 c0		 xor	 al, al
  01658	e9 4b 05 00 00	 jmp	 $LN1@OnUserOper
$LN78@OnUserOper:

; 1547 :  
; 1548 : 					cbGangKind = WIK_MING_GANG;

  0165d	c6 85 8e fc ff
	ff 01		 mov	 BYTE PTR _cbGangKind$36[ebp], 1

; 1549 : 
; 1550 :  					//组合扑克
; 1551 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].cbParam = WIK_MING_GANG;

  01664	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  01668	6b d1 24	 imul	 edx, ecx, 36
  0166b	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01671	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  01678	0f b6 95 95 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveIndex$40[ebp]
  0167f	6b c2 09	 imul	 eax, edx, 9
  01682	c6 44 01 02 01	 mov	 BYTE PTR [ecx+eax+2], 1

; 1552 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].cbWeaveKind = cbOperateCode;

  01687	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0168b	6b d1 24	 imul	 edx, ecx, 36
  0168e	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01694	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  0169b	0f b6 95 95 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveIndex$40[ebp]
  016a2	6b c2 09	 imul	 eax, edx, 9
  016a5	8a 55 0c	 mov	 dl, BYTE PTR _cbOperateCode$[ebp]
  016a8	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 1553 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].cbCenterCard = cbOperateCard[0];

  016ab	b8 01 00 00 00	 mov	 eax, 1
  016b0	6b c8 00	 imul	 ecx, eax, 0
  016b3	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  016b7	6b c2 24	 imul	 eax, edx, 36
  016ba	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  016c0	8d 84 02 42 08
	00 00		 lea	 eax, DWORD PTR [edx+eax+2114]
  016c7	0f b6 95 95 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveIndex$40[ebp]
  016ce	6b d2 09	 imul	 edx, edx, 9
  016d1	8b 75 10	 mov	 esi, DWORD PTR _cbOperateCard$[ebp]
  016d4	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  016d7	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 1554 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].cbCardData[3] = cbOperateCard[0];

  016db	ba 01 00 00 00	 mov	 edx, 1
  016e0	6b c2 00	 imul	 eax, edx, 0
  016e3	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  016e7	6b d1 24	 imul	 edx, ecx, 36
  016ea	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  016f0	8d 94 11 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+edx+2114]
  016f7	0f b6 8d 95 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbWeaveIndex$40[ebp]
  016fe	6b c9 09	 imul	 ecx, ecx, 9
  01701	03 d1		 add	 edx, ecx
  01703	b9 01 00 00 00	 mov	 ecx, 1
  01708	6b c9 03	 imul	 ecx, ecx, 3
  0170b	8b 75 10	 mov	 esi, DWORD PTR _cbOperateCard$[ebp]
  0170e	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  01711	88 44 0a 05	 mov	 BYTE PTR [edx+ecx+5], al

; 1555 :  
; 1556 :  					//杠牌得分
; 1557 :  					wProvideUser = m_WeaveItemArray[wChairID][cbWeaveIndex].wProvideUser;

  01715	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  01719	6b d1 24	 imul	 edx, ecx, 36
  0171c	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01722	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  01729	0f b6 95 95 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveIndex$40[ebp]
  01730	6b c2 09	 imul	 eax, edx, 9
  01733	66 8b 4c 01 03	 mov	 cx, WORD PTR [ecx+eax+3]
  01738	66 89 8d 60 fc
	ff ff		 mov	 WORD PTR _wProvideUser$15[ebp], cx

; 1558 :  				}
; 1559 :  				else

  0173f	e9 6b 01 00 00	 jmp	 $LN76@OnUserOper
$LN75@OnUserOper:

; 1560 :  				{
; 1561 :  					//扑克效验
; 1562 :  					ASSERT(m_cbCardIndex[wChairID][cbCardIndex] == 4);
; 1563 :  					if (m_cbCardIndex[wChairID][cbCardIndex] != 4) 

  01744	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  01748	6b c2 22	 imul	 eax, edx, 34
  0174b	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01751	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  01758	0f b6 85 87 fc
	ff ff		 movzx	 eax, BYTE PTR _cbCardIndex$34[ebp]
  0175f	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  01763	83 f9 04	 cmp	 ecx, 4
  01766	74 07		 je	 SHORT $LN79@OnUserOper

; 1564 :  						return false;

  01768	32 c0		 xor	 al, al
  0176a	e9 39 04 00 00	 jmp	 $LN1@OnUserOper
$LN79@OnUserOper:

; 1565 :  
; 1566 :  					//设置变量
; 1567 :  					cbGangKind = WIK_AN_GANG;

  0176f	c6 85 8e fc ff
	ff 03		 mov	 BYTE PTR _cbGangKind$36[ebp], 3

; 1568 :  					cbWeaveIndex = m_cbWeaveItemCount[wChairID]++;

  01776	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  0177a	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01780	8a 8c 10 3e 08
	00 00		 mov	 cl, BYTE PTR [eax+edx+2110]
  01787	88 8d 95 fc ff
	ff		 mov	 BYTE PTR _cbWeaveIndex$40[ebp], cl
  0178d	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  01791	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01797	8a 8c 10 3e 08
	00 00		 mov	 cl, BYTE PTR [eax+edx+2110]
  0179e	80 c1 01	 add	 cl, 1
  017a1	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  017a5	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  017ab	88 8c 10 3e 08
	00 00		 mov	 BYTE PTR [eax+edx+2110], cl

; 1569 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].cbParam = WIK_AN_GANG;

  017b2	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  017b6	6b d1 24	 imul	 edx, ecx, 36
  017b9	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  017bf	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  017c6	0f b6 95 95 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveIndex$40[ebp]
  017cd	6b c2 09	 imul	 eax, edx, 9
  017d0	c6 44 01 02 03	 mov	 BYTE PTR [ecx+eax+2], 3

; 1570 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].wProvideUser = wChairID;

  017d5	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  017d9	6b d1 24	 imul	 edx, ecx, 36
  017dc	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  017e2	8d 8c 10 42 08
	00 00		 lea	 ecx, DWORD PTR [eax+edx+2114]
  017e9	0f b6 95 95 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveIndex$40[ebp]
  017f0	6b c2 09	 imul	 eax, edx, 9
  017f3	66 8b 55 08	 mov	 dx, WORD PTR _wChairID$[ebp]
  017f7	66 89 54 01 03	 mov	 WORD PTR [ecx+eax+3], dx

; 1571 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].cbWeaveKind = cbOperateCode;

  017fc	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  01800	6b c8 24	 imul	 ecx, eax, 36
  01803	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01809	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  01810	0f b6 8d 95 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbWeaveIndex$40[ebp]
  01817	6b d1 09	 imul	 edx, ecx, 9
  0181a	8a 4d 0c	 mov	 cl, BYTE PTR _cbOperateCode$[ebp]
  0181d	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1572 :  					m_WeaveItemArray[wChairID][cbWeaveIndex].cbCenterCard = cbOperateCard[0];

  01820	ba 01 00 00 00	 mov	 edx, 1
  01825	6b c2 00	 imul	 eax, edx, 0
  01828	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0182c	6b d1 24	 imul	 edx, ecx, 36
  0182f	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01835	8d 94 11 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+edx+2114]
  0183c	0f b6 8d 95 fc
	ff ff		 movzx	 ecx, BYTE PTR _cbWeaveIndex$40[ebp]
  01843	6b c9 09	 imul	 ecx, ecx, 9
  01846	8b 75 10	 mov	 esi, DWORD PTR _cbOperateCard$[ebp]
  01849	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0184c	88 44 0a 01	 mov	 BYTE PTR [edx+ecx+1], al

; 1573 :  					for(BYTE j = 0; j < 4; j++) 

  01850	c6 85 8f fc ff
	ff 00		 mov	 BYTE PTR _j$37[ebp], 0
  01857	eb 0f		 jmp	 SHORT $LN26@OnUserOper
$LN24@OnUserOper:
  01859	8a 8d 8f fc ff
	ff		 mov	 cl, BYTE PTR _j$37[ebp]
  0185f	80 c1 01	 add	 cl, 1
  01862	88 8d 8f fc ff
	ff		 mov	 BYTE PTR _j$37[ebp], cl
$LN26@OnUserOper:
  01868	0f b6 95 8f fc
	ff ff		 movzx	 edx, BYTE PTR _j$37[ebp]
  0186f	83 fa 04	 cmp	 edx, 4
  01872	7d 3b		 jge	 SHORT $LN76@OnUserOper

; 1574 : 					{
; 1575 : 						m_WeaveItemArray[wChairID][cbWeaveIndex].cbCardData[j] = cbOperateCard[0];

  01874	b8 01 00 00 00	 mov	 eax, 1
  01879	6b c8 00	 imul	 ecx, eax, 0
  0187c	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  01880	6b c2 24	 imul	 eax, edx, 36
  01883	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01889	8d 84 02 42 08
	00 00		 lea	 eax, DWORD PTR [edx+eax+2114]
  01890	0f b6 95 95 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveIndex$40[ebp]
  01897	6b d2 09	 imul	 edx, edx, 9
  0189a	03 c2		 add	 eax, edx
  0189c	0f b6 95 8f fc
	ff ff		 movzx	 edx, BYTE PTR _j$37[ebp]
  018a3	8b 75 10	 mov	 esi, DWORD PTR _cbOperateCard$[ebp]
  018a6	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  018a9	88 4c 10 05	 mov	 BYTE PTR [eax+edx+5], cl

; 1576 : 					}

  018ad	eb aa		 jmp	 SHORT $LN24@OnUserOper
$LN76@OnUserOper:

; 1577 :  				}
; 1578 :  
; 1579 :  				//删除扑克
; 1580 :  				m_cbCardIndex[wChairID][cbCardIndex] = 0;

  018af	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  018b3	6b c2 22	 imul	 eax, edx, 34
  018b6	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  018bc	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  018c3	0f b6 85 87 fc
	ff ff		 movzx	 eax, BYTE PTR _cbCardIndex$34[ebp]
  018ca	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1581 : 				m_cbGangStatus = cbGangKind;

  018ce	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  018d4	8a 95 8e fc ff
	ff		 mov	 dl, BYTE PTR _cbGangKind$36[ebp]
  018da	88 91 cc 04 00
	00		 mov	 BYTE PTR [ecx+1228], dl

; 1582 : 				m_wProvideGangUser = wProvideUser;

  018e0	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  018e6	66 8b 8d 60 fc
	ff ff		 mov	 cx, WORD PTR _wProvideUser$15[ebp]
  018ed	66 89 88 ce 04
	00 00		 mov	 WORD PTR [eax+1230], cx

; 1583 : 				m_bGangCard[wChairID] = true;

  018f4	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  018f8	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  018fe	c6 84 10 dc 04
	00 00 01	 mov	 BYTE PTR [eax+edx+1244], 1

; 1584 : 				m_cbGangCount[wChairID]++;

  01906	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0190a	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01910	8a 84 0a e2 04
	00 00		 mov	 al, BYTE PTR [edx+ecx+1250]
  01917	04 01		 add	 al, 1
  01919	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0191d	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01923	88 84 0a e2 04
	00 00		 mov	 BYTE PTR [edx+ecx+1250], al

; 1585 :  
; 1586 :  				//构造结果
; 1587 :  				CMD_S_OperateResult OperateResult;
; 1588 :  				ZeroMemory(&OperateResult, sizeof(OperateResult));

  0192a	6a 09		 push	 9
  0192c	6a 00		 push	 0
  0192e	8d 45 d8	 lea	 eax, DWORD PTR _OperateResult$46[ebp]
  01931	50		 push	 eax
  01932	e8 00 00 00 00	 call	 _memset
  01937	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1589 :  				OperateResult.wOperateUser = wChairID;

  0193a	66 8b 4d 08	 mov	 cx, WORD PTR _wChairID$[ebp]
  0193e	66 89 4d d8	 mov	 WORD PTR _OperateResult$46[ebp], cx

; 1590 :  				OperateResult.wProvideUser = wProvideUser;

  01942	66 8b 95 60 fc
	ff ff		 mov	 dx, WORD PTR _wProvideUser$15[ebp]
  01949	66 89 55 db	 mov	 WORD PTR _OperateResult$46[ebp+3], dx

; 1591 :  				OperateResult.cbOperateCode = cbOperateCode;

  0194d	8a 45 0c	 mov	 al, BYTE PTR _cbOperateCode$[ebp]
  01950	88 45 dd	 mov	 BYTE PTR _OperateResult$46[ebp+5], al

; 1592 :  				OperateResult.cbOperateCard[0] = cbOperateCard[0];

  01953	b9 01 00 00 00	 mov	 ecx, 1
  01958	6b d1 00	 imul	 edx, ecx, 0
  0195b	b8 01 00 00 00	 mov	 eax, 1
  01960	6b c8 00	 imul	 ecx, eax, 0
  01963	8b 45 10	 mov	 eax, DWORD PTR _cbOperateCard$[ebp]
  01966	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  01969	88 54 0d de	 mov	 BYTE PTR _OperateResult$46[ebp+ecx+6], dl

; 1593 :  
; 1594 :  				//发送消息
; 1595 :  				m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_OPERATE_RESULT, &OperateResult, sizeof(OperateResult));

  0196d	68 c8 00 00 00	 push	 200			; 000000c8H
  01972	6a 09		 push	 9
  01974	8d 45 d8	 lea	 eax, DWORD PTR _OperateResult$46[ebp]
  01977	50		 push	 eax
  01978	6a 68		 push	 104			; 00000068H
  0197a	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0197f	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01985	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  0198b	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01991	8b 12		 mov	 edx, DWORD PTR [edx]
  01993	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  01999	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  0199f	ff d0		 call	 eax

; 1596 :  				m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_OPERATE_RESULT, &OperateResult, sizeof(OperateResult));

  019a1	6a 09		 push	 9
  019a3	8d 4d d8	 lea	 ecx, DWORD PTR _OperateResult$46[ebp]
  019a6	51		 push	 ecx
  019a7	6a 68		 push	 104			; 00000068H
  019a9	68 ff ff 00 00	 push	 65535			; 0000ffffH
  019ae	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  019b4	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  019ba	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  019c0	8b 10		 mov	 edx, DWORD PTR [eax]
  019c2	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  019c8	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  019ce	ff d0		 call	 eax

; 1597 : 
; 1598 : 				if(m_pGameVideo)

  019d0	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  019d6	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  019dd	74 2d		 je	 SHORT $LN80@OnUserOper

; 1599 : 				{
; 1600 : 					m_pGameVideo->AddVideoData(SUB_S_OPERATE_RESULT,&OperateResult,sizeof(OperateResult),true);

  019df	6a 01		 push	 1
  019e1	6a 09		 push	 9
  019e3	8d 55 d8	 lea	 edx, DWORD PTR _OperateResult$46[ebp]
  019e6	52		 push	 edx
  019e7	6a 68		 push	 104			; 00000068H
  019e9	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  019ef	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  019f5	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  019fb	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  01a01	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01a03	50		 push	 eax
  01a04	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01a07	ff d2		 call	 edx
  01a09	83 c4 14	 add	 esp, 20			; 00000014H
$LN80@OnUserOper:

; 1601 : 				}
; 1602 :  				//效验动作
; 1603 :  				bool bAroseAction = false;

  01a0c	c6 85 77 fc ff
	ff 00		 mov	 BYTE PTR _bAroseAction$29[ebp], 0

; 1604 :  				if (cbGangKind == WIK_MING_GANG) 

  01a13	0f b6 85 8e fc
	ff ff		 movzx	 eax, BYTE PTR _cbGangKind$36[ebp]
  01a1a	83 f8 01	 cmp	 eax, 1
  01a1d	75 28		 jne	 SHORT $LN81@OnUserOper

; 1605 : 				{
; 1606 : 					bAroseAction=EstimateUserRespond(wChairID, cbOperateCard[0], EstimatKind_GangCard);

  01a1f	6a 01		 push	 1
  01a21	b9 01 00 00 00	 mov	 ecx, 1
  01a26	6b d1 00	 imul	 edx, ecx, 0
  01a29	8b 45 10	 mov	 eax, DWORD PTR _cbOperateCard$[ebp]
  01a2c	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  01a30	51		 push	 ecx
  01a31	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  01a35	52		 push	 edx
  01a36	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a3c	e8 00 00 00 00	 call	 ?EstimateUserRespond@CTableFrameSink@@IAE_NGEW4enEstimatKind@@@Z ; CTableFrameSink::EstimateUserRespond
  01a41	88 85 77 fc ff
	ff		 mov	 BYTE PTR _bAroseAction$29[ebp], al
$LN81@OnUserOper:

; 1607 : 				}
; 1608 :  
; 1609 :  				//发送扑克
; 1610 :  				if (!bAroseAction)

  01a47	0f b6 85 77 fc
	ff ff		 movzx	 eax, BYTE PTR _bAroseAction$29[ebp]
  01a4e	85 c0		 test	 eax, eax
  01a50	75 12		 jne	 SHORT $LN82@OnUserOper

; 1611 :  				{
; 1612 :  					DispatchCardData(wChairID, true);

  01a52	6a 01		 push	 1
  01a54	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  01a58	51		 push	 ecx
  01a59	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a5f	e8 00 00 00 00	 call	 ?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::DispatchCardData
$LN82@OnUserOper:

; 1613 :  				}
; 1614 :  
; 1615 :  				return true;

  01a64	b0 01		 mov	 al, 1
  01a66	e9 3d 01 00 00	 jmp	 $LN1@OnUserOper
$LN83@OnUserOper:

; 1616 :  			}
; 1617 :  		case WIK_CHI_HU:		//自摸
; 1618 :  			{
; 1619 :  				//普通胡牌
; 1620 :  				BYTE cbWeaveItemCount = m_cbWeaveItemCount[wChairID];

  01a6b	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  01a6f	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01a75	8a 8c 10 3e 08
	00 00		 mov	 cl, BYTE PTR [eax+edx+2110]
  01a7c	88 8d 69 fc ff
	ff		 mov	 BYTE PTR _cbWeaveItemCount$21[ebp], cl

; 1621 :  				tagWeaveItem * pWeaveItem = m_WeaveItemArray[wChairID];

  01a82	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  01a86	6b c2 24	 imul	 eax, edx, 36
  01a89	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01a8f	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  01a96	89 95 28 fc ff
	ff		 mov	 DWORD PTR _pWeaveItem$2[ebp], edx

; 1622 :  				if(!m_GameLogic.RemoveCard(m_cbCardIndex[wChairID], &m_cbSendCardData, 1))

  01a9c	6a 01		 push	 1
  01a9e	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01aa4	05 3c 07 00 00	 add	 eax, 1852		; 0000073cH
  01aa9	50		 push	 eax
  01aaa	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  01aae	6b d1 22	 imul	 edx, ecx, 34
  01ab1	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01ab7	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  01abe	51		 push	 ecx
  01abf	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01ac5	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  01acb	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEQBEE@Z ; CGameLogic::RemoveCard
  01ad0	0f b6 d0	 movzx	 edx, al
  01ad3	85 d2		 test	 edx, edx
  01ad5	75 07		 jne	 SHORT $LN84@OnUserOper

; 1623 :  				{
; 1624 :  					ASSERT(FALSE);
; 1625 :  					return false;

  01ad7	32 c0		 xor	 al, al
  01ad9	e9 ca 00 00 00	 jmp	 $LN1@OnUserOper
$LN84@OnUserOper:

; 1626 :  				}
; 1627 :  				m_dwChiHuKind[wChairID] = m_GameLogic.AnalyseChiHuCard(m_cbCardIndex[wChairID], pWeaveItem, cbWeaveItemCount, m_cbSendCardData, m_ChiHuRight[wChairID],true);

  01ade	6a 01		 push	 1
  01ae0	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  01ae4	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01aea	8d 94 81 2c 06
	00 00		 lea	 edx, DWORD PTR [ecx+eax*4+1580]
  01af1	52		 push	 edx
  01af2	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01af8	0f b6 88 3c 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1852]
  01aff	51		 push	 ecx
  01b00	0f b6 95 69 fc
	ff ff		 movzx	 edx, BYTE PTR _cbWeaveItemCount$21[ebp]
  01b07	52		 push	 edx
  01b08	8b 85 28 fc ff
	ff		 mov	 eax, DWORD PTR _pWeaveItem$2[ebp]
  01b0e	50		 push	 eax
  01b0f	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  01b13	6b d1 22	 imul	 edx, ecx, 34
  01b16	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01b1c	8d 8c 10 b2 07
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1970]
  01b23	51		 push	 ecx
  01b24	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b2a	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  01b30	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  01b35	0f b6 d0	 movzx	 edx, al
  01b38	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  01b3c	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b42	89 94 81 1c 06
	00 00		 mov	 DWORD PTR [ecx+eax*4+1564], edx

; 1628 :  
; 1629 :  				//结束信息
; 1630 : 				m_cbChiHuCard = m_cbSendCardData;

  01b49	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01b4f	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01b55	8a 88 3c 07 00
	00		 mov	 cl, BYTE PTR [eax+1852]
  01b5b	88 8a 18 06 00
	00		 mov	 BYTE PTR [edx+1560], cl

; 1631 : 				m_cbProvideCard = m_cbSendCardData;

  01b61	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01b67	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01b6d	8a 88 3c 07 00
	00		 mov	 cl, BYTE PTR [eax+1852]
  01b73	88 8a c2 04 00
	00		 mov	 BYTE PTR [edx+1218], cl

; 1632 : 				
; 1633 :  				//结束游戏
; 1634 :  				OnEventGameConclude(m_wProvideUser, NULL, GER_NORMAL);

  01b79	6a 00		 push	 0
  01b7b	6a 00		 push	 0
  01b7d	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01b83	0f b7 82 c0 04
	00 00		 movzx	 eax, WORD PTR [edx+1216]
  01b8a	50		 push	 eax
  01b8b	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b91	8b 11		 mov	 edx, DWORD PTR [ecx]
  01b93	8b 8d 9c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01b99	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01b9c	ff d0		 call	 eax

; 1635 :  
; 1636 :  				return true;

  01b9e	b0 01		 mov	 al, 1
  01ba0	eb 06		 jmp	 SHORT $LN1@OnUserOper
$LN19@OnUserOper:

; 1637 :  			}
; 1638 :  		}
; 1639 :  
; 1640 :  		return true;

  01ba2	b0 01		 mov	 al, 1
  01ba4	eb 02		 jmp	 SHORT $LN1@OnUserOper
$LN71@OnUserOper:

; 1641 :  	}
; 1642 : 
; 1643 : 	return false;

  01ba6	32 c0		 xor	 al, al
$LN1@OnUserOper:

; 1644 : }

  01ba8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01bab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01bb2	59		 pop	 ecx
  01bb3	5e		 pop	 esi
  01bb4	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01bb7	33 cd		 xor	 ecx, ebp
  01bb9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01bbe	8b e5		 mov	 esp, ebp
  01bc0	5d		 pop	 ebp
  01bc1	c2 0c 00	 ret	 12			; 0000000cH
$LN100@OnUserOper:
  01bc4	00 00 00 00	 DD	 $LN47@OnUserOper
  01bc8	00 00 00 00	 DD	 $LN51@OnUserOper
  01bcc	00 00 00 00	 DD	 $LN49@OnUserOper
  01bd0	00 00 00 00	 DD	 $LN53@OnUserOper
  01bd4	00 00 00 00	 DD	 $LN55@OnUserOper
  01bd8	00 00 00 00	 DD	 $LN57@OnUserOper
$LN98@OnUserOper:
  01bdc	00		 DB	 0
  01bdd	01		 DB	 1
  01bde	05		 DB	 5
  01bdf	02		 DB	 2
  01be0	05		 DB	 5
  01be1	05		 DB	 5
  01be2	05		 DB	 5
  01be3	03		 DB	 3
  01be4	05		 DB	 5
  01be5	05		 DB	 5
  01be6	05		 DB	 5
  01be7	05		 DB	 5
  01be8	05		 DB	 5
  01be9	05		 DB	 5
  01bea	05		 DB	 5
  01beb	04		 DB	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z$0:
  00000	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _cc$32[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z$1:
  0000c	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _cc$4[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 8a 2c fc ff
	ff		 mov	 ecx, DWORD PTR [edx-980]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z ENDP	; CTableFrameSink::OnUserOperateCard
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv78 = -44						; size = 4
tv74 = -40						; size = 4
_i$2 = -36						; size = 4
_OutCard$ = -32						; size = 4
_ss$ = -28						; size = 4
_this$ = -24						; size = 4
$T3 = -18						; size = 1
_bAroseAction$ = -17					; size = 1
$T4 = -16						; size = 1
$T5 = -15						; size = 1
$T6 = -14						; size = 1
$T7 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_wChairID$ = 8						; size = 2
_cbCardData$ = 12					; size = 1
_bSysOut$ = 16						; size = 1
?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z PROC	; CTableFrameSink::OnUserOutCard
; _this$ = ecx

; 1063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1064 : 	CString ss;

  00028	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1065 : 	ss.Format(_T("玩家%d出牌%0x,curuser=%d,sysout%d,trustee%d"), wChairID, cbCardData, m_wCurrentUser, bSysOut ? 1 : 0, m_bTrustee[wChairID] ? 1 : 0);

  00038	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  0003c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	0f b6 94 01 78
	04 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1144]
  00047	85 d2		 test	 edx, edx
  00049	74 09		 je	 SHORT $LN15@OnUserOutC
  0004b	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00052	eb 07		 jmp	 SHORT $LN16@OnUserOutC
$LN15@OnUserOutC:
  00054	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN16@OnUserOutC:
  0005b	0f b6 45 10	 movzx	 eax, BYTE PTR _bSysOut$[ebp]
  0005f	85 c0		 test	 eax, eax
  00061	74 09		 je	 SHORT $LN17@OnUserOutC
  00063	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0006a	eb 07		 jmp	 SHORT $LN18@OnUserOutC
$LN17@OnUserOutC:
  0006c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN18@OnUserOutC:
  00073	8b 4d d8	 mov	 ecx, DWORD PTR tv74[ebp]
  00076	51		 push	 ecx
  00077	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  0007a	52		 push	 edx
  0007b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  00085	51		 push	 ecx
  00086	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCardData$[ebp]
  0008a	52		 push	 edx
  0008b	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET $SG313876
  00095	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  00098	51		 push	 ecx
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  0009f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1066 : 	WriteDebugInfo(ss);

  000a2	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  000ab	50		 push	 eax
  000ac	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1067 : 	//效验状态
; 1068 : 	ASSERT(m_pITableFrame->GetGameStatus() == GAME_SCENE_PLAY);
; 1069 : 	if (m_pITableFrame->GetGameStatus() != GAME_SCENE_PLAY)

  000b4	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000b7	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  000bd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	8b 10		 mov	 edx, DWORD PTR [eax]
  000c2	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  000c8	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  000cb	ff d0		 call	 eax
  000cd	0f b6 c8	 movzx	 ecx, al
  000d0	83 f9 64	 cmp	 ecx, 100		; 00000064H
  000d3	74 29		 je	 SHORT $LN5@OnUserOutC

; 1070 : 	{
; 1071 : 		WriteDebugInfo(_T("出牌error1"));

  000d5	68 00 00 00 00	 push	 OFFSET $SG313878
  000da	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1072 : 		return true;

  000e2	c6 45 f3 01	 mov	 BYTE PTR $T7[ebp], 1
  000e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ed	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  000f6	8a 45 f3	 mov	 al, BYTE PTR $T7[ebp]
  000f9	e9 23 03 00 00	 jmp	 $LN1@OnUserOutC
$LN5@OnUserOutC:

; 1073 : 	}
; 1074 : 	//错误断言
; 1075 : 	ASSERT(wChairID == m_wCurrentUser);
; 1076 : 	ASSERT(m_GameLogic.IsValidCard(cbCardData));
; 1077 : 
; 1078 : 	//效验参数
; 1079 : 	if (wChairID != m_wCurrentUser)

  000fe	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00102	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00105	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  0010c	3b d1		 cmp	 edx, ecx
  0010e	74 29		 je	 SHORT $LN6@OnUserOutC

; 1080 : 	{
; 1081 : 		WriteDebugInfo(_T("出牌error2"));

  00110	68 00 00 00 00	 push	 OFFSET $SG313881
  00115	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1082 : 		return false;

  0011d	c6 45 f2 00	 mov	 BYTE PTR $T6[ebp], 0
  00121	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00128	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00131	8a 45 f2	 mov	 al, BYTE PTR $T6[ebp]
  00134	e9 e8 02 00 00	 jmp	 $LN1@OnUserOutC
$LN6@OnUserOutC:

; 1083 : 	}
; 1084 : 	if (!m_GameLogic.IsValidCard(cbCardData))

  00139	0f b6 55 0c	 movzx	 edx, BYTE PTR _cbCardData$[ebp]
  0013d	52		 push	 edx
  0013e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00147	e8 00 00 00 00	 call	 ?IsValidCard@CGameLogic@@QAE_NE@Z ; CGameLogic::IsValidCard
  0014c	0f b6 c0	 movzx	 eax, al
  0014f	85 c0		 test	 eax, eax
  00151	75 29		 jne	 SHORT $LN7@OnUserOutC

; 1085 : 	{
; 1086 : 		WriteDebugInfo(_T("出牌error3"));

  00153	68 00 00 00 00	 push	 OFFSET $SG313884
  00158	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1087 : 		return false;

  00160	c6 45 f1 00	 mov	 BYTE PTR $T5[ebp], 0
  00164	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0016b	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00174	8a 45 f1	 mov	 al, BYTE PTR $T5[ebp]
  00177	e9 a5 02 00 00	 jmp	 $LN1@OnUserOutC
$LN7@OnUserOutC:

; 1088 : 	}
; 1089 : 	//删除扑克
; 1090 :  	if (!m_GameLogic.RemoveCard(m_cbCardIndex[wChairID], cbCardData))

  0017c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCardData$[ebp]
  00180	51		 push	 ecx
  00181	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00185	6b c2 22	 imul	 eax, edx, 34
  00188	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00192	52		 push	 edx
  00193	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0019c	e8 00 00 00 00	 call	 ?RemoveCard@CGameLogic@@QAE_NQAEE@Z ; CGameLogic::RemoveCard
  001a1	0f b6 c0	 movzx	 eax, al
  001a4	85 c0		 test	 eax, eax
  001a6	75 29		 jne	 SHORT $LN8@OnUserOutC

; 1091 :  	{
; 1092 : 		WriteDebugInfo(_T("出牌error4"));

  001a8	68 00 00 00 00	 push	 OFFSET $SG313887
  001ad	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b0	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1093 :  		ASSERT(FALSE);
; 1094 :  		return false;

  001b5	c6 45 f0 00	 mov	 BYTE PTR $T4[ebp], 0
  001b9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001c0	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  001c9	8a 45 f0	 mov	 al, BYTE PTR $T4[ebp]
  001cc	e9 50 02 00 00	 jmp	 $LN1@OnUserOutC
$LN8@OnUserOutC:

; 1095 :  	}
; 1096 : 
; 1097 : 	//清除禁止
; 1098 : 	m_bEnjoinChiHu[wChairID] = false;

  001d1	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  001d5	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001d8	c6 84 0a d0 04
	00 00 00	 mov	 BYTE PTR [edx+ecx+1232], 0

; 1099 : 	m_bEnjoinChiPeng[wChairID] = false;

  001e0	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  001e4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	c6 84 01 d4 04
	00 00 00	 mov	 BYTE PTR [ecx+eax+1236], 0

; 1100 : 	m_vecEnjoinChiPeng[wChairID].clear();

  001ef	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  001f3	6b c2 0c	 imul	 eax, edx, 12
  001f6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f9	8d 8c 01 1c 05
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1308]
  00200	e8 00 00 00 00	 call	 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear

; 1101 : 	m_vecEnjoinChiHu[wChairID].clear();

  00205	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00209	6b c2 0c	 imul	 eax, edx, 12
  0020c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020f	8d 8c 01 ec 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1260]
  00216	e8 00 00 00 00	 call	 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear

; 1102 : 
; 1103 : 	//设置变量
; 1104 : 	m_enSendStatus = OutCard_Send;

  0021b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0021e	c7 82 c8 04 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+1224], 1

; 1105 : 	m_cbSendCardData = 0;

  00228	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0022b	c6 80 3c 07 00
	00 00		 mov	 BYTE PTR [eax+1852], 0

; 1106 : 	m_cbUserAction[wChairID] = WIK_NULL;

  00232	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00236	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00239	c6 84 0a e4 05
	00 00 00	 mov	 BYTE PTR [edx+ecx+1508], 0

; 1107 : 	m_cbPerformAction[wChairID] = WIK_NULL;

  00241	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00245	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00248	c6 84 01 f4 05
	00 00 00	 mov	 BYTE PTR [ecx+eax+1524], 0

; 1108 : 	//出牌记录
; 1109 : 	m_wOutCardUser = wChairID;

  00250	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00253	66 8b 45 08	 mov	 ax, WORD PTR _wChairID$[ebp]
  00257	66 89 82 44 06
	00 00		 mov	 WORD PTR [edx+1604], ax

; 1110 : 	m_cbOutCardData = cbCardData;

  0025e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00261	8a 55 0c	 mov	 dl, BYTE PTR _cbCardData$[ebp]
  00264	88 91 46 06 00
	00		 mov	 BYTE PTR [ecx+1606], dl

; 1111 : 
; 1112 : 	//构造数据
; 1113 : 	CMD_S_OutCard OutCard;
; 1114 : 	OutCard.wOutCardUser = wChairID;

  0026a	66 8b 45 08	 mov	 ax, WORD PTR _wChairID$[ebp]
  0026e	66 89 45 e0	 mov	 WORD PTR _OutCard$[ebp], ax

; 1115 : 	OutCard.cbOutCardData = cbCardData;

  00272	8a 4d 0c	 mov	 cl, BYTE PTR _cbCardData$[ebp]
  00275	88 4d e2	 mov	 BYTE PTR _OutCard$[ebp+2], cl

; 1116 : 	OutCard.bSysOut=bSysOut;

  00278	8a 55 10	 mov	 dl, BYTE PTR _bSysOut$[ebp]
  0027b	88 55 e3	 mov	 BYTE PTR _OutCard$[ebp+3], dl

; 1117 : 	//发送消息
; 1118 : 	m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_OUT_CARD, &OutCard, sizeof(OutCard));

  0027e	68 c8 00 00 00	 push	 200			; 000000c8H
  00283	6a 04		 push	 4
  00285	8d 45 e0	 lea	 eax, DWORD PTR _OutCard$[ebp]
  00288	50		 push	 eax
  00289	6a 65		 push	 101			; 00000065H
  0028b	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00290	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00293	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00299	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0029c	8b 12		 mov	 edx, DWORD PTR [edx]
  0029e	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  002a4	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  002aa	ff d0		 call	 eax

; 1119 : 	m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_OUT_CARD, &OutCard, sizeof(OutCard));

  002ac	6a 04		 push	 4
  002ae	8d 4d e0	 lea	 ecx, DWORD PTR _OutCard$[ebp]
  002b1	51		 push	 ecx
  002b2	6a 65		 push	 101			; 00000065H
  002b4	68 ff ff 00 00	 push	 65535			; 0000ffffH
  002b9	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  002bc	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  002c2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c5	8b 10		 mov	 edx, DWORD PTR [eax]
  002c7	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  002cd	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  002d3	ff d0		 call	 eax

; 1120 : 	if (m_pGameVideo)

  002d5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d8	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  002df	74 27		 je	 SHORT $LN9@OnUserOutC

; 1121 : 	{
; 1122 : 		m_pGameVideo->AddVideoData(SUB_S_OUT_CARD,&OutCard,sizeof(OutCard),true);

  002e1	6a 01		 push	 1
  002e3	6a 04		 push	 4
  002e5	8d 55 e0	 lea	 edx, DWORD PTR _OutCard$[ebp]
  002e8	52		 push	 edx
  002e9	6a 65		 push	 101			; 00000065H
  002eb	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  002ee	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  002f4	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  002f7	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  002fd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002ff	50		 push	 eax
  00300	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00303	ff d2		 call	 edx
  00305	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@OnUserOutC:

; 1123 : 	}
; 1124 : 	m_wProvideUser = wChairID;

  00308	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0030b	66 8b 4d 08	 mov	 cx, WORD PTR _wChairID$[ebp]
  0030f	66 89 88 c0 04
	00 00		 mov	 WORD PTR [eax+1216], cx

; 1125 : 	m_cbProvideCard = cbCardData;

  00316	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00319	8a 45 0c	 mov	 al, BYTE PTR _cbCardData$[ebp]
  0031c	88 82 c2 04 00
	00		 mov	 BYTE PTR [edx+1218], al

; 1126 : 
; 1127 : 	//用户切换
; 1128 : 	m_wCurrentUser = (wChairID + 1) % m_cbPlayerCount;

  00322	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00326	83 c0 01	 add	 eax, 1
  00329	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0032c	0f b6 49 09	 movzx	 ecx, BYTE PTR [ecx+9]
  00330	99		 cdq
  00331	f7 f9		 idiv	 ecx
  00333	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00336	66 89 90 be 04
	00 00		 mov	 WORD PTR [eax+1214], dx

; 1129 : 	for(int i=0;i<m_cbPlayerCount;i++)

  0033d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00344	eb 09		 jmp	 SHORT $LN4@OnUserOutC
$LN2@OnUserOutC:
  00346	8b 4d dc	 mov	 ecx, DWORD PTR _i$2[ebp]
  00349	83 c1 01	 add	 ecx, 1
  0034c	89 4d dc	 mov	 DWORD PTR _i$2[ebp], ecx
$LN4@OnUserOutC:
  0034f	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00352	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  00356	39 45 dc	 cmp	 DWORD PTR _i$2[ebp], eax
  00359	7d 3e		 jge	 SHORT $LN3@OnUserOutC

; 1130 : 	{
; 1131 : 		if(m_bPlayStatus[m_wCurrentUser])

  0035b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0035e	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  00365	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00368	0f b6 8c 10 7d
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1149]
  00370	85 c9		 test	 ecx, ecx
  00372	74 02		 je	 SHORT $LN10@OnUserOutC

; 1132 : 			break;

  00374	eb 23		 jmp	 SHORT $LN3@OnUserOutC
$LN10@OnUserOutC:

; 1133 : 		m_wCurrentUser = (m_wCurrentUser+1)%m_cbPlayerCount;

  00376	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00379	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  00380	83 c0 01	 add	 eax, 1
  00383	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00386	0f b6 49 09	 movzx	 ecx, BYTE PTR [ecx+9]
  0038a	99		 cdq
  0038b	f7 f9		 idiv	 ecx
  0038d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00390	66 89 90 be 04
	00 00		 mov	 WORD PTR [eax+1214], dx

; 1134 : 	}

  00397	eb ad		 jmp	 SHORT $LN2@OnUserOutC
$LN3@OnUserOutC:

; 1135 : 
; 1136 : 	//响应判断
; 1137 :  	bool bAroseAction = EstimateUserRespond(wChairID, cbCardData, EstimatKind_OutCard);

  00399	6a 00		 push	 0
  0039b	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cbCardData$[ebp]
  0039f	51		 push	 ecx
  003a0	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  003a4	52		 push	 edx
  003a5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?EstimateUserRespond@CTableFrameSink@@IAE_NGEW4enEstimatKind@@@Z ; CTableFrameSink::EstimateUserRespond
  003ad	88 45 ef	 mov	 BYTE PTR _bAroseAction$[ebp], al

; 1138 :  
; 1139 : 	if(m_cbGangStatus != WIK_GANERAL)

  003b0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  003b3	0f b6 88 cc 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1228]
  003ba	85 c9		 test	 ecx, ecx
  003bc	74 25		 je	 SHORT $LN11@OnUserOutC

; 1140 : 	{
; 1141 : 		m_bGangOutCard = true;

  003be	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  003c1	c6 82 c6 04 00
	00 01		 mov	 BYTE PTR [edx+1222], 1

; 1142 : 		m_cbGangStatus = WIK_GANERAL;

  003c8	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  003cb	c6 80 cc 04 00
	00 00		 mov	 BYTE PTR [eax+1228], 0

; 1143 : 		m_wProvideGangUser = INVALID_CHAIR;

  003d2	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  003d7	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  003da	66 89 8a ce 04
	00 00		 mov	 WORD PTR [edx+1230], cx

; 1144 : 	}	
; 1145 : 	else

  003e1	eb 0a		 jmp	 SHORT $LN12@OnUserOutC
$LN11@OnUserOutC:

; 1146 : 	{
; 1147 : 		m_bGangOutCard = false;

  003e3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  003e6	c6 80 c6 04 00
	00 00		 mov	 BYTE PTR [eax+1222], 0
$LN12@OnUserOutC:

; 1148 : 	}
; 1149 : 
; 1150 :  	//派发扑克
; 1151 :  	if (!bAroseAction) 

  003ed	0f b6 4d ef	 movzx	 ecx, BYTE PTR _bAroseAction$[ebp]
  003f1	85 c9		 test	 ecx, ecx
  003f3	75 15		 jne	 SHORT $LN13@OnUserOutC

; 1152 : 	{
; 1153 : 		DispatchCardData(m_wCurrentUser);

  003f5	6a 00		 push	 0
  003f7	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  003fa	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  00401	50		 push	 eax
  00402	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00405	e8 00 00 00 00	 call	 ?DispatchCardData@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::DispatchCardData
$LN13@OnUserOutC:

; 1154 : 	}
; 1155 : 
; 1156 : 	return true;

  0040a	c6 45 ee 01	 mov	 BYTE PTR $T3[ebp], 1
  0040e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00415	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  00418	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  0041e	8a 45 ee	 mov	 al, BYTE PTR $T3[ebp]
$LN1@OnUserOutC:

; 1157 : }

  00421	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00424	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0042b	59		 pop	 ecx
  0042c	8b e5		 mov	 esp, ebp
  0042e	5d		 pop	 ebp
  0042f	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _ss$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z ENDP	; CTableFrameSink::OnUserOutCard
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.h
;	COMDAT ?OnActionUserOnReady@CTableFrameSink@@UAE_NGPAUIServerUserItem@@PAXG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
_pData$ = 16						; size = 4
_wDataSize$ = 20					; size = 2
?OnActionUserOnReady@CTableFrameSink@@UAE_NGPAUIServerUserItem@@PAXG@Z PROC ; CTableFrameSink::OnActionUserOnReady, COMDAT
; _this$ = ecx

; 227  : 	virtual bool OnActionUserOnReady(WORD wChairID, IServerUserItem * pIServerUserItem, VOID * pData, WORD wDataSize) { return true; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 10 00	 ret	 16			; 00000010H
?OnActionUserOnReady@CTableFrameSink@@UAE_NGPAUIServerUserItem@@PAXG@Z ENDP ; CTableFrameSink::OnActionUserOnReady
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_cc$ = -28						; size = 4
_this$ = -24						; size = 4
_i$2 = -20						; size = 2
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
_bLookonUser$ = 16					; size = 1
?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z PROC ; CTableFrameSink::OnActionUserStandUp
; _this$ = ecx

; 1022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1023 : 	CString cc;

  00028	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1024 : 	cc.Format(_T("玩家离开:chair=%d,userid=%d,name=%s"), wChairID, pIServerUserItem->GetUserID(), pIServerUserItem->GetNickName());

  00038	8b 45 0c	 mov	 eax, DWORD PTR _pIServerUserItem$[ebp]
  0003b	8b 10		 mov	 edx, DWORD PTR [eax]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00040	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00043	ff d0		 call	 eax
  00045	50		 push	 eax
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  0004e	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00051	ff d0		 call	 eax
  00053	50		 push	 eax
  00054	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00058	51		 push	 ecx
  00059	68 00 00 00 00	 push	 OFFSET $SG313853
  0005e	8d 55 e4	 lea	 edx, DWORD PTR _cc$[ebp]
  00061	52		 push	 edx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00068	83 c4 14	 add	 esp, 20			; 00000014H

; 1025 : 	WriteDebugInfo(cc);

  0006b	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00074	50		 push	 eax
  00075	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	83 e9 04	 sub	 ecx, 4
  0007b	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 1026 : 	//历史积分
; 1027 : 	if (bLookonUser==false)

  00080	0f b6 45 10	 movzx	 eax, BYTE PTR _bLookonUser$[ebp]
  00084	85 c0		 test	 eax, eax
  00086	75 31		 jne	 SHORT $LN5@OnActionUs

; 1028 : 	{
; 1029 : 		ASSERT(wChairID!=INVALID_CHAIR);
; 1030 : 		m_HistoryScore.OnEventUserLeave(wChairID);

  00088	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	81 c1 dc 08 00
	00		 add	 ecx, 2268		; 000008dcH
  00096	e8 00 00 00 00	 call	 ?OnEventUserLeave@CHistoryScore@@QAEXG@Z ; CHistoryScore::OnEventUserLeave

; 1031 : 		m_wBankerUser = INVALID_CHAIR;

  0009b	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000a0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	66 89 90 6e 04
	00 00		 mov	 WORD PTR [eax+1134], dx

; 1032 : 		m_wLianZhuang = 1;

  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	66 89 8a dc 04
	00 00		 mov	 WORD PTR [edx+1244], cx
$LN5@OnActionUs:

; 1033 : 	}
; 1034 : 
; 1035 : 	if( (m_pGameServiceOption->wServerType&GAME_GENRE_PERSONAL) !=0 )//房卡模式

  000b9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	8b 88 2c 09 00
	00		 mov	 ecx, DWORD PTR [eax+2348]
  000c2	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  000c6	83 e2 10	 and	 edx, 16			; 00000010H
  000c9	74 39		 je	 SHORT $LN6@OnActionUs

; 1036 : 	{
; 1037 : 		if(m_pITableFrame->IsPersonalRoomDisumme() )//当前朋友局解散清理记录

  000cb	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	8b 88 24 09 00
	00		 mov	 ecx, DWORD PTR [eax+2340]
  000d4	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000d7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d9	8b 8a 24 09 00
	00		 mov	 ecx, DWORD PTR [edx+2340]
  000df	8b 90 2c 01 00
	00		 mov	 edx, DWORD PTR [eax+300]
  000e5	ff d2		 call	 edx
  000e7	0f b6 c0	 movzx	 eax, al
  000ea	85 c0		 test	 eax, eax
  000ec	74 16		 je	 SHORT $LN6@OnActionUs

; 1038 : 		{
; 1039 : 			ZeroMemory(&m_stRecord,sizeof(m_stRecord));

  000ee	68 34 04 00 00	 push	 1076			; 00000434H
  000f3	6a 00		 push	 0
  000f5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	83 c1 06	 add	 ecx, 6
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 _memset
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@OnActionUs:

; 1040 : 		}
; 1041 : 	}
; 1042 : 	
; 1043 : 	//房卡积分类型
; 1044 : 	if (IsRoomCardScoreType() == true)

  00104	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	83 e9 04	 sub	 ecx, 4
  0010a	e8 00 00 00 00	 call	 ?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::IsRoomCardScoreType
  0010f	0f b6 d0	 movzx	 edx, al
  00112	83 fa 01	 cmp	 edx, 1
  00115	75 3c		 jne	 SHORT $LN8@OnActionUs

; 1045 : 	{
; 1046 : 		for (WORD i=0; i<GAME_PLAYER; i++)

  00117	33 c0		 xor	 eax, eax
  00119	66 89 45 ec	 mov	 WORD PTR _i$2[ebp], ax
  0011d	eb 0c		 jmp	 SHORT $LN4@OnActionUs
$LN2@OnActionUs:
  0011f	66 8b 4d ec	 mov	 cx, WORD PTR _i$2[ebp]
  00123	66 83 c1 01	 add	 cx, 1
  00127	66 89 4d ec	 mov	 WORD PTR _i$2[ebp], cx
$LN4@OnActionUs:
  0012b	0f b7 55 ec	 movzx	 edx, WORD PTR _i$2[ebp]
  0012f	83 fa 04	 cmp	 edx, 4
  00132	7d 1f		 jge	 SHORT $LN8@OnActionUs

; 1047 : 		{
; 1048 : 			m_lRoomCardInitialScore[i] = INVALID_LONGLONG;

  00134	0f b7 45 ec	 movzx	 eax, WORD PTR _i$2[ebp]
  00138	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	c7 84 c1 84 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*8+1156], -1
  00146	c7 84 c1 88 04
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*8+1160], 0

; 1049 : 		}

  00151	eb cc		 jmp	 SHORT $LN2@OnActionUs
$LN8@OnActionUs:

; 1050 : 	}
; 1051 : 
; 1052 : 	m_vecRecord[wChairID].clear();

  00153	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00157	6b c2 0c	 imul	 eax, edx, 12
  0015a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	8d 8c 01 3c 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1084]
  00164	e8 00 00 00 00	 call	 ?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ; std::vector<__int64,std::allocator<__int64> >::clear

; 1053 : 	m_stRecord.lAllScore[wChairID] = 0;

  00169	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  0016d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00170	c7 44 d0 1a 00
	00 00 00	 mov	 DWORD PTR [eax+edx*8+26], 0
  00178	c7 44 d0 1e 00
	00 00 00	 mov	 DWORD PTR [eax+edx*8+30], 0

; 1054 : 	m_stRecord.cbAnGang[wChairID] = 0;

  00180	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00184	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00187	c6 44 0a 12 00	 mov	 BYTE PTR [edx+ecx+18], 0

; 1055 : 	m_stRecord.cbHuCount[wChairID] = 0;

  0018c	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00190	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	c6 44 01 0a 00	 mov	 BYTE PTR [ecx+eax+10], 0

; 1056 : 	m_stRecord.cbMaCount[wChairID] = 0;

  00198	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  0019c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0019f	c6 44 10 0e 00	 mov	 BYTE PTR [eax+edx+14], 0

; 1057 : 	m_stRecord.cbMingGang[wChairID] = 0;

  001a4	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  001a8	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001ab	c6 44 0a 16 00	 mov	 BYTE PTR [edx+ecx+22], 0

; 1058 : 	return true;

  001b0	c6 45 f3 01	 mov	 BYTE PTR $T3[ebp], 1
  001b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001bb	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  001c4	8a 45 f3	 mov	 al, BYTE PTR $T3[ebp]

; 1059 : }

  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b e5		 mov	 esp, ebp
  001d4	5d		 pop	 ebp
  001d5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnActionUserStandUp@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z ENDP ; CTableFrameSink::OnActionUserStandUp
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_cc$ = -28						; size = 4
_pSetInfo$ = -24					; size = 4
_this$ = -20						; size = 4
_cbMax$2 = -14						; size = 1
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
_bLookonUser$ = 16					; size = 1
?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z PROC ; CTableFrameSink::OnActionUserSitDown
; _this$ = ecx

; 982  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 983  : 	CString cc;

  00029	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 984  : 	cc.Format(_T("玩家进入:chair=%d,userid=%d,name=%s"), wChairID, pIServerUserItem->GetUserID(), pIServerUserItem->GetNickName());

  00039	8b 45 0c	 mov	 eax, DWORD PTR _pIServerUserItem$[ebp]
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00041	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00044	ff d0		 call	 eax
  00046	50		 push	 eax
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  0004f	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00052	ff d0		 call	 eax
  00054	50		 push	 eax
  00055	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00059	51		 push	 ecx
  0005a	68 00 00 00 00	 push	 OFFSET $SG313835
  0005f	8d 55 e4	 lea	 edx, DWORD PTR _cc$[ebp]
  00062	52		 push	 edx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00069	83 c4 14	 add	 esp, 20			; 00000014H

; 985  : 	WriteDebugInfo(cc);

  0006c	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00075	50		 push	 eax
  00076	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	83 e9 04	 sub	 ecx, 4
  0007c	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 986  : 	//获取房卡规则
; 987  : 	BYTE* pSetInfo = m_pITableFrame->GetGameRule();

  00081	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 88 24 09 00
	00		 mov	 ecx, DWORD PTR [eax+2340]
  0008a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008f	8b 8a 24 09 00
	00		 mov	 ecx, DWORD PTR [edx+2340]
  00095	8b 90 18 01 00
	00		 mov	 edx, DWORD PTR [eax+280]
  0009b	ff d2		 call	 edx
  0009d	89 45 e8	 mov	 DWORD PTR _pSetInfo$[ebp], eax

; 988  : 	if(pSetInfo[0] == 1)

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	6b c8 00	 imul	 ecx, eax, 0
  000a8	8b 55 e8	 mov	 edx, DWORD PTR _pSetInfo$[ebp]
  000ab	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000af	83 f8 01	 cmp	 eax, 1
  000b2	75 38		 jne	 SHORT $LN2@OnActionUs

; 989  : 	{
; 990  : 		m_cbPlayerCount = pSetInfo[1];

  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	c1 e1 00	 shl	 ecx, 0
  000bc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000bf	8b 45 e8	 mov	 eax, DWORD PTR _pSetInfo$[ebp]
  000c2	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  000c5	88 4a 05	 mov	 BYTE PTR [edx+5], cl

; 991  : 		BYTE cbMax= pSetInfo[2];

  000c8	ba 01 00 00 00	 mov	 edx, 1
  000cd	d1 e2		 shl	 edx, 1
  000cf	8b 45 e8	 mov	 eax, DWORD PTR _pSetInfo$[ebp]
  000d2	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  000d5	88 4d f2	 mov	 BYTE PTR _cbMax$2[ebp], cl

; 992  : 		m_cbMaCount = pSetInfo[3];

  000d8	ba 01 00 00 00	 mov	 edx, 1
  000dd	6b c2 03	 imul	 eax, edx, 3
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	8b 55 e8	 mov	 edx, DWORD PTR _pSetInfo$[ebp]
  000e6	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  000e9	88 41 04	 mov	 BYTE PTR [ecx+4], al
$LN2@OnActionUs:

; 993  : 	}
; 994  : 
; 995  : 
; 996  : 	//历史积分
; 997  : 	if (bLookonUser==false)

  000ec	0f b6 4d 10	 movzx	 ecx, BYTE PTR _bLookonUser$[ebp]
  000f0	85 c9		 test	 ecx, ecx
  000f2	75 31		 jne	 SHORT $LN3@OnActionUs

; 998  : 	{
; 999  : 		ASSERT(wChairID!=INVALID_CHAIR);
; 1000 : 		m_HistoryScore.OnEventUserEnter(wChairID);

  000f4	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  000f8	52		 push	 edx
  000f9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	81 c1 dc 08 00
	00		 add	 ecx, 2268		; 000008dcH
  00102	e8 00 00 00 00	 call	 ?OnEventUserEnter@CHistoryScore@@QAEXG@Z ; CHistoryScore::OnEventUserEnter

; 1001 : 		m_wBankerUser = INVALID_CHAIR;

  00107	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0010c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	66 89 81 6e 04
	00 00		 mov	 WORD PTR [ecx+1134], ax

; 1002 : 		m_wLianZhuang = 1;

  00116	ba 01 00 00 00	 mov	 edx, 1
  0011b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	66 89 90 dc 04
	00 00		 mov	 WORD PTR [eax+1244], dx
$LN3@OnActionUs:

; 1003 : 	}
; 1004 : 	
; 1005 : 	//房卡积分类型
; 1006 : 	if (IsRoomCardScoreType() == true)

  00125	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	83 e9 04	 sub	 ecx, 4
  0012b	e8 00 00 00 00	 call	 ?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::IsRoomCardScoreType
  00130	0f b6 c8	 movzx	 ecx, al
  00133	83 f9 01	 cmp	 ecx, 1
  00136	75 25		 jne	 SHORT $LN4@OnActionUs

; 1007 : 	{
; 1008 : 		m_lRoomCardInitialScore[wChairID] = pIServerUserItem->GetUserScore();

  00138	8b 55 0c	 mov	 edx, DWORD PTR _pIServerUserItem$[ebp]
  0013b	8b 02		 mov	 eax, DWORD PTR [edx]
  0013d	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00140	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00146	ff d2		 call	 edx
  00148	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0014c	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0014f	89 84 ce 84 04
	00 00		 mov	 DWORD PTR [esi+ecx*8+1156], eax
  00156	89 94 ce 88 04
	00 00		 mov	 DWORD PTR [esi+ecx*8+1160], edx
$LN4@OnActionUs:

; 1009 : 	}
; 1010 : 
; 1011 : 	m_vecRecord[wChairID].clear();

  0015d	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00161	6b c2 0c	 imul	 eax, edx, 12
  00164	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	8d 8c 01 3c 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1084]
  0016e	e8 00 00 00 00	 call	 ?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ; std::vector<__int64,std::allocator<__int64> >::clear

; 1012 : 	m_stRecord.lAllScore[wChairID] = 0;

  00173	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00177	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	c7 44 d0 1a 00
	00 00 00	 mov	 DWORD PTR [eax+edx*8+26], 0
  00182	c7 44 d0 1e 00
	00 00 00	 mov	 DWORD PTR [eax+edx*8+30], 0

; 1013 : 	m_stRecord.cbAnGang[wChairID] = 0;

  0018a	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0018e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00191	c6 44 0a 12 00	 mov	 BYTE PTR [edx+ecx+18], 0

; 1014 : 	m_stRecord.cbHuCount[wChairID] = 0;

  00196	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  0019a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	c6 44 01 0a 00	 mov	 BYTE PTR [ecx+eax+10], 0

; 1015 : 	m_stRecord.cbMaCount[wChairID] = 0;

  001a2	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  001a6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001a9	c6 44 10 0e 00	 mov	 BYTE PTR [eax+edx+14], 0

; 1016 : 	m_stRecord.cbMingGang[wChairID] = 0;

  001ae	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  001b2	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001b5	c6 44 0a 16 00	 mov	 BYTE PTR [edx+ecx+22], 0

; 1017 : 	return true;

  001ba	c6 45 f3 01	 mov	 BYTE PTR $T3[ebp], 1
  001be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001c5	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  001ce	8a 45 f3	 mov	 al, BYTE PTR $T3[ebp]

; 1018 : }

  001d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001db	59		 pop	 ecx
  001dc	5e		 pop	 esi
  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _cc$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnActionUserSitDown@CTableFrameSink@@UAE_NGPAUIServerUserItem@@_N@Z ENDP ; CTableFrameSink::OnActionUserSitDown
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.h
;	COMDAT ?OnActionUserConnect@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
?OnActionUserConnect@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z PROC ; CTableFrameSink::OnActionUserConnect, COMDAT
; _this$ = ecx

; 221  : 	virtual bool OnActionUserConnect(WORD wChairID, IServerUserItem * pIServerUserItem) { return true; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?OnActionUserConnect@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z ENDP ; CTableFrameSink::OnActionUserConnect
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
?OnActionUserOffLine@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z PROC ; CTableFrameSink::OnActionUserOffLine
; _this$ = ecx

; 2383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2384 : 	return true;

  00007	b0 01		 mov	 al, 1

; 2385 : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?OnActionUserOffLine@CTableFrameSink@@UAE_NGPAUIServerUserItem@@@Z ENDP ; CTableFrameSink::OnActionUserOffLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lBaseScore$ = 8					; size = 4
?SetGameBaseScore@CTableFrameSink@@UAEXJ@Z PROC		; CTableFrameSink::SetGameBaseScore
; _this$ = ecx

; 2315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2316 : 	//发送数据
; 2317 : 	m_pITableFrame->SendTableData(INVALID_CHAIR,SUB_S_SET_BASESCORE,&lBaseScore,sizeof(lBaseScore));

  00007	68 c8 00 00 00	 push	 200			; 000000c8H
  0000c	6a 04		 push	 4
  0000e	8d 45 08	 lea	 eax, DWORD PTR _lBaseScore$[ebp]
  00011	50		 push	 eax
  00012	6a 6d		 push	 109			; 0000006dH
  00014	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 12		 mov	 edx, DWORD PTR [edx]
  00027	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  0002d	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00033	ff d0		 call	 eax

; 2318 : 	m_pITableFrame->SendLookonData(INVALID_CHAIR,SUB_S_SET_BASESCORE,&lBaseScore,sizeof(lBaseScore));

  00035	6a 04		 push	 4
  00037	8d 4d 08	 lea	 ecx, DWORD PTR _lBaseScore$[ebp]
  0003a	51		 push	 ecx
  0003b	6a 6d		 push	 109			; 0000006dH
  0003d	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 10		 mov	 edx, DWORD PTR [eax]
  00050	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00056	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  0005c	ff d0		 call	 eax

; 2319 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
?SetGameBaseScore@CTableFrameSink@@UAEXJ@Z ENDP		; CTableFrameSink::SetGameBaseScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wSubCmdID$ = 8						; size = 2
_pData$ = 12						; size = 4
_wDataSize$ = 16					; size = 2
_pIServerUserItem$ = 20					; size = 4
?OnFrameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z PROC ; CTableFrameSink::OnFrameMessage
; _this$ = ecx

; 976  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 	return false;

  00007	32 c0		 xor	 al, al

; 978  : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 10 00	 ret	 16			; 00000010H
?OnFrameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z ENDP ; CTableFrameSink::OnFrameMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_pTrustee$1 = -1112					; size = 4
_pOperateCard$2 = -1108					; size = 4
_pOutCard$3 = -1104					; size = 4
_pOperateCard$4 = -1100					; size = 4
tv65 = -1096						; size = 4
_i$5 = -1092						; size = 4
_this$ = -1088						; size = 4
_wChairID$6 = -1084					; size = 2
_RoomCardRecord$7 = -1080				; size = 1076
__$ArrayPad$ = -4					; size = 4
_wSubCmdID$ = 8						; size = 2
_pData$ = 12						; size = 4
_wDataSize$ = 16					; size = 2
_pIServerUserItem$ = 20					; size = 4
?OnGameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z PROC ; CTableFrameSink::OnGameMessage
; _this$ = ecx

; 876  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 04 00
	00		 sub	 esp, 1112		; 00000458H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	89 8d c0 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 877  : 	switch (wSubCmdID)

  0001a	0f b7 45 08	 movzx	 eax, WORD PTR _wSubCmdID$[ebp]
  0001e	89 85 b8 fb ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  00024	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  0002a	83 e9 01	 sub	 ecx, 1
  0002d	89 8d b8 fb ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00033	83 bd b8 fb ff
	ff 06		 cmp	 DWORD PTR tv65[ebp], 6
  0003a	0f 87 bb 03 00
	00		 ja	 $LN2@OnGameMess
  00040	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR tv65[ebp]
  00046	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN24@OnGameMess[edx*4]
$LN7@OnGameMess:

; 878  : 	{
; 879  : 	case SUB_C_OUT_CARD:
; 880  : 		{
; 881  : 			//效验消息
; 882  : 			ASSERT(wDataSize == sizeof(CMD_C_OutCard));
; 883  : 			if (wDataSize != sizeof(CMD_C_OutCard)) return false;

  0004d	0f b7 45 10	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00051	83 f8 01	 cmp	 eax, 1
  00054	74 07		 je	 SHORT $LN8@OnGameMess
  00056	32 c0		 xor	 al, al
  00058	e9 a0 03 00 00	 jmp	 $LN1@OnGameMess
$LN8@OnGameMess:

; 884  : 
; 885  : 			//用户效验
; 886  : 			ASSERT(pIServerUserItem->GetUserStatus() == US_PLAYING);
; 887  : 			if (pIServerUserItem->GetUserStatus() != US_PLAYING) return true;

  0005d	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00065	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00068	ff d0		 call	 eax
  0006a	0f b6 c8	 movzx	 ecx, al
  0006d	83 f9 05	 cmp	 ecx, 5
  00070	74 07		 je	 SHORT $LN9@OnGameMess
  00072	b0 01		 mov	 al, 1
  00074	e9 84 03 00 00	 jmp	 $LN1@OnGameMess
$LN9@OnGameMess:

; 888  : 
; 889  : 			//消息处理
; 890  : 			CMD_C_OutCard * pOutCard = (CMD_C_OutCard *)pData;

  00079	8b 55 0c	 mov	 edx, DWORD PTR _pData$[ebp]
  0007c	89 95 b0 fb ff
	ff		 mov	 DWORD PTR _pOutCard$3[ebp], edx

; 891  : 			return OnUserOutCard(pIServerUserItem->GetChairID(), pOutCard->cbCardData);

  00082	6a 00		 push	 0
  00084	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pOutCard$3[ebp]
  0008a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0008d	51		 push	 ecx
  0008e	8b 55 14	 mov	 edx, DWORD PTR _pIServerUserItem$[ebp]
  00091	8b 02		 mov	 eax, DWORD PTR [edx]
  00093	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00096	8b 50 78	 mov	 edx, DWORD PTR [eax+120]
  00099	ff d2		 call	 edx
  0009b	0f b7 c0	 movzx	 eax, ax
  0009e	50		 push	 eax
  0009f	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?OnUserOutCard@CTableFrameSink@@IAE_NGE_N@Z ; CTableFrameSink::OnUserOutCard
  000aa	e9 4e 03 00 00	 jmp	 $LN1@OnGameMess
$LN10@OnGameMess:

; 892  : 		}
; 893  : 	case SUB_C_OPERATE_CARD:	//操作消息
; 894  : 		{
; 895  : 			//效验消息
; 896  : 			ASSERT(wDataSize == sizeof(CMD_C_OperateCard));
; 897  : 			if (wDataSize != sizeof(CMD_C_OperateCard)) return false;

  000af	0f b7 4d 10	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  000b3	83 f9 04	 cmp	 ecx, 4
  000b6	74 07		 je	 SHORT $LN11@OnGameMess
  000b8	32 c0		 xor	 al, al
  000ba	e9 3e 03 00 00	 jmp	 $LN1@OnGameMess
$LN11@OnGameMess:

; 898  : 
; 899  : 			//用户效验
; 900  : 			if (pIServerUserItem->GetUserStatus() != US_PLAYING) return true;

  000bf	8b 55 14	 mov	 edx, DWORD PTR _pIServerUserItem$[ebp]
  000c2	8b 02		 mov	 eax, DWORD PTR [edx]
  000c4	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  000c7	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  000ca	ff d2		 call	 edx
  000cc	0f b6 c0	 movzx	 eax, al
  000cf	83 f8 05	 cmp	 eax, 5
  000d2	74 07		 je	 SHORT $LN12@OnGameMess
  000d4	b0 01		 mov	 al, 1
  000d6	e9 22 03 00 00	 jmp	 $LN1@OnGameMess
$LN12@OnGameMess:

; 901  : 
; 902  : 			//消息处理
; 903  : 			CMD_C_OperateCard * pOperateCard = (CMD_C_OperateCard *)pData;

  000db	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  000de	89 8d b4 fb ff
	ff		 mov	 DWORD PTR _pOperateCard$4[ebp], ecx

; 904  : 			return OnUserOperateCard(pIServerUserItem->GetChairID(), pOperateCard->cbOperateCode, pOperateCard->cbOperateCard);

  000e4	8b 95 b4 fb ff
	ff		 mov	 edx, DWORD PTR _pOperateCard$4[ebp]
  000ea	83 c2 01	 add	 edx, 1
  000ed	52		 push	 edx
  000ee	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _pOperateCard$4[ebp]
  000f4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000f7	51		 push	 ecx
  000f8	8b 55 14	 mov	 edx, DWORD PTR _pIServerUserItem$[ebp]
  000fb	8b 02		 mov	 eax, DWORD PTR [edx]
  000fd	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00100	8b 50 78	 mov	 edx, DWORD PTR [eax+120]
  00103	ff d2		 call	 edx
  00105	0f b7 c0	 movzx	 eax, ax
  00108	50		 push	 eax
  00109	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	e8 00 00 00 00	 call	 ?OnUserOperateCard@CTableFrameSink@@IAE_NGEQAE@Z ; CTableFrameSink::OnUserOperateCard
  00114	e9 e4 02 00 00	 jmp	 $LN1@OnGameMess
$LN13@OnGameMess:

; 905  : 		}
; 906  : 	case SUB_C_LISTEN_CARD:
; 907  : 		{
; 908  : 			//效验消息
; 909  : 			ASSERT(wDataSize == sizeof(CMD_C_ListenCard));
; 910  : 			if (wDataSize != sizeof(CMD_C_ListenCard)) return false;

  00119	0f b7 4d 10	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  0011d	83 f9 01	 cmp	 ecx, 1
  00120	74 07		 je	 SHORT $LN14@OnGameMess
  00122	32 c0		 xor	 al, al
  00124	e9 d4 02 00 00	 jmp	 $LN1@OnGameMess
$LN14@OnGameMess:

; 911  : 
; 912  : 			//用户效验
; 913  : 			if (pIServerUserItem->GetUserStatus() != US_PLAYING) return true;

  00129	8b 55 14	 mov	 edx, DWORD PTR _pIServerUserItem$[ebp]
  0012c	8b 02		 mov	 eax, DWORD PTR [edx]
  0012e	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00131	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  00134	ff d2		 call	 edx
  00136	0f b6 c0	 movzx	 eax, al
  00139	83 f8 05	 cmp	 eax, 5
  0013c	74 07		 je	 SHORT $LN15@OnGameMess
  0013e	b0 01		 mov	 al, 1
  00140	e9 b8 02 00 00	 jmp	 $LN1@OnGameMess
$LN15@OnGameMess:

; 914  : 
; 915  : 			//消息处理
; 916  : 			CMD_C_ListenCard * pOperateCard = (CMD_C_ListenCard *)pData;

  00145	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00148	89 8d ac fb ff
	ff		 mov	 DWORD PTR _pOperateCard$2[ebp], ecx

; 917  : 			return OnUserListenCard(pIServerUserItem->GetChairID(), pOperateCard->bListenCard);

  0014e	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR _pOperateCard$2[ebp]
  00154	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00157	50		 push	 eax
  00158	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  0015b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015d	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  00160	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00163	ff d0		 call	 eax
  00165	0f b7 c8	 movzx	 ecx, ax
  00168	51		 push	 ecx
  00169	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	e8 00 00 00 00	 call	 ?OnUserListenCard@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::OnUserListenCard
  00174	e9 84 02 00 00	 jmp	 $LN1@OnGameMess
$LN16@OnGameMess:

; 918  : 		}
; 919  : 	case SUB_C_TRUSTEE:
; 920  : 		{
; 921  : 			CMD_C_Trustee *pTrustee =(CMD_C_Trustee *)pData;

  00179	8b 55 0c	 mov	 edx, DWORD PTR _pData$[ebp]
  0017c	89 95 a8 fb ff
	ff		 mov	 DWORD PTR _pTrustee$1[ebp], edx

; 922  : 			if(wDataSize != sizeof(CMD_C_Trustee)) return false;

  00182	0f b7 45 10	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00186	83 f8 01	 cmp	 eax, 1
  00189	74 07		 je	 SHORT $LN17@OnGameMess
  0018b	32 c0		 xor	 al, al
  0018d	e9 6b 02 00 00	 jmp	 $LN1@OnGameMess
$LN17@OnGameMess:

; 923  : 
; 924  : 			return OnUserTrustee(pIServerUserItem->GetChairID(), pTrustee->bTrustee);

  00192	8b 8d a8 fb ff
	ff		 mov	 ecx, DWORD PTR _pTrustee$1[ebp]
  00198	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0019b	52		 push	 edx
  0019c	8b 45 14	 mov	 eax, DWORD PTR _pIServerUserItem$[ebp]
  0019f	8b 10		 mov	 edx, DWORD PTR [eax]
  001a1	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  001a4	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  001a7	ff d0		 call	 eax
  001a9	0f b7 c8	 movzx	 ecx, ax
  001ac	51		 push	 ecx
  001ad	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	e8 00 00 00 00	 call	 ?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::OnUserTrustee
  001b8	e9 40 02 00 00	 jmp	 $LN1@OnGameMess
$LN18@OnGameMess:

; 925  : 		}
; 926  : 	case SUB_C_REQUEST_RCRecord:
; 927  : 	{
; 928  : 		ASSERT(IsRoomCard());
; 929  : 		if (IsRoomCard() == false)

  001bd	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	e8 00 00 00 00	 call	 ?IsRoomCard@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::IsRoomCard
  001c8	0f b6 d0	 movzx	 edx, al
  001cb	85 d2		 test	 edx, edx
  001cd	75 07		 jne	 SHORT $LN19@OnGameMess

; 930  : 			return true;

  001cf	b0 01		 mov	 al, 1
  001d1	e9 27 02 00 00	 jmp	 $LN1@OnGameMess
$LN19@OnGameMess:

; 931  : 
; 932  : 		WORD wChairID = pIServerUserItem->GetChairID();

  001d6	8b 45 14	 mov	 eax, DWORD PTR _pIServerUserItem$[ebp]
  001d9	8b 10		 mov	 edx, DWORD PTR [eax]
  001db	8b 4d 14	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  001de	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  001e1	ff d0		 call	 eax
  001e3	66 89 85 c4 fb
	ff ff		 mov	 WORD PTR _wChairID$6[ebp], ax

; 933  : 		CMD_S_RECORD RoomCardRecord;
; 934  : 		ZeroMemory(&RoomCardRecord, sizeof(RoomCardRecord));

  001ea	68 34 04 00 00	 push	 1076			; 00000434H
  001ef	6a 00		 push	 0
  001f1	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _RoomCardRecord$7[ebp]
  001f7	51		 push	 ecx
  001f8	e8 00 00 00 00	 call	 _memset
  001fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 935  : 		if (IsRoomCardScoreType())

  00200	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00206	e8 00 00 00 00	 call	 ?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::IsRoomCardScoreType
  0020b	0f b6 d0	 movzx	 edx, al
  0020e	85 d2		 test	 edx, edx
  00210	74 23		 je	 SHORT $LN20@OnGameMess

; 936  : 			CopyMemory(&RoomCardRecord, &m_stRecord, sizeof(m_stRecord));

  00212	68 34 04 00 00	 push	 1076			; 00000434H
  00217	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0021d	83 c0 0a	 add	 eax, 10			; 0000000aH
  00220	50		 push	 eax
  00221	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _RoomCardRecord$7[ebp]
  00227	51		 push	 ecx
  00228	e8 00 00 00 00	 call	 _memcpy
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 937  : 		else

  00230	e9 85 01 00 00	 jmp	 $LN21@OnGameMess
$LN20@OnGameMess:

; 938  : 		{
; 939  : 			RoomCardRecord.cbAnGang[wChairID] = m_stRecord.cbAnGang[wChairID];

  00235	0f b7 95 c4 fb
	ff ff		 movzx	 edx, WORD PTR _wChairID$6[ebp]
  0023c	0f b7 85 c4 fb
	ff ff		 movzx	 eax, WORD PTR _wChairID$6[ebp]
  00243	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00249	8a 54 11 16	 mov	 dl, BYTE PTR [ecx+edx+22]
  0024d	88 94 05 d4 fb
	ff ff		 mov	 BYTE PTR _RoomCardRecord$7[ebp+eax+12], dl

; 940  : 			RoomCardRecord.cbHuCount[wChairID] = m_stRecord.cbHuCount[wChairID];

  00254	0f b7 85 c4 fb
	ff ff		 movzx	 eax, WORD PTR _wChairID$6[ebp]
  0025b	0f b7 8d c4 fb
	ff ff		 movzx	 ecx, WORD PTR _wChairID$6[ebp]
  00262	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00268	8a 44 02 0e	 mov	 al, BYTE PTR [edx+eax+14]
  0026c	88 84 0d cc fb
	ff ff		 mov	 BYTE PTR _RoomCardRecord$7[ebp+ecx+4], al

; 941  : 			RoomCardRecord.cbMaCount[wChairID] = m_stRecord.cbMaCount[wChairID];

  00273	0f b7 8d c4 fb
	ff ff		 movzx	 ecx, WORD PTR _wChairID$6[ebp]
  0027a	0f b7 95 c4 fb
	ff ff		 movzx	 edx, WORD PTR _wChairID$6[ebp]
  00281	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00287	8a 4c 08 12	 mov	 cl, BYTE PTR [eax+ecx+18]
  0028b	88 8c 15 d0 fb
	ff ff		 mov	 BYTE PTR _RoomCardRecord$7[ebp+edx+8], cl

; 942  : 			RoomCardRecord.cbMingGang[wChairID] = m_stRecord.cbMingGang[wChairID];

  00292	0f b7 95 c4 fb
	ff ff		 movzx	 edx, WORD PTR _wChairID$6[ebp]
  00299	0f b7 85 c4 fb
	ff ff		 movzx	 eax, WORD PTR _wChairID$6[ebp]
  002a0	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002a6	8a 54 11 1a	 mov	 dl, BYTE PTR [ecx+edx+26]
  002aa	88 94 05 d8 fb
	ff ff		 mov	 BYTE PTR _RoomCardRecord$7[ebp+eax+16], dl

; 943  : 			RoomCardRecord.nCount = m_vecRecord[wChairID].size();

  002b1	0f b7 85 c4 fb
	ff ff		 movzx	 eax, WORD PTR _wChairID$6[ebp]
  002b8	6b c8 0c	 imul	 ecx, eax, 12
  002bb	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002c1	8d 8c 0a 40 04
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1088]
  002c8	e8 00 00 00 00	 call	 ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
  002cd	89 85 c8 fb ff
	ff		 mov	 DWORD PTR _RoomCardRecord$7[ebp], eax

; 944  : 			RoomCardRecord.lAllScore[wChairID] = 0;

  002d3	0f b7 85 c4 fb
	ff ff		 movzx	 eax, WORD PTR _wChairID$6[ebp]
  002da	c7 84 c5 dc fb
	ff ff 00 00 00
	00		 mov	 DWORD PTR _RoomCardRecord$7[ebp+eax*8+20], 0
  002e5	c7 84 c5 e0 fb
	ff ff 00 00 00
	00		 mov	 DWORD PTR _RoomCardRecord$7[ebp+eax*8+24], 0

; 945  : 			for (int i = 0; i < RoomCardRecord.nCount; i++)

  002f0	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$5[ebp], 0
  002fa	eb 0f		 jmp	 SHORT $LN6@OnGameMess
$LN4@OnGameMess:
  002fc	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _i$5[ebp]
  00302	83 c1 01	 add	 ecx, 1
  00305	89 8d bc fb ff
	ff		 mov	 DWORD PTR _i$5[ebp], ecx
$LN6@OnGameMess:
  0030b	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR _i$5[ebp]
  00311	3b 95 c8 fb ff
	ff		 cmp	 edx, DWORD PTR _RoomCardRecord$7[ebp]
  00317	0f 8d 9d 00 00
	00		 jge	 $LN21@OnGameMess

; 946  : 			{
; 947  : 				RoomCardRecord.lDetailScore[wChairID][i] = m_vecRecord[wChairID][i];

  0031d	8b 85 bc fb ff
	ff		 mov	 eax, DWORD PTR _i$5[ebp]
  00323	50		 push	 eax
  00324	0f b7 8d c4 fb
	ff ff		 movzx	 ecx, WORD PTR _wChairID$6[ebp]
  0032b	6b d1 0c	 imul	 edx, ecx, 12
  0032e	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00334	8d 8c 10 40 04
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1088]
  0033b	e8 00 00 00 00	 call	 ??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ; std::vector<__int64,std::allocator<__int64> >::operator[]
  00340	0f b7 8d c4 fb
	ff ff		 movzx	 ecx, WORD PTR _wChairID$6[ebp]
  00347	c1 e1 08	 shl	 ecx, 8
  0034a	8d 94 0d fc fb
	ff ff		 lea	 edx, DWORD PTR _RoomCardRecord$7[ebp+ecx+52]
  00351	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _i$5[ebp]
  00357	8b 30		 mov	 esi, DWORD PTR [eax]
  00359	89 34 ca	 mov	 DWORD PTR [edx+ecx*8], esi
  0035c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0035f	89 44 ca 04	 mov	 DWORD PTR [edx+ecx*8+4], eax

; 948  : 				RoomCardRecord.lAllScore[wChairID] += m_vecRecord[wChairID][i];

  00363	0f b7 b5 c4 fb
	ff ff		 movzx	 esi, WORD PTR _wChairID$6[ebp]
  0036a	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _i$5[ebp]
  00370	51		 push	 ecx
  00371	0f b7 95 c4 fb
	ff ff		 movzx	 edx, WORD PTR _wChairID$6[ebp]
  00378	6b c2 0c	 imul	 eax, edx, 12
  0037b	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00381	8d 8c 01 40 04
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1088]
  00388	e8 00 00 00 00	 call	 ??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ; std::vector<__int64,std::allocator<__int64> >::operator[]
  0038d	8b 94 f5 dc fb
	ff ff		 mov	 edx, DWORD PTR _RoomCardRecord$7[ebp+esi*8+20]
  00394	03 10		 add	 edx, DWORD PTR [eax]
  00396	8b 8c f5 e0 fb
	ff ff		 mov	 ecx, DWORD PTR _RoomCardRecord$7[ebp+esi*8+24]
  0039d	13 48 04	 adc	 ecx, DWORD PTR [eax+4]
  003a0	0f b7 85 c4 fb
	ff ff		 movzx	 eax, WORD PTR _wChairID$6[ebp]
  003a7	89 94 c5 dc fb
	ff ff		 mov	 DWORD PTR _RoomCardRecord$7[ebp+eax*8+20], edx
  003ae	89 8c c5 e0 fb
	ff ff		 mov	 DWORD PTR _RoomCardRecord$7[ebp+eax*8+24], ecx

; 949  : 			}

  003b5	e9 42 ff ff ff	 jmp	 $LN4@OnGameMess
$LN21@OnGameMess:

; 950  : 		}
; 951  : 		m_pITableFrame->SendTableData(wChairID, SUB_S_RECORD, &RoomCardRecord, sizeof(RoomCardRecord));

  003ba	68 c8 00 00 00	 push	 200			; 000000c8H
  003bf	68 34 04 00 00	 push	 1076			; 00000434H
  003c4	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _RoomCardRecord$7[ebp]
  003ca	51		 push	 ecx
  003cb	6a 6f		 push	 111			; 0000006fH
  003cd	0f b7 95 c4 fb
	ff ff		 movzx	 edx, WORD PTR _wChairID$6[ebp]
  003d4	52		 push	 edx
  003d5	8b 85 c0 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003db	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  003e1	8b 95 c0 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  003e9	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  003ef	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  003f5	ff d2		 call	 edx

; 952  : 
; 953  : 		return true;

  003f7	b0 01		 mov	 al, 1
  003f9	eb 02		 jmp	 SHORT $LN1@OnGameMess
$LN2@OnGameMess:

; 954  : 	}
; 955  : #ifdef  CARD_DISPATCHER_CONTROL
; 956  : 	case SUB_C_SEND_CARD:
; 957  : 		{
; 958  : 			ASSERT(wDataSize==sizeof(CMD_C_SendCard));
; 959  : 			if(wDataSize!=sizeof(CMD_C_SendCard)) return false;
; 960  : 
; 961  : 			CMD_C_SendCard * pSendCard = (CMD_C_SendCard *)pData;
; 962  : 
; 963  : 			return OnUserSendCard(pSendCard->cbCardCount, pSendCard->wBankerUser, pSendCard->cbCardData, pSendCard->cbControlGameCount);
; 964  : 		}
; 965  : #endif
; 966  : 
; 967  : 	default:
; 968  : 		break;
; 969  : 	}
; 970  : 
; 971  : 	return false;

  003fb	32 c0		 xor	 al, al
$LN1@OnGameMess:

; 972  : }

  003fd	5e		 pop	 esi
  003fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00401	33 cd		 xor	 ecx, ebp
  00403	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00408	8b e5		 mov	 esp, ebp
  0040a	5d		 pop	 ebp
  0040b	c2 10 00	 ret	 16			; 00000010H
  0040e	66 90		 npad	 2
$LN24@OnGameMess:
  00410	00 00 00 00	 DD	 $LN7@OnGameMess
  00414	00 00 00 00	 DD	 $LN10@OnGameMess
  00418	00 00 00 00	 DD	 $LN13@OnGameMess
  0041c	00 00 00 00	 DD	 $LN16@OnGameMess
  00420	00 00 00 00	 DD	 $LN2@OnGameMess
  00424	00 00 00 00	 DD	 $LN2@OnGameMess
  00428	00 00 00 00	 DD	 $LN18@OnGameMess
?OnGameMessage@CTableFrameSink@@UAE_NGPAXGPAUIServerUserItem@@@Z ENDP ; CTableFrameSink::OnGameMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
_cbReason$ = 16						; size = 1
?OnUserScroeNotify@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z PROC ; CTableFrameSink::OnUserScroeNotify
; _this$ = ecx

; 870  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 871  : 	return false;

  00007	32 c0		 xor	 al, al

; 872  : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 0c 00	 ret	 12			; 0000000cH
?OnUserScroeNotify@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z ENDP ; CTableFrameSink::OnUserScroeNotify
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wRequestID$ = 8					; size = 2
_pData$ = 12						; size = 4
_wDataSize$ = 16					; size = 2
?OnDataBaseMessage@CTableFrameSink@@UAE_NGPAXG@Z PROC	; CTableFrameSink::OnDataBaseMessage
; _this$ = ecx

; 864  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 865  : 	return false;

  00007	32 c0		 xor	 al, al

; 866  : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 0c 00	 ret	 12			; 0000000cH
?OnDataBaseMessage@CTableFrameSink@@UAE_NGPAXG@Z ENDP	; CTableFrameSink::OnDataBaseMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_cc$2 = -32						; size = 4
_cc$3 = -28						; size = 4
_this$ = -24						; size = 4
_i$4 = -20						; size = 2
$T5 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_wTimerID$ = 8						; size = 4
_wBindParam$ = 12					; size = 4
?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z PROC		; CTableFrameSink::OnTimerMessage
; _this$ = ecx

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 832  : 	if(wTimerID == IDI_OUT_CARD)

  00028	83 7d 08 03	 cmp	 DWORD PTR _wTimerID$[ebp], 3
  0002c	0f 85 94 00 00
	00		 jne	 $LN5@OnTimerMes

; 833  : 	{
; 834  : 		CString cc;

  00032	8d 4d e4	 lea	 ecx, DWORD PTR _cc$3[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 835  : 		cc.Format(_T("出牌倒计时结束，当前玩家%d"), m_wCurrentUser);

  00042	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  0004c	51		 push	 ecx
  0004d	68 00 00 00 00	 push	 OFFSET $SG313753
  00052	8d 55 e4	 lea	 edx, DWORD PTR _cc$3[ebp]
  00055	52		 push	 edx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 836  : 		WriteDebugInfo(cc);

  0005f	8d 4d e4	 lea	 ecx, DWORD PTR _cc$3[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00068	50		 push	 eax
  00069	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 837  : 		m_pITableFrame->KillGameTimer(wTimerID);

  00071	8b 45 08	 mov	 eax, DWORD PTR _wTimerID$[ebp]
  00074	50		 push	 eax
  00075	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  0007e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 12		 mov	 edx, DWORD PTR [edx]
  00083	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00089	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0008f	ff d0		 call	 eax

; 838  : 
; 839  : 		return OnUserTrustee(m_wCurrentUser,true);

  00091	6a 01		 push	 1
  00093	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  0009d	52		 push	 edx
  0009e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::OnUserTrustee
  000a6	88 45 f3	 mov	 BYTE PTR $T5[ebp], al
  000a9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b0	8d 4d e4	 lea	 ecx, DWORD PTR _cc$3[ebp]
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  000b9	8a 45 f3	 mov	 al, BYTE PTR $T5[ebp]
  000bc	e9 df 00 00 00	 jmp	 $LN1@OnTimerMes
  000c1	e9 d8 00 00 00	 jmp	 $LN6@OnTimerMes
$LN5@OnTimerMes:

; 840  : 	}
; 841  : 	else if (wTimerID == IDI_OPERATE_CARD)

  000c6	83 7d 08 04	 cmp	 DWORD PTR _wTimerID$[ebp], 4
  000ca	0f 85 ce 00 00
	00		 jne	 $LN6@OnTimerMes

; 842  : 	{
; 843  : 		m_pITableFrame->KillGameTimer(wTimerID);

  000d0	8b 45 08	 mov	 eax, DWORD PTR _wTimerID$[ebp]
  000d3	50		 push	 eax
  000d4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  000dd	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 12		 mov	 edx, DWORD PTR [edx]
  000e2	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  000e8	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000ee	ff d0		 call	 eax

; 844  : 
; 845  : 		for (WORD i = 0; i < m_cbPlayerCount; i++)

  000f0	33 c9		 xor	 ecx, ecx
  000f2	66 89 4d ec	 mov	 WORD PTR _i$4[ebp], cx
  000f6	eb 0c		 jmp	 SHORT $LN4@OnTimerMes
$LN2@OnTimerMes:
  000f8	66 8b 55 ec	 mov	 dx, WORD PTR _i$4[ebp]
  000fc	66 83 c2 01	 add	 dx, 1
  00100	66 89 55 ec	 mov	 WORD PTR _i$4[ebp], dx
$LN4@OnTimerMes:
  00104	0f b7 45 ec	 movzx	 eax, WORD PTR _i$4[ebp]
  00108	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	0f b6 51 09	 movzx	 edx, BYTE PTR [ecx+9]
  0010f	3b c2		 cmp	 eax, edx
  00111	0f 8d 83 00 00
	00		 jge	 $LN3@OnTimerMes

; 846  : 		{
; 847  : 			if (m_cbUserAction[i] != WIK_NULL && m_bResponse[i] == false)

  00117	0f b7 45 ec	 movzx	 eax, WORD PTR _i$4[ebp]
  0011b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	0f b6 94 01 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1508]
  00126	85 d2		 test	 edx, edx
  00128	74 6b		 je	 SHORT $LN8@OnTimerMes
  0012a	0f b7 45 ec	 movzx	 eax, WORD PTR _i$4[ebp]
  0012e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	0f b6 94 01 e0
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1504]
  00139	85 d2		 test	 edx, edx
  0013b	75 58		 jne	 SHORT $LN8@OnTimerMes

; 848  : 			{
; 849  : 				CString cc;

  0013d	8d 4d e0	 lea	 ecx, DWORD PTR _cc$2[ebp]
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00146	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 850  : 				cc.Format(_T("操作倒计时结束，玩家%d"), i);

  0014d	0f b7 45 ec	 movzx	 eax, WORD PTR _i$4[ebp]
  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET $SG313757
  00157	8d 4d e0	 lea	 ecx, DWORD PTR _cc$2[ebp]
  0015a	51		 push	 ecx
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 851  : 				WriteDebugInfo(cc);

  00164	8d 4d e0	 lea	 ecx, DWORD PTR _cc$2[ebp]
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  0016d	50		 push	 eax
  0016e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 852  : 				OnUserTrustee(i, true);

  00176	6a 01		 push	 1
  00178	0f b7 55 ec	 movzx	 edx, WORD PTR _i$4[ebp]
  0017c	52		 push	 edx
  0017d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	e8 00 00 00 00	 call	 ?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::OnUserTrustee

; 853  : 			}

  00185	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018c	8d 4d e0	 lea	 ecx, DWORD PTR _cc$2[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
$LN8@OnTimerMes:

; 854  : 		}

  00195	e9 5e ff ff ff	 jmp	 $LN2@OnTimerMes
$LN3@OnTimerMes:

; 855  : 
; 856  : 		return true;

  0019a	b0 01		 mov	 al, 1
  0019c	eb 02		 jmp	 SHORT $LN1@OnTimerMes
$LN6@OnTimerMes:

; 857  : 	}
; 858  : 
; 859  : 	return false;

  0019e	32 c0		 xor	 al, al
$LN1@OnTimerMes:

; 860  : }

  001a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001aa	59		 pop	 ecx
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _cc$3[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z$1:
  00009	8d 4d e0	 lea	 ecx, DWORD PTR _cc$2[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnTimerMessage@CTableFrameSink@@UAE_NKI@Z ENDP		; CTableFrameSink::OnTimerMessage
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_tRes$2 = -1604						; size = 8
_tRes$3 = -1596						; size = 8
_curTime$4 = -1588					; size = 8
_pHistoryScore$5 = -1580				; size = 4
tv400 = -1576						; size = 4
tv262 = -1572						; size = 4
_pHistoryScore$6 = -1568				; size = 4
tv65 = -1564						; size = 4
_cc$7 = -1560						; size = 4
_i$8 = -1556						; size = 4
_j$9 = -1552						; size = 4
_i$10 = -1548						; size = 4
$T11 = -1541						; size = 1
_i$12 = -1540						; size = 2
_i$13 = -1536						; size = 2
_i$14 = -1532						; size = 2
_this$ = -1528						; size = 4
_StatusPlay$15 = -1524					; size = 1366
_StatusFree$16 = -156					; size = 106
_lRoomCardInitialScore$17 = -48				; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
_cbGameStatus$ = 16					; size = 1
_bSendSecret$ = 20					; size = 1
?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z PROC ; CTableFrameSink::OnEventSendGameScene
; _this$ = ecx

; 677  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 38 06 00
	00		 sub	 esp, 1592		; 00000638H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 8d 08 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 678  : 	switch (cbGameStatus)

  00032	8a 45 10	 mov	 al, BYTE PTR _cbGameStatus$[ebp]
  00035	88 85 e4 f9 ff
	ff		 mov	 BYTE PTR tv65[ebp], al
  0003b	80 bd e4 f9 ff
	ff 00		 cmp	 BYTE PTR tv65[ebp], 0
  00042	74 12		 je	 SHORT $LN22@OnEventSen
  00044	80 bd e4 f9 ff
	ff 64		 cmp	 BYTE PTR tv65[ebp], 100	; 00000064H
  0004b	0f 84 d6 01 00
	00		 je	 $LN23@OnEventSen
  00051	e9 d9 08 00 00	 jmp	 $LN2@OnEventSen
$LN22@OnEventSen:

; 679  : 	{
; 680  : 	case GAME_SCENE_FREE:	//空闲状态
; 681  : 		{
; 682  : 			//构造数据
; 683  : 			CMD_S_StatusFree StatusFree;
; 684  : 			ZeroMemory(&StatusFree, sizeof(StatusFree));

  00056	6a 6a		 push	 106			; 0000006aH
  00058	6a 00		 push	 0
  0005a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _StatusFree$16[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 _memset
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 685  : 
; 686  : 			//设置变量
; 687  : 			StatusFree.lCellScore = m_pITableFrame->GetCellScore();

  00069	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00075	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	8b 10		 mov	 edx, DWORD PTR [eax]
  0007d	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00083	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00086	ff d0		 call	 eax
  00088	89 85 64 ff ff
	ff		 mov	 DWORD PTR _StatusFree$16[ebp], eax

; 688  : 			StatusFree.cbMaCount = m_cbMaCount;

  0008e	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00094	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00097	88 55 ac	 mov	 BYTE PTR _StatusFree$16[ebp+72], dl

; 689  : 			StatusFree.cbPlayerCount = m_cbPlayerCount;

  0009a	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000a0	8a 48 09	 mov	 cl, BYTE PTR [eax+9]
  000a3	88 4d ab	 mov	 BYTE PTR _StatusFree$16[ebp+71], cl

; 690  : 			//自定规则
; 691  : 			StatusFree.cbTimeOutCard = m_pGameCustomRule->cbTimeOutCard;		

  000a6	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000ac	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  000b2	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  000b5	88 8d 68 ff ff
	ff		 mov	 BYTE PTR _StatusFree$16[ebp+4], cl

; 692  : 			StatusFree.cbTimeOperateCard = m_pGameCustomRule->cbTimeOperateCard;

  000bb	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  000c7	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  000ca	88 8d 69 ff ff
	ff		 mov	 BYTE PTR _StatusFree$16[ebp+5], cl

; 693  : 			StatusFree.cbTimeStartGame = m_pGameCustomRule->cbTimeStartGame;

  000d0	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000d6	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  000dc	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000df	88 8d 6a ff ff
	ff		 mov	 BYTE PTR _StatusFree$16[ebp+6], cl

; 694  : 			StatusFree.cbPlayMode = m_pITableFrame->GetDataBaseMode();

  000e5	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000eb	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  000f1	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	8b 10		 mov	 edx, DWORD PTR [eax]
  000f9	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  000ff	8b 82 34 01 00
	00		 mov	 eax, DWORD PTR [edx+308]
  00105	ff d0		 call	 eax
  00107	88 45 cd	 mov	 BYTE PTR _StatusFree$16[ebp+105], al

; 695  : 			//分配的初始积分都一样
; 696  : 			SCORE lRoomCardInitialScore[GAME_PLAYER];
; 697  : 			for (WORD i=0; i<GAME_PLAYER; i++)

  0010a	33 c9		 xor	 ecx, ecx
  0010c	66 89 8d fc f9
	ff ff		 mov	 WORD PTR _i$12[ebp], cx
  00113	eb 12		 jmp	 SHORT $LN6@OnEventSen
$LN4@OnEventSen:
  00115	66 8b 95 fc f9
	ff ff		 mov	 dx, WORD PTR _i$12[ebp]
  0011c	66 83 c2 01	 add	 dx, 1
  00120	66 89 95 fc f9
	ff ff		 mov	 WORD PTR _i$12[ebp], dx
$LN6@OnEventSen:
  00127	0f b7 85 fc f9
	ff ff		 movzx	 eax, WORD PTR _i$12[ebp]
  0012e	83 f8 04	 cmp	 eax, 4
  00131	7d 29		 jge	 SHORT $LN5@OnEventSen

; 698  : 			{
; 699  : 				lRoomCardInitialScore[i] = m_lRoomCardInitialScore[wChairID];

  00133	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  00137	0f b7 95 fc f9
	ff ff		 movzx	 edx, WORD PTR _i$12[ebp]
  0013e	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00144	8b b4 c8 88 04
	00 00		 mov	 esi, DWORD PTR [eax+ecx*8+1160]
  0014b	89 74 d5 d0	 mov	 DWORD PTR _lRoomCardInitialScore$17[ebp+edx*8], esi
  0014f	8b 8c c8 8c 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*8+1164]
  00156	89 4c d5 d4	 mov	 DWORD PTR _lRoomCardInitialScore$17[ebp+edx*8+4], ecx

; 700  : 			}

  0015a	eb b9		 jmp	 SHORT $LN4@OnEventSen
$LN5@OnEventSen:

; 701  : 
; 702  : 			CopyMemory(StatusFree.lRoomCardInitialScore, lRoomCardInitialScore, sizeof(lRoomCardInitialScore));

  0015c	6a 20		 push	 32			; 00000020H
  0015e	8d 55 d0	 lea	 edx, DWORD PTR _lRoomCardInitialScore$17[ebp]
  00161	52		 push	 edx
  00162	8d 45 ad	 lea	 eax, DWORD PTR _StatusFree$16[ebp+73]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _memcpy
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 703  : 
; 704  : 			//历史积分
; 705  : 			for (WORD i = 0; i < GAME_PLAYER; i++)

  0016e	33 c9		 xor	 ecx, ecx
  00170	66 89 8d 04 fa
	ff ff		 mov	 WORD PTR _i$14[ebp], cx
  00177	eb 12		 jmp	 SHORT $LN9@OnEventSen
$LN7@OnEventSen:
  00179	66 8b 95 04 fa
	ff ff		 mov	 dx, WORD PTR _i$14[ebp]
  00180	66 83 c2 01	 add	 dx, 1
  00184	66 89 95 04 fa
	ff ff		 mov	 WORD PTR _i$14[ebp], dx
$LN9@OnEventSen:
  0018b	0f b7 85 04 fa
	ff ff		 movzx	 eax, WORD PTR _i$14[ebp]
  00192	83 f8 04	 cmp	 eax, 4
  00195	7d 5c		 jge	 SHORT $LN8@OnEventSen

; 706  : 			{
; 707  : 				//变量定义
; 708  : 				tagHistoryScore * pHistoryScore = m_HistoryScore.GetHistoryScore(i);

  00197	0f b7 8d 04 fa
	ff ff		 movzx	 ecx, WORD PTR _i$14[ebp]
  0019e	51		 push	 ecx
  0019f	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	81 c1 e0 08 00
	00		 add	 ecx, 2272		; 000008e0H
  001ab	e8 00 00 00 00	 call	 ?GetHistoryScore@CHistoryScore@@QAEPAUtagHistoryScore@@G@Z ; CHistoryScore::GetHistoryScore
  001b0	89 85 e0 f9 ff
	ff		 mov	 DWORD PTR _pHistoryScore$6[ebp], eax

; 709  : 
; 710  : 				//设置变量
; 711  : 				StatusFree.lTurnScore[i] = pHistoryScore->lTurnScore;

  001b6	0f b7 95 04 fa
	ff ff		 movzx	 edx, WORD PTR _i$14[ebp]
  001bd	8b 85 e0 f9 ff
	ff		 mov	 eax, DWORD PTR _pHistoryScore$6[ebp]
  001c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c5	89 8c d5 6b ff
	ff ff		 mov	 DWORD PTR _StatusFree$16[ebp+edx*8+7], ecx
  001cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001cf	89 84 d5 6f ff
	ff ff		 mov	 DWORD PTR _StatusFree$16[ebp+edx*8+11], eax

; 712  : 				StatusFree.lCollectScore[i] = pHistoryScore->lCollectScore;

  001d6	0f b7 8d 04 fa
	ff ff		 movzx	 ecx, WORD PTR _i$14[ebp]
  001dd	8b 95 e0 f9 ff
	ff		 mov	 edx, DWORD PTR _pHistoryScore$6[ebp]
  001e3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001e6	89 44 cd 8b	 mov	 DWORD PTR _StatusFree$16[ebp+ecx*8+39], eax
  001ea	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  001ed	89 54 cd 8f	 mov	 DWORD PTR _StatusFree$16[ebp+ecx*8+43], edx

; 713  : 			}

  001f1	eb 86		 jmp	 SHORT $LN7@OnEventSen
$LN8@OnEventSen:

; 714  : 
; 715  : 			//发送场景
; 716  : 			return m_pITableFrame->SendGameScene(pIServerUserItem, &StatusFree, sizeof(StatusFree));

  001f3	6a 6a		 push	 106			; 0000006aH
  001f5	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _StatusFree$16[ebp]
  001fb	50		 push	 eax
  001fc	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  001ff	51		 push	 ecx
  00200	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00206	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  0020c	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00212	8b 10		 mov	 edx, DWORD PTR [eax]
  00214	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  0021a	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  00220	ff d0		 call	 eax
  00222	e9 0a 07 00 00	 jmp	 $LN1@OnEventSen
$LN23@OnEventSen:

; 717  : 		}
; 718  : 	case GAME_SCENE_PLAY:	//游戏状态
; 719  : 		{
; 720  : 			CString cc;

  00227	8d 8d e8 f9 ff
	ff		 lea	 ecx, DWORD PTR _cc$7[ebp]
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00233	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 721  : 			cc.Format(_T("玩家%d断线重连"), wChairID);

  0023a	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  0023e	51		 push	 ecx
  0023f	68 00 00 00 00	 push	 OFFSET $SG313730
  00244	8d 95 e8 f9 ff
	ff		 lea	 edx, DWORD PTR _cc$7[ebp]
  0024a	52		 push	 edx
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH

; 722  : 			WriteDebugInfo(cc);

  00254	8d 8d e8 f9 ff
	ff		 lea	 ecx, DWORD PTR _cc$7[ebp]
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00260	50		 push	 eax
  00261	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00267	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 723  : 			OnUserTrustee(wChairID, false);//重入取消托管

  0026c	6a 00		 push	 0
  0026e	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00272	50		 push	 eax
  00273	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00279	e8 00 00 00 00	 call	 ?OnUserTrustee@CTableFrameSink@@IAE_NG_N@Z ; CTableFrameSink::OnUserTrustee

; 724  : 			//变量定义
; 725  : 			CMD_S_StatusPlay StatusPlay;
; 726  : 			ZeroMemory(&StatusPlay, sizeof(StatusPlay));

  0027e	68 56 05 00 00	 push	 1366			; 00000556H
  00283	6a 00		 push	 0
  00285	8d 8d 0c fa ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp]
  0028b	51		 push	 ecx
  0028c	e8 00 00 00 00	 call	 _memset
  00291	83 c4 0c	 add	 esp, 12			; 0000000cH

; 727  : 
; 728  : 			//自定规则
; 729  : 			StatusPlay.cbTimeOutCard = m_pGameCustomRule->cbTimeOutCard;		

  00294	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0029a	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  002a0	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  002a3	88 8d 0c fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp], cl

; 730  : 			StatusPlay.cbTimeOperateCard = m_pGameCustomRule->cbTimeOperateCard;

  002a9	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002af	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  002b5	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  002b8	88 8d 0d fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+1], cl

; 731  : 			StatusPlay.cbTimeStartGame = m_pGameCustomRule->cbTimeStartGame;

  002be	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002c4	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  002ca	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  002cd	88 8d 0e fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+2], cl

; 732  : 
; 733  : 			//规则
; 734  : 			StatusPlay.cbMaCount = m_cbMaCount;

  002d3	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002d9	8a 42 08	 mov	 al, BYTE PTR [edx+8]
  002dc	88 85 1d fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+17], al

; 735  : 			StatusPlay.cbPlayerCount = m_cbPlayerCount;

  002e2	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  002eb	88 95 1c fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+16], dl

; 736  : 			//游戏变量
; 737  : 			StatusPlay.wBankerUser = m_wBankerUser;

  002f1	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002f7	66 8b 88 72 04
	00 00		 mov	 cx, WORD PTR [eax+1138]
  002fe	66 89 8d 17 fa
	ff ff		 mov	 WORD PTR _StatusPlay$15[ebp+11], cx

; 738  : 			StatusPlay.wCurrentUser = m_wCurrentUser;

  00305	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0030b	66 8b 82 be 04
	00 00		 mov	 ax, WORD PTR [edx+1214]
  00312	66 89 85 19 fa
	ff ff		 mov	 WORD PTR _StatusPlay$15[ebp+13], ax

; 739  : 			StatusPlay.lCellScore = m_pITableFrame->GetCellScore();

  00319	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0031f	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00325	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0032b	8b 12		 mov	 edx, DWORD PTR [edx]
  0032d	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00333	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00336	ff d0		 call	 eax
  00338	99		 cdq
  00339	89 85 0f fa ff
	ff		 mov	 DWORD PTR _StatusPlay$15[ebp+3], eax
  0033f	89 95 13 fa ff
	ff		 mov	 DWORD PTR _StatusPlay$15[ebp+7], edx

; 740  : 			StatusPlay.cbMagicIndex = m_cbMagicIndex;

  00345	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0034b	8a 91 7c 04 00
	00		 mov	 dl, BYTE PTR [ecx+1148]
  00351	88 95 1b fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+15], dl

; 741  : 			CopyMemory(StatusPlay.bTrustee, m_bTrustee, sizeof(m_bTrustee));

  00357	6a 04		 push	 4
  00359	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0035f	05 78 04 00 00	 add	 eax, 1144		; 00000478H
  00364	50		 push	 eax
  00365	8d 8d 21 fa ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp+21]
  0036b	51		 push	 ecx
  0036c	e8 00 00 00 00	 call	 _memcpy
  00371	83 c4 0c	 add	 esp, 12			; 0000000cH

; 742  : 			StatusPlay.cbPlayMode = m_pITableFrame->GetDataBaseMode();

  00374	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0037a	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00380	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00386	8b 10		 mov	 edx, DWORD PTR [eax]
  00388	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  0038e	8b 82 34 01 00
	00		 mov	 eax, DWORD PTR [edx+308]
  00394	ff d0		 call	 eax
  00396	88 85 d8 fd ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+972], al

; 743  : 			//状态变量
; 744  : 			StatusPlay.cbActionCard = m_cbProvideCard;

  0039c	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003a2	8a 91 c2 04 00
	00		 mov	 dl, BYTE PTR [ecx+1218]
  003a8	88 95 1e fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+18], dl

; 745  : 			StatusPlay.cbLeftCardCount = m_cbLeftCardCount;

  003ae	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003b4	8a 88 b1 07 00
	00		 mov	 cl, BYTE PTR [eax+1969]
  003ba	88 8d 20 fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+20], cl

; 746  : 			StatusPlay.cbActionMask = !m_bResponse[wChairID] ? m_cbUserAction[wChairID] : WIK_NULL;

  003c0	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  003c4	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003ca	0f b6 8c 10 e0
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1504]
  003d2	85 c9		 test	 ecx, ecx
  003d4	75 1a		 jne	 SHORT $LN33@OnEventSen
  003d6	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  003da	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003e0	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  003e8	89 8d dc f9 ff
	ff		 mov	 DWORD PTR tv262[ebp], ecx
  003ee	eb 0a		 jmp	 SHORT $LN34@OnEventSen
$LN33@OnEventSen:
  003f0	c7 85 dc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv262[ebp], 0
$LN34@OnEventSen:
  003fa	8a 95 dc f9 ff
	ff		 mov	 dl, BYTE PTR tv262[ebp]
  00400	88 95 1f fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+19], dl

; 747  : 			
; 748  : 			CopyMemory(StatusPlay.bTrustee, m_bTrustee, sizeof(StatusPlay.bTrustee));

  00406	6a 04		 push	 4
  00408	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0040e	05 78 04 00 00	 add	 eax, 1144		; 00000478H
  00413	50		 push	 eax
  00414	8d 8d 21 fa ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp+21]
  0041a	51		 push	 ecx
  0041b	e8 00 00 00 00	 call	 _memcpy
  00420	83 c4 0c	 add	 esp, 12			; 0000000cH

; 749  : 			CopyMemory(StatusPlay.bTing, m_bTing, sizeof(StatusPlay.bTing));

  00423	6a 04		 push	 4
  00425	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0042b	81 c2 74 04 00
	00		 add	 edx, 1140		; 00000474H
  00431	52		 push	 edx
  00432	8d 85 25 fa ff
	ff		 lea	 eax, DWORD PTR _StatusPlay$15[ebp+25]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 _memcpy
  0043e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  : 			//当前能胡的牌
; 751  : 			StatusPlay.cbOutCardCount = m_GameLogic.AnalyseTingCard(m_cbCardIndex[wChairID],m_WeaveItemArray[wChairID],m_cbWeaveItemCount[wChairID],StatusPlay.cbOutCardCount,StatusPlay.cbOutCardDataEx,StatusPlay.cbHuCardCount,StatusPlay.cbHuCardData); 

  00441	8d 8d e1 fb ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp+469]
  00447	51		 push	 ecx
  00448	8d 95 d3 fb ff
	ff		 lea	 edx, DWORD PTR _StatusPlay$15[ebp+455]
  0044e	52		 push	 edx
  0044f	8d 85 6a fd ff
	ff		 lea	 eax, DWORD PTR _StatusPlay$15[ebp+862]
  00455	50		 push	 eax
  00456	8d 8d 69 fd ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp+861]
  0045c	51		 push	 ecx
  0045d	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00461	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00467	0f b6 8c 10 3e
	08 00 00	 movzx	 ecx, BYTE PTR [eax+edx+2110]
  0046f	51		 push	 ecx
  00470	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  00474	6b c2 24	 imul	 eax, edx, 36
  00477	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0047d	8d 94 01 42 08
	00 00		 lea	 edx, DWORD PTR [ecx+eax+2114]
  00484	52		 push	 edx
  00485	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00489	6b c8 22	 imul	 ecx, eax, 34
  0048c	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00492	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  00499	50		 push	 eax
  0049a	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004a0	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  004a6	e8 00 00 00 00	 call	 ?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z ; CGameLogic::AnalyseTingCard
  004ab	88 85 69 fd ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+861], al

; 752  : 			if (StatusPlay.cbOutCardCount > 0)

  004b1	0f b6 8d 69 fd
	ff ff		 movzx	 ecx, BYTE PTR _StatusPlay$15[ebp+861]
  004b8	85 c9		 test	 ecx, ecx
  004ba	0f 8e b6 00 00
	00		 jle	 $LN24@OnEventSen

; 753  : 			{
; 754  : 				for (int i = 0; i < MAX_COUNT; i++)

  004c0	c7 85 f4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$10[ebp], 0
  004ca	eb 0f		 jmp	 SHORT $LN12@OnEventSen
$LN10@OnEventSen:
  004cc	8b 95 f4 f9 ff
	ff		 mov	 edx, DWORD PTR _i$10[ebp]
  004d2	83 c2 01	 add	 edx, 1
  004d5	89 95 f4 f9 ff
	ff		 mov	 DWORD PTR _i$10[ebp], edx
$LN12@OnEventSen:
  004db	83 bd f4 f9 ff
	ff 0e		 cmp	 DWORD PTR _i$10[ebp], 14 ; 0000000eH
  004e2	0f 8d 8e 00 00
	00		 jge	 $LN24@OnEventSen

; 755  : 				{
; 756  : 					if (StatusPlay.cbHuCardCount[i] > 0)

  004e8	8b 85 f4 f9 ff
	ff		 mov	 eax, DWORD PTR _i$10[ebp]
  004ee	0f b6 8c 05 d3
	fb ff ff	 movzx	 ecx, BYTE PTR _StatusPlay$15[ebp+eax+455]
  004f6	85 c9		 test	 ecx, ecx
  004f8	7e 75		 jle	 SHORT $LN25@OnEventSen

; 757  : 					{
; 758  : 						for (int j = 0; j < StatusPlay.cbHuCardCount[i]; j++)

  004fa	c7 85 f0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$9[ebp], 0
  00504	eb 0f		 jmp	 SHORT $LN15@OnEventSen
$LN13@OnEventSen:
  00506	8b 95 f0 f9 ff
	ff		 mov	 edx, DWORD PTR _j$9[ebp]
  0050c	83 c2 01	 add	 edx, 1
  0050f	89 95 f0 f9 ff
	ff		 mov	 DWORD PTR _j$9[ebp], edx
$LN15@OnEventSen:
  00515	8b 85 f4 f9 ff
	ff		 mov	 eax, DWORD PTR _i$10[ebp]
  0051b	0f b6 8c 05 d3
	fb ff ff	 movzx	 ecx, BYTE PTR _StatusPlay$15[ebp+eax+455]
  00523	39 8d f0 f9 ff
	ff		 cmp	 DWORD PTR _j$9[ebp], ecx
  00529	7d 42		 jge	 SHORT $LN14@OnEventSen

; 759  : 						{
; 760  : 							StatusPlay.cbHuCardRemainingCount[i][j] = GetRemainingCount(wChairID, StatusPlay.cbHuCardData[i][j]);

  0052b	6b 95 f4 f9 ff
	ff 1c		 imul	 edx, DWORD PTR _i$10[ebp], 28
  00532	8d 84 15 e1 fb
	ff ff		 lea	 eax, DWORD PTR _StatusPlay$15[ebp+edx+469]
  00539	8b 8d f0 f9 ff
	ff		 mov	 ecx, DWORD PTR _j$9[ebp]
  0053f	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00543	52		 push	 edx
  00544	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  00548	50		 push	 eax
  00549	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0054f	e8 00 00 00 00	 call	 ?GetRemainingCount@CTableFrameSink@@IAEEGE@Z ; CTableFrameSink::GetRemainingCount
  00554	6b 8d f4 f9 ff
	ff 1c		 imul	 ecx, DWORD PTR _i$10[ebp], 28
  0055b	8d 94 0d da fd
	ff ff		 lea	 edx, DWORD PTR _StatusPlay$15[ebp+ecx+974]
  00562	8b 8d f0 f9 ff
	ff		 mov	 ecx, DWORD PTR _j$9[ebp]
  00568	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 761  : 						}

  0056b	eb 99		 jmp	 SHORT $LN13@OnEventSen
$LN14@OnEventSen:

; 762  : 					}
; 763  : 					else

  0056d	eb 02		 jmp	 SHORT $LN26@OnEventSen
$LN25@OnEventSen:

; 764  : 						break;

  0056f	eb 05		 jmp	 SHORT $LN24@OnEventSen
$LN26@OnEventSen:

; 765  : 				}

  00571	e9 56 ff ff ff	 jmp	 $LN10@OnEventSen
$LN24@OnEventSen:

; 766  : 			}
; 767  : 
; 768  : 			//历史记录
; 769  : 			StatusPlay.wOutCardUser = m_wOutCardUser;

  00576	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0057c	66 8b 82 44 06
	00 00		 mov	 ax, WORD PTR [edx+1604]
  00583	66 89 85 29 fa
	ff ff		 mov	 WORD PTR _StatusPlay$15[ebp+29], ax

; 770  : 			StatusPlay.cbOutCardData = m_cbOutCardData;

  0058a	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00590	8a 91 46 06 00
	00		 mov	 dl, BYTE PTR [ecx+1606]
  00596	88 95 2b fa ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+31], dl

; 771  : 			CopyMemory(StatusPlay.cbDiscardCard, m_cbDiscardCard, sizeof(StatusPlay.cbDiscardCard));

  0059c	68 f0 00 00 00	 push	 240			; 000000f0H
  005a1	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005a7	05 4c 06 00 00	 add	 eax, 1612		; 0000064cH
  005ac	50		 push	 eax
  005ad	8d 8d 30 fa ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp+36]
  005b3	51		 push	 ecx
  005b4	e8 00 00 00 00	 call	 _memcpy
  005b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 772  : 			CopyMemory(StatusPlay.cbDiscardCount, m_cbDiscardCount, sizeof(StatusPlay.cbDiscardCount));

  005bc	6a 04		 push	 4
  005be	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  005c4	81 c2 48 06 00
	00		 add	 edx, 1608		; 00000648H
  005ca	52		 push	 edx
  005cb	8d 85 2c fa ff
	ff		 lea	 eax, DWORD PTR _StatusPlay$15[ebp+32]
  005d1	50		 push	 eax
  005d2	e8 00 00 00 00	 call	 _memcpy
  005d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 773  : 
; 774  : 			//组合扑克
; 775  : 			CopyMemory(StatusPlay.WeaveItemArray, m_WeaveItemArray, sizeof(StatusPlay.WeaveItemArray));

  005da	68 90 00 00 00	 push	 144			; 00000090H
  005df	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005e5	81 c1 42 08 00
	00		 add	 ecx, 2114		; 00000842H
  005eb	51		 push	 ecx
  005ec	8d 95 37 fb ff
	ff		 lea	 edx, DWORD PTR _StatusPlay$15[ebp+299]
  005f2	52		 push	 edx
  005f3	e8 00 00 00 00	 call	 _memcpy
  005f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 776  : 			CopyMemory(StatusPlay.cbWeaveItemCount, m_cbWeaveItemCount, sizeof(StatusPlay.cbWeaveItemCount));

  005fb	6a 04		 push	 4
  005fd	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00603	05 3e 08 00 00	 add	 eax, 2110		; 0000083eH
  00608	50		 push	 eax
  00609	8d 8d 33 fb ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp+295]
  0060f	51		 push	 ecx
  00610	e8 00 00 00 00	 call	 _memcpy
  00615	83 c4 0c	 add	 esp, 12			; 0000000cH

; 777  : 
; 778  : 			//堆立信息
; 779  : 			StatusPlay.wHeapHead = m_wHeapHead;

  00618	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0061e	66 8b 82 b0 04
	00 00		 mov	 ax, WORD PTR [edx+1200]
  00625	66 89 85 c7 fb
	ff ff		 mov	 WORD PTR _StatusPlay$15[ebp+443], ax

; 780  : 			StatusPlay.wHeapTail = m_wHeapTail;

  0062c	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00632	66 8b 91 b2 04
	00 00		 mov	 dx, WORD PTR [ecx+1202]
  00639	66 89 95 c9 fb
	ff ff		 mov	 WORD PTR _StatusPlay$15[ebp+445], dx

; 781  : 			CopyMemory(StatusPlay.cbHeapCardInfo, m_cbHeapCardInfo, sizeof(m_cbHeapCardInfo));

  00640	6a 08		 push	 8
  00642	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00648	05 b4 04 00 00	 add	 eax, 1204		; 000004b4H
  0064d	50		 push	 eax
  0064e	8d 8d cb fb ff
	ff		 lea	 ecx, DWORD PTR _StatusPlay$15[ebp+447]
  00654	51		 push	 ecx
  00655	e8 00 00 00 00	 call	 _memcpy
  0065a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 782  : 
; 783  : 			//扑克数据
; 784  : 			for(int i = 0; i < GAME_PLAYER; i++)

  0065d	c7 85 ec f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$8[ebp], 0
  00667	eb 0f		 jmp	 SHORT $LN18@OnEventSen
$LN16@OnEventSen:
  00669	8b 95 ec f9 ff
	ff		 mov	 edx, DWORD PTR _i$8[ebp]
  0066f	83 c2 01	 add	 edx, 1
  00672	89 95 ec f9 ff
	ff		 mov	 DWORD PTR _i$8[ebp], edx
$LN18@OnEventSen:
  00678	83 bd ec f9 ff
	ff 04		 cmp	 DWORD PTR _i$8[ebp], 4
  0067f	7d 35		 jge	 SHORT $LN17@OnEventSen

; 785  : 			{
; 786  : 				StatusPlay.cbCardCount[i] = m_GameLogic.GetCardCount(m_cbCardIndex[i]);

  00681	6b 85 ec f9 ff
	ff 22		 imul	 eax, DWORD PTR _i$8[ebp], 34
  00688	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0068e	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00695	52		 push	 edx
  00696	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0069c	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  006a2	e8 00 00 00 00	 call	 ?GetCardCount@CGameLogic@@QAEEQBE@Z ; CGameLogic::GetCardCount
  006a7	8b 8d ec f9 ff
	ff		 mov	 ecx, DWORD PTR _i$8[ebp]
  006ad	88 84 0d 20 fb
	ff ff		 mov	 BYTE PTR _StatusPlay$15[ebp+ecx+276], al

; 787  : 			}

  006b4	eb b3		 jmp	 SHORT $LN16@OnEventSen
$LN17@OnEventSen:

; 788  : 			m_GameLogic.SwitchToCardData(m_cbCardIndex[wChairID], StatusPlay.cbCardData);

  006b6	8d 95 24 fb ff
	ff		 lea	 edx, DWORD PTR _StatusPlay$15[ebp+280]
  006bc	52		 push	 edx
  006bd	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  006c1	6b c8 22	 imul	 ecx, eax, 34
  006c4	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006ca	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  006d1	50		 push	 eax
  006d2	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006d8	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  006de	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z ; CGameLogic::SwitchToCardData

; 789  : 			StatusPlay.cbSendCardData = (m_wCurrentUser == wChairID) ? m_cbSendCardData : 0x00;

  006e3	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006e9	0f b7 91 be 04
	00 00		 movzx	 edx, WORD PTR [ecx+1214]
  006f0	0f b7 45 08	 movzx	 eax, WORD PTR _wChairID$[ebp]
  006f4	3b d0		 cmp	 edx, eax
  006f6	75 15		 jne	 SHORT $LN35@OnEventSen
  006f8	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006fe	0f b6 91 3c 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1852]
  00705	89 95 d8 f9 ff
	ff		 mov	 DWORD PTR tv400[ebp], edx
  0070b	eb 0a		 jmp	 SHORT $LN36@OnEventSen
$LN35@OnEventSen:
  0070d	c7 85 d8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv400[ebp], 0
$LN36@OnEventSen:
  00717	8a 85 d8 f9 ff
	ff		 mov	 al, BYTE PTR tv400[ebp]
  0071d	88 85 32 fb ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+294], al

; 790  : 			
; 791  : 			CopyMemory(StatusPlay.lRoomCardInitialScore, m_lRoomCardInitialScore, sizeof(m_lRoomCardInitialScore));

  00723	6a 20		 push	 32			; 00000020H
  00725	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0072b	81 c1 88 04 00
	00		 add	 ecx, 1160		; 00000488H
  00731	51		 push	 ecx
  00732	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR _StatusPlay$15[ebp+940]
  00738	52		 push	 edx
  00739	e8 00 00 00 00	 call	 _memcpy
  0073e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 792  : 
; 793  : 			//历史积分
; 794  : 			for (WORD i = 0; i < GAME_PLAYER; i++)

  00741	33 c0		 xor	 eax, eax
  00743	66 89 85 00 fa
	ff ff		 mov	 WORD PTR _i$13[ebp], ax
  0074a	eb 12		 jmp	 SHORT $LN21@OnEventSen
$LN19@OnEventSen:
  0074c	66 8b 8d 00 fa
	ff ff		 mov	 cx, WORD PTR _i$13[ebp]
  00753	66 83 c1 01	 add	 cx, 1
  00757	66 89 8d 00 fa
	ff ff		 mov	 WORD PTR _i$13[ebp], cx
$LN21@OnEventSen:
  0075e	0f b7 95 00 fa
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  00765	83 fa 04	 cmp	 edx, 4
  00768	7d 62		 jge	 SHORT $LN20@OnEventSen

; 795  : 			{
; 796  : 				//变量定义
; 797  : 				tagHistoryScore * pHistoryScore = m_HistoryScore.GetHistoryScore(i);

  0076a	0f b7 85 00 fa
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  00771	50		 push	 eax
  00772	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00778	81 c1 e0 08 00
	00		 add	 ecx, 2272		; 000008e0H
  0077e	e8 00 00 00 00	 call	 ?GetHistoryScore@CHistoryScore@@QAEPAUtagHistoryScore@@G@Z ; CHistoryScore::GetHistoryScore
  00783	89 85 d4 f9 ff
	ff		 mov	 DWORD PTR _pHistoryScore$5[ebp], eax

; 798  : 
; 799  : 				//设置变量
; 800  : 				StatusPlay.lTurnScore[i] = pHistoryScore->lTurnScore;

  00789	0f b7 8d 00 fa
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00790	8b 95 d4 f9 ff
	ff		 mov	 edx, DWORD PTR _pHistoryScore$5[ebp]
  00796	8b 02		 mov	 eax, DWORD PTR [edx]
  00798	89 84 cd 78 fd
	ff ff		 mov	 DWORD PTR _StatusPlay$15[ebp+ecx*8+876], eax
  0079f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  007a2	89 94 cd 7c fd
	ff ff		 mov	 DWORD PTR _StatusPlay$15[ebp+ecx*8+880], edx

; 801  : 				StatusPlay.lCollectScore[i] = pHistoryScore->lCollectScore;

  007a9	0f b7 85 00 fa
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  007b0	8b 8d d4 f9 ff
	ff		 mov	 ecx, DWORD PTR _pHistoryScore$5[ebp]
  007b6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  007b9	89 94 c5 98 fd
	ff ff		 mov	 DWORD PTR _StatusPlay$15[ebp+eax*8+908], edx
  007c0	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  007c3	89 8c c5 9c fd
	ff ff		 mov	 DWORD PTR _StatusPlay$15[ebp+eax*8+912], ecx

; 802  : 			}

  007ca	eb 80		 jmp	 SHORT $LN19@OnEventSen
$LN20@OnEventSen:

; 803  : 
; 804  : 			time_t curTime = time(0);

  007cc	6a 00		 push	 0
  007ce	e8 00 00 00 00	 call	 _time
  007d3	83 c4 04	 add	 esp, 4
  007d6	89 85 cc f9 ff
	ff		 mov	 DWORD PTR _curTime$4[ebp], eax
  007dc	89 95 d0 f9 ff
	ff		 mov	 DWORD PTR _curTime$4[ebp+4], edx

; 805  : 			if (m_wCurrentUser != INVALID_CHAIR)

  007e2	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007e8	0f b7 82 be 04
	00 00		 movzx	 eax, WORD PTR [edx+1214]
  007ef	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  007f4	74 60		 je	 SHORT $LN27@OnEventSen

; 806  : 			{
; 807  : 				time_t tRes = m_tActionStartTime + m_pGameCustomRule->cbTimeOutCard - curTime;

  007f6	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007fc	8b 91 2c 09 00
	00		 mov	 edx, DWORD PTR [ecx+2348]
  00802	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00806	99		 cdq
  00807	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0080d	03 81 a8 04 00
	00		 add	 eax, DWORD PTR [ecx+1192]
  00813	13 91 ac 04 00
	00		 adc	 edx, DWORD PTR [ecx+1196]
  00819	2b 85 cc f9 ff
	ff		 sub	 eax, DWORD PTR _curTime$4[ebp]
  0081f	1b 95 d0 f9 ff
	ff		 sbb	 edx, DWORD PTR _curTime$4[ebp+4]
  00825	89 85 c4 f9 ff
	ff		 mov	 DWORD PTR _tRes$3[ebp], eax
  0082b	89 95 c8 f9 ff
	ff		 mov	 DWORD PTR _tRes$3[ebp+4], edx

; 808  : 				if (tRes > 0)

  00831	83 bd c8 f9 ff
	ff 00		 cmp	 DWORD PTR _tRes$3[ebp+4], 0
  00838	7c 17		 jl	 SHORT $LN29@OnEventSen
  0083a	7f 09		 jg	 SHORT $LN38@OnEventSen
  0083c	83 bd c4 f9 ff
	ff 00		 cmp	 DWORD PTR _tRes$3[ebp], 0
  00843	76 0c		 jbe	 SHORT $LN29@OnEventSen
$LN38@OnEventSen:

; 809  : 					StatusPlay.cbRemainingTime = (BYTE)tRes;

  00845	8a 95 c4 f9 ff
	ff		 mov	 dl, BYTE PTR _tRes$3[ebp]
  0084b	88 95 d9 fd ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+973], dl
$LN29@OnEventSen:

; 810  : 			}

  00851	e9 86 00 00 00	 jmp	 $LN28@OnEventSen
$LN27@OnEventSen:

; 811  : 			else if (m_wCurrentUser == INVALID_CHAIR && m_cbUserAction[wChairID] != WIK_NULL)

  00856	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0085c	0f b7 88 be 04
	00 00		 movzx	 ecx, WORD PTR [eax+1214]
  00863	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00869	75 71		 jne	 SHORT $LN28@OnEventSen
  0086b	0f b7 55 08	 movzx	 edx, WORD PTR _wChairID$[ebp]
  0086f	8b 85 08 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00875	0f b6 8c 10 e4
	05 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1508]
  0087d	85 c9		 test	 ecx, ecx
  0087f	74 5b		 je	 SHORT $LN28@OnEventSen

; 812  : 			{
; 813  : 				time_t tRes = m_tActionStartTime + m_pGameCustomRule->cbTimeOperateCard - curTime;

  00881	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00887	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  0088d	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00891	99		 cdq
  00892	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00898	03 81 a8 04 00
	00		 add	 eax, DWORD PTR [ecx+1192]
  0089e	13 91 ac 04 00
	00		 adc	 edx, DWORD PTR [ecx+1196]
  008a4	2b 85 cc f9 ff
	ff		 sub	 eax, DWORD PTR _curTime$4[ebp]
  008aa	1b 95 d0 f9 ff
	ff		 sbb	 edx, DWORD PTR _curTime$4[ebp+4]
  008b0	89 85 bc f9 ff
	ff		 mov	 DWORD PTR _tRes$2[ebp], eax
  008b6	89 95 c0 f9 ff
	ff		 mov	 DWORD PTR _tRes$2[ebp+4], edx

; 814  : 				if (tRes > 0)

  008bc	83 bd c0 f9 ff
	ff 00		 cmp	 DWORD PTR _tRes$2[ebp+4], 0
  008c3	7c 17		 jl	 SHORT $LN28@OnEventSen
  008c5	7f 09		 jg	 SHORT $LN39@OnEventSen
  008c7	83 bd bc f9 ff
	ff 00		 cmp	 DWORD PTR _tRes$2[ebp], 0
  008ce	76 0c		 jbe	 SHORT $LN28@OnEventSen
$LN39@OnEventSen:

; 815  : 					StatusPlay.cbRemainingTime = (BYTE)tRes;

  008d0	8a 95 bc f9 ff
	ff		 mov	 dl, BYTE PTR _tRes$2[ebp]
  008d6	88 95 d9 fd ff
	ff		 mov	 BYTE PTR _StatusPlay$15[ebp+973], dl
$LN28@OnEventSen:

; 816  : 			}
; 817  : 
; 818  : 			//发送场景
; 819  : 			return m_pITableFrame->SendGameScene(pIServerUserItem, &StatusPlay, sizeof(StatusPlay));

  008dc	68 56 05 00 00	 push	 1366			; 00000556H
  008e1	8d 85 0c fa ff
	ff		 lea	 eax, DWORD PTR _StatusPlay$15[ebp]
  008e7	50		 push	 eax
  008e8	8b 4d 0c	 mov	 ecx, DWORD PTR _pIServerUserItem$[ebp]
  008eb	51		 push	 ecx
  008ec	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008f2	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  008f8	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008fe	8b 10		 mov	 edx, DWORD PTR [eax]
  00900	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00906	8b 82 04 01 00
	00		 mov	 eax, DWORD PTR [edx+260]
  0090c	ff d0		 call	 eax
  0090e	88 85 fb f9 ff
	ff		 mov	 BYTE PTR $T11[ebp], al
  00914	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0091b	8d 8d e8 f9 ff
	ff		 lea	 ecx, DWORD PTR _cc$7[ebp]
  00921	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00927	8a 85 fb f9 ff
	ff		 mov	 al, BYTE PTR $T11[ebp]
  0092d	eb 02		 jmp	 SHORT $LN1@OnEventSen
$LN2@OnEventSen:

; 820  : 		}
; 821  : 	}
; 822  : 
; 823  : 	//错误断言
; 824  : 	ASSERT(FALSE);
; 825  : 
; 826  : 	return false;

  0092f	32 c0		 xor	 al, al
$LN1@OnEventSen:

; 827  : }

  00931	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00934	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0093b	59		 pop	 ecx
  0093c	5e		 pop	 esi
  0093d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00940	33 cd		 xor	 ecx, ebp
  00942	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00947	8b e5		 mov	 esp, ebp
  00949	5d		 pop	 ebp
  0094a	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z$0:
  00000	8d 8d e8 f9 ff
	ff		 lea	 ecx, DWORD PTR _cc$7[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 8a c0 f9 ff
	ff		 mov	 ecx, DWORD PTR [edx-1600]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnEventSendGameScene@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E_N@Z ENDP ; CTableFrameSink::OnEventSendGameScene
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
$T2 = -1220						; size = 4
$T3 = -1216						; size = 4
$T4 = -1212						; size = 4
tv366 = -1208						; size = 4
tv860 = -1204						; size = 4
tv818 = -1200						; size = 4
tv65 = -1196						; size = 4
_cc$5 = -1192						; size = 4
_cbCardIndex$6 = -1185					; size = 1
_nCount$7 = -1184					; size = 4
_i$8 = -1180						; size = 4
_i$9 = -1176						; size = 4
$T10 = -1169						; size = 1
_i$11 = -1168						; size = 2
_i$12 = -1164						; size = 2
_i$13 = -1160						; size = 2
_this$ = -1156						; size = 4
_GameConclude$14 = -1152				; size = 472
_GameConclude$15 = -680					; size = 472
_ScoreInfoArray$16 = -208				; size = 160
_lUserGameScore$17 = -48				; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
_cbReason$ = 16						; size = 1
?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z PROC ; CTableFrameSink::OnEventGameConclude
; _this$ = ecx

; 507  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b8 04 00
	00		 sub	 esp, 1208		; 000004b8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 8d 7c fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 508  : 	switch (cbReason)

  00032	0f b6 45 10	 movzx	 eax, BYTE PTR _cbReason$[ebp]
  00036	89 85 54 fb ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0003c	83 bd 54 fb ff
	ff 03		 cmp	 DWORD PTR tv65[ebp], 3
  00043	0f 87 ad 0c 00
	00		 ja	 $LN2@OnEventGam
  00049	8b 8d 54 fb ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  0004f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN41@OnEventGam[ecx*4]
$LN19@OnEventGam:

; 509  : 	{
; 510  : 	case GER_NORMAL:		//常规结束
; 511  : 		{
; 512  : 			m_pITableFrame->KillGameTimer(IDI_OUT_CARD);

  00056	6a 03		 push	 3
  00058	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00064	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 10		 mov	 edx, DWORD PTR [eax]
  0006c	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00072	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00078	ff d0		 call	 eax

; 513  : 			m_pITableFrame->KillGameTimer(IDI_OPERATE_CARD);

  0007a	6a 04		 push	 4
  0007c	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00088	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b 12		 mov	 edx, DWORD PTR [edx]
  00090	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00096	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0009c	ff d0		 call	 eax

; 514  : 			//变量定义
; 515  : 			CMD_S_GameConclude GameConclude;
; 516  : 			ZeroMemory(&GameConclude, sizeof(GameConclude));

  0009e	68 d8 01 00 00	 push	 472			; 000001d8H
  000a3	6a 00		 push	 0
  000a5	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR _GameConclude$15[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 			GameConclude.cbSendCardData = m_cbSendCardData;

  000b4	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000ba	8a 82 3c 07 00
	00		 mov	 al, BYTE PTR [edx+1852]
  000c0	88 85 bf fd ff
	ff		 mov	 BYTE PTR _GameConclude$15[ebp+103], al

; 518  : 			GameConclude.wLeftUser = INVALID_CHAIR;			

  000c6	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  000cb	66 89 8d e0 fd
	ff ff		 mov	 WORD PTR _GameConclude$15[ebp+136], cx

; 519  : 
; 520  : 			//结束信息
; 521  : 			for (WORD i = 0; i < m_cbPlayerCount; i++)

  000d2	33 d2		 xor	 edx, edx
  000d4	66 89 95 74 fb
	ff ff		 mov	 WORD PTR _i$12[ebp], dx
  000db	eb 12		 jmp	 SHORT $LN6@OnEventGam
$LN4@OnEventGam:
  000dd	66 8b 85 74 fb
	ff ff		 mov	 ax, WORD PTR _i$12[ebp]
  000e4	66 83 c0 01	 add	 ax, 1
  000e8	66 89 85 74 fb
	ff ff		 mov	 WORD PTR _i$12[ebp], ax
$LN6@OnEventGam:
  000ef	0f b7 8d 74 fb
	ff ff		 movzx	 ecx, WORD PTR _i$12[ebp]
  000f6	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000fc	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  00100	3b c8		 cmp	 ecx, eax
  00102	0f 8d 2f 01 00
	00		 jge	 $LN5@OnEventGam

; 522  : 			{
; 523  : 				GameConclude.dwChiHuKind[i] = m_dwChiHuKind[i];

  00108	0f b7 8d 74 fb
	ff ff		 movzx	 ecx, WORD PTR _i$12[ebp]
  0010f	0f b7 95 74 fb
	ff ff		 movzx	 edx, WORD PTR _i$12[ebp]
  00116	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011c	8b 8c 88 1c 06
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+1564]
  00123	89 8c 95 c0 fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+edx*4+104], ecx

; 524  : 				//权位过滤
; 525  : 				if(m_dwChiHuKind[i] == WIK_CHI_HU)

  0012a	0f b7 95 74 fb
	ff ff		 movzx	 edx, WORD PTR _i$12[ebp]
  00131	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00137	83 bc 90 1c 06
	00 00 40	 cmp	 DWORD PTR [eax+edx*4+1564], 64 ; 00000040H
  0013f	75 52		 jne	 SHORT $LN20@OnEventGam

; 526  : 				{
; 527  : 					FiltrateRight(i, m_ChiHuRight[i]);

  00141	0f b7 8d 74 fb
	ff ff		 movzx	 ecx, WORD PTR _i$12[ebp]
  00148	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0014e	8d 84 8a 2c 06
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1580]
  00155	50		 push	 eax
  00156	0f b7 8d 74 fb
	ff ff		 movzx	 ecx, WORD PTR _i$12[ebp]
  0015d	51		 push	 ecx
  0015e	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00164	e8 00 00 00 00	 call	 ?FiltrateRight@CTableFrameSink@@IAEXGAAVCChiHuRight@@@Z ; CTableFrameSink::FiltrateRight

; 528  : 					m_ChiHuRight[i].GetRightData(GameConclude.dwChiHuRight[i], MAX_RIGHT_COUNT);

  00169	6a 01		 push	 1
  0016b	0f b7 95 74 fb
	ff ff		 movzx	 edx, WORD PTR _i$12[ebp]
  00172	8d 84 95 d0 fd
	ff ff		 lea	 eax, DWORD PTR _GameConclude$15[ebp+edx*4+120]
  00179	50		 push	 eax
  0017a	0f b7 8d 74 fb
	ff ff		 movzx	 ecx, WORD PTR _i$12[ebp]
  00181	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00187	8d 8c 8a 2c 06
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*4+1580]
  0018e	e8 00 00 00 00	 call	 ?GetRightData@CChiHuRight@@QAEEQAKE@Z ; CChiHuRight::GetRightData
$LN20@OnEventGam:

; 529  : 				}
; 530  : 				GameConclude.cbCardCount[i] = m_GameLogic.SwitchToCardData(m_cbCardIndex[i], GameConclude.cbHandCardData[i]);

  00193	0f b7 85 74 fb
	ff ff		 movzx	 eax, WORD PTR _i$12[ebp]
  0019a	6b c8 0e	 imul	 ecx, eax, 14
  0019d	8d 94 0d e8 fd
	ff ff		 lea	 edx, DWORD PTR _GameConclude$15[ebp+ecx+144]
  001a4	52		 push	 edx
  001a5	0f b7 85 74 fb
	ff ff		 movzx	 eax, WORD PTR _i$12[ebp]
  001ac	6b c8 22	 imul	 ecx, eax, 34
  001af	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001b5	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  001bc	50		 push	 eax
  001bd	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  001c9	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z ; CGameLogic::SwitchToCardData
  001ce	0f b7 8d 74 fb
	ff ff		 movzx	 ecx, WORD PTR _i$12[ebp]
  001d5	88 84 0d e4 fd
	ff ff		 mov	 BYTE PTR _GameConclude$15[ebp+ecx+140], al

; 531  : 
; 532  : 				GameConclude.cbWeaveItemCount[i] = m_cbWeaveItemCount[i];

  001dc	0f b7 95 74 fb
	ff ff		 movzx	 edx, WORD PTR _i$12[ebp]
  001e3	0f b7 85 74 fb
	ff ff		 movzx	 eax, WORD PTR _i$12[ebp]
  001ea	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001f0	8a 94 11 3e 08
	00 00		 mov	 dl, BYTE PTR [ecx+edx+2110]
  001f7	88 94 05 9c fe
	ff ff		 mov	 BYTE PTR _GameConclude$15[ebp+eax+324], dl

; 533  : 				memcpy(GameConclude.WeaveItemArray[i], m_WeaveItemArray[i], sizeof(GameConclude.WeaveItemArray[i]));

  001fe	6a 24		 push	 36			; 00000024H
  00200	0f b7 85 74 fb
	ff ff		 movzx	 eax, WORD PTR _i$12[ebp]
  00207	6b c8 24	 imul	 ecx, eax, 36
  0020a	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00210	8d 84 0a 42 08
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2114]
  00217	50		 push	 eax
  00218	0f b7 8d 74 fb
	ff ff		 movzx	 ecx, WORD PTR _i$12[ebp]
  0021f	6b d1 24	 imul	 edx, ecx, 36
  00222	8d 84 15 a0 fe
	ff ff		 lea	 eax, DWORD PTR _GameConclude$15[ebp+edx+328]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 _memcpy
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 534  : 			}

  00232	e9 a6 fe ff ff	 jmp	 $LN4@OnEventGam
$LN5@OnEventGam:

; 535  : 
; 536  : 			//计算胡牌输赢分
; 537  : 			SCORE lUserGameScore[GAME_PLAYER]={0};

  00237	0f 57 c0	 xorps	 xmm0, xmm0
  0023a	66 0f 13 45 d0	 movlpd	 QWORD PTR _lUserGameScore$17[ebp], xmm0
  0023f	33 c9		 xor	 ecx, ecx
  00241	89 4d d8	 mov	 DWORD PTR _lUserGameScore$17[ebp+8], ecx
  00244	89 4d dc	 mov	 DWORD PTR _lUserGameScore$17[ebp+12], ecx
  00247	89 4d e0	 mov	 DWORD PTR _lUserGameScore$17[ebp+16], ecx
  0024a	89 4d e4	 mov	 DWORD PTR _lUserGameScore$17[ebp+20], ecx
  0024d	89 4d e8	 mov	 DWORD PTR _lUserGameScore$17[ebp+24], ecx
  00250	89 4d ec	 mov	 DWORD PTR _lUserGameScore$17[ebp+28], ecx

; 538  : 			CalHuPaiScore(lUserGameScore);

  00253	8d 55 d0	 lea	 edx, DWORD PTR _lUserGameScore$17[ebp]
  00256	52		 push	 edx
  00257	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	e8 00 00 00 00	 call	 ?CalHuPaiScore@CTableFrameSink@@IAEXQA_J@Z ; CTableFrameSink::CalHuPaiScore

; 539  : 
; 540  : 			//拷贝码数据
; 541  : 			CopyMemory(GameConclude.cbMaCount,m_cbUserMaCount,sizeof(m_cbUserMaCount));

  00262	6a 04		 push	 4
  00264	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0026a	05 dc 05 00 00	 add	 eax, 1500		; 000005dcH
  0026f	50		 push	 eax
  00270	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _GameConclude$15[ebp+200]
  00276	51		 push	 ecx
  00277	e8 00 00 00 00	 call	 _memcpy
  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 542  : 			int nCount = m_cbMaCount;

  0027f	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00285	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  00289	89 85 60 fb ff
	ff		 mov	 DWORD PTR _nCount$7[ebp], eax

; 543  : 			if(nCount>1)

  0028f	83 bd 60 fb ff
	ff 01		 cmp	 DWORD PTR _nCount$7[ebp], 1
  00296	7e 0f		 jle	 SHORT $LN21@OnEventGam

; 544  : 				nCount++;

  00298	8b 8d 60 fb ff
	ff		 mov	 ecx, DWORD PTR _nCount$7[ebp]
  0029e	83 c1 01	 add	 ecx, 1
  002a1	89 8d 60 fb ff
	ff		 mov	 DWORD PTR _nCount$7[ebp], ecx
$LN21@OnEventGam:

; 545  : 
; 546  : 			for(int i=0;i<nCount;i++)

  002a7	c7 85 68 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$9[ebp], 0
  002b1	eb 0f		 jmp	 SHORT $LN9@OnEventGam
$LN7@OnEventGam:
  002b3	8b 95 68 fb ff
	ff		 mov	 edx, DWORD PTR _i$9[ebp]
  002b9	83 c2 01	 add	 edx, 1
  002bc	89 95 68 fb ff
	ff		 mov	 DWORD PTR _i$9[ebp], edx
$LN9@OnEventGam:
  002c2	8b 85 68 fb ff
	ff		 mov	 eax, DWORD PTR _i$9[ebp]
  002c8	3b 85 60 fb ff
	ff		 cmp	 eax, DWORD PTR _nCount$7[ebp]
  002ce	7d 36		 jge	 SHORT $LN8@OnEventGam

; 547  : 			{
; 548  : 				GameConclude.cbMaData[i] = m_cbRepertoryCard[MAX_REPERTORY - m_cbMinusHeadCount-i-1];

  002d0	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	0f b6 91 af 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1967]
  002dd	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  002e2	2b c2		 sub	 eax, edx
  002e4	2b 85 68 fb ff
	ff		 sub	 eax, DWORD PTR _i$9[ebp]
  002ea	8b 8d 68 fb ff
	ff		 mov	 ecx, DWORD PTR _i$9[ebp]
  002f0	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002f6	8a 84 02 3d 07
	00 00		 mov	 al, BYTE PTR [edx+eax+1853]
  002fd	88 84 0d 24 fe
	ff ff		 mov	 BYTE PTR _GameConclude$15[ebp+ecx+204], al

; 549  : 			}

  00304	eb ad		 jmp	 SHORT $LN7@OnEventGam
$LN8@OnEventGam:

; 550  : 
; 551  : 			GameConclude.cbLeftCardCount=m_cbLeftCardCount;

  00306	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0030c	8a 91 b1 07 00
	00		 mov	 dl, BYTE PTR [ecx+1969]
  00312	88 95 2b fe ff
	ff		 mov	 BYTE PTR _GameConclude$15[ebp+211], dl

; 552  : 
; 553  : 			for(int i=0;i<m_cbLeftCardCount;i++)

  00318	c7 85 64 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$8[ebp], 0
  00322	eb 0f		 jmp	 SHORT $LN12@OnEventGam
$LN10@OnEventGam:
  00324	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _i$8[ebp]
  0032a	83 c0 01	 add	 eax, 1
  0032d	89 85 64 fb ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
$LN12@OnEventGam:
  00333	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	0f b6 91 b1 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1969]
  00340	39 95 64 fb ff
	ff		 cmp	 DWORD PTR _i$8[ebp], edx
  00346	7d 36		 jge	 SHORT $LN11@OnEventGam

; 554  : 				GameConclude.cbLeftCardData[i]=m_cbRepertoryCard[MAX_REPERTORY-m_cbMinusHeadCount-i-1];

  00348	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0034e	0f b6 88 af 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1967]
  00355	ba 70 00 00 00	 mov	 edx, 112		; 00000070H
  0035a	2b d1		 sub	 edx, ecx
  0035c	2b 95 64 fb ff
	ff		 sub	 edx, DWORD PTR _i$8[ebp]
  00362	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _i$8[ebp]
  00368	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0036e	8a 94 11 3d 07
	00 00		 mov	 dl, BYTE PTR [ecx+edx+1853]
  00375	88 94 05 2c fe
	ff ff		 mov	 BYTE PTR _GameConclude$15[ebp+eax+212], dl
  0037c	eb a6		 jmp	 SHORT $LN10@OnEventGam
$LN11@OnEventGam:

; 555  : 
; 556  : 			//积分变量
; 557  : 			tagScoreInfo ScoreInfoArray[GAME_PLAYER];
; 558  : 			ZeroMemory(&ScoreInfoArray, sizeof(ScoreInfoArray));

  0037e	68 a0 00 00 00	 push	 160			; 000000a0H
  00383	6a 00		 push	 0
  00385	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _ScoreInfoArray$16[ebp]
  0038b	50		 push	 eax
  0038c	e8 00 00 00 00	 call	 _memset
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH

; 559  : 
; 560  : 			GameConclude.wProvideUser = m_wProvideUser;

  00394	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0039a	66 8b 91 c0 04
	00 00		 mov	 dx, WORD PTR [ecx+1216]
  003a1	66 89 95 bc fd
	ff ff		 mov	 WORD PTR _GameConclude$15[ebp+100], dx

; 561  : 			GameConclude.cbProvideCard = m_cbProvideCard;

  003a8	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003ae	8a 88 c2 04 00
	00		 mov	 cl, BYTE PTR [eax+1218]
  003b4	88 8d be fd ff
	ff		 mov	 BYTE PTR _GameConclude$15[ebp+102], cl

; 562  : 
; 563  : 			//统计积分
; 564  : 			for (WORD i = 0; i < m_cbPlayerCount; i++)

  003ba	33 d2		 xor	 edx, edx
  003bc	66 89 95 78 fb
	ff ff		 mov	 WORD PTR _i$13[ebp], dx
  003c3	eb 12		 jmp	 SHORT $LN15@OnEventGam
$LN13@OnEventGam:
  003c5	66 8b 85 78 fb
	ff ff		 mov	 ax, WORD PTR _i$13[ebp]
  003cc	66 83 c0 01	 add	 ax, 1
  003d0	66 89 85 78 fb
	ff ff		 mov	 WORD PTR _i$13[ebp], ax
$LN15@OnEventGam:
  003d7	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  003de	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003e4	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  003e8	3b c8		 cmp	 ecx, eax
  003ea	0f 8d d6 03 00
	00		 jge	 $LN14@OnEventGam

; 565  : 			{
; 566  : 				if(!m_bPlayStatus[i])

  003f0	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  003f7	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003fd	0f b6 84 0a 7d
	04 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1149]
  00405	85 c0		 test	 eax, eax
  00407	75 02		 jne	 SHORT $LN22@OnEventGam

; 567  : 					continue;

  00409	eb ba		 jmp	 SHORT $LN13@OnEventGam
$LN22@OnEventGam:

; 568  : 
; 569  : 				GameConclude.lGameScore[i] = lUserGameScore[i];

  0040b	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00412	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  00419	8b 44 cd d0	 mov	 eax, DWORD PTR _lUserGameScore$17[ebp+ecx*8]
  0041d	89 84 d5 5c fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+edx*8+4], eax
  00424	8b 4c cd d4	 mov	 ecx, DWORD PTR _lUserGameScore$17[ebp+ecx*8+4]
  00428	89 8c d5 60 fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+edx*8+8], ecx

; 570  : 				//胡牌分算完后再加上杠的输赢分就是玩家本轮最终输赢分
; 571  : 				GameConclude.lGameScore[i] += m_lUserGangScore[i];

  0042f	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  00436	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  0043d	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00443	8b b4 d5 5c fd
	ff ff		 mov	 esi, DWORD PTR _GameConclude$15[ebp+edx*8+4]
  0044a	03 b4 c1 f8 05
	00 00		 add	 esi, DWORD PTR [ecx+eax*8+1528]
  00451	8b 94 d5 60 fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$15[ebp+edx*8+8]
  00458	13 94 c1 fc 05
	00 00		 adc	 edx, DWORD PTR [ecx+eax*8+1532]
  0045f	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  00466	89 b4 c5 5c fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+eax*8+4], esi
  0046d	89 94 c5 60 fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+eax*8+8], edx

; 572  : 				GameConclude.lGangScore[i] = m_lUserGangScore[i];

  00474	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  0047b	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  00482	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00488	8b b4 c8 f8 05
	00 00		 mov	 esi, DWORD PTR [eax+ecx*8+1528]
  0048f	89 b4 d5 9c fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+edx*8+68], esi
  00496	8b 8c c8 fc 05
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*8+1532]
  0049d	89 8c d5 a0 fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+edx*8+72], ecx

; 573  : 
; 574  : 				//收税
; 575  : 				if (GameConclude.lGameScore[i]>0 && ((m_pGameServiceOption->wServerType&GAME_GENRE_PERSONAL)==0 || m_pITableFrame->GetDataBaseMode()==1))

  004a4	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  004ab	89 95 50 fb ff
	ff		 mov	 DWORD PTR tv818[ebp], edx
  004b1	8b 85 50 fb ff
	ff		 mov	 eax, DWORD PTR tv818[ebp]
  004b7	83 bc c5 60 fd
	ff ff 00	 cmp	 DWORD PTR _GameConclude$15[ebp+eax*8+8], 0
  004bf	0f 8c ee 00 00
	00		 jl	 $LN23@OnEventGam
  004c5	7f 14		 jg	 SHORT $LN38@OnEventGam
  004c7	8b 8d 50 fb ff
	ff		 mov	 ecx, DWORD PTR tv818[ebp]
  004cd	83 bc cd 5c fd
	ff ff 00	 cmp	 DWORD PTR _GameConclude$15[ebp+ecx*8+4], 0
  004d5	0f 86 d8 00 00
	00		 jbe	 $LN23@OnEventGam
$LN38@OnEventGam:
  004db	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004e1	8b 82 30 09 00
	00		 mov	 eax, DWORD PTR [edx+2352]
  004e7	0f b7 48 54	 movzx	 ecx, WORD PTR [eax+84]
  004eb	83 e1 10	 and	 ecx, 16			; 00000010H
  004ee	74 2e		 je	 SHORT $LN24@OnEventGam
  004f0	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004f6	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  004fc	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00502	8b 10		 mov	 edx, DWORD PTR [eax]
  00504	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  0050a	8b 82 34 01 00
	00		 mov	 eax, DWORD PTR [edx+308]
  00510	ff d0		 call	 eax
  00512	0f b6 c8	 movzx	 ecx, al
  00515	83 f9 01	 cmp	 ecx, 1
  00518	0f 85 95 00 00
	00		 jne	 $LN23@OnEventGam
$LN24@OnEventGam:

; 576  : 				{
; 577  : 					GameConclude.lRevenue[i] = m_pITableFrame->CalculateRevenue(i,GameConclude.lGameScore[i]);

  0051e	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  00525	8b 84 d5 60 fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$15[ebp+edx*8+8]
  0052c	50		 push	 eax
  0052d	8b 8c d5 5c fd
	ff ff		 mov	 ecx, DWORD PTR _GameConclude$15[ebp+edx*8+4]
  00534	51		 push	 ecx
  00535	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  0053c	52		 push	 edx
  0053d	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00543	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00549	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0054f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00551	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00557	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0055d	ff d2		 call	 edx
  0055f	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00566	89 84 cd 7c fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+ecx*8+36], eax
  0056d	89 94 cd 80 fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+ecx*8+40], edx

; 578  : 					GameConclude.lGameScore[i] -= GameConclude.lRevenue[i];

  00574	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  0057b	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  00582	8b 8c d5 5c fd
	ff ff		 mov	 ecx, DWORD PTR _GameConclude$15[ebp+edx*8+4]
  00589	2b 8c c5 7c fd
	ff ff		 sub	 ecx, DWORD PTR _GameConclude$15[ebp+eax*8+36]
  00590	8b 94 d5 60 fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$15[ebp+edx*8+8]
  00597	1b 94 c5 80 fd
	ff ff		 sbb	 edx, DWORD PTR _GameConclude$15[ebp+eax*8+40]
  0059e	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  005a5	89 8c c5 5c fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+eax*8+4], ecx
  005ac	89 94 c5 60 fd
	ff ff		 mov	 DWORD PTR _GameConclude$15[ebp+eax*8+8], edx
$LN23@OnEventGam:

; 579  : 				}
; 580  : 
; 581  : 				ScoreInfoArray[i].lRevenue = GameConclude.lRevenue[i];

  005b3	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  005ba	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  005c1	6b c2 28	 imul	 eax, edx, 40
  005c4	8b 94 cd 7c fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$15[ebp+ecx*8+36]
  005cb	89 94 05 48 ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$16[ebp+eax+24], edx
  005d2	8b 8c cd 80 fd
	ff ff		 mov	 ecx, DWORD PTR _GameConclude$15[ebp+ecx*8+40]
  005d9	89 8c 05 4c ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$16[ebp+eax+28], ecx

; 582  : 				ScoreInfoArray[i].lScore = GameConclude.lGameScore[i];

  005e0	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  005e7	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  005ee	6b c8 28	 imul	 ecx, eax, 40
  005f1	8b 84 d5 5c fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$15[ebp+edx*8+4]
  005f8	89 84 0d 38 ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$16[ebp+ecx+8], eax
  005ff	8b 94 d5 60 fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$15[ebp+edx*8+8]
  00606	89 94 0d 3c ff
	ff ff		 mov	 DWORD PTR _ScoreInfoArray$16[ebp+ecx+12], edx

; 583  : 				ScoreInfoArray[i].cbType = ScoreInfoArray[i].lScore > 0 ? SCORE_TYPE_WIN : SCORE_TYPE_LOSE;

  0060d	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  00614	6b c8 28	 imul	 ecx, eax, 40
  00617	89 8d 4c fb ff
	ff		 mov	 DWORD PTR tv860[ebp], ecx
  0061d	8b 95 4c fb ff
	ff		 mov	 edx, DWORD PTR tv860[ebp]
  00623	83 bc 15 3c ff
	ff ff 00	 cmp	 DWORD PTR _ScoreInfoArray$16[ebp+edx+12], 0
  0062b	7c 1e		 jl	 SHORT $LN35@OnEventGam
  0062d	7f 10		 jg	 SHORT $LN39@OnEventGam
  0062f	8b 85 4c fb ff
	ff		 mov	 eax, DWORD PTR tv860[ebp]
  00635	83 bc 05 38 ff
	ff ff 00	 cmp	 DWORD PTR _ScoreInfoArray$16[ebp+eax+8], 0
  0063d	76 0c		 jbe	 SHORT $LN35@OnEventGam
$LN39@OnEventGam:
  0063f	c7 85 48 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv366[ebp], 1
  00649	eb 0a		 jmp	 SHORT $LN36@OnEventGam
$LN35@OnEventGam:
  0064b	c7 85 48 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR tv366[ebp], 2
$LN36@OnEventGam:
  00655	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  0065c	6b d1 28	 imul	 edx, ecx, 40
  0065f	8a 85 48 fb ff
	ff		 mov	 al, BYTE PTR tv366[ebp]
  00665	88 84 15 30 ff
	ff ff		 mov	 BYTE PTR _ScoreInfoArray$16[ebp+edx], al

; 584  : 
; 585  : 				//历史积分
; 586  : 				m_HistoryScore.OnEventUserScore(i, GameConclude.lGameScore[i]);

  0066c	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00673	8b 94 cd 60 fd
	ff ff		 mov	 edx, DWORD PTR _GameConclude$15[ebp+ecx*8+8]
  0067a	52		 push	 edx
  0067b	8b 84 cd 5c fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$15[ebp+ecx*8+4]
  00682	50		 push	 eax
  00683	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  0068a	51		 push	 ecx
  0068b	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00691	81 c1 e0 08 00
	00		 add	 ecx, 2272		; 000008e0H
  00697	e8 00 00 00 00	 call	 ?OnEventUserScore@CHistoryScore@@QAEXG_J@Z ; CHistoryScore::OnEventUserScore

; 587  : 				if(m_stRecord.nCount<32)

  0069c	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006a2	83 7a 0a 20	 cmp	 DWORD PTR [edx+10], 32	; 00000020H
  006a6	7d 78		 jge	 SHORT $LN25@OnEventGam

; 588  : 				{
; 589  : 					m_stRecord.lDetailScore[i][m_stRecord.nCount]=GameConclude.lGameScore[i];

  006a8	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  006af	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  006b6	c1 e1 08	 shl	 ecx, 8
  006b9	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006bf	8d 4c 0a 3e	 lea	 ecx, DWORD PTR [edx+ecx+62]
  006c3	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006c9	8b 52 0a	 mov	 edx, DWORD PTR [edx+10]
  006cc	8b b4 c5 5c fd
	ff ff		 mov	 esi, DWORD PTR _GameConclude$15[ebp+eax*8+4]
  006d3	89 34 d1	 mov	 DWORD PTR [ecx+edx*8], esi
  006d6	8b 84 c5 60 fd
	ff ff		 mov	 eax, DWORD PTR _GameConclude$15[ebp+eax*8+8]
  006dd	89 44 d1 04	 mov	 DWORD PTR [ecx+edx*8+4], eax

; 590  : 					m_stRecord.lAllScore[i] += GameConclude.lGameScore[i];

  006e1	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  006e8	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  006ef	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006f5	8b 74 c8 1e	 mov	 esi, DWORD PTR [eax+ecx*8+30]
  006f9	03 b4 d5 5c fd
	ff ff		 add	 esi, DWORD PTR _GameConclude$15[ebp+edx*8+4]
  00700	8b 4c c8 22	 mov	 ecx, DWORD PTR [eax+ecx*8+34]
  00704	13 8c d5 60 fd
	ff ff		 adc	 ecx, DWORD PTR _GameConclude$15[ebp+edx*8+8]
  0070b	0f b7 95 78 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  00712	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00718	89 74 d0 1e	 mov	 DWORD PTR [eax+edx*8+30], esi
  0071c	89 4c d0 22	 mov	 DWORD PTR [eax+edx*8+34], ecx
$LN25@OnEventGam:

; 591  : 				}
; 592  : 				m_vecRecord[i].push_back(GameConclude.lGameScore[i]);

  00720	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00727	8d 94 cd 5c fd
	ff ff		 lea	 edx, DWORD PTR _GameConclude$15[ebp+ecx*8+4]
  0072e	52		 push	 edx
  0072f	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  00736	6b c8 0c	 imul	 ecx, eax, 12
  00739	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0073f	8d 8c 0a 40 04
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1088]
  00746	e8 00 00 00 00	 call	 ?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QAEXAB_J@Z ; std::vector<__int64,std::allocator<__int64> >::push_back

; 593  : 				if (m_vecRecord[i].size()>30)

  0074b	0f b7 85 78 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  00752	6b c8 0c	 imul	 ecx, eax, 12
  00755	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0075b	8d 8c 0a 40 04
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1088]
  00762	e8 00 00 00 00	 call	 ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
  00767	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0076a	76 55		 jbe	 SHORT $LN26@OnEventGam

; 594  : 					m_vecRecord[i].erase(m_vecRecord[i].begin());

  0076c	8d 85 40 fb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00772	50		 push	 eax
  00773	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  0077a	6b d1 0c	 imul	 edx, ecx, 12
  0077d	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00783	8d 8c 10 40 04
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1088]
  0078a	e8 00 00 00 00	 call	 ?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ ; std::vector<__int64,std::allocator<__int64> >::begin
  0078f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00791	89 8d 44 fb ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  00797	8b 95 44 fb ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  0079d	52		 push	 edx
  0079e	8d 85 3c fb ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  007a4	50		 push	 eax
  007a5	0f b7 8d 78 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  007ac	6b d1 0c	 imul	 edx, ecx, 12
  007af	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007b5	8d 8c 10 40 04
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1088]
  007bc	e8 00 00 00 00	 call	 ?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z ; std::vector<__int64,std::allocator<__int64> >::erase
$LN26@OnEventGam:

; 595  : 			}

  007c1	e9 ff fb ff ff	 jmp	 $LN13@OnEventGam
$LN14@OnEventGam:

; 596  : 			m_stRecord.nCount++;

  007c6	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007cc	8b 51 0a	 mov	 edx, DWORD PTR [ecx+10]
  007cf	83 c2 01	 add	 edx, 1
  007d2	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007d8	89 50 0a	 mov	 DWORD PTR [eax+10], edx

; 597  : 			if (IsRoomCardScoreType())

  007db	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007e1	e8 00 00 00 00	 call	 ?IsRoomCardScoreType@CTableFrameSink@@IAE_NXZ ; CTableFrameSink::IsRoomCardScoreType
  007e6	0f b6 c8	 movzx	 ecx, al
  007e9	85 c9		 test	 ecx, ecx
  007eb	74 3d		 je	 SHORT $LN27@OnEventGam

; 598  : 				m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_RECORD, &m_stRecord, sizeof(m_stRecord));

  007ed	68 c8 00 00 00	 push	 200			; 000000c8H
  007f2	68 34 04 00 00	 push	 1076			; 00000434H
  007f7	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007fd	83 c2 0a	 add	 edx, 10			; 0000000aH
  00800	52		 push	 edx
  00801	6a 6f		 push	 111			; 0000006fH
  00803	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00808	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0080e	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00814	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0081a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0081c	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00822	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00828	ff d2		 call	 edx
$LN27@OnEventGam:

; 599  : 			//发送数据
; 600  : 			m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_GAME_CONCLUDE, &GameConclude, sizeof(GameConclude));

  0082a	68 c8 00 00 00	 push	 200			; 000000c8H
  0082f	68 d8 01 00 00	 push	 472			; 000001d8H
  00834	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _GameConclude$15[ebp]
  0083a	50		 push	 eax
  0083b	6a 6c		 push	 108			; 0000006cH
  0083d	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00842	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00848	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  0084e	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00854	8b 12		 mov	 edx, DWORD PTR [edx]
  00856	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  0085c	8b 82 ac 00 00
	00		 mov	 eax, DWORD PTR [edx+172]
  00862	ff d0		 call	 eax

; 601  : 			m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_GAME_CONCLUDE, &GameConclude, sizeof(GameConclude));

  00864	68 d8 01 00 00	 push	 472			; 000001d8H
  00869	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR _GameConclude$15[ebp]
  0086f	51		 push	 ecx
  00870	6a 6c		 push	 108			; 0000006cH
  00872	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00877	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0087d	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00883	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00889	8b 10		 mov	 edx, DWORD PTR [eax]
  0088b	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00891	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  00897	ff d0		 call	 eax

; 602  : 
; 603  : 			if (m_pGameVideo)

  00899	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0089f	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  008a6	0f 84 95 00 00
	00		 je	 $LN28@OnEventGam

; 604  : 			{
; 605  : 				m_pGameVideo->AddVideoData(SUB_S_GAME_CONCLUDE,&GameConclude,sizeof(GameConclude),true);

  008ac	6a 01		 push	 1
  008ae	68 d8 01 00 00	 push	 472			; 000001d8H
  008b3	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR _GameConclude$15[ebp]
  008b9	52		 push	 edx
  008ba	6a 6c		 push	 108			; 0000006cH
  008bc	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008c2	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  008c8	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008ce	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  008d4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  008d6	50		 push	 eax
  008d7	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  008da	ff d2		 call	 edx
  008dc	83 c4 14	 add	 esp, 20			; 00000014H

; 606  : 				m_pGameVideo->StopAndSaveVideo(m_pGameServiceOption->wServerID,m_pITableFrame->GetTableID(),m_cbPlayerCount);

  008df	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008e5	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  008e9	51		 push	 ecx
  008ea	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008f0	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  008f6	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008fc	8b 10		 mov	 edx, DWORD PTR [eax]
  008fe	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00904	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00907	ff d0		 call	 eax
  00909	0f b7 c8	 movzx	 ecx, ax
  0090c	51		 push	 ecx
  0090d	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00913	8b 82 30 09 00
	00		 mov	 eax, DWORD PTR [edx+2352]
  00919	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  0091d	51		 push	 ecx
  0091e	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00924	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  0092a	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00930	8b 91 40 06 00
	00		 mov	 edx, DWORD PTR [ecx+1600]
  00936	8b 00		 mov	 eax, DWORD PTR [eax]
  00938	52		 push	 edx
  00939	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0093c	ff d1		 call	 ecx
  0093e	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@OnEventGam:

; 607  : 			}
; 608  : 			//写入积分
; 609  : 			m_pITableFrame->WriteTableScore(ScoreInfoArray, m_cbPlayerCount);

  00941	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00947	66 0f b6 42 09	 movzx	 ax, BYTE PTR [edx+9]
  0094c	0f b7 c8	 movzx	 ecx, ax
  0094f	51		 push	 ecx
  00950	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _ScoreInfoArray$16[ebp]
  00956	52		 push	 edx
  00957	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0095d	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00963	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00969	8b 01		 mov	 eax, DWORD PTR [ecx]
  0096b	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00971	8b 90 84 00 00
	00		 mov	 edx, DWORD PTR [eax+132]
  00977	ff d2		 call	 edx

; 610  : 
; 611  : 			//结束游戏
; 612  : 			m_pITableFrame->ConcludeGame(GAME_SCENE_FREE);

  00979	6a 00		 push	 0
  0097b	6a 00		 push	 0
  0097d	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00983	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00989	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0098f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00991	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00997	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  0099a	ff d2		 call	 edx

; 613  : 			m_pITableFrame->SetGameStatus(GAME_STATUS_FREE);

  0099c	6a 00		 push	 0
  0099e	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009a4	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  009aa	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  009b0	8b 01		 mov	 eax, DWORD PTR [ecx]
  009b2	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  009b8	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  009bb	ff d2		 call	 edx

; 614  : 			
; 615  : 			return true;

  009bd	b0 01		 mov	 al, 1
  009bf	e9 34 03 00 00	 jmp	 $LN1@OnEventGam
$LN29@OnEventGam:

; 616  : 		}
; 617  : 	case GER_NETWORK_ERROR:	//网络中断
; 618  : 	case GER_USER_LEAVE:	//用户强退
; 619  : 		{
; 620  : 			CString cc;

  009c4	8d 8d 58 fb ff
	ff		 lea	 ecx, DWORD PTR _cc$5[ebp]
  009ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  009d0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 621  : 			cc.Format(_T("玩家强退:wchair=%d,cbreson=%d"), wChairID, cbReason);

  009d7	0f b6 45 10	 movzx	 eax, BYTE PTR _cbReason$[ebp]
  009db	50		 push	 eax
  009dc	0f b7 4d 08	 movzx	 ecx, WORD PTR _wChairID$[ebp]
  009e0	51		 push	 ecx
  009e1	68 00 00 00 00	 push	 OFFSET $SG313676
  009e6	8d 95 58 fb ff
	ff		 lea	 edx, DWORD PTR _cc$5[ebp]
  009ec	52		 push	 edx
  009ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  009f3	83 c4 10	 add	 esp, 16			; 00000010H

; 622  : 			WriteDebugInfo(cc);

  009f6	8d 8d 58 fb ff
	ff		 lea	 ecx, DWORD PTR _cc$5[ebp]
  009fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00a02	50		 push	 eax
  00a03	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a09	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 623  : 			return true;

  00a0e	c6 85 6f fb ff
	ff 01		 mov	 BYTE PTR $T10[ebp], 1
  00a15	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a1c	8d 8d 58 fb ff
	ff		 lea	 ecx, DWORD PTR _cc$5[ebp]
  00a22	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  00a28	8a 85 6f fb ff
	ff		 mov	 al, BYTE PTR $T10[ebp]
  00a2e	e9 c5 02 00 00	 jmp	 $LN1@OnEventGam
$LN30@OnEventGam:

; 624  : 		}
; 625  : 	case GER_DISMISS:		//游戏解散
; 626  : 		{
; 627  : 			WriteDebugInfo(_T("解散"));

  00a33	68 00 00 00 00	 push	 OFFSET $SG313679
  00a38	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a3e	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 628  : 			m_pITableFrame->KillGameTimer(IDI_OUT_CARD);

  00a43	6a 03		 push	 3
  00a45	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a4b	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00a51	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00a57	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a59	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00a5f	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00a65	ff d2		 call	 edx

; 629  : 			m_pITableFrame->KillGameTimer(IDI_OPERATE_CARD);

  00a67	6a 04		 push	 4
  00a69	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a6f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00a75	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00a7b	8b 01		 mov	 eax, DWORD PTR [ecx]
  00a7d	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00a83	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00a89	ff d2		 call	 edx

; 630  : 			//变量定义
; 631  : 			CMD_S_GameConclude GameConclude;
; 632  : 			ZeroMemory(&GameConclude, sizeof(GameConclude));

  00a8b	68 d8 01 00 00	 push	 472			; 000001d8H
  00a90	6a 00		 push	 0
  00a92	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _GameConclude$14[ebp]
  00a98	50		 push	 eax
  00a99	e8 00 00 00 00	 call	 _memset
  00a9e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 633  : 
; 634  : 			m_wBankerUser = INVALID_CHAIR;

  00aa1	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00aa6	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00aac	66 89 8a 72 04
	00 00		 mov	 WORD PTR [edx+1138], cx

; 635  : 
; 636  : 			GameConclude.cbSendCardData = m_cbSendCardData;

  00ab3	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ab9	8a 88 3c 07 00
	00		 mov	 cl, BYTE PTR [eax+1852]
  00abf	88 8d e7 fb ff
	ff		 mov	 BYTE PTR _GameConclude$14[ebp+103], cl

; 637  : 
; 638  : 			//用户扑克
; 639  : 			BYTE cbCardIndex=0;

  00ac5	c6 85 5f fb ff
	ff 00		 mov	 BYTE PTR _cbCardIndex$6[ebp], 0

; 640  : 			for (WORD i = 0; i < GAME_PLAYER; i++)

  00acc	33 d2		 xor	 edx, edx
  00ace	66 89 95 70 fb
	ff ff		 mov	 WORD PTR _i$11[ebp], dx
  00ad5	eb 12		 jmp	 SHORT $LN18@OnEventGam
$LN16@OnEventGam:
  00ad7	66 8b 85 70 fb
	ff ff		 mov	 ax, WORD PTR _i$11[ebp]
  00ade	66 83 c0 01	 add	 ax, 1
  00ae2	66 89 85 70 fb
	ff ff		 mov	 WORD PTR _i$11[ebp], ax
$LN18@OnEventGam:
  00ae9	0f b7 8d 70 fb
	ff ff		 movzx	 ecx, WORD PTR _i$11[ebp]
  00af0	83 f9 04	 cmp	 ecx, 4
  00af3	7d 4b		 jge	 SHORT $LN17@OnEventGam

; 641  : 			{
; 642  : 				GameConclude.cbCardCount[i] = m_GameLogic.SwitchToCardData(m_cbCardIndex[i], GameConclude.cbHandCardData[i]);

  00af5	0f b7 95 70 fb
	ff ff		 movzx	 edx, WORD PTR _i$11[ebp]
  00afc	6b c2 0e	 imul	 eax, edx, 14
  00aff	8d 8c 05 10 fc
	ff ff		 lea	 ecx, DWORD PTR _GameConclude$14[ebp+eax+144]
  00b06	51		 push	 ecx
  00b07	0f b7 95 70 fb
	ff ff		 movzx	 edx, WORD PTR _i$11[ebp]
  00b0e	6b c2 22	 imul	 eax, edx, 34
  00b11	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b17	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00b1e	52		 push	 edx
  00b1f	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b25	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00b2b	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z ; CGameLogic::SwitchToCardData
  00b30	0f b7 8d 70 fb
	ff ff		 movzx	 ecx, WORD PTR _i$11[ebp]
  00b37	88 84 0d 0c fc
	ff ff		 mov	 BYTE PTR _GameConclude$14[ebp+ecx+140], al

; 643  : 			}

  00b3e	eb 97		 jmp	 SHORT $LN16@OnEventGam
$LN17@OnEventGam:

; 644  : 
; 645  : 			//发送信息
; 646  : 			m_pITableFrame->SendTableData(INVALID_CHAIR, SUB_S_GAME_CONCLUDE, &GameConclude, sizeof(GameConclude));

  00b40	68 c8 00 00 00	 push	 200			; 000000c8H
  00b45	68 d8 01 00 00	 push	 472			; 000001d8H
  00b4a	8d 95 80 fb ff
	ff		 lea	 edx, DWORD PTR _GameConclude$14[ebp]
  00b50	52		 push	 edx
  00b51	6a 6c		 push	 108			; 0000006cH
  00b53	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00b58	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b5e	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00b64	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00b6a	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b6c	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00b72	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00b78	ff d2		 call	 edx

; 647  : 			m_pITableFrame->SendLookonData(INVALID_CHAIR, SUB_S_GAME_CONCLUDE, &GameConclude, sizeof(GameConclude));

  00b7a	68 d8 01 00 00	 push	 472			; 000001d8H
  00b7f	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR _GameConclude$14[ebp]
  00b85	50		 push	 eax
  00b86	6a 6c		 push	 108			; 0000006cH
  00b88	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00b8d	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b93	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00b99	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b9f	8b 12		 mov	 edx, DWORD PTR [edx]
  00ba1	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00ba7	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  00bad	ff d0		 call	 eax

; 648  : 
; 649  : 			if (m_pGameVideo)

  00baf	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00bb5	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  00bbc	0f 84 95 00 00
	00		 je	 $LN31@OnEventGam

; 650  : 			{
; 651  : 				m_pGameVideo->AddVideoData(SUB_S_GAME_CONCLUDE,&GameConclude,sizeof(GameConclude),true);

  00bc2	6a 01		 push	 1
  00bc4	68 d8 01 00 00	 push	 472			; 000001d8H
  00bc9	8d 95 80 fb ff
	ff		 lea	 edx, DWORD PTR _GameConclude$14[ebp]
  00bcf	52		 push	 edx
  00bd0	6a 6c		 push	 108			; 0000006cH
  00bd2	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00bd8	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  00bde	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00be4	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00bea	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00bec	50		 push	 eax
  00bed	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00bf0	ff d2		 call	 edx
  00bf2	83 c4 14	 add	 esp, 20			; 00000014H

; 652  : 				m_pGameVideo->StopAndSaveVideo(m_pGameServiceOption->wServerID,m_pITableFrame->GetTableID(),m_cbPlayerCount);

  00bf5	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00bfb	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00bff	51		 push	 ecx
  00c00	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c06	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00c0c	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c12	8b 10		 mov	 edx, DWORD PTR [eax]
  00c14	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00c1a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c1d	ff d0		 call	 eax
  00c1f	0f b7 c8	 movzx	 ecx, ax
  00c22	51		 push	 ecx
  00c23	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c29	8b 82 30 09 00
	00		 mov	 eax, DWORD PTR [edx+2352]
  00c2f	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00c33	51		 push	 ecx
  00c34	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c3a	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00c40	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c46	8b 91 40 06 00
	00		 mov	 edx, DWORD PTR [ecx+1600]
  00c4c	8b 00		 mov	 eax, DWORD PTR [eax]
  00c4e	52		 push	 edx
  00c4f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c52	ff d1		 call	 ecx
  00c54	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@OnEventGam:

; 653  : 			}
; 654  : 			//结束游戏
; 655  : 			m_pITableFrame->ConcludeGame(GAME_SCENE_FREE);

  00c57	6a 00		 push	 0
  00c59	6a 00		 push	 0
  00c5b	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c61	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00c67	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c6d	8b 10		 mov	 edx, DWORD PTR [eax]
  00c6f	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00c75	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00c78	ff d0		 call	 eax

; 656  : 			m_pITableFrame->SetGameStatus(GAME_STATUS_FREE);

  00c7a	6a 00		 push	 0
  00c7c	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c82	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00c88	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c8e	8b 12		 mov	 edx, DWORD PTR [edx]
  00c90	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00c96	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00c99	ff d0		 call	 eax

; 657  : 			if( (m_pGameServiceOption->wServerType&GAME_GENRE_PERSONAL) !=0 )//房卡模式

  00c9b	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ca1	8b 91 30 09 00
	00		 mov	 edx, DWORD PTR [ecx+2352]
  00ca7	0f b7 42 54	 movzx	 eax, WORD PTR [edx+84]
  00cab	83 e0 10	 and	 eax, 16			; 00000010H
  00cae	74 42		 je	 SHORT $LN32@OnEventGam

; 658  : 			{
; 659  : 				if(m_pITableFrame->IsPersonalRoomDisumme() )//当前朋友局解散清理记录

  00cb0	8b 8d 7c fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cb6	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00cbc	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00cc2	8b 12		 mov	 edx, DWORD PTR [edx]
  00cc4	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00cca	8b 82 2c 01 00
	00		 mov	 eax, DWORD PTR [edx+300]
  00cd0	ff d0		 call	 eax
  00cd2	0f b6 c8	 movzx	 ecx, al
  00cd5	85 c9		 test	 ecx, ecx
  00cd7	74 19		 je	 SHORT $LN32@OnEventGam

; 660  : 				{
; 661  : 					ZeroMemory(&m_stRecord,sizeof(m_stRecord));

  00cd9	68 34 04 00 00	 push	 1076			; 00000434H
  00cde	6a 00		 push	 0
  00ce0	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ce6	83 c2 0a	 add	 edx, 10			; 0000000aH
  00ce9	52		 push	 edx
  00cea	e8 00 00 00 00	 call	 _memset
  00cef	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@OnEventGam:

; 662  : 				}
; 663  : 			}
; 664  : 			
; 665  : 			return true;

  00cf2	b0 01		 mov	 al, 1
  00cf4	eb 02		 jmp	 SHORT $LN1@OnEventGam
$LN2@OnEventGam:

; 666  : 		}
; 667  : 	}
; 668  : 
; 669  : 	//错误断言
; 670  : 	ASSERT(FALSE);
; 671  : 
; 672  : 	return false;

  00cf6	32 c0		 xor	 al, al
$LN1@OnEventGam:

; 673  : }

  00cf8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cfb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00d02	59		 pop	 ecx
  00d03	5e		 pop	 esi
  00d04	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d07	33 cd		 xor	 ecx, ebp
  00d09	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d0e	8b e5		 mov	 esp, ebp
  00d10	5d		 pop	 ebp
  00d11	c2 0c 00	 ret	 12			; 0000000cH
$LN41@OnEventGam:
  00d14	00 00 00 00	 DD	 $LN19@OnEventGam
  00d18	00 00 00 00	 DD	 $LN30@OnEventGam
  00d1c	00 00 00 00	 DD	 $LN29@OnEventGam
  00d20	00 00 00 00	 DD	 $LN29@OnEventGam
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z$0:
  00000	8d 8d 58 fb ff
	ff		 lea	 ecx, DWORD PTR _cc$5[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 8a 40 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1216]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnEventGameConclude@CTableFrameSink@@UAE_NGPAUIServerUserItem@@E@Z ENDP ; CTableFrameSink::OnEventGameConclude
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_chr$ = -1144						; size = 4
_OwnerId$2 = -1140					; size = 4
tv536 = -1136						; size = 4
tv486 = -1132						; size = 4
tv389 = -1128						; size = 4
tv323 = -1124						; size = 4
tv406 = -1120						; size = 4
_cbCount$3 = -1113					; size = 1
_wSiceCount$ = -1112					; size = 2
_cc$ = -1108						; size = 4
_pServerUserItem$4 = -1104				; size = 4
_j$5 = -1100						; size = 4
_pOwnerItem$6 = -1096					; size = 4
_i$7 = -1092						; size = 4
$T8 = -1086						; size = 1
_minSice$ = -1085					; size = 1
_index$9 = -1084					; size = 4
_i$10 = -1080						; size = 2
_bFirst$ = -1074					; size = 1
_cbRemoveCount$11 = -1073				; size = 1
tv395 = -1072						; size = 1
_cbValidCount$12 = -1071				; size = 1
tv303 = -1070						; size = 1
tv140 = -1069						; size = 1
_wTakeChairID$ = -1068					; size = 2
_i$13 = -1064						; size = 2
_Sice2$ = -1058						; size = 1
_Sice1$ = -1057						; size = 1
_i$14 = -1056						; size = 2
_cbTakeCount$ = -1049					; size = 1
_this$ = -1048						; size = 4
_HuData$15 = -1044					; size = 813
_video$16 = -228					; size = 132
_GangCardResult$ = -96					; size = 5
_GameStart$ = -88					; size = 70
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnEventGameStart@CTableFrameSink@@UAE_NXZ PROC		; CTableFrameSink::OnEventGameStart
; _this$ = ecx

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnEventGameStart@CTableFrameSink@@UAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 6c 04 00
	00		 sub	 esp, 1132		; 0000046cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 8d e8 fb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 283  : 	CString cc;

  00032	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _cc$[ebp]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 284  : 	cc.Format(_T("游戏开始servertype=%d,outtime=%d,operatetime=%d"),m_pGameServiceOption->wServerType, m_pGameCustomRule->cbTimeOutCard, m_pGameCustomRule->cbTimeOperateCard);

  00045	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 88 2c 09 00
	00		 mov	 ecx, DWORD PTR [eax+2348]
  00051	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00055	52		 push	 edx
  00056	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 88 2c 09 00
	00		 mov	 ecx, DWORD PTR [eax+2348]
  00062	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00066	52		 push	 edx
  00067	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 88 30 09 00
	00		 mov	 ecx, DWORD PTR [eax+2352]
  00073	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  00077	52		 push	 edx
  00078	68 00 00 00 00	 push	 OFFSET $SG313482
  0007d	8d 85 ac fb ff
	ff		 lea	 eax, DWORD PTR _cc$[ebp]
  00083	50		 push	 eax
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  0008a	83 c4 14	 add	 esp, 20			; 00000014H

; 285  : 	WriteDebugInfo(cc);

  0008d	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _cc$[ebp]
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  00099	50		 push	 eax
  0009a	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 286  : 	//设置状态
; 287  : 	m_pITableFrame->SetGameStatus(GAME_SCENE_PLAY);

  000a5	6a 64		 push	 100			; 00000064H
  000a7	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  000b3	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 12		 mov	 edx, DWORD PTR [edx]
  000bb	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  000c1	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  000c4	ff d0		 call	 eax

; 288  : 
; 289  : 	//随机扑克
; 290  : 	BYTE Sice1 = rand()%6 + 1;

  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000cc	99		 cdq
  000cd	b9 06 00 00 00	 mov	 ecx, 6
  000d2	f7 f9		 idiv	 ecx
  000d4	83 c2 01	 add	 edx, 1
  000d7	88 95 df fb ff
	ff		 mov	 BYTE PTR _Sice1$[ebp], dl

; 291  : 	BYTE Sice2 = rand()%6 + 1;

  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000e3	99		 cdq
  000e4	b9 06 00 00 00	 mov	 ecx, 6
  000e9	f7 f9		 idiv	 ecx
  000eb	83 c2 01	 add	 edx, 1
  000ee	88 95 de fb ff
	ff		 mov	 BYTE PTR _Sice2$[ebp], dl

; 292  : 	BYTE minSice = min(Sice1,Sice2);

  000f4	0f b6 95 df fb
	ff ff		 movzx	 edx, BYTE PTR _Sice1$[ebp]
  000fb	0f b6 85 de fb
	ff ff		 movzx	 eax, BYTE PTR _Sice2$[ebp]
  00102	3b d0		 cmp	 edx, eax
  00104	7d 0e		 jge	 SHORT $LN37@OnEventGam
  00106	8a 8d df fb ff
	ff		 mov	 cl, BYTE PTR _Sice1$[ebp]
  0010c	88 8d d3 fb ff
	ff		 mov	 BYTE PTR tv140[ebp], cl
  00112	eb 0c		 jmp	 SHORT $LN38@OnEventGam
$LN37@OnEventGam:
  00114	8a 95 de fb ff
	ff		 mov	 dl, BYTE PTR _Sice2$[ebp]
  0011a	88 95 d3 fb ff
	ff		 mov	 BYTE PTR tv140[ebp], dl
$LN38@OnEventGam:
  00120	8a 85 d3 fb ff
	ff		 mov	 al, BYTE PTR tv140[ebp]
  00126	88 85 c3 fb ff
	ff		 mov	 BYTE PTR _minSice$[ebp], al

; 293  : 	m_wSiceCount = MAKEWORD(Sice1,Sice2);

  0012c	0f b6 8d df fb
	ff ff		 movzx	 ecx, BYTE PTR _Sice1$[ebp]
  00133	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00139	0f b6 d1	 movzx	 edx, cl
  0013c	0f b6 85 de fb
	ff ff		 movzx	 eax, BYTE PTR _Sice2$[ebp]
  00143	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00148	0f b6 c8	 movzx	 ecx, al
  0014b	c1 e1 08	 shl	 ecx, 8
  0014e	0b d1		 or	 edx, ecx
  00150	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00156	66 89 90 70 04
	00 00		 mov	 WORD PTR [eax+1136], dx

; 294  : 	m_cbLeftCardCount=MAX_REPERTORY;

  0015d	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00163	c6 81 b1 07 00
	00 70		 mov	 BYTE PTR [ecx+1969], 112 ; 00000070H

; 295  : 	m_cbSendCardCount = 0;

  0016a	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00170	c6 82 3d 07 00
	00 00		 mov	 BYTE PTR [edx+1853], 0

; 296  : 	m_enSendStatus = Not_Send;

  00177	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0017d	c7 80 c8 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1224], 0

; 297  : 	m_cbGangStatus = WIK_GANERAL;

  00187	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	c6 81 cc 04 00
	00 00		 mov	 BYTE PTR [ecx+1228], 0

; 298  : 	m_wProvideGangUser = INVALID_CHAIR;

  00194	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00199	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0019f	66 89 90 ce 04
	00 00		 mov	 WORD PTR [eax+1230], dx

; 299  : 
; 300  : 	m_GameLogic.RandCardList(m_cbRepertoryCard,CountArray(m_cbRepertoryCard));

  001a6	6a 70		 push	 112			; 00000070H
  001a8	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	81 c1 3e 07 00
	00		 add	 ecx, 1854		; 0000073eH
  001b4	51		 push	 ecx
  001b5	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  001c1	e8 00 00 00 00	 call	 ?RandCardList@CGameLogic@@QAEXQAEE@Z ; CGameLogic::RandCardList

; 301  : 
; 302  : #ifdef  CARD_DISPATCHER_CONTROL
; 303  : 
; 304  : 	TCHAR szPath[MAX_PATH] = TEXT("");
; 305  : 	GetCurrentDirectory(sizeof(szPath), szPath);
; 306  : 	CString strSaveFileName;
; 307  : 	strSaveFileName.Format(TEXT("%s\\SparrowHZData.dat"), szPath);
; 308  : 	//非控制状态
; 309  : 	if(m_cbControlGameCount==0)
; 310  : 	{
; 311  : 		CFile file;
; 312  : 		if (file.Open(strSaveFileName, CFile::modeRead))
; 313  : 		{
; 314  : 			file.Read(&m_wBankerUser,sizeof(m_wBankerUser));
; 315  : 			file.Read(m_cbRepertoryCard,sizeof(m_cbRepertoryCard));		
; 316  : 			file.Close();
; 317  : 		}		
; 318  : 	}
; 319  : 	else
; 320  : 	{
; 321  : 		m_wBankerUser = m_wControBankerUser;
; 322  : 		CopyMemory(m_cbRepertoryCard, m_cbControlRepertoryCard, sizeof(m_cbRepertoryCard));
; 323  : 		m_cbControlGameCount--;
; 324  : 	}
; 325  : 
; 326  : #endif
; 327  : 
; 328  : 	//红中可以当财神
; 329  :  	m_cbMagicIndex = m_GameLogic.SwitchToCardIndex(0x35);

  001c6	6a 35		 push	 53			; 00000035H
  001c8	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001ce	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  001d4	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  001d9	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001df	88 82 7c 04 00
	00		 mov	 BYTE PTR [edx+1148], al

; 330  :  	m_GameLogic.SetMagicIndex(m_cbMagicIndex);

  001e5	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001eb	0f b6 88 7c 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1148]
  001f2	51		 push	 ecx
  001f3	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001f9	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  001ff	e8 00 00 00 00	 call	 ?SetMagicIndex@CGameLogic@@QAEXE@Z ; CGameLogic::SetMagicIndex

; 331  : 
; 332  : 	//分发扑克
; 333  : 	for (WORD i = 0; i < m_cbPlayerCount; i++)

  00204	33 d2		 xor	 edx, edx
  00206	66 89 95 d8 fb
	ff ff		 mov	 WORD PTR _i$13[ebp], dx
  0020d	eb 12		 jmp	 SHORT $LN4@OnEventGam
$LN2@OnEventGam:
  0020f	66 8b 85 d8 fb
	ff ff		 mov	 ax, WORD PTR _i$13[ebp]
  00216	66 83 c0 01	 add	 ax, 1
  0021a	66 89 85 d8 fb
	ff ff		 mov	 WORD PTR _i$13[ebp], ax
$LN4@OnEventGam:
  00221	0f b7 8d d8 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00228	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0022e	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  00232	3b c8		 cmp	 ecx, eax
  00234	0f 8d dd 00 00
	00		 jge	 $LN3@OnEventGam

; 334  : 	{
; 335  : 		if(m_pITableFrame->GetTableUserItem(i) == NULL)

  0023a	0f b7 8d d8 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00241	51		 push	 ecx
  00242	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00248	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  0024e	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00254	8b 10		 mov	 edx, DWORD PTR [eax]
  00256	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  0025c	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  00262	ff d0		 call	 eax
  00264	85 c0		 test	 eax, eax
  00266	75 02		 jne	 SHORT $LN22@OnEventGam

; 336  : 			continue;

  00268	eb a5		 jmp	 SHORT $LN2@OnEventGam
$LN22@OnEventGam:

; 337  : 
; 338  : 		m_bPlayStatus[i]=true;

  0026a	0f b7 8d d8 fb
	ff ff		 movzx	 ecx, WORD PTR _i$13[ebp]
  00271	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00277	c6 84 0a 7d 04
	00 00 01	 mov	 BYTE PTR [edx+ecx+1149], 1

; 339  : 		m_cbLeftCardCount -= (MAX_COUNT - 1);

  0027f	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00285	0f b6 88 b1 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1969]
  0028c	83 e9 0d	 sub	 ecx, 13			; 0000000dH
  0028f	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00295	88 8a b1 07 00
	00		 mov	 BYTE PTR [edx+1969], cl

; 340  : 		m_cbMinusHeadCount += (MAX_COUNT - 1);

  0029b	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002a1	0f b6 88 af 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1967]
  002a8	83 c1 0d	 add	 ecx, 13			; 0000000dH
  002ab	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002b1	88 8a af 07 00
	00		 mov	 BYTE PTR [edx+1967], cl

; 341  : 		m_cbHandCardCount[i] = (MAX_COUNT - 1);

  002b7	0f b7 85 d8 fb
	ff ff		 movzx	 eax, WORD PTR _i$13[ebp]
  002be	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002c4	c6 84 01 3a 08
	00 00 0d	 mov	 BYTE PTR [ecx+eax+2106], 13 ; 0000000dH

; 342  : 		m_GameLogic.SwitchToCardIndex(&m_cbRepertoryCard[m_cbLeftCardCount], MAX_COUNT - 1, m_cbCardIndex[i]);

  002cc	0f b7 95 d8 fb
	ff ff		 movzx	 edx, WORD PTR _i$13[ebp]
  002d3	6b c2 22	 imul	 eax, edx, 34
  002d6	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002dc	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  002e3	52		 push	 edx
  002e4	6a 0d		 push	 13			; 0000000dH
  002e6	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002ec	0f b6 88 b1 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1969]
  002f3	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002f9	8d 84 0a 3e 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1854]
  00300	50		 push	 eax
  00301	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00307	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0030d	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEQBEEQAE@Z ; CGameLogic::SwitchToCardIndex

; 343  : 	}

  00312	e9 f8 fe ff ff	 jmp	 $LN2@OnEventGam
$LN3@OnEventGam:

; 344  : 
; 345  : 	if(m_wBankerUser == INVALID_CHAIR && (m_pGameServiceOption->wServerType&GAME_GENRE_PERSONAL)!=0 )//房卡模式下先把庄家给房主

  00317	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0031d	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  00324	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0032a	0f 85 b4 00 00
	00		 jne	 $LN23@OnEventGam
  00330	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00336	8b 88 30 09 00
	00		 mov	 ecx, DWORD PTR [eax+2352]
  0033c	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  00340	83 e2 10	 and	 edx, 16			; 00000010H
  00343	0f 84 9b 00 00
	00		 je	 $LN23@OnEventGam

; 346  : 	{
; 347  : 		DWORD OwnerId =  m_pITableFrame->GetTableOwner();

  00349	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0034f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00355	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0035b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0035d	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00363	8b 50 54	 mov	 edx, DWORD PTR [eax+84]
  00366	ff d2		 call	 edx
  00368	89 85 8c fb ff
	ff		 mov	 DWORD PTR _OwnerId$2[ebp], eax

; 348  : 		IServerUserItem *pOwnerItem = m_pITableFrame->SearchUserItem(OwnerId);

  0036e	8b 85 8c fb ff
	ff		 mov	 eax, DWORD PTR _OwnerId$2[ebp]
  00374	50		 push	 eax
  00375	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0037b	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00381	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00387	8b 12		 mov	 edx, DWORD PTR [edx]
  00389	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  0038f	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  00395	ff d0		 call	 eax
  00397	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _pOwnerItem$6[ebp], eax

; 349  : 		if(pOwnerItem && pOwnerItem->GetChairID() != INVALID_CHAIR)

  0039d	83 bd b8 fb ff
	ff 00		 cmp	 DWORD PTR _pOwnerItem$6[ebp], 0
  003a4	74 3e		 je	 SHORT $LN23@OnEventGam
  003a6	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _pOwnerItem$6[ebp]
  003ac	8b 11		 mov	 edx, DWORD PTR [ecx]
  003ae	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _pOwnerItem$6[ebp]
  003b4	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  003b7	ff d0		 call	 eax
  003b9	0f b7 c8	 movzx	 ecx, ax
  003bc	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  003c2	74 20		 je	 SHORT $LN23@OnEventGam

; 350  : 			m_wBankerUser = pOwnerItem->GetChairID();

  003c4	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR _pOwnerItem$6[ebp]
  003ca	8b 02		 mov	 eax, DWORD PTR [edx]
  003cc	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _pOwnerItem$6[ebp]
  003d2	8b 50 78	 mov	 edx, DWORD PTR [eax+120]
  003d5	ff d2		 call	 edx
  003d7	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003dd	66 89 81 72 04
	00 00		 mov	 WORD PTR [ecx+1138], ax
$LN23@OnEventGam:

; 351  : 	}
; 352  : 	//确定庄家
; 353  : 	if(m_wBankerUser == INVALID_CHAIR || m_bPlayStatus[m_wBankerUser]==false)

  003e4	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003ea	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  003f1	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  003f6	74 23		 je	 SHORT $LN26@OnEventGam
  003f8	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003fe	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  00405	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0040b	0f b6 8c 10 7d
	04 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1149]
  00413	85 c9		 test	 ecx, ecx
  00415	0f 85 80 00 00
	00		 jne	 $LN25@OnEventGam
$LN26@OnEventGam:

; 354  : 	{
; 355  : 		m_wBankerUser = rand() % m_cbPlayerCount;

  0041b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00421	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00427	0f b6 4a 09	 movzx	 ecx, BYTE PTR [edx+9]
  0042b	99		 cdq
  0042c	f7 f9		 idiv	 ecx
  0042e	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00434	66 89 90 72 04
	00 00		 mov	 WORD PTR [eax+1138], dx
$LN5@OnEventGam:

; 356  : 		while(m_pITableFrame->GetTableUserItem(m_wBankerUser)==NULL)

  0043b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00441	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  00448	52		 push	 edx
  00449	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0044f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00455	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0045b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0045d	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00463	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  00469	ff d2		 call	 edx
  0046b	85 c0		 test	 eax, eax
  0046d	75 2c		 jne	 SHORT $LN25@OnEventGam

; 357  : 		{
; 358  : 			m_wBankerUser = (m_wBankerUser+1)%m_cbPlayerCount;

  0046f	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00475	0f b7 80 72 04
	00 00		 movzx	 eax, WORD PTR [eax+1138]
  0047c	83 c0 01	 add	 eax, 1
  0047f	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00485	0f b6 49 09	 movzx	 ecx, BYTE PTR [ecx+9]
  00489	99		 cdq
  0048a	f7 f9		 idiv	 ecx
  0048c	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00492	66 89 90 72 04
	00 00		 mov	 WORD PTR [eax+1138], dx

; 359  : 		}

  00499	eb a0		 jmp	 SHORT $LN5@OnEventGam
$LN25@OnEventGam:

; 360  : 	}
; 361  : 
; 362  : 	//发送扑克
; 363  : 	m_cbMinusHeadCount++;

  0049b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004a1	8a 91 af 07 00
	00		 mov	 dl, BYTE PTR [ecx+1967]
  004a7	80 c2 01	 add	 dl, 1
  004aa	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004b0	88 90 af 07 00
	00		 mov	 BYTE PTR [eax+1967], dl

; 364  : 	m_cbSendCardData = m_cbRepertoryCard[--m_cbLeftCardCount];

  004b6	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004bc	8a 91 b1 07 00
	00		 mov	 dl, BYTE PTR [ecx+1969]
  004c2	80 ea 01	 sub	 dl, 1
  004c5	88 95 d2 fb ff
	ff		 mov	 BYTE PTR tv303[ebp], dl
  004cb	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004d1	8a 8d d2 fb ff
	ff		 mov	 cl, BYTE PTR tv303[ebp]
  004d7	88 88 b1 07 00
	00		 mov	 BYTE PTR [eax+1969], cl
  004dd	0f b6 95 d2 fb
	ff ff		 movzx	 edx, BYTE PTR tv303[ebp]
  004e4	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004ea	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004f0	8a 94 11 3e 07
	00 00		 mov	 dl, BYTE PTR [ecx+edx+1854]
  004f7	88 90 3c 07 00
	00		 mov	 BYTE PTR [eax+1852], dl

; 365  : 	m_cbCardIndex[m_wBankerUser][m_GameLogic.SwitchToCardIndex(m_cbSendCardData)]++;

  004fd	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00503	0f b7 88 72 04
	00 00		 movzx	 ecx, WORD PTR [eax+1138]
  0050a	6b d1 22	 imul	 edx, ecx, 34
  0050d	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00513	8d b4 10 b2 07
	00 00		 lea	 esi, DWORD PTR [eax+edx+1970]
  0051a	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00520	0f b6 91 3c 07
	00 00		 movzx	 edx, BYTE PTR [ecx+1852]
  00527	52		 push	 edx
  00528	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0052e	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00534	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  00539	0f b6 c0	 movzx	 eax, al
  0053c	03 f0		 add	 esi, eax
  0053e	89 b5 9c fb ff
	ff		 mov	 DWORD PTR tv323[ebp], esi
  00544	8b 8d 9c fb ff
	ff		 mov	 ecx, DWORD PTR tv323[ebp]
  0054a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0054c	80 c2 01	 add	 dl, 1
  0054f	8b 85 9c fb ff
	ff		 mov	 eax, DWORD PTR tv323[ebp]
  00555	88 10		 mov	 BYTE PTR [eax], dl

; 366  : 	m_cbUserCatchCardCount[m_wBankerUser]++;

  00557	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0055d	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  00564	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0056a	8a 8c 10 4c 05
	00 00		 mov	 cl, BYTE PTR [eax+edx+1356]
  00571	80 c1 01	 add	 cl, 1
  00574	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0057a	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  00581	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00587	88 8c 02 4c 05
	00 00		 mov	 BYTE PTR [edx+eax+1356], cl

; 367  : 	//设置变量
; 368  : 	m_cbProvideCard = m_cbSendCardData;

  0058e	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00594	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0059a	8a 91 3c 07 00
	00		 mov	 dl, BYTE PTR [ecx+1852]
  005a0	88 90 c2 04 00
	00		 mov	 BYTE PTR [eax+1218], dl

; 369  : 	m_wProvideUser = m_wBankerUser;

  005a6	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005ac	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005b2	66 8b 91 72 04
	00 00		 mov	 dx, WORD PTR [ecx+1138]
  005b9	66 89 90 c0 04
	00 00		 mov	 WORD PTR [eax+1216], dx

; 370  : 	m_wCurrentUser = m_wBankerUser;

  005c0	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005c6	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005cc	66 8b 91 72 04
	00 00		 mov	 dx, WORD PTR [ecx+1138]
  005d3	66 89 90 be 04
	00 00		 mov	 WORD PTR [eax+1214], dx

; 371  : 
; 372  : 	//堆立信息
; 373  : 	WORD wSiceCount = LOBYTE(m_wSiceCount) + HIBYTE(m_wSiceCount);

  005da	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005e0	0f b7 88 70 04
	00 00		 movzx	 ecx, WORD PTR [eax+1136]
  005e7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005ed	0f b6 d1	 movzx	 edx, cl
  005f0	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005f6	0f b7 88 70 04
	00 00		 movzx	 ecx, WORD PTR [eax+1136]
  005fd	c1 e9 08	 shr	 ecx, 8
  00600	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00606	0f b6 c1	 movzx	 eax, cl
  00609	03 d0		 add	 edx, eax
  0060b	66 89 95 a8 fb
	ff ff		 mov	 WORD PTR _wSiceCount$[ebp], dx

; 374  : 	WORD wTakeChairID = (m_wBankerUser + wSiceCount - 1) % GAME_PLAYER;

  00612	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00618	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  0061f	0f b7 85 a8 fb
	ff ff		 movzx	 eax, WORD PTR _wSiceCount$[ebp]
  00626	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  0062a	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00630	79 05		 jns	 SHORT $LN47@OnEventGam
  00632	49		 dec	 ecx
  00633	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00636	41		 inc	 ecx
$LN47@OnEventGam:
  00637	66 89 8d d4 fb
	ff ff		 mov	 WORD PTR _wTakeChairID$[ebp], cx

; 375  : 	BYTE cbTakeCount = MAX_REPERTORY - m_cbLeftCardCount;

  0063e	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00644	0f b6 82 b1 07
	00 00		 movzx	 eax, BYTE PTR [edx+1969]
  0064b	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00650	2b c8		 sub	 ecx, eax
  00652	88 8d e7 fb ff
	ff		 mov	 BYTE PTR _cbTakeCount$[ebp], cl

; 376  : 	for (WORD i = 0; i < GAME_PLAYER; i++)

  00658	33 d2		 xor	 edx, edx
  0065a	66 89 95 c8 fb
	ff ff		 mov	 WORD PTR _i$10[ebp], dx
  00661	eb 12		 jmp	 SHORT $LN9@OnEventGam
$LN7@OnEventGam:
  00663	66 8b 85 c8 fb
	ff ff		 mov	 ax, WORD PTR _i$10[ebp]
  0066a	66 83 c0 01	 add	 ax, 1
  0066e	66 89 85 c8 fb
	ff ff		 mov	 WORD PTR _i$10[ebp], ax
$LN9@OnEventGam:
  00675	0f b7 8d c8 fb
	ff ff		 movzx	 ecx, WORD PTR _i$10[ebp]
  0067c	83 f9 04	 cmp	 ecx, 4
  0067f	0f 8d 82 01 00
	00		 jge	 $LN8@OnEventGam

; 377  : 	{
; 378  : 		//计算数目
; 379  : 		BYTE cbValidCount = HEAP_FULL_COUNT - m_cbHeapCardInfo[wTakeChairID][1] - ((i == 0) ? (minSice) * 2 : 0);

  00685	0f b7 95 c8 fb
	ff ff		 movzx	 edx, WORD PTR _i$10[ebp]
  0068c	85 d2		 test	 edx, edx
  0068e	75 11		 jne	 SHORT $LN39@OnEventGam
  00690	0f b6 85 c3 fb
	ff ff		 movzx	 eax, BYTE PTR _minSice$[ebp]
  00697	d1 e0		 shl	 eax, 1
  00699	89 85 98 fb ff
	ff		 mov	 DWORD PTR tv389[ebp], eax
  0069f	eb 0a		 jmp	 SHORT $LN40@OnEventGam
$LN39@OnEventGam:
  006a1	c7 85 98 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv389[ebp], 0
$LN40@OnEventGam:
  006ab	0f b7 8d d4 fb
	ff ff		 movzx	 ecx, WORD PTR _wTakeChairID$[ebp]
  006b2	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006b8	8d 84 4a b4 04
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+1204]
  006bf	b9 01 00 00 00	 mov	 ecx, 1
  006c4	c1 e1 00	 shl	 ecx, 0
  006c7	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  006cb	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  006d0	2b c2		 sub	 eax, edx
  006d2	2b 85 98 fb ff
	ff		 sub	 eax, DWORD PTR tv389[ebp]
  006d8	88 85 d1 fb ff
	ff		 mov	 BYTE PTR _cbValidCount$12[ebp], al

; 380  : 		BYTE cbRemoveCount = __min(cbValidCount, cbTakeCount);

  006de	0f b6 8d d1 fb
	ff ff		 movzx	 ecx, BYTE PTR _cbValidCount$12[ebp]
  006e5	0f b6 95 e7 fb
	ff ff		 movzx	 edx, BYTE PTR _cbTakeCount$[ebp]
  006ec	3b ca		 cmp	 ecx, edx
  006ee	7d 0e		 jge	 SHORT $LN41@OnEventGam
  006f0	8a 85 d1 fb ff
	ff		 mov	 al, BYTE PTR _cbValidCount$12[ebp]
  006f6	88 85 d0 fb ff
	ff		 mov	 BYTE PTR tv395[ebp], al
  006fc	eb 0c		 jmp	 SHORT $LN42@OnEventGam
$LN41@OnEventGam:
  006fe	8a 8d e7 fb ff
	ff		 mov	 cl, BYTE PTR _cbTakeCount$[ebp]
  00704	88 8d d0 fb ff
	ff		 mov	 BYTE PTR tv395[ebp], cl
$LN42@OnEventGam:
  0070a	8a 95 d0 fb ff
	ff		 mov	 dl, BYTE PTR tv395[ebp]
  00710	88 95 cf fb ff
	ff		 mov	 BYTE PTR _cbRemoveCount$11[ebp], dl

; 381  : 
; 382  : 		//提取扑克
; 383  : 		cbTakeCount -= cbRemoveCount;

  00716	0f b6 85 cf fb
	ff ff		 movzx	 eax, BYTE PTR _cbRemoveCount$11[ebp]
  0071d	0f b6 8d e7 fb
	ff ff		 movzx	 ecx, BYTE PTR _cbTakeCount$[ebp]
  00724	2b c8		 sub	 ecx, eax
  00726	88 8d e7 fb ff
	ff		 mov	 BYTE PTR _cbTakeCount$[ebp], cl

; 384  : 		m_cbHeapCardInfo[wTakeChairID][(i == 0) ? 1 : 0] += cbRemoveCount;

  0072c	0f b7 95 c8 fb
	ff ff		 movzx	 edx, WORD PTR _i$10[ebp]
  00733	85 d2		 test	 edx, edx
  00735	75 0c		 jne	 SHORT $LN43@OnEventGam
  00737	c7 85 a0 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv406[ebp], 1
  00741	eb 0a		 jmp	 SHORT $LN44@OnEventGam
$LN43@OnEventGam:
  00743	c7 85 a0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv406[ebp], 0
$LN44@OnEventGam:
  0074d	0f b7 85 d4 fb
	ff ff		 movzx	 eax, WORD PTR _wTakeChairID$[ebp]
  00754	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0075a	8d 94 41 b4 04
	00 00		 lea	 edx, DWORD PTR [ecx+eax*2+1204]
  00761	0f b6 85 cf fb
	ff ff		 movzx	 eax, BYTE PTR _cbRemoveCount$11[ebp]
  00768	8b 8d a0 fb ff
	ff		 mov	 ecx, DWORD PTR tv406[ebp]
  0076e	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00772	03 d0		 add	 edx, eax
  00774	0f b7 85 d4 fb
	ff ff		 movzx	 eax, WORD PTR _wTakeChairID$[ebp]
  0077b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00781	8d 84 41 b4 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax*2+1204]
  00788	8b 8d a0 fb ff
	ff		 mov	 ecx, DWORD PTR tv406[ebp]
  0078e	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 385  : 
; 386  : 		//完成判断
; 387  : 		if (cbTakeCount == 0)

  00791	0f b6 95 e7 fb
	ff ff		 movzx	 edx, BYTE PTR _cbTakeCount$[ebp]
  00798	85 d2		 test	 edx, edx
  0079a	75 48		 jne	 SHORT $LN27@OnEventGam

; 388  : 		{
; 389  : 			m_wHeapHead = wTakeChairID;

  0079c	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007a2	66 8b 8d d4 fb
	ff ff		 mov	 cx, WORD PTR _wTakeChairID$[ebp]
  007a9	66 89 88 b0 04
	00 00		 mov	 WORD PTR [eax+1200], cx

; 390  : 			m_wHeapTail = (m_wBankerUser + wSiceCount - 1) % GAME_PLAYER;

  007b0	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007b6	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  007bd	0f b7 8d a8 fb
	ff ff		 movzx	 ecx, WORD PTR _wSiceCount$[ebp]
  007c4	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  007c8	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  007ce	79 05		 jns	 SHORT $LN48@OnEventGam
  007d0	4a		 dec	 edx
  007d1	83 ca fc	 or	 edx, -4			; fffffffcH
  007d4	42		 inc	 edx
$LN48@OnEventGam:
  007d5	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007db	66 89 90 b2 04
	00 00		 mov	 WORD PTR [eax+1202], dx

; 391  : 			break;

  007e2	eb 23		 jmp	 SHORT $LN8@OnEventGam
$LN27@OnEventGam:

; 392  : 		}
; 393  : 		//切换索引
; 394  : 		wTakeChairID = (wTakeChairID + GAME_PLAYER - 1) % GAME_PLAYER;

  007e4	0f b7 8d d4 fb
	ff ff		 movzx	 ecx, WORD PTR _wTakeChairID$[ebp]
  007eb	83 c1 03	 add	 ecx, 3
  007ee	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  007f4	79 05		 jns	 SHORT $LN49@OnEventGam
  007f6	49		 dec	 ecx
  007f7	83 c9 fc	 or	 ecx, -4			; fffffffcH
  007fa	41		 inc	 ecx
$LN49@OnEventGam:
  007fb	66 89 8d d4 fb
	ff ff		 mov	 WORD PTR _wTakeChairID$[ebp], cx

; 395  : 	}

  00802	e9 5c fe ff ff	 jmp	 $LN7@OnEventGam
$LN8@OnEventGam:

; 396  : 
; 397  : 	//操作分析
; 398  : 	ZeroMemory(m_cbUserAction, sizeof(m_cbUserAction));

  00807	6a 04		 push	 4
  00809	6a 00		 push	 0
  0080b	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00811	81 c2 e4 05 00
	00		 add	 edx, 1508		; 000005e4H
  00817	52		 push	 edx
  00818	e8 00 00 00 00	 call	 _memset
  0081d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 399  : 
; 400  : 	//杠牌判断
; 401  : 	tagGangCardResult GangCardResult;
; 402  : 	m_cbUserAction[m_wBankerUser]|=m_GameLogic.AnalyseGangCardEx(m_cbCardIndex[m_wBankerUser],NULL,0,0,GangCardResult);

  00820	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00826	0f b7 b0 72 04
	00 00		 movzx	 esi, WORD PTR [eax+1138]
  0082d	8d 4d a0	 lea	 ecx, DWORD PTR _GangCardResult$[ebp]
  00830	51		 push	 ecx
  00831	6a 00		 push	 0
  00833	6a 00		 push	 0
  00835	6a 00		 push	 0
  00837	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0083d	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  00844	6b c8 22	 imul	 ecx, eax, 34
  00847	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0084d	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  00854	50		 push	 eax
  00855	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0085b	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00861	e8 00 00 00 00	 call	 ?AnalyseGangCardEx@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAUtagGangCardResult@@@Z ; CGameLogic::AnalyseGangCardEx
  00866	0f b6 c8	 movzx	 ecx, al
  00869	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0086f	0f b6 84 32 e4
	05 00 00	 movzx	 eax, BYTE PTR [edx+esi+1508]
  00877	0b c1		 or	 eax, ecx
  00879	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0087f	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  00886	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0088c	88 84 11 e4 05
	00 00		 mov	 BYTE PTR [ecx+edx+1508], al

; 403  : 
; 404  : 	//胡牌判断
; 405  : 	CChiHuRight chr;

  00893	8d 8d 88 fb ff
	ff		 lea	 ecx, DWORD PTR _chr$[ebp]
  00899	e8 00 00 00 00	 call	 ??0CChiHuRight@@QAE@XZ	; CChiHuRight::CChiHuRight

; 406  : 	m_cbCardIndex[m_wBankerUser][m_GameLogic.SwitchToCardIndex(m_cbSendCardData)]--;

  0089e	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008a4	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  008ab	6b c8 22	 imul	 ecx, eax, 34
  008ae	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008b4	8d b4 0a b2 07
	00 00		 lea	 esi, DWORD PTR [edx+ecx+1970]
  008bb	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008c1	0f b6 88 3c 07
	00 00		 movzx	 ecx, BYTE PTR [eax+1852]
  008c8	51		 push	 ecx
  008c9	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008cf	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  008d5	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  008da	0f b6 d0	 movzx	 edx, al
  008dd	03 f2		 add	 esi, edx
  008df	89 b5 94 fb ff
	ff		 mov	 DWORD PTR tv486[ebp], esi
  008e5	8b 85 94 fb ff
	ff		 mov	 eax, DWORD PTR tv486[ebp]
  008eb	8a 08		 mov	 cl, BYTE PTR [eax]
  008ed	80 e9 01	 sub	 cl, 1
  008f0	8b 95 94 fb ff
	ff		 mov	 edx, DWORD PTR tv486[ebp]
  008f6	88 0a		 mov	 BYTE PTR [edx], cl

; 407  : 	m_cbUserAction[m_wBankerUser]|=m_GameLogic.AnalyseChiHuCard(m_cbCardIndex[m_wBankerUser],NULL,0,m_cbSendCardData,chr,true);

  008f8	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008fe	0f b7 b0 72 04
	00 00		 movzx	 esi, WORD PTR [eax+1138]
  00905	6a 01		 push	 1
  00907	8d 8d 88 fb ff
	ff		 lea	 ecx, DWORD PTR _chr$[ebp]
  0090d	51		 push	 ecx
  0090e	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00914	0f b6 82 3c 07
	00 00		 movzx	 eax, BYTE PTR [edx+1852]
  0091b	50		 push	 eax
  0091c	6a 00		 push	 0
  0091e	6a 00		 push	 0
  00920	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00926	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  0092d	6b c2 22	 imul	 eax, edx, 34
  00930	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00936	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  0093d	52		 push	 edx
  0093e	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00944	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  0094a	e8 00 00 00 00	 call	 ?AnalyseChiHuCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EEAAVCChiHuRight@@_N@Z ; CGameLogic::AnalyseChiHuCard
  0094f	0f b6 c0	 movzx	 eax, al
  00952	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00958	0f b6 94 31 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+esi+1508]
  00960	0b d0		 or	 edx, eax
  00962	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00968	0f b7 88 72 04
	00 00		 movzx	 ecx, WORD PTR [eax+1138]
  0096f	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00975	88 94 08 e4 05
	00 00		 mov	 BYTE PTR [eax+ecx+1508], dl

; 408  : 	m_cbCardIndex[m_wBankerUser][m_GameLogic.SwitchToCardIndex(m_cbSendCardData)]++;

  0097c	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00982	0f b7 91 72 04
	00 00		 movzx	 edx, WORD PTR [ecx+1138]
  00989	6b c2 22	 imul	 eax, edx, 34
  0098c	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00992	8d b4 01 b2 07
	00 00		 lea	 esi, DWORD PTR [ecx+eax+1970]
  00999	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0099f	0f b6 82 3c 07
	00 00		 movzx	 eax, BYTE PTR [edx+1852]
  009a6	50		 push	 eax
  009a7	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009ad	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  009b3	e8 00 00 00 00	 call	 ?SwitchToCardIndex@CGameLogic@@QAEEE@Z ; CGameLogic::SwitchToCardIndex
  009b8	0f b6 c8	 movzx	 ecx, al
  009bb	03 f1		 add	 esi, ecx
  009bd	89 b5 90 fb ff
	ff		 mov	 DWORD PTR tv536[ebp], esi
  009c3	8b 95 90 fb ff
	ff		 mov	 edx, DWORD PTR tv536[ebp]
  009c9	8a 02		 mov	 al, BYTE PTR [edx]
  009cb	04 01		 add	 al, 1
  009cd	8b 8d 90 fb ff
	ff		 mov	 ecx, DWORD PTR tv536[ebp]
  009d3	88 01		 mov	 BYTE PTR [ecx], al

; 409  : 	m_cbHandCardCount[m_wBankerUser]++;

  009d5	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  009db	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  009e2	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009e8	8a 94 01 3a 08
	00 00		 mov	 dl, BYTE PTR [ecx+eax+2106]
  009ef	80 c2 01	 add	 dl, 1
  009f2	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009f8	0f b7 88 72 04
	00 00		 movzx	 ecx, WORD PTR [eax+1138]
  009ff	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a05	88 94 08 3a 08
	00 00		 mov	 BYTE PTR [eax+ecx+2106], dl

; 410  : 
; 411  : 	//听牌判断
; 412  : 	for(int index=0;index<GAME_PLAYER;index++)

  00a0c	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _index$9[ebp], 0
  00a16	eb 0f		 jmp	 SHORT $LN12@OnEventGam
$LN10@OnEventGam:
  00a18	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _index$9[ebp]
  00a1e	83 c1 01	 add	 ecx, 1
  00a21	89 8d c4 fb ff
	ff		 mov	 DWORD PTR _index$9[ebp], ecx
$LN12@OnEventGam:
  00a27	83 bd c4 fb ff
	ff 04		 cmp	 DWORD PTR _index$9[ebp], 4
  00a2e	0f 8d f4 01 00
	00		 jge	 $LN11@OnEventGam

; 413  : 	{
; 414  : 		if(!m_bPlayStatus[index])continue;

  00a34	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00a3a	03 95 c4 fb ff
	ff		 add	 edx, DWORD PTR _index$9[ebp]
  00a40	0f b6 82 7d 04
	00 00		 movzx	 eax, BYTE PTR [edx+1149]
  00a47	85 c0		 test	 eax, eax
  00a49	75 02		 jne	 SHORT $LN28@OnEventGam
  00a4b	eb cb		 jmp	 SHORT $LN10@OnEventGam
$LN28@OnEventGam:

; 415  : 
; 416  : 		BYTE cbCount = 0;

  00a4d	c6 85 a7 fb ff
	ff 00		 mov	 BYTE PTR _cbCount$3[ebp], 0

; 417  : 		CMD_S_Hu_Data HuData;
; 418  : 		ZeroMemory(&HuData,sizeof(HuData));

  00a54	68 2d 03 00 00	 push	 813			; 0000032dH
  00a59	6a 00		 push	 0
  00a5b	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _HuData$15[ebp]
  00a61	51		 push	 ecx
  00a62	e8 00 00 00 00	 call	 _memset
  00a67	83 c4 0c	 add	 esp, 12			; 0000000cH

; 419  : 
; 420  : 		m_GameLogic.AnalyseTingCard(m_cbCardIndex[index],0,0,HuData.cbOutCardCount,HuData.cbOutCardData,HuData.cbHuCardCount,HuData.cbHuCardData);

  00a6a	8d 95 09 fc ff
	ff		 lea	 edx, DWORD PTR _HuData$15[ebp+29]
  00a70	52		 push	 edx
  00a71	8d 85 fb fb ff
	ff		 lea	 eax, DWORD PTR _HuData$15[ebp+15]
  00a77	50		 push	 eax
  00a78	8d 8d ed fb ff
	ff		 lea	 ecx, DWORD PTR _HuData$15[ebp+1]
  00a7e	51		 push	 ecx
  00a7f	8d 95 ec fb ff
	ff		 lea	 edx, DWORD PTR _HuData$15[ebp]
  00a85	52		 push	 edx
  00a86	6a 00		 push	 0
  00a88	6a 00		 push	 0
  00a8a	6b 85 c4 fb ff
	ff 22		 imul	 eax, DWORD PTR _index$9[ebp], 34
  00a91	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a97	8d 94 01 b2 07
	00 00		 lea	 edx, DWORD PTR [ecx+eax+1970]
  00a9e	52		 push	 edx
  00a9f	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00aa5	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00aab	e8 00 00 00 00	 call	 ?AnalyseTingCard@CGameLogic@@QAEEQBEQBUtagWeaveItem@@EAAEQAE3QAY0BM@E@Z ; CGameLogic::AnalyseTingCard

; 421  : 
; 422  : 		if(index == m_wBankerUser)

  00ab0	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ab6	0f b7 88 72 04
	00 00		 movzx	 ecx, WORD PTR [eax+1138]
  00abd	39 8d c4 fb ff
	ff		 cmp	 DWORD PTR _index$9[ebp], ecx
  00ac3	75 38		 jne	 SHORT $LN29@OnEventGam

; 423  : 			m_cbUserAction[m_wBankerUser] |= WIK_LISTEN;

  00ac5	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00acb	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  00ad2	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ad8	0f b6 94 01 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1508]
  00ae0	83 ca 20	 or	 edx, 32			; 00000020H
  00ae3	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ae9	0f b7 88 72 04
	00 00		 movzx	 ecx, WORD PTR [eax+1138]
  00af0	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00af6	88 94 08 e4 05
	00 00		 mov	 BYTE PTR [eax+ecx+1508], dl
$LN29@OnEventGam:

; 424  : 
; 425  : 		for(int i=0;i<MAX_COUNT;i++)

  00afd	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$7[ebp], 0
  00b07	eb 0f		 jmp	 SHORT $LN15@OnEventGam
$LN13@OnEventGam:
  00b09	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _i$7[ebp]
  00b0f	83 c1 01	 add	 ecx, 1
  00b12	89 8d bc fb ff
	ff		 mov	 DWORD PTR _i$7[ebp], ecx
$LN15@OnEventGam:
  00b18	83 bd bc fb ff
	ff 0e		 cmp	 DWORD PTR _i$7[ebp], 14	; 0000000eH
  00b1f	0f 8d 91 00 00
	00		 jge	 $LN14@OnEventGam

; 426  : 		{
; 427  : 			if(HuData.cbHuCardCount[i]>0)

  00b25	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR _i$7[ebp]
  00b2b	0f b6 84 15 fb
	fb ff ff	 movzx	 eax, BYTE PTR _HuData$15[ebp+edx+15]
  00b33	85 c0		 test	 eax, eax
  00b35	7e 78		 jle	 SHORT $LN30@OnEventGam

; 428  : 			{
; 429  : 				for(int j=0;j<HuData.cbHuCardCount[i];j++)

  00b37	c7 85 b4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$5[ebp], 0
  00b41	eb 0f		 jmp	 SHORT $LN18@OnEventGam
$LN16@OnEventGam:
  00b43	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _j$5[ebp]
  00b49	83 c1 01	 add	 ecx, 1
  00b4c	89 8d b4 fb ff
	ff		 mov	 DWORD PTR _j$5[ebp], ecx
$LN18@OnEventGam:
  00b52	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR _i$7[ebp]
  00b58	0f b6 84 15 fb
	fb ff ff	 movzx	 eax, BYTE PTR _HuData$15[ebp+edx+15]
  00b60	39 85 b4 fb ff
	ff		 cmp	 DWORD PTR _j$5[ebp], eax
  00b66	7d 45		 jge	 SHORT $LN17@OnEventGam

; 430  : 				{
; 431  : 					HuData.cbHuCardRemainingCount[i][j] = GetRemainingCount(index,HuData.cbHuCardData[i][j]);

  00b68	6b 8d bc fb ff
	ff 1c		 imul	 ecx, DWORD PTR _i$7[ebp], 28
  00b6f	8d 94 0d 09 fc
	ff ff		 lea	 edx, DWORD PTR _HuData$15[ebp+ecx+29]
  00b76	8b 85 b4 fb ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00b7c	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00b80	51		 push	 ecx
  00b81	0f b7 95 c4 fb
	ff ff		 movzx	 edx, WORD PTR _index$9[ebp]
  00b88	52		 push	 edx
  00b89	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b8f	e8 00 00 00 00	 call	 ?GetRemainingCount@CTableFrameSink@@IAEEGE@Z ; CTableFrameSink::GetRemainingCount
  00b94	6b 8d bc fb ff
	ff 1c		 imul	 ecx, DWORD PTR _i$7[ebp], 28
  00b9b	8d 94 0d 91 fd
	ff ff		 lea	 edx, DWORD PTR _HuData$15[ebp+ecx+421]
  00ba2	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _j$5[ebp]
  00ba8	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 432  : 				}

  00bab	eb 96		 jmp	 SHORT $LN16@OnEventGam
$LN17@OnEventGam:

; 433  : 			}
; 434  : 			else

  00bad	eb 02		 jmp	 SHORT $LN31@OnEventGam
$LN30@OnEventGam:

; 435  : 				break;

  00baf	eb 05		 jmp	 SHORT $LN14@OnEventGam
$LN31@OnEventGam:

; 436  : 		}

  00bb1	e9 53 ff ff ff	 jmp	 $LN13@OnEventGam
$LN14@OnEventGam:

; 437  : 		//特殊标记方便手机端处理
; 438  : 		if(index != m_wBankerUser && HuData.cbHuCardCount[0]>0)

  00bb6	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00bbc	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  00bc3	39 85 c4 fb ff
	ff		 cmp	 DWORD PTR _index$9[ebp], eax
  00bc9	74 1b		 je	 SHORT $LN32@OnEventGam
  00bcb	b9 01 00 00 00	 mov	 ecx, 1
  00bd0	6b d1 00	 imul	 edx, ecx, 0
  00bd3	0f b6 84 15 fb
	fb ff ff	 movzx	 eax, BYTE PTR _HuData$15[ebp+edx+15]
  00bdb	85 c0		 test	 eax, eax
  00bdd	7e 07		 jle	 SHORT $LN32@OnEventGam

; 439  : 			HuData.cbOutCardCount=1;

  00bdf	c6 85 ec fb ff
	ff 01		 mov	 BYTE PTR _HuData$15[ebp], 1
$LN32@OnEventGam:

; 440  : 
; 441  : 		m_pITableFrame->SendTableData(index,SUB_S_HU_CARD,&HuData,sizeof(HuData));

  00be6	68 c8 00 00 00	 push	 200			; 000000c8H
  00beb	68 2d 03 00 00	 push	 813			; 0000032dH
  00bf0	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _HuData$15[ebp]
  00bf6	51		 push	 ecx
  00bf7	6a 6e		 push	 110			; 0000006eH
  00bf9	0f b7 95 c4 fb
	ff ff		 movzx	 edx, WORD PTR _index$9[ebp]
  00c00	52		 push	 edx
  00c01	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c07	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00c0d	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c13	8b 01		 mov	 eax, DWORD PTR [ecx]
  00c15	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00c1b	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00c21	ff d2		 call	 edx

; 442  : 
; 443  : 	}

  00c23	e9 f0 fd ff ff	 jmp	 $LN10@OnEventGam
$LN11@OnEventGam:

; 444  : 	if(m_pGameVideo)

  00c28	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c2e	83 b8 40 06 00
	00 00		 cmp	 DWORD PTR [eax+1600], 0
  00c35	74 30		 je	 SHORT $LN33@OnEventGam

; 445  : 	{
; 446  : 		m_pGameVideo->StartVideo(m_pITableFrame);

  00c37	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c3d	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  00c43	52		 push	 edx
  00c44	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c4a	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  00c50	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c56	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00c5c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00c5e	50		 push	 eax
  00c5f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00c62	ff d2		 call	 edx
  00c64	83 c4 08	 add	 esp, 8
$LN33@OnEventGam:

; 447  : 	}
; 448  : 	//构造变量
; 449  : 	CMD_S_GameStart GameStart;
; 450  : 	ZeroMemory(&GameStart,sizeof(GameStart));

  00c67	6a 46		 push	 70			; 00000046H
  00c69	6a 00		 push	 0
  00c6b	8d 45 a8	 lea	 eax, DWORD PTR _GameStart$[ebp]
  00c6e	50		 push	 eax
  00c6f	e8 00 00 00 00	 call	 _memset
  00c74	83 c4 0c	 add	 esp, 12			; 0000000cH

; 451  : 	GameStart.wBankerUser = m_wBankerUser;

  00c77	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00c7d	66 8b 91 72 04
	00 00		 mov	 dx, WORD PTR [ecx+1138]
  00c84	66 89 55 a8	 mov	 WORD PTR _GameStart$[ebp], dx

; 452  : 	GameStart.wSiceCount = m_wSiceCount;

  00c88	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c8e	66 8b 88 70 04
	00 00		 mov	 cx, WORD PTR [eax+1136]
  00c95	66 89 4d ac	 mov	 WORD PTR _GameStart$[ebp+4], cx

; 453  : 	GameStart.wHeapHead = m_wHeapHead;

  00c99	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c9f	66 8b 82 b0 04
	00 00		 mov	 ax, WORD PTR [edx+1200]
  00ca6	66 89 45 ae	 mov	 WORD PTR _GameStart$[ebp+6], ax

; 454  : 	GameStart.wHeapTail = m_wHeapTail;

  00caa	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00cb0	66 8b 91 b2 04
	00 00		 mov	 dx, WORD PTR [ecx+1202]
  00cb7	66 89 55 b0	 mov	 WORD PTR _GameStart$[ebp+8], dx

; 455  : 	GameStart.cbMagicIndex = m_cbMagicIndex;

  00cbb	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00cc1	8a 88 7c 04 00
	00		 mov	 cl, BYTE PTR [eax+1148]
  00cc7	88 4d b2	 mov	 BYTE PTR _GameStart$[ebp+10], cl

; 456  : 	CopyMemory(GameStart.cbHeapCardInfo, m_cbHeapCardInfo, sizeof(GameStart.cbHeapCardInfo));

  00cca	6a 08		 push	 8
  00ccc	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00cd2	81 c2 b4 04 00
	00		 add	 edx, 1204		; 000004b4H
  00cd8	52		 push	 edx
  00cd9	8d 45 b3	 lea	 eax, DWORD PTR _GameStart$[ebp+11]
  00cdc	50		 push	 eax
  00cdd	e8 00 00 00 00	 call	 _memcpy
  00ce2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 457  : 
; 458  : 	CopyMemory(GameStart.lRoomCardInitialScore, m_lRoomCardInitialScore, sizeof(m_lRoomCardInitialScore));

  00ce5	6a 20		 push	 32			; 00000020H
  00ce7	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ced	81 c1 88 04 00
	00		 add	 ecx, 1160		; 00000488H
  00cf3	51		 push	 ecx
  00cf4	8d 55 ca	 lea	 edx, DWORD PTR _GameStart$[ebp+34]
  00cf7	52		 push	 edx
  00cf8	e8 00 00 00 00	 call	 _memcpy
  00cfd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 459  : 	CopyMemory(GameStart.cbPlayStatus, m_bPlayStatus, sizeof(m_bPlayStatus));

  00d00	6a 04		 push	 4
  00d02	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d08	05 7d 04 00 00	 add	 eax, 1149		; 0000047dH
  00d0d	50		 push	 eax
  00d0e	8d 4d ea	 lea	 ecx, DWORD PTR _GameStart$[ebp+66]
  00d11	51		 push	 ecx
  00d12	e8 00 00 00 00	 call	 _memcpy
  00d17	83 c4 0c	 add	 esp, 12			; 0000000cH

; 460  : 
; 461  : 	//发送数据
; 462  : 	bool bFirst = true;

  00d1a	c6 85 ce fb ff
	ff 01		 mov	 BYTE PTR _bFirst$[ebp], 1

; 463  : 	for (WORD i=0;i<m_cbPlayerCount;i++)

  00d21	33 d2		 xor	 edx, edx
  00d23	66 89 95 e0 fb
	ff ff		 mov	 WORD PTR _i$14[ebp], dx
  00d2a	eb 12		 jmp	 SHORT $LN21@OnEventGam
$LN19@OnEventGam:
  00d2c	66 8b 85 e0 fb
	ff ff		 mov	 ax, WORD PTR _i$14[ebp]
  00d33	66 83 c0 01	 add	 ax, 1
  00d37	66 89 85 e0 fb
	ff ff		 mov	 WORD PTR _i$14[ebp], ax
$LN21@OnEventGam:
  00d3e	0f b7 8d e0 fb
	ff ff		 movzx	 ecx, WORD PTR _i$14[ebp]
  00d45	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d4b	0f b6 42 09	 movzx	 eax, BYTE PTR [edx+9]
  00d4f	3b c8		 cmp	 ecx, eax
  00d51	0f 8d 80 02 00
	00		 jge	 $LN20@OnEventGam

; 464  : 	{
; 465  : 		IServerUserItem *pServerUserItem = m_pITableFrame->GetTableUserItem(i) ;

  00d57	0f b7 8d e0 fb
	ff ff		 movzx	 ecx, WORD PTR _i$14[ebp]
  00d5e	51		 push	 ecx
  00d5f	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d65	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00d6b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00d71	8b 10		 mov	 edx, DWORD PTR [eax]
  00d73	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00d79	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  00d7f	ff d0		 call	 eax
  00d81	89 85 b0 fb ff
	ff		 mov	 DWORD PTR _pServerUserItem$4[ebp], eax

; 466  : 		if(pServerUserItem == NULL)

  00d87	83 bd b0 fb ff
	ff 00		 cmp	 DWORD PTR _pServerUserItem$4[ebp], 0
  00d8e	75 02		 jne	 SHORT $LN34@OnEventGam

; 467  : 			continue;

  00d90	eb 9a		 jmp	 SHORT $LN19@OnEventGam
$LN34@OnEventGam:

; 468  : 
; 469  : 		GameStart.cbUserAction = m_cbUserAction[i];

  00d92	0f b7 8d e0 fb
	ff ff		 movzx	 ecx, WORD PTR _i$14[ebp]
  00d99	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d9f	8a 84 0a e4 05
	00 00		 mov	 al, BYTE PTR [edx+ecx+1508]
  00da6	88 45 bb	 mov	 BYTE PTR _GameStart$[ebp+19], al

; 470  : 		ZeroMemory(GameStart.cbCardData, sizeof(GameStart.cbCardData));

  00da9	6a 0e		 push	 14			; 0000000eH
  00dab	6a 00		 push	 0
  00dad	8d 4d bc	 lea	 ecx, DWORD PTR _GameStart$[ebp+20]
  00db0	51		 push	 ecx
  00db1	e8 00 00 00 00	 call	 _memset
  00db6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 471  : 		m_GameLogic.SwitchToCardData(m_cbCardIndex[i], GameStart.cbCardData);

  00db9	8d 55 bc	 lea	 edx, DWORD PTR _GameStart$[ebp+20]
  00dbc	52		 push	 edx
  00dbd	0f b7 85 e0 fb
	ff ff		 movzx	 eax, WORD PTR _i$14[ebp]
  00dc4	6b c8 22	 imul	 ecx, eax, 34
  00dc7	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00dcd	8d 84 0a b2 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1970]
  00dd4	50		 push	 eax
  00dd5	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ddb	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00de1	e8 00 00 00 00	 call	 ?SwitchToCardData@CGameLogic@@QAEEQBEQAE@Z ; CGameLogic::SwitchToCardData

; 472  : 
; 473  : 		m_pITableFrame->SendTableData(i, SUB_S_GAME_START, &GameStart, sizeof(GameStart));

  00de6	68 c8 00 00 00	 push	 200			; 000000c8H
  00deb	6a 46		 push	 70			; 00000046H
  00ded	8d 4d a8	 lea	 ecx, DWORD PTR _GameStart$[ebp]
  00df0	51		 push	 ecx
  00df1	6a 64		 push	 100			; 00000064H
  00df3	0f b7 95 e0 fb
	ff ff		 movzx	 edx, WORD PTR _i$14[ebp]
  00dfa	52		 push	 edx
  00dfb	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e01	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00e07	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00e0d	8b 01		 mov	 eax, DWORD PTR [ecx]
  00e0f	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00e15	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  00e1b	ff d2		 call	 edx

; 474  : 		m_pITableFrame->SendLookonData(i, SUB_S_GAME_START, &GameStart, sizeof(GameStart));		

  00e1d	6a 46		 push	 70			; 00000046H
  00e1f	8d 45 a8	 lea	 eax, DWORD PTR _GameStart$[ebp]
  00e22	50		 push	 eax
  00e23	6a 64		 push	 100			; 00000064H
  00e25	0f b7 8d e0 fb
	ff ff		 movzx	 ecx, WORD PTR _i$14[ebp]
  00e2c	51		 push	 ecx
  00e2d	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00e33	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  00e39	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e3f	8b 10		 mov	 edx, DWORD PTR [eax]
  00e41	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00e47	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  00e4d	ff d0		 call	 eax

; 475  : 
; 476  : 		if (m_pGameVideo)

  00e4f	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e55	83 b9 40 06 00
	00 00		 cmp	 DWORD PTR [ecx+1600], 0
  00e5c	0f 84 70 01 00
	00		 je	 $LN35@OnEventGam

; 477  : 		{
; 478  : 			Video_GameStart video;
; 479  : 			ZeroMemory(&video, sizeof(video));

  00e62	68 84 00 00 00	 push	 132			; 00000084H
  00e67	6a 00		 push	 0
  00e69	8d 95 1c ff ff
	ff		 lea	 edx, DWORD PTR _video$16[ebp]
  00e6f	52		 push	 edx
  00e70	e8 00 00 00 00	 call	 _memset
  00e75	83 c4 0c	 add	 esp, 12			; 0000000cH

; 480  : 			lstrcpyn(video.szNickName,pServerUserItem->GetNickName(),CountArray(video.szNickName));

  00e78	6a 20		 push	 32			; 00000020H
  00e7a	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _pServerUserItem$4[ebp]
  00e80	8b 10		 mov	 edx, DWORD PTR [eax]
  00e82	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pServerUserItem$4[ebp]
  00e88	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00e8b	ff d0		 call	 eax
  00e8d	50		 push	 eax
  00e8e	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _video$16[ebp]
  00e94	51		 push	 ecx
  00e95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpynW@12

; 481  : 			video.lScore			= pServerUserItem->GetUserScore();

  00e9b	8b 95 b0 fb ff
	ff		 mov	 edx, DWORD PTR _pServerUserItem$4[ebp]
  00ea1	8b 02		 mov	 eax, DWORD PTR [edx]
  00ea3	8b 8d b0 fb ff
	ff		 mov	 ecx, DWORD PTR _pServerUserItem$4[ebp]
  00ea9	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  00eaf	ff d2		 call	 edx
  00eb1	89 85 5e ff ff
	ff		 mov	 DWORD PTR _video$16[ebp+66], eax
  00eb7	89 95 62 ff ff
	ff		 mov	 DWORD PTR _video$16[ebp+70], edx

; 482  : 			video.lCellScore		= m_pITableFrame->GetCellScore();

  00ebd	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ec3	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00ec9	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00ecf	8b 01		 mov	 eax, DWORD PTR [ecx]
  00ed1	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00ed7	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00eda	ff d2		 call	 edx
  00edc	89 85 66 ff ff
	ff		 mov	 DWORD PTR _video$16[ebp+74], eax

; 483  : 			video.wChairID = i;

  00ee2	66 8b 85 e0 fb
	ff ff		 mov	 ax, WORD PTR _i$14[ebp]
  00ee9	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _video$16[ebp+64], ax

; 484  : 			video.wBankerUser = m_wBankerUser;

  00ef0	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00ef6	66 8b 91 72 04
	00 00		 mov	 dx, WORD PTR [ecx+1138]
  00efd	66 89 95 6a ff
	ff ff		 mov	 WORD PTR _video$16[ebp+78], dx

; 485  : 			video.wSiceCount = m_wSiceCount;

  00f04	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f0a	66 8b 88 70 04
	00 00		 mov	 cx, WORD PTR [eax+1136]
  00f11	66 89 8d 6c ff
	ff ff		 mov	 WORD PTR _video$16[ebp+80], cx

; 486  : 			video.cbMagicIndex=m_cbMagicIndex;

  00f18	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00f1e	8a 82 7c 04 00
	00		 mov	 al, BYTE PTR [edx+1148]
  00f24	88 85 6f ff ff
	ff		 mov	 BYTE PTR _video$16[ebp+83], al

; 487  : 			video.cbUserAction = m_cbUserAction[i];

  00f2a	0f b7 8d e0 fb
	ff ff		 movzx	 ecx, WORD PTR _i$14[ebp]
  00f31	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00f37	8a 84 0a e4 05
	00 00		 mov	 al, BYTE PTR [edx+ecx+1508]
  00f3e	88 85 70 ff ff
	ff		 mov	 BYTE PTR _video$16[ebp+84], al

; 488  : 			video.cbPlayerCount = m_cbPlayerCount;

  00f44	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f4a	8a 51 09	 mov	 dl, BYTE PTR [ecx+9]
  00f4d	88 95 6e ff ff
	ff		 mov	 BYTE PTR _video$16[ebp+82], dl

; 489  : 			video.cbMaCount = m_cbMaCount;

  00f53	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f59	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  00f5c	88 8d 7f ff ff
	ff		 mov	 BYTE PTR _video$16[ebp+99], cl

; 490  : 			CopyMemory(video.cbCardData,GameStart.cbCardData,sizeof(BYTE)*MAX_COUNT);

  00f62	6a 0e		 push	 14			; 0000000eH
  00f64	8d 55 bc	 lea	 edx, DWORD PTR _GameStart$[ebp+20]
  00f67	52		 push	 edx
  00f68	8d 85 71 ff ff
	ff		 lea	 eax, DWORD PTR _video$16[ebp+85]
  00f6e	50		 push	 eax
  00f6f	e8 00 00 00 00	 call	 _memcpy
  00f74	83 c4 0c	 add	 esp, 12			; 0000000cH

; 491  : 			CopyMemory(video.lRoomCardInitialScore, m_lRoomCardInitialScore, sizeof(m_lRoomCardInitialScore));

  00f77	6a 20		 push	 32			; 00000020H
  00f79	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f7f	81 c1 88 04 00
	00		 add	 ecx, 1160		; 00000488H
  00f85	51		 push	 ecx
  00f86	8d 55 80	 lea	 edx, DWORD PTR _video$16[ebp+100]
  00f89	52		 push	 edx
  00f8a	e8 00 00 00 00	 call	 _memcpy
  00f8f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 492  : 			m_pGameVideo->AddVideoData(SUB_S_GAME_START, &video,sizeof(video), bFirst);

  00f92	0f b6 85 ce fb
	ff ff		 movzx	 eax, BYTE PTR _bFirst$[ebp]
  00f99	50		 push	 eax
  00f9a	68 84 00 00 00	 push	 132			; 00000084H
  00f9f	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _video$16[ebp]
  00fa5	51		 push	 ecx
  00fa6	6a 64		 push	 100			; 00000064H
  00fa8	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00fae	8b 82 40 06 00
	00		 mov	 eax, DWORD PTR [edx+1600]
  00fb4	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00fba	8b 91 40 06 00
	00		 mov	 edx, DWORD PTR [ecx+1600]
  00fc0	8b 00		 mov	 eax, DWORD PTR [eax]
  00fc2	52		 push	 edx
  00fc3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00fc6	ff d1		 call	 ecx
  00fc8	83 c4 14	 add	 esp, 20			; 00000014H

; 493  : 			bFirst = false;

  00fcb	c6 85 ce fb ff
	ff 00		 mov	 BYTE PTR _bFirst$[ebp], 0
$LN35@OnEventGam:

; 494  : 		}
; 495  : 	}

  00fd2	e9 55 fd ff ff	 jmp	 $LN19@OnEventGam
$LN20@OnEventGam:

; 496  : 
; 497  : 
; 498  : 	m_pITableFrame->SetGameTimer(IDI_OUT_CARD, (m_pGameCustomRule->cbTimeOutCard + TIME_DISPATCH_CARD) * 1000, 1, 0);

  00fd7	6a 00		 push	 0
  00fd9	6a 01		 push	 1
  00fdb	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00fe1	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  00fe7	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00feb	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00fee	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  00ff4	52		 push	 edx
  00ff5	6a 03		 push	 3
  00ff7	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ffd	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  01003	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  01009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0100b	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  01011	8b 90 a4 00 00
	00		 mov	 edx, DWORD PTR [eax+164]
  01017	ff d2		 call	 edx

; 499  : 	m_tActionStartTime = time(0);

  01019	6a 00		 push	 0
  0101b	e8 00 00 00 00	 call	 _time
  01020	83 c4 04	 add	 esp, 4
  01023	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01029	89 81 a8 04 00
	00		 mov	 DWORD PTR [ecx+1192], eax
  0102f	89 91 ac 04 00
	00		 mov	 DWORD PTR [ecx+1196], edx

; 500  : 	cc.Format(_T("游戏开始1,庄家%d可动作%d"), m_wBankerUser, m_cbUserAction[m_wBankerUser]);

  01035	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0103b	0f b7 82 72 04
	00 00		 movzx	 eax, WORD PTR [edx+1138]
  01042	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01048	0f b6 94 01 e4
	05 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1508]
  01050	52		 push	 edx
  01051	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01057	0f b7 88 72 04
	00 00		 movzx	 ecx, WORD PTR [eax+1138]
  0105e	51		 push	 ecx
  0105f	68 00 00 00 00	 push	 OFFSET $SG313497
  01064	8d 95 ac fb ff
	ff		 lea	 edx, DWORD PTR _cc$[ebp]
  0106a	52		 push	 edx
  0106b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAAXPB_WZZ
  01071	83 c4 10	 add	 esp, 16			; 00000010H

; 501  : 	WriteDebugInfo(cc);

  01074	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _cc$[ebp]
  0107a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@_W$00@ATL@@QBEPB_WXZ
  01080	50		 push	 eax
  01081	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  01087	e8 00 00 00 00	 call	 ?WriteDebugInfo@CTableFrameSink@@IAEXPB_W@Z ; CTableFrameSink::WriteDebugInfo

; 502  : 	return true;

  0108c	c6 85 c2 fb ff
	ff 01		 mov	 BYTE PTR $T8[ebp], 1
  01093	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0109a	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _cc$[ebp]
  010a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
  010a6	8a 85 c2 fb ff
	ff		 mov	 al, BYTE PTR $T8[ebp]

; 503  : }

  010ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  010af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  010b6	59		 pop	 ecx
  010b7	5e		 pop	 esi
  010b8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010bb	33 cd		 xor	 ecx, ebp
  010bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010c2	8b e5		 mov	 esp, ebp
  010c4	5d		 pop	 ebp
  010c5	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnEventGameStart@CTableFrameSink@@UAE_NXZ$0:
  00000	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _cc$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnEventGameStart@CTableFrameSink@@UAE_NXZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 8a 8c fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1140]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnEventGameStart@CTableFrameSink@@UAE_NXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnEventGameStart@CTableFrameSink@@UAE_NXZ ENDP		; CTableFrameSink::OnEventGameStart
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.h
;	COMDAT ?QueryBuckleServiceCharge@CTableFrameSink@@UAE_NG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wChairID$ = 8						; size = 2
?QueryBuckleServiceCharge@CTableFrameSink@@UAE_NG@Z PROC ; CTableFrameSink::QueryBuckleServiceCharge, COMDAT
; _this$ = ecx

; 183  : 	virtual bool QueryBuckleServiceCharge(WORD wChairID){return true;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?QueryBuckleServiceCharge@CTableFrameSink@@UAE_NG@Z ENDP ; CTableFrameSink::QueryBuckleServiceCharge
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wChairID$ = 8						; size = 2
_pIServerUserItem$ = 12					; size = 4
?QueryLessEnterScore@CTableFrameSink@@UAE_JGPAUIServerUserItem@@@Z PROC ; CTableFrameSink::QueryLessEnterScore
; _this$ = ecx

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 272  : 	//金币游戏
; 273  : 	if (m_pGameServiceOption->wServerType&(GAME_GENRE_GOLD|SCORE_GENRE_POSITIVE))

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 88 30 09 00
	00		 mov	 ecx, DWORD PTR [eax+2352]
  00010	0f b7 51 54	 movzx	 edx, WORD PTR [ecx+84]
  00014	81 e2 01 02 00
	00		 and	 edx, 513		; 00000201H
  0001a	74 1f		 je	 SHORT $LN2@QueryLessE

; 274  : 	{		
; 275  : 		return 100 * m_pITableFrame->GetCellScore();

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00025	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	8b 8a 28 09 00
	00		 mov	 ecx, DWORD PTR [edx+2344]
  00030	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00033	ff d2		 call	 edx
  00035	6b c0 64	 imul	 eax, eax, 100
  00038	99		 cdq
  00039	eb 04		 jmp	 SHORT $LN1@QueryLessE
$LN2@QueryLessE:

; 276  : 	}
; 277  : 	return 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	33 d2		 xor	 edx, edx
$LN1@QueryLessE:

; 278  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?QueryLessEnterScore@CTableFrameSink@@UAE_JGPAUIServerUserItem@@@Z ENDP ; CTableFrameSink::QueryLessEnterScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pIServerUserItem$ = 8					; size = 4
?QueryConsumeQuota@CTableFrameSink@@UAE_JPAUIServerUserItem@@@Z PROC ; CTableFrameSink::QueryConsumeQuota
; _this$ = ecx

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 266  : 	return 0L;

  00007	33 c0		 xor	 eax, eax
  00009	33 d2		 xor	 edx, edx

; 267  : }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?QueryConsumeQuota@CTableFrameSink@@UAE_JPAUIServerUserItem@@@Z ENDP ; CTableFrameSink::QueryConsumeQuota
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_pIUnknownEx$ = 8					; size = 4
?Initialization@CTableFrameSink@@UAE_NPAUIUnknownEx@@@Z PROC ; CTableFrameSink::Initialization
; _this$ = ecx

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 232  : 	//查询接口
; 233  : 	m_pITableFrame=QUERY_OBJECT_PTR_INTERFACE(pIUnknownEx,ITableFrame);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pIUnknownEx$[ebp], 0
  0000d	75 09		 jne	 SHORT $LN6@Initializa
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  00016	eb 1a		 jmp	 SHORT $LN7@Initializa
$LN6@Initializa:
  00018	68 00 01 01 06	 push	 100729088		; 06010100H
  0001d	68 00 00 00 00	 push	 OFFSET ?IID_ITableFrame@@3U_GUID@@B
  00022	8b 45 08	 mov	 eax, DWORD PTR _pIUnknownEx$[ebp]
  00025	8b 10		 mov	 edx, DWORD PTR [eax]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pIUnknownEx$[ebp]
  0002a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002d	ff d0		 call	 eax
  0002f	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN7@Initializa:
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00038	89 91 28 09 00
	00		 mov	 DWORD PTR [ecx+2344], edx

; 234  : 
; 235  : 	//错误判断
; 236  : 	if (m_pITableFrame==NULL)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 b8 28 09 00
	00 00		 cmp	 DWORD PTR [eax+2344], 0
  00048	75 17		 jne	 SHORT $LN2@Initializa

; 237  : 	{
; 238  : 		CTraceService::TraceString(TEXT("游戏桌子 CTableFrameSink 查询 ITableFrame 接口失败"),TraceLevel_Exception);

  0004a	6a 03		 push	 3
  0004c	68 00 00 00 00	 push	 OFFSET $SG313410
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?TraceString@CTraceService@@SA_NPB_WW4enTraceLevel@@@Z
  00057	83 c4 08	 add	 esp, 8

; 239  : 		return false;

  0005a	32 c0		 xor	 al, al
  0005c	e9 eb 00 00 00	 jmp	 $LN1@Initializa
$LN2@Initializa:

; 240  : 	}
; 241  : 
; 242  : 	//游戏配置
; 243  : 	m_pGameServiceAttrib=m_pITableFrame->GetGameServiceAttrib();

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 12		 mov	 edx, DWORD PTR [edx]
  0006f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00075	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00078	ff d0		 call	 eax
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	89 81 34 09 00
	00		 mov	 DWORD PTR [ecx+2356], eax

; 244  : 	m_pGameServiceOption=m_pITableFrame->GetGameServiceOption();

  00083	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00086	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	8b 10		 mov	 edx, DWORD PTR [eax]
  00091	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00097	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0009a	ff d0		 call	 eax
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	89 81 30 09 00
	00		 mov	 DWORD PTR [ecx+2352], eax

; 245  : 
; 246  : 	//自定规则
; 247  : 	ASSERT(m_pITableFrame->GetCustomRule()!=NULL);
; 248  : 	m_pGameCustomRule=(tagCustomRule *)m_pITableFrame->GetCustomRule();

  000a5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	8b 10		 mov	 edx, DWORD PTR [eax]
  000b3	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  000b9	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000bc	ff d0		 call	 eax
  000be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	89 81 2c 09 00
	00		 mov	 DWORD PTR [ecx+2348], eax

; 249  : 
; 250  : 	m_cbMaCount = m_pGameCustomRule->cbMaCount;

  000c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	8b 82 2c 09 00
	00		 mov	 eax, DWORD PTR [edx+2348]
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	8a 10		 mov	 dl, BYTE PTR [eax]
  000d5	88 51 08	 mov	 BYTE PTR [ecx+8], dl

; 251  : 	m_cbPlayerCount = m_pGameCustomRule->cbPlayerCount;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000db	8b 88 2c 09 00
	00		 mov	 ecx, DWORD PTR [eax+2348]
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e4	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000e7	88 42 09	 mov	 BYTE PTR [edx+9], al

; 252  : 
; 253  : 	ZeroMemory(&m_stRecord,sizeof(m_stRecord));

  000ea	68 34 04 00 00	 push	 1076			; 00000434H
  000ef	6a 00		 push	 0
  000f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	83 c1 0a	 add	 ecx, 10			; 0000000aH
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 _memset
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 254  : 
; 255  : 	if( (m_pGameServiceOption->wServerType&GAME_GENRE_PERSONAL) !=0 )

  00100	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00103	8b 82 30 09 00
	00		 mov	 eax, DWORD PTR [edx+2352]
  00109	0f b7 48 54	 movzx	 ecx, WORD PTR [eax+84]
  0010d	83 e1 10	 and	 ecx, 16			; 00000010H
  00110	74 1d		 je	 SHORT $LN3@Initializa

; 256  : 		m_pITableFrame->SetStartMode(START_MODE_FULL_READY);

  00112	6a 01		 push	 1
  00114	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00117	8b 82 28 09 00
	00		 mov	 eax, DWORD PTR [edx+2344]
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	8b 10		 mov	 edx, DWORD PTR [eax]
  00122	8b 89 28 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2344]
  00128	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0012b	ff d0		 call	 eax

; 257  : 	else

  0012d	eb 1b		 jmp	 SHORT $LN4@Initializa
$LN3@Initializa:

; 258  : 		m_pITableFrame->SetStartMode(START_MODE_ALL_READY);

  0012f	6a 00		 push	 0
  00131	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	8b 91 28 09 00
	00		 mov	 edx, DWORD PTR [ecx+2344]
  0013a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013d	8b 12		 mov	 edx, DWORD PTR [edx]
  0013f	8b 88 28 09 00
	00		 mov	 ecx, DWORD PTR [eax+2344]
  00145	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00148	ff d0		 call	 eax
$LN4@Initializa:

; 259  : 
; 260  : 	return true;

  0014a	b0 01		 mov	 al, 1
$LN1@Initializa:

; 261  : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 04 00	 ret	 4
?Initialization@CTableFrameSink@@UAE_NPAUIUnknownEx@@@Z ENDP ; CTableFrameSink::Initialization
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RepositionSink@CTableFrameSink@@UAEXXZ PROC		; CTableFrameSink::RepositionSink
; _this$ = ecx

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 150  : 	//游戏变量
; 151  : 	m_wSiceCount = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	66 89 81 70 04
	00 00		 mov	 WORD PTR [ecx+1136], ax

; 152  : 	m_wCurrentUser = INVALID_CHAIR;

  00015	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	66 89 90 be 04
	00 00		 mov	 WORD PTR [eax+1214], dx

; 153  : 	m_cbMagicIndex = MAX_INDEX;

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	c6 81 7c 04 00
	00 22		 mov	 BYTE PTR [ecx+1148], 34	; 00000022H

; 154  : 	m_cbMinusHeadCount = 0;

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	c6 82 af 07 00
	00 00		 mov	 BYTE PTR [edx+1967], 0

; 155  : 	m_cbMinusLastCount = 0;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c6 80 b0 07 00
	00 00		 mov	 BYTE PTR [eax+1968], 0

; 156  : 	m_cbLeftCardCount = MAX_REPERTORY;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c6 81 b1 07 00
	00 70		 mov	 BYTE PTR [ecx+1969], 112 ; 00000070H

; 157  : 	m_cbEndLeftCount = 0;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	c6 82 ae 07 00
	00 00		 mov	 BYTE PTR [edx+1966], 0

; 158  : 	m_cbSendCardCount = 0;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c6 80 3d 07 00
	00 00		 mov	 BYTE PTR [eax+1853], 0

; 159  : 
; 160  : 	ZeroMemory(m_bTing, sizeof(m_bTing));

  00060	6a 04		 push	 4
  00062	6a 00		 push	 0
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	81 c1 74 04 00
	00		 add	 ecx, 1140		; 00000474H
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _memset
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 	ZeroMemory(m_bTrustee, sizeof(m_bTrustee));

  00076	6a 04		 push	 4
  00078	6a 00		 push	 0
  0007a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	81 c2 78 04 00
	00		 add	 edx, 1144		; 00000478H
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _memset
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 162  : 
; 163  : 	//堆立信息
; 164  : 	m_wHeapHead = INVALID_CHAIR;

  0008c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	66 89 81 b0 04
	00 00		 mov	 WORD PTR [ecx+1200], ax

; 165  : 	m_wHeapTail = INVALID_CHAIR;

  0009b	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	66 89 90 b2 04
	00 00		 mov	 WORD PTR [eax+1202], dx

; 166  : 	ZeroMemory(m_cbHeapCardInfo, sizeof(m_cbHeapCardInfo));

  000aa	6a 08		 push	 8
  000ac	6a 00		 push	 0
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	81 c1 b4 04 00
	00		 add	 ecx, 1204		; 000004b4H
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _memset
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 
; 168  : 	//运行变量
; 169  : 	m_cbProvideCard = 0;

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c3	c6 82 c2 04 00
	00 00		 mov	 BYTE PTR [edx+1218], 0

; 170  : 	m_wResumeUser = INVALID_CHAIR;

  000ca	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	66 89 81 bc 04
	00 00		 mov	 WORD PTR [ecx+1212], ax

; 171  : 	m_wProvideUser = INVALID_CHAIR;

  000d9	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	66 89 90 c0 04
	00 00		 mov	 WORD PTR [eax+1216], dx

; 172  : 
; 173  : 	//状态变量
; 174  : 	m_bGangOutCard = false;

  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	c6 81 c6 04 00
	00 00		 mov	 BYTE PTR [ecx+1222], 0

; 175  : 	m_enSendStatus = Not_Send;

  000f2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f5	c7 82 c8 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1224], 0

; 176  : 	m_cbGangStatus = WIK_GANERAL;

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	c6 80 cc 04 00
	00 00		 mov	 BYTE PTR [eax+1228], 0

; 177  : 	m_wProvideGangUser = INVALID_CHAIR;

  00109	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0010e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00111	66 89 8a ce 04
	00 00		 mov	 WORD PTR [edx+1230], cx

; 178  : 	ZeroMemory(m_bEnjoinChiHu, sizeof(m_bEnjoinChiHu));

  00118	6a 04		 push	 4
  0011a	6a 00		 push	 0
  0011c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	05 d0 04 00 00	 add	 eax, 1232		; 000004d0H
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _memset
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 179  : 	ZeroMemory(m_bEnjoinChiPeng, sizeof(m_bEnjoinChiPeng));	

  0012d	6a 04		 push	 4
  0012f	6a 00		 push	 0
  00131	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	81 c1 d4 04 00
	00		 add	 ecx, 1236		; 000004d4H
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _memset
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 180  : 	ZeroMemory(m_bEnjoinGang, sizeof(m_bEnjoinGang));

  00143	6a 04		 push	 4
  00145	6a 00		 push	 0
  00147	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0014a	81 c2 d8 04 00
	00		 add	 edx, 1240		; 000004d8H
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _memset
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 181  : 	ZeroMemory(m_cbChiPengCount, sizeof(m_cbChiPengCount));

  00159	6a 04		 push	 4
  0015b	6a 00		 push	 0
  0015d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00160	05 e6 04 00 00	 add	 eax, 1254		; 000004e6H
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _memset
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 182  : 	ZeroMemory(m_bGangCard, sizeof(m_bGangCard));	

  0016e	6a 04		 push	 4
  00170	6a 00		 push	 0
  00172	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00175	81 c1 dc 04 00
	00		 add	 ecx, 1244		; 000004dcH
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 _memset
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 	ZeroMemory(m_cbGangCount, sizeof(m_cbGangCount));

  00184	6a 04		 push	 4
  00186	6a 00		 push	 0
  00188	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0018b	81 c2 e2 04 00
	00		 add	 edx, 1250		; 000004e2H
  00191	52		 push	 edx
  00192	e8 00 00 00 00	 call	 _memset
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 
; 185  : 	for(int i = 0; i < GAME_PLAYER; i++)

  0019a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  001a1	eb 09		 jmp	 SHORT $LN4@Reposition
$LN2@Reposition:
  001a3	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  001a6	83 c0 01	 add	 eax, 1
  001a9	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Reposition:
  001ac	83 7d f8 04	 cmp	 DWORD PTR _i$1[ebp], 4
  001b0	7d 28		 jge	 SHORT $LN3@Reposition

; 186  : 	{
; 187  : 		m_vecEnjoinChiHu[i].clear();

  001b2	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$1[ebp], 12
  001b6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001b9	8d 8c 0a ec 04
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+1260]
  001c0	e8 00 00 00 00	 call	 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear

; 188  : 		m_vecEnjoinChiPeng[i].clear();	

  001c5	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  001c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	8d 8c 01 1c 05
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+1308]
  001d3	e8 00 00 00 00	 call	 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear

; 189  : 	}

  001d8	eb c9		 jmp	 SHORT $LN2@Reposition
$LN3@Reposition:

; 190  : 
; 191  : 	//用户状态
; 192  : 	ZeroMemory(m_bResponse, sizeof(m_bResponse));

  001da	6a 04		 push	 4
  001dc	6a 00		 push	 0
  001de	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001e1	81 c2 e0 05 00
	00		 add	 edx, 1504		; 000005e0H
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 _memset
  001ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 193  : 	ZeroMemory(m_cbUserAction, sizeof(m_cbUserAction));

  001f0	6a 04		 push	 4
  001f2	6a 00		 push	 0
  001f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f7	05 e4 05 00 00	 add	 eax, 1508		; 000005e4H
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 _memset
  00202	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  : 	ZeroMemory(m_cbOperateCard, sizeof(m_cbOperateCard));

  00205	6a 0c		 push	 12			; 0000000cH
  00207	6a 00		 push	 0
  00209	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	81 c1 e8 05 00
	00		 add	 ecx, 1512		; 000005e8H
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 _memset
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  : 	ZeroMemory(m_cbPerformAction, sizeof(m_cbPerformAction));

  0021b	6a 04		 push	 4
  0021d	6a 00		 push	 0
  0021f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00222	81 c2 f4 05 00
	00		 add	 edx, 1524		; 000005f4H
  00228	52		 push	 edx
  00229	e8 00 00 00 00	 call	 _memset
  0022e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 
; 197  : 	//组合扑克
; 198  : 	ZeroMemory(m_WeaveItemArray, sizeof(m_WeaveItemArray));

  00231	68 90 00 00 00	 push	 144			; 00000090H
  00236	6a 00		 push	 0
  00238	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023b	05 42 08 00 00	 add	 eax, 2114		; 00000842H
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 _memset
  00246	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  : 	ZeroMemory(m_cbWeaveItemCount, sizeof(m_cbWeaveItemCount));

  00249	6a 04		 push	 4
  0024b	6a 00		 push	 0
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	81 c1 3e 08 00
	00		 add	 ecx, 2110		; 0000083eH
  00256	51		 push	 ecx
  00257	e8 00 00 00 00	 call	 _memset
  0025c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 
; 201  : 	//结束信息
; 202  : 	m_cbChiHuCard=0;

  0025f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00262	c6 82 18 06 00
	00 00		 mov	 BYTE PTR [edx+1560], 0

; 203  : 	ZeroMemory(m_dwChiHuKind, sizeof(m_dwChiHuKind));

  00269	6a 10		 push	 16			; 00000010H
  0026b	6a 00		 push	 0
  0026d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00270	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  00275	50		 push	 eax
  00276	e8 00 00 00 00	 call	 _memset
  0027b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 	
; 205  : 	//出牌信息
; 206  : 	m_cbOutCardData = 0;

  0027e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00281	c6 81 46 06 00
	00 00		 mov	 BYTE PTR [ecx+1606], 0

; 207  : 	m_cbOutCardCount = 0;

  00288	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0028b	c6 82 47 06 00
	00 00		 mov	 BYTE PTR [edx+1607], 0

; 208  : 	m_wOutCardUser = INVALID_CHAIR;

  00292	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00297	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029a	66 89 81 44 06
	00 00		 mov	 WORD PTR [ecx+1604], ax

; 209  : 
; 210  : 	ZeroMemory(m_cbDiscardCard, sizeof(m_cbDiscardCard));

  002a1	68 f0 00 00 00	 push	 240			; 000000f0H
  002a6	6a 00		 push	 0
  002a8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ab	81 c2 4c 06 00
	00		 add	 edx, 1612		; 0000064cH
  002b1	52		 push	 edx
  002b2	e8 00 00 00 00	 call	 _memset
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 211  : 	ZeroMemory(m_cbDiscardCount, sizeof(m_cbDiscardCount));

  002ba	6a 04		 push	 4
  002bc	6a 00		 push	 0
  002be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002c1	05 48 06 00 00	 add	 eax, 1608		; 00000648H
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 _memset
  002cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 212  : 
; 213  : 	//扑克信息
; 214  : 	ZeroMemory(m_cbCardIndex, sizeof(m_cbCardIndex));

  002cf	68 88 00 00 00	 push	 136			; 00000088H
  002d4	6a 00		 push	 0
  002d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d9	81 c1 b2 07 00
	00		 add	 ecx, 1970		; 000007b2H
  002df	51		 push	 ecx
  002e0	e8 00 00 00 00	 call	 _memset
  002e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 215  : 	ZeroMemory(m_cbHandCardCount, sizeof(m_cbHandCardCount));

  002e8	6a 04		 push	 4
  002ea	6a 00		 push	 0
  002ec	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ef	81 c2 3a 08 00
	00		 add	 edx, 2106		; 0000083aH
  002f5	52		 push	 edx
  002f6	e8 00 00 00 00	 call	 _memset
  002fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 216  : 	ZeroMemory(m_cbUserCatchCardCount,sizeof(m_cbUserCatchCardCount));

  002fe	6a 04		 push	 4
  00300	6a 00		 push	 0
  00302	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00305	05 4c 05 00 00	 add	 eax, 1356		; 0000054cH
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 _memset
  00310	83 c4 0c	 add	 esp, 12			; 0000000cH

; 217  : 	ZeroMemory(m_bTrustee,sizeof(m_bTrustee));

  00313	6a 04		 push	 4
  00315	6a 00		 push	 0
  00317	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031a	81 c1 78 04 00
	00		 add	 ecx, 1144		; 00000478H
  00320	51		 push	 ecx
  00321	e8 00 00 00 00	 call	 _memset
  00326	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 	ZeroMemory(m_lUserGangScore,sizeof(m_lUserGangScore));

  00329	6a 20		 push	 32			; 00000020H
  0032b	6a 00		 push	 0
  0032d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00330	81 c2 f8 05 00
	00		 add	 edx, 1528		; 000005f8H
  00336	52		 push	 edx
  00337	e8 00 00 00 00	 call	 _memset
  0033c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 219  : 	ZeroMemory(m_bPlayStatus,sizeof(m_bPlayStatus));

  0033f	6a 04		 push	 4
  00341	6a 00		 push	 0
  00343	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00346	05 7d 04 00 00	 add	 eax, 1149		; 0000047dH
  0034b	50		 push	 eax
  0034c	e8 00 00 00 00	 call	 _memset
  00351	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  : 
; 221  : 	m_wLastCatchCardUser=INVALID_CHAIR;

  00354	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00359	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0035c	66 89 8a c4 04
	00 00		 mov	 WORD PTR [edx+1220], cx

; 222  : 
; 223  : 	ZeroMemory(m_cbHuCardCount,sizeof(m_cbHuCardCount));

  00363	6a 04		 push	 4
  00365	6a 00		 push	 0
  00367	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0036a	05 50 05 00 00	 add	 eax, 1360		; 00000550H
  0036f	50		 push	 eax
  00370	e8 00 00 00 00	 call	 _memset
  00375	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  : 	ZeroMemory(m_cbHuCardData,sizeof(m_cbHuCardData));

  00378	68 88 00 00 00	 push	 136			; 00000088H
  0037d	6a 00		 push	 0
  0037f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00382	81 c1 54 05 00
	00		 add	 ecx, 1364		; 00000554H
  00388	51		 push	 ecx
  00389	e8 00 00 00 00	 call	 _memset
  0038e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 225  : 	ZeroMemory(m_cbUserMaCount,sizeof(m_cbUserMaCount));

  00391	6a 04		 push	 4
  00393	6a 00		 push	 0
  00395	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00398	81 c2 dc 05 00
	00		 add	 edx, 1500		; 000005dcH
  0039e	52		 push	 edx
  0039f	e8 00 00 00 00	 call	 _memset
  003a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 226  : 	return;
; 227  : }

  003a7	8b e5		 mov	 esp, ebp
  003a9	5d		 pop	 ebp
  003aa	c3		 ret	 0
?RepositionSink@CTableFrameSink@@UAEXXZ ENDP		; CTableFrameSink::RepositionSink
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_Guid$ = 8						; size = 4
_dwQueryVer$ = 12					; size = 4
?QueryInterface@CTableFrameSink@@UAEPAXABU_GUID@@K@Z PROC ; CTableFrameSink::QueryInterface
; _this$ = ecx

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 	QUERYINTERFACE(ITableFrameSink,Guid,dwQueryVer);

  00009	68 00 00 00 00	 push	 OFFSET ?IID_ITableFrameSink@@3U_GUID@@B
  0000e	8b 45 08	 mov	 eax, DWORD PTR _Guid$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _==
  00017	83 c4 08	 add	 esp, 8
  0001a	0f b6 c8	 movzx	 ecx, al
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 20		 je	 SHORT $LN2@QueryInter
  00021	68 00 01 01 06	 push	 100729088		; 06010100H
  00026	8b 55 0c	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  0002f	83 c4 08	 add	 esp, 8
  00032	0f b6 c0	 movzx	 eax, al
  00035	85 c0		 test	 eax, eax
  00037	74 08		 je	 SHORT $LN2@QueryInter
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	e9 84 00 00 00	 jmp	 $LN1@QueryInter
$LN2@QueryInter:

; 142  : 	QUERYINTERFACE(ITableUserAction,Guid,dwQueryVer);

  00041	68 00 00 00 00	 push	 OFFSET ?IID_ITableUserAction@@3U_GUID@@B
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Guid$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _==
  0004f	83 c4 08	 add	 esp, 8
  00052	0f b6 d0	 movzx	 edx, al
  00055	85 d2		 test	 edx, edx
  00057	74 35		 je	 SHORT $LN3@QueryInter
  00059	68 00 01 01 06	 push	 100729088		; 06010100H
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  00067	83 c4 08	 add	 esp, 8
  0006a	0f b6 c8	 movzx	 ecx, al
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 1d		 je	 SHORT $LN3@QueryInter
  00071	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  00075	74 0b		 je	 SHORT $LN6@QueryInter
  00077	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	83 c2 04	 add	 edx, 4
  0007d	89 55 f8	 mov	 DWORD PTR tv92[ebp], edx
  00080	eb 07		 jmp	 SHORT $LN7@QueryInter
$LN6@QueryInter:
  00082	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN7@QueryInter:
  00089	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  0008c	eb 37		 jmp	 SHORT $LN1@QueryInter
$LN3@QueryInter:

; 143  : 	QUERYINTERFACE_IUNKNOWNEX(ITableFrameSink,Guid,dwQueryVer);

  0008e	68 00 00 00 00	 push	 OFFSET ?IID_IUnknownEx@@3U_GUID@@B
  00093	8b 45 08	 mov	 eax, DWORD PTR _Guid$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _==
  0009c	83 c4 08	 add	 esp, 8
  0009f	0f b6 c8	 movzx	 ecx, al
  000a2	85 c9		 test	 ecx, ecx
  000a4	74 1d		 je	 SHORT $LN4@QueryInter
  000a6	68 00 01 01 06	 push	 100729088		; 06010100H
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  000b4	83 c4 08	 add	 esp, 8
  000b7	0f b6 c0	 movzx	 eax, al
  000ba	85 c0		 test	 eax, eax
  000bc	74 05		 je	 SHORT $LN4@QueryInter
  000be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	eb 02		 jmp	 SHORT $LN1@QueryInter
$LN4@QueryInter:

; 144  : 	return NULL;

  000c3	33 c0		 xor	 eax, eax
$LN1@QueryInter:

; 145  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 08 00	 ret	 8
?QueryInterface@CTableFrameSink@@UAEPAXABU_GUID@@K@Z ENDP ; CTableFrameSink::QueryInterface
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.h
;	COMDAT ?Release@CTableFrameSink@@UAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
$T1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
?Release@CTableFrameSink@@UAEXXZ PROC			; CTableFrameSink::Release, COMDAT
; _this$ = ecx

; 165  : 	virtual VOID Release() { delete this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
  00015	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00019	74 14		 je	 SHORT $LN3@Release
  0001b	6a 01		 push	 1
  0001d	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00025	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  00028	ff d2		 call	 edx
  0002a	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  0002d	eb 07		 jmp	 SHORT $LN1@Release
$LN3@Release:
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN1@Release:
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?Release@CTableFrameSink@@UAEXXZ ENDP			; CTableFrameSink::Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
tv134 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTableFrameSink@@UAE@XZ PROC				; CTableFrameSink::~CTableFrameSink
; _this$ = ecx

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTableFrameSink@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTableFrameSink@@6BITableFrameSink@@@
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_7CTableFrameSink@@6BITableUserAction@@@

; 125  : 	if(m_pGameVideo)

  0003b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	83 ba 40 06 00
	00 00		 cmp	 DWORD PTR [edx+1600], 0
  00045	74 3f		 je	 SHORT $LN2@CTableFram

; 126  : 	{
; 127  : 		delete m_pGameVideo;

  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 88 40 06 00
	00		 mov	 ecx, DWORD PTR [eax+1600]
  00050	89 4d e8	 mov	 DWORD PTR $T2[ebp], ecx
  00053	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp]
  00056	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
  00059	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  0005d	74 13		 je	 SHORT $LN5@CTableFram
  0005f	6a 01		 push	 1
  00061	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00064	8b 10		 mov	 edx, DWORD PTR [eax]
  00066	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00069	8b 02		 mov	 eax, DWORD PTR [edx]
  0006b	ff d0		 call	 eax
  0006d	89 45 e4	 mov	 DWORD PTR tv134[ebp], eax
  00070	eb 07		 jmp	 SHORT $LN6@CTableFram
$LN5@CTableFram:
  00072	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
$LN6@CTableFram:

; 128  : 		m_pGameVideo = NULL;

  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	c7 81 40 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1600], 0
$LN2@CTableFram:

; 129  : 	}
; 130  : 
; 131  : 	if(m_hVideoInst)

  00086	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00089	83 ba 3c 06 00
	00 00		 cmp	 DWORD PTR [edx+1596], 0
  00090	74 1d		 je	 SHORT $LN1@CTableFram

; 132  : 	{
; 133  : 		FreeLibrary(m_hVideoInst);

  00092	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 88 3c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1596]
  0009b	51		 push	 ecx
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 134  : 		m_hVideoInst = NULL;

  000a2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	c7 82 3c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1596], 0
$LN1@CTableFram:

; 135  : 	}
; 136  : }

  000af	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	81 c1 e0 08 00
	00		 add	 ecx, 2272		; 000008e0H
  000b8	e8 00 00 00 00	 call	 ??1CHistoryScore@@UAE@XZ ; CHistoryScore::~CHistoryScore
  000bd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  000c6	e8 00 00 00 00	 call	 ??1CGameLogic@@UAE@XZ	; CGameLogic::~CGameLogic
  000cb	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  000d0	6a 04		 push	 4
  000d2	6a 0c		 push	 12			; 0000000cH
  000d4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	05 1c 05 00 00	 add	 eax, 1308		; 0000051cH
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000e2	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  000e7	6a 04		 push	 4
  000e9	6a 0c		 push	 12			; 0000000cH
  000eb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	81 c1 ec 04 00
	00		 add	 ecx, 1260		; 000004ecH
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000fa	68 00 00 00 00	 push	 OFFSET ??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
  000ff	6a 04		 push	 4
  00101	6a 0c		 push	 12			; 0000000cH
  00103	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00106	81 c2 40 04 00
	00		 add	 edx, 1088		; 00000440H
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00112	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1CTableFrameSink@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CTableFrameSink@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CTableFrameSink@@UAE@XZ ENDP				; CTableFrameSink::~CTableFrameSink
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.h
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
_TEXT	SEGMENT
_GameVideo$2 = -24					; size = 4
_this$ = -20						; size = 4
_i$3 = -16						; size = 2
__$EHRec$ = -12						; size = 12
??0CTableFrameSink@@QAE@XZ PROC				; CTableFrameSink::CTableFrameSink
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTableFrameSink@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0ITableFrameSink@@QAE@XZ
  00030	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 04	 add	 ecx, 4
  00036	e8 00 00 00 00	 call	 ??0ITableUserAction@@QAE@XZ
  0003b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTableFrameSink@@6BITableFrameSink@@@
  00044	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_7CTableFrameSink@@6BITableUserAction@@@
  0004e	68 00 00 00 00	 push	 OFFSET ??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
  00053	68 00 00 00 00	 push	 OFFSET ??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
  00058	6a 04		 push	 4
  0005a	6a 0c		 push	 12			; 0000000cH
  0005c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	81 c2 40 04 00
	00		 add	 edx, 1088		; 00000440H
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00072	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00077	68 00 00 00 00	 push	 OFFSET ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  0007c	6a 04		 push	 4
  0007e	6a 0c		 push	 12			; 0000000cH
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	05 ec 04 00 00	 add	 eax, 1260		; 000004ecH
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0008e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00092	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00097	68 00 00 00 00	 push	 OFFSET ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  0009c	6a 04		 push	 4
  0009e	6a 0c		 push	 12			; 0000000cH
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	81 c1 1c 05 00
	00		 add	 ecx, 1308		; 0000051cH
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  000af	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.h

; 98   : 	BYTE						m_cbChiHuCard;									//吃胡扑克

  000b3	68 00 00 00 00	 push	 OFFSET ??0CChiHuRight@@QAE@XZ ; CChiHuRight::CChiHuRight
  000b8	6a 04		 push	 4
  000ba	6a 04		 push	 4
  000bc	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000bf	81 c2 2c 06 00
	00		 add	 edx, 1580		; 0000062cH
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp

; 11   : {

  000cb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  000d4	e8 00 00 00 00	 call	 ??0CGameLogic@@QAE@XZ	; CGameLogic::CGameLogic
  000d9	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	81 c1 e0 08 00
	00		 add	 ecx, 2272		; 000008e0H
  000e6	e8 00 00 00 00	 call	 ??0CHistoryScore@@QAE@XZ ; CHistoryScore::CHistoryScore
  000eb	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 12   : 	//组件变量
; 13   : 	m_pITableFrame = NULL;

  000ef	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	c7 80 28 09 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2344], 0

; 14   : 	m_pGameCustomRule = NULL;

  000fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	c7 81 2c 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2348], 0

; 15   : 	m_pGameServiceOption = NULL;

  00109	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0010c	c7 82 30 09 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+2352], 0

; 16   : 	m_pGameServiceAttrib = NULL;	

  00116	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00119	c7 80 34 09 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2356], 0

; 17   : 
; 18   : 	//游戏变量
; 19   : 	m_wSiceCount = 0;

  00123	33 c9		 xor	 ecx, ecx
  00125	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00128	66 89 8a 70 04
	00 00		 mov	 WORD PTR [edx+1136], cx

; 20   : 	m_wBankerUser = INVALID_CHAIR;

  0012f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00134	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	66 89 81 72 04
	00 00		 mov	 WORD PTR [ecx+1138], ax

; 21   : 	m_wLianZhuang = 1;

  0013e	ba 01 00 00 00	 mov	 edx, 1
  00143	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00146	66 89 90 e0 04
	00 00		 mov	 WORD PTR [eax+1248], dx

; 22   : 	m_wCurrentUser = INVALID_CHAIR;

  0014d	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00152	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00155	66 89 8a be 04
	00 00		 mov	 WORD PTR [edx+1214], cx

; 23   : 	m_cbMagicIndex = MAX_INDEX;

  0015c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0015f	c6 80 7c 04 00
	00 22		 mov	 BYTE PTR [eax+1148], 34	; 00000022H

; 24   : 	ZeroMemory(m_bTing, sizeof(m_bTing));

  00166	6a 04		 push	 4
  00168	6a 00		 push	 0
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	81 c1 74 04 00
	00		 add	 ecx, 1140		; 00000474H
  00173	51		 push	 ecx
  00174	e8 00 00 00 00	 call	 _memset
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25   : 	ZeroMemory(m_bTrustee, sizeof(m_bTrustee));

  0017c	6a 04		 push	 4
  0017e	6a 00		 push	 0
  00180	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00183	81 c2 78 04 00
	00		 add	 edx, 1144		; 00000478H
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 _memset
  0018f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26   : 	
; 27   : 	for (WORD i=0; i<GAME_PLAYER; i++)

  00192	33 c0		 xor	 eax, eax
  00194	66 89 45 f0	 mov	 WORD PTR _i$3[ebp], ax
  00198	eb 0c		 jmp	 SHORT $LN4@CTableFram
$LN2@CTableFram:
  0019a	66 8b 4d f0	 mov	 cx, WORD PTR _i$3[ebp]
  0019e	66 83 c1 01	 add	 cx, 1
  001a2	66 89 4d f0	 mov	 WORD PTR _i$3[ebp], cx
$LN4@CTableFram:
  001a6	0f b7 55 f0	 movzx	 edx, WORD PTR _i$3[ebp]
  001aa	83 fa 04	 cmp	 edx, 4
  001ad	7d 1f		 jge	 SHORT $LN3@CTableFram

; 28   : 	{
; 29   : 		m_lRoomCardInitialScore[i] = INVALID_LONGLONG;

  001af	0f b7 45 f0	 movzx	 eax, WORD PTR _i$3[ebp]
  001b3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b6	c7 84 c1 88 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*8+1160], -1
  001c1	c7 84 c1 8c 04
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*8+1164], 0

; 30   : 	}

  001cc	eb cc		 jmp	 SHORT $LN2@CTableFram
$LN3@CTableFram:

; 31   : 
; 32   : 	//堆立信息
; 33   : 	m_wHeapHead = INVALID_CHAIR;

  001ce	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  001d3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001d6	66 89 90 b0 04
	00 00		 mov	 WORD PTR [eax+1200], dx

; 34   : 	m_wHeapTail = INVALID_CHAIR;

  001dd	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001e2	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001e5	66 89 8a b2 04
	00 00		 mov	 WORD PTR [edx+1202], cx

; 35   : 	ZeroMemory(m_cbHeapCardInfo, sizeof(m_cbHeapCardInfo));

  001ec	6a 08		 push	 8
  001ee	6a 00		 push	 0
  001f0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001f3	05 b4 04 00 00	 add	 eax, 1204		; 000004b4H
  001f8	50		 push	 eax
  001f9	e8 00 00 00 00	 call	 _memset
  001fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 36   : 
; 37   : 	//运行变量
; 38   : 	m_cbProvideCard = 0;

  00201	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00204	c6 81 c2 04 00
	00 00		 mov	 BYTE PTR [ecx+1218], 0

; 39   : 	m_wResumeUser = INVALID_CHAIR;

  0020b	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00210	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00213	66 89 90 bc 04
	00 00		 mov	 WORD PTR [eax+1212], dx

; 40   : 	m_wProvideUser = INVALID_CHAIR;

  0021a	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0021f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00222	66 89 8a c0 04
	00 00		 mov	 WORD PTR [edx+1216], cx

; 41   : 
; 42   : 	//用户状态
; 43   : 	ZeroMemory(m_bResponse, sizeof(m_bResponse));

  00229	6a 04		 push	 4
  0022b	6a 00		 push	 0
  0022d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00230	05 e0 05 00 00	 add	 eax, 1504		; 000005e0H
  00235	50		 push	 eax
  00236	e8 00 00 00 00	 call	 _memset
  0023b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 	ZeroMemory(m_cbUserAction, sizeof(m_cbUserAction));

  0023e	6a 04		 push	 4
  00240	6a 00		 push	 0
  00242	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	81 c1 e4 05 00
	00		 add	 ecx, 1508		; 000005e4H
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 _memset
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH

; 45   : 	ZeroMemory(m_cbOperateCard, sizeof(m_cbOperateCard));

  00254	6a 0c		 push	 12			; 0000000cH
  00256	6a 00		 push	 0
  00258	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0025b	81 c2 e8 05 00
	00		 add	 edx, 1512		; 000005e8H
  00261	52		 push	 edx
  00262	e8 00 00 00 00	 call	 _memset
  00267	83 c4 0c	 add	 esp, 12			; 0000000cH

; 46   : 	ZeroMemory(m_cbPerformAction, sizeof(m_cbPerformAction));

  0026a	6a 04		 push	 4
  0026c	6a 00		 push	 0
  0026e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00271	05 f4 05 00 00	 add	 eax, 1524		; 000005f4H
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 _memset
  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   : 
; 48   : 	//组合扑克
; 49   : 	ZeroMemory(m_WeaveItemArray, sizeof(m_WeaveItemArray));

  0027f	68 90 00 00 00	 push	 144			; 00000090H
  00284	6a 00		 push	 0
  00286	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00289	81 c1 42 08 00
	00		 add	 ecx, 2114		; 00000842H
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 _memset
  00295	83 c4 0c	 add	 esp, 12			; 0000000cH

; 50   : 	ZeroMemory(m_cbWeaveItemCount, sizeof(m_cbWeaveItemCount));

  00298	6a 04		 push	 4
  0029a	6a 00		 push	 0
  0029c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0029f	81 c2 3e 08 00
	00		 add	 edx, 2110		; 0000083eH
  002a5	52		 push	 edx
  002a6	e8 00 00 00 00	 call	 _memset
  002ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 
; 52   : 	//结束信息
; 53   : 	m_cbChiHuCard = 0;

  002ae	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002b1	c6 80 18 06 00
	00 00		 mov	 BYTE PTR [eax+1560], 0

; 54   : 	ZeroMemory(m_dwChiHuKind, sizeof(m_dwChiHuKind));

  002b8	6a 10		 push	 16			; 00000010H
  002ba	6a 00		 push	 0
  002bc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002bf	81 c1 1c 06 00
	00		 add	 ecx, 1564		; 0000061cH
  002c5	51		 push	 ecx
  002c6	e8 00 00 00 00	 call	 _memset
  002cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   : 	//状态变量
; 57   : 	m_bGangOutCard = false;

  002ce	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002d1	c6 82 c6 04 00
	00 00		 mov	 BYTE PTR [edx+1222], 0

; 58   : 	m_enSendStatus = Not_Send;

  002d8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002db	c7 80 c8 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1224], 0

; 59   : 	m_cbGangStatus = WIK_GANERAL;

  002e5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	c6 81 cc 04 00
	00 00		 mov	 BYTE PTR [ecx+1228], 0

; 60   : 	m_wProvideGangUser = INVALID_CHAIR;

  002ef	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  002f4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002f7	66 89 90 ce 04
	00 00		 mov	 WORD PTR [eax+1230], dx

; 61   : 	ZeroMemory(m_bEnjoinChiHu, sizeof(m_bEnjoinChiHu));

  002fe	6a 04		 push	 4
  00300	6a 00		 push	 0
  00302	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00305	81 c1 d0 04 00
	00		 add	 ecx, 1232		; 000004d0H
  0030b	51		 push	 ecx
  0030c	e8 00 00 00 00	 call	 _memset
  00311	83 c4 0c	 add	 esp, 12			; 0000000cH

; 62   : 	ZeroMemory(m_bEnjoinChiPeng, sizeof(m_bEnjoinChiPeng));

  00314	6a 04		 push	 4
  00316	6a 00		 push	 0
  00318	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0031b	81 c2 d4 04 00
	00		 add	 edx, 1236		; 000004d4H
  00321	52		 push	 edx
  00322	e8 00 00 00 00	 call	 _memset
  00327	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   : 	ZeroMemory(m_bEnjoinGang, sizeof(m_bEnjoinGang));

  0032a	6a 04		 push	 4
  0032c	6a 00		 push	 0
  0032e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00331	05 d8 04 00 00	 add	 eax, 1240		; 000004d8H
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 _memset
  0033c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 64   : 	ZeroMemory(m_bGangCard, sizeof(m_bGangCard));

  0033f	6a 04		 push	 4
  00341	6a 00		 push	 0
  00343	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00346	81 c1 dc 04 00
	00		 add	 ecx, 1244		; 000004dcH
  0034c	51		 push	 ecx
  0034d	e8 00 00 00 00	 call	 _memset
  00352	83 c4 0c	 add	 esp, 12			; 0000000cH

; 65   : 	ZeroMemory(m_cbChiPengCount, sizeof(m_cbChiPengCount));	

  00355	6a 04		 push	 4
  00357	6a 00		 push	 0
  00359	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0035c	81 c2 e6 04 00
	00		 add	 edx, 1254		; 000004e6H
  00362	52		 push	 edx
  00363	e8 00 00 00 00	 call	 _memset
  00368	83 c4 0c	 add	 esp, 12			; 0000000cH

; 66   : 	ZeroMemory(m_cbGangCount, sizeof(m_cbGangCount));

  0036b	6a 04		 push	 4
  0036d	6a 00		 push	 0
  0036f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00372	05 e2 04 00 00	 add	 eax, 1250		; 000004e2H
  00377	50		 push	 eax
  00378	e8 00 00 00 00	 call	 _memset
  0037d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   : 
; 68   : 	//出牌信息
; 69   : 	m_cbOutCardData = 0;

  00380	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00383	c6 81 46 06 00
	00 00		 mov	 BYTE PTR [ecx+1606], 0

; 70   : 	m_cbOutCardCount = 0;

  0038a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0038d	c6 82 47 06 00
	00 00		 mov	 BYTE PTR [edx+1607], 0

; 71   : 	m_wOutCardUser = INVALID_CHAIR;

  00394	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00399	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0039c	66 89 81 44 06
	00 00		 mov	 WORD PTR [ecx+1604], ax

; 72   : 
; 73   : 	ZeroMemory(m_cbDiscardCard, sizeof(m_cbDiscardCard));

  003a3	68 f0 00 00 00	 push	 240			; 000000f0H
  003a8	6a 00		 push	 0
  003aa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  003ad	81 c2 4c 06 00
	00		 add	 edx, 1612		; 0000064cH
  003b3	52		 push	 edx
  003b4	e8 00 00 00 00	 call	 _memset
  003b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 74   : 	ZeroMemory(m_cbDiscardCount, sizeof(m_cbDiscardCount));

  003bc	6a 04		 push	 4
  003be	6a 00		 push	 0
  003c0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003c3	05 48 06 00 00	 add	 eax, 1608		; 00000648H
  003c8	50		 push	 eax
  003c9	e8 00 00 00 00	 call	 _memset
  003ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 75   : 
; 76   : 	//出牌信息
; 77   : 	m_cbMinusHeadCount = 0;

  003d1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003d4	c6 81 af 07 00
	00 00		 mov	 BYTE PTR [ecx+1967], 0

; 78   : 	m_cbMinusLastCount = 0;

  003db	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  003de	c6 82 b0 07 00
	00 00		 mov	 BYTE PTR [edx+1968], 0

; 79   : 	m_cbLeftCardCount = MAX_REPERTORY;

  003e5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003e8	c6 80 b1 07 00
	00 70		 mov	 BYTE PTR [eax+1969], 112 ; 00000070H

; 80   : 	m_cbEndLeftCount = 0;

  003ef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003f2	c6 81 ae 07 00
	00 00		 mov	 BYTE PTR [ecx+1966], 0

; 81   : 	m_cbSendCardCount = 0;

  003f9	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  003fc	c6 82 3d 07 00
	00 00		 mov	 BYTE PTR [edx+1853], 0

; 82   : 
; 83   : 	//扑克信息
; 84   : 	ZeroMemory(m_cbCardIndex, sizeof(m_cbCardIndex));

  00403	68 88 00 00 00	 push	 136			; 00000088H
  00408	6a 00		 push	 0
  0040a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0040d	05 b2 07 00 00	 add	 eax, 1970		; 000007b2H
  00412	50		 push	 eax
  00413	e8 00 00 00 00	 call	 _memset
  00418	83 c4 0c	 add	 esp, 12			; 0000000cH

; 85   : 	ZeroMemory(m_cbHandCardCount, sizeof(m_cbHandCardCount));

  0041b	6a 04		 push	 4
  0041d	6a 00		 push	 0
  0041f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00422	81 c1 3a 08 00
	00		 add	 ecx, 2106		; 0000083aH
  00428	51		 push	 ecx
  00429	e8 00 00 00 00	 call	 _memset
  0042e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   : 
; 87   : 	ZeroMemory(m_lUserGangScore,sizeof(m_lUserGangScore));

  00431	6a 20		 push	 32			; 00000020H
  00433	6a 00		 push	 0
  00435	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00438	81 c2 f8 05 00
	00		 add	 edx, 1528		; 000005f8H
  0043e	52		 push	 edx
  0043f	e8 00 00 00 00	 call	 _memset
  00444	83 c4 0c	 add	 esp, 12			; 0000000cH

; 88   : 	ZeroMemory(m_cbUserCatchCardCount,sizeof(m_cbUserCatchCardCount));

  00447	6a 04		 push	 4
  00449	6a 00		 push	 0
  0044b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0044e	05 4c 05 00 00	 add	 eax, 1356		; 0000054cH
  00453	50		 push	 eax
  00454	e8 00 00 00 00	 call	 _memset
  00459	83 c4 0c	 add	 esp, 12			; 0000000cH

; 89   : 	ZeroMemory(m_bPlayStatus,sizeof(m_bPlayStatus));

  0045c	6a 04		 push	 4
  0045e	6a 00		 push	 0
  00460	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00463	81 c1 7d 04 00
	00		 add	 ecx, 1149		; 0000047dH
  00469	51		 push	 ecx
  0046a	e8 00 00 00 00	 call	 _memset
  0046f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   : 
; 91   : 	ZeroMemory(m_cbHuCardCount,sizeof(m_cbHuCardCount));

  00472	6a 04		 push	 4
  00474	6a 00		 push	 0
  00476	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00479	81 c2 50 05 00
	00		 add	 edx, 1360		; 00000550H
  0047f	52		 push	 edx
  00480	e8 00 00 00 00	 call	 _memset
  00485	83 c4 0c	 add	 esp, 12			; 0000000cH

; 92   : 	ZeroMemory(m_cbHuCardData,sizeof(m_cbHuCardData));

  00488	68 88 00 00 00	 push	 136			; 00000088H
  0048d	6a 00		 push	 0
  0048f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00492	05 54 05 00 00	 add	 eax, 1364		; 00000554H
  00497	50		 push	 eax
  00498	e8 00 00 00 00	 call	 _memset
  0049d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : 	ZeroMemory(m_cbUserMaCount,sizeof(m_cbUserMaCount));

  004a0	6a 04		 push	 4
  004a2	6a 00		 push	 0
  004a4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004a7	81 c1 dc 05 00
	00		 add	 ecx, 1500		; 000005dcH
  004ad	51		 push	 ecx
  004ae	e8 00 00 00 00	 call	 _memset
  004b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 94   : 	ZeroMemory(&m_stRecord,sizeof(m_stRecord));

  004b6	68 34 04 00 00	 push	 1076			; 00000434H
  004bb	6a 00		 push	 0
  004bd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  004c0	83 c2 0a	 add	 edx, 10			; 0000000aH
  004c3	52		 push	 edx
  004c4	e8 00 00 00 00	 call	 _memset
  004c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 95   : 	m_wLastCatchCardUser=INVALID_CHAIR;

  004cc	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  004d1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004d4	66 89 81 c4 04
	00 00		 mov	 WORD PTR [ecx+1220], ax

; 96   : 
; 97   : 	//规则变量
; 98   : 	m_cbMaCount=0;

  004db	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  004de	c6 42 08 00	 mov	 BYTE PTR [edx+8], 0

; 99   : 	m_cbPlayerCount=0;

  004e2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  004e5	c6 40 09 00	 mov	 BYTE PTR [eax+9], 0

; 100  : 
; 101  : #ifdef  CARD_DISPATCHER_CONTROL
; 102  : 	m_cbControlGameCount = 0;
; 103  : #endif
; 104  : 
; 105  : 	//游戏视频
; 106  : 	m_hVideoInst = NULL;

  004e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004ec	c7 81 3c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1596], 0

; 107  : 	m_pGameVideo = NULL;

  004f6	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  004f9	c7 82 40 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1600], 0

; 108  : 	m_hVideoInst = LoadLibrary(TEXT("SparrowHZHGameVideo.dll"));

  00503	68 00 00 00 00	 push	 OFFSET $SG313288
  00508	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryW@4
  0050e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00511	89 81 3c 06 00
	00		 mov	 DWORD PTR [ecx+1596], eax

; 109  : 	if ( m_hVideoInst )

  00517	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0051a	83 ba 3c 06 00
	00 00		 cmp	 DWORD PTR [edx+1596], 0
  00521	74 2a		 je	 SHORT $LN1@CTableFram

; 110  : 	{
; 111  : 		typedef void * (*CREATE)(); 
; 112  : 		CREATE GameVideo = (CREATE)GetProcAddress(m_hVideoInst,"CreateGameVideo"); 

  00523	68 00 00 00 00	 push	 OFFSET $SG313290
  00528	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0052b	8b 88 3c 06 00
	00		 mov	 ecx, DWORD PTR [eax+1596]
  00531	51		 push	 ecx
  00532	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00538	89 45 e8	 mov	 DWORD PTR _GameVideo$2[ebp], eax

; 113  : 		if ( GameVideo )

  0053b	83 7d e8 00	 cmp	 DWORD PTR _GameVideo$2[ebp], 0
  0053f	74 0c		 je	 SHORT $LN1@CTableFram

; 114  : 		{
; 115  : 			m_pGameVideo = static_cast<IGameVideo*>(GameVideo());

  00541	ff 55 e8	 call	 DWORD PTR _GameVideo$2[ebp]
  00544	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00547	89 82 40 06 00
	00		 mov	 DWORD PTR [edx+1600], eax
$LN1@CTableFram:

; 116  : 		}
; 117  : 	}	
; 118  : 
; 119  : 	return;
; 120  : }

  0054d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00554	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00557	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0055a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00561	59		 pop	 ecx
  00562	8b e5		 mov	 esp, ebp
  00564	5d		 pop	 ebp
  00565	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CTableFrameSink@@QAE@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
  00005	6a 04		 push	 4
  00007	6a 0c		 push	 12			; 0000000cH
  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 40 04 00 00	 add	 eax, 1088		; 00000440H
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00017	c3		 ret	 0
__unwindfunclet$??0CTableFrameSink@@QAE@XZ$1:
  00018	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  0001d	6a 04		 push	 4
  0001f	6a 0c		 push	 12			; 0000000cH
  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	05 ec 04 00 00	 add	 eax, 1260		; 000004ecH
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0002f	c3		 ret	 0
__unwindfunclet$??0CTableFrameSink@@QAE@XZ$2:
  00030	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00035	6a 04		 push	 4
  00037	6a 0c		 push	 12			; 0000000cH
  00039	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	05 1c 05 00 00	 add	 eax, 1308		; 0000051cH
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00047	c3		 ret	 0
__unwindfunclet$??0CTableFrameSink@@QAE@XZ$3:
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	81 c1 d4 08 00
	00		 add	 ecx, 2260		; 000008d4H
  00051	e9 00 00 00 00	 jmp	 ??1CGameLogic@@UAE@XZ	; CGameLogic::~CGameLogic
__unwindfunclet$??0CTableFrameSink@@QAE@XZ$4:
  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	81 c1 e0 08 00
	00		 add	 ecx, 2272		; 000008e0H
  0005f	e9 00 00 00 00	 jmp	 ??1CHistoryScore@@UAE@XZ ; CHistoryScore::~CHistoryScore
__ehhandler$??0CTableFrameSink@@QAE@XZ:
  00064	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00068	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006b	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0006e	33 c8		 xor	 ecx, eax
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTableFrameSink@@QAE@XZ
  0007a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTableFrameSink@@QAE@XZ ENDP				; CTableFrameSink::CTableFrameSink
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 : 		if (this->_Myfirst() != pointer())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	0f 84 81 00 00
	00		 je	 $LN1@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all

; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
  00047	8b f0		 mov	 esi, eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  00051	8b 16		 mov	 edx, DWORD PTR [esi]
  00053	2b 10		 sub	 edx, DWORD PTR [eax]
  00055	52		 push	 edx
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	50		 push	 eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
  00069	8b c8		 mov	 ecx, eax
  0006b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  00078	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1644 : 			this->_Mylast() = pointer();

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1645 : 			this->_Myend() = pointer();

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
  00094	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Tidy:

; 1646 : 			}
; 1647 : 		}

  0009a	5e		 pop	 esi
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
  0000f	50		 push	 eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Destroy_range<std::allocator<unsigned char>,unsigned char *>
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1582 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1540 : 		this->_Orphan_all();

  00027	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all

; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	50		 push	 eax
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	51		 push	 ecx
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  00055	8b f0		 mov	 esi, eax
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
  0005f	8b 16		 mov	 edx, DWORD PTR [esi]
  00061	89 10		 mov	 DWORD PTR [eax], edx

; 1543 : 		}

  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	03 45 08	 add	 eax, DWORD PTR __Pos$[ebp]

; 1243 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 1179 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
  00010	8b f0		 mov	 esi, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0001e	8b c1		 mov	 eax, ecx

; 1181 : 		}

  00020	5e		 pop	 esi
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 		_Tidy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 977  : 		}

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 707  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 706  : 		: _Mybase()

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >

; 708  : 		}

  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00034	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003b	59		 pop	 ecx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 321  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 316  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 296  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 488  : 		{	// initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 485  : 		: _Myfirst(),

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 486  : 		_Mylast(),

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 489  : 		}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 663  : 		return (_Get_data()._Myend);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
  0000f	83 c0 08	 add	 eax, 8

; 664  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		{	// return const reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 658  : 		return (_Get_data()._Mylast);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
  0000f	83 c0 04	 add	 eax, 4

; 659  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
  0000f	83 c0 04	 add	 eax, 4

; 654  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 648  : 		return (_Get_data()._Myfirst);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data

; 649  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data

; 644  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		return (_Mypair._Get_second());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second

; 639  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second

; 634  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 623  : 		return (_Mypair._Get_first());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first

; 624  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 613  : 		_Get_data()._Orphan_all();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 614  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >, COMDAT
; _this$ = ecx

; 520  : 		{	// default construct allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 519  : 		: _Mypair(_Zero_then_variadic_args_t())

  00009	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>

; 521  : 		}

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@E@std@@QAEXPAEI@Z ; std::allocator<unsigned char>::deallocate

; 988  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 936  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 935  : 		: _Mybase()

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@E@std@@QAE@XZ ; std::allocator<unsigned char>::allocator<unsigned char>

; 937  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXPAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00007	6a 01		 push	 1
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 721  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?deallocate@?$allocator@E@std@@QAEXPAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 699  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@_JV?$allocator@_J@std@@@std@@IBEXPA_J0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@_JV?$allocator@_J@std@@@std@@IBEXPA_J0@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1793 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1794 : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 08 00	 ret	 8
?_Orphan_range@?$vector@_JV?$allocator@_J@std@@@std@@IBEXPA_J0@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@IBEXXZ PROC ; std::vector<__int64,std::allocator<__int64> >::_Xlen, COMDAT
; _this$ = ecx

; 1764 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1765 : 		_Xlength_error("vector<T> too long");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN2@Xlen:

; 1766 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@IBEXXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ PROC ; std::vector<__int64,std::allocator<__int64> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1637 : 		if (this->_Myfirst() != pointer())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	0f 84 84 00 00
	00		 je	 $LN1@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Orphan_all

; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  00047	8b f0		 mov	 esi, eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00051	8b 16		 mov	 edx, DWORD PTR [esi]
  00053	2b 10		 sub	 edx, DWORD PTR [eax]
  00055	c1 fa 03	 sar	 edx, 3
  00058	52		 push	 edx
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	50		 push	 eax
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  0006c	8b c8		 mov	 ecx, eax
  0006e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JI@Z ; std::_Wrap_alloc<std::allocator<__int64> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  0007b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1644 : 			this->_Mylast() = pointer();

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00089	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1645 : 			this->_Myend() = pointer();

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  00097	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Tidy:

; 1646 : 			}
; 1647 : 		}

  0009d	5e		 pop	 esi
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1627 : 		if (_Unused_capacity() < _Count)

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Unused_capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::_Unused_capacity
  00010	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00013	73 3e		 jae	 SHORT $LN4@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::max_size
  0001d	8b f0		 mov	 esi, eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
  00027	2b f0		 sub	 esi, eax
  00029	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0002c	73 08		 jae	 SHORT $LN3@Reserve

; 1630 : 				_Xlen();

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Xlen@?$vector@_JV?$allocator@_J@std@@@std@@IBEXXZ ; std::vector<__int64,std::allocator<__int64> >::_Xlen
$LN3@Reserve:

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
  0003e	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00041	50		 push	 eax
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@_JV?$allocator@_J@std@@@std@@IBEII@Z ; std::vector<__int64,std::allocator<__int64> >::_Grow_to
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::_Reallocate
$LN4@Reserve:

; 1632 : 			}
; 1633 : 		}

  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?_Reserve@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  0002f	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00032	50		 push	 eax
  00033	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  0003b	8b c8		 mov	 ecx, eax
  0003d	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEPA_JI@Z ; std::_Wrap_alloc<std::allocator<__int64> >::allocate
  00042	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1603 : 
; 1604 : 		_TRY_BEGIN

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  0004c	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0004f	51		 push	 ecx
  00050	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	52		 push	 edx
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	50		 push	 eax
  00066	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Umove@PA_J@?$vector@_JV?$allocator@_J@std@@@std@@IAEPA_JPA_J00@Z ; std::vector<__int64,std::allocator<__int64> >::_Umove<__int64 *>
  0006e	eb 26		 jmp	 SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z$0:

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);

  00070	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00073	51		 push	 ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00077	52		 push	 edx
  00078	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  00080	8b c8		 mov	 ecx, eax
  00082	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JI@Z ; std::_Wrap_alloc<std::allocator<__int64> >::deallocate

; 1608 : 		_RERAISE;

  00087	6a 00		 push	 0
  00089	6a 00		 push	 0
  0008b	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1609 : 		_CATCH_END

  00090	b8 00 00 00 00	 mov	 eax, $LN8@Reallocate
  00095	c3		 ret	 0
$LN5@Reallocate:
  00096	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0009d	eb 07		 jmp	 SHORT __tryend$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
  0009f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z$1:

; 1610 : 
; 1611 : 		size_type _Size = size();

  000a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::size
  000ae	89 45 e4	 mov	 DWORD PTR __Size$[ebp], eax

; 1612 : 		if (this->_Myfirst() != pointer())

  000b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  000b9	83 38 00	 cmp	 DWORD PTR [eax], 0
  000bc	74 52		 je	 SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  000c6	8b 00		 mov	 eax, DWORD PTR [eax]
  000c8	50		 push	 eax
  000c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  000d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d3	51		 push	 ecx
  000d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Destroy

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  000dc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  000e4	8b f0		 mov	 esi, eax
  000e6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  000ee	8b 10		 mov	 edx, DWORD PTR [eax]
  000f0	2b 16		 sub	 edx, DWORD PTR [esi]
  000f2	c1 fa 03	 sar	 edx, 3
  000f5	52		 push	 edx
  000f6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  000fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00100	50		 push	 eax
  00101	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  00109	8b c8		 mov	 ecx, eax
  0010b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JI@Z ; std::_Wrap_alloc<std::allocator<__int64> >::deallocate
$LN3@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();

  00110	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Orphan_all

; 1620 : 		this->_Myend() = _Ptr + _Count;

  00118	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0011b	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0011e	8d 34 ca	 lea	 esi, DWORD PTR [edx+ecx*8]
  00121	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  00129	89 30		 mov	 DWORD PTR [eax], esi

; 1621 : 		this->_Mylast() = _Ptr + _Size;

  0012b	8b 45 e4	 mov	 eax, DWORD PTR __Size$[ebp]
  0012e	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00131	8d 34 c1	 lea	 esi, DWORD PTR [ecx+eax*8]
  00134	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0013c	89 30		 mov	 DWORD PTR [eax], esi

; 1622 : 		this->_Myfirst() = _Ptr;

  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00146	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00149	89 10		 mov	 DWORD PTR [eax], edx
$LN4@Reallocate:

; 1623 : 		}

  0014b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0014e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00155	59		 pop	 ecx
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@_JV?$allocator@_J@std@@@std@@IBE_NPB_J@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@_JV?$allocator@_J@std@@@std@@IBE_NPB_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Unfancy@_J@std@@YAPA_JPA_J@Z ; std::_Unfancy<__int64>
  00019	83 c4 04	 add	 esp, 4
  0001c	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  0001f	73 21		 jae	 SHORT $LN3@Inside
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$_Unfancy@_J@std@@YAPA_JPA_J@Z ; std::_Unfancy<__int64>
  00031	83 c4 04	 add	 esp, 4
  00034	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  00037	77 09		 ja	 SHORT $LN3@Inside
  00039	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00040	eb 07		 jmp	 SHORT $LN4@Inside
$LN3@Inside:
  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN4@Inside:
  00049	8a 45 f8	 mov	 al, BYTE PTR tv82[ebp]

; 1598 : 		}

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?_Inside@?$vector@_JV?$allocator@_J@std@@@std@@IBE_NPB_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@_JV?$allocator@_J@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@_JV?$allocator@_J@std@@@std@@IBEII@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1586 : 		size_type _Capacity = capacity();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::capacity
  00011	89 45 fc	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ; std::vector<__int64,std::allocator<__int64> >::max_size
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0001f	d1 e9		 shr	 ecx, 1
  00021	2b c1		 sub	 eax, ecx
  00023	3b 45 fc	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00026	73 09		 jae	 SHORT $LN4@Grow_to
  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0002f	eb 0b		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00031	8b 55 fc	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00034	d1 ea		 shr	 edx, 1
  00036	03 55 fc	 add	 edx, DWORD PTR __Capacity$[ebp]
  00039	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
  0003c	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  0003f	89 45 fc	 mov	 DWORD PTR __Capacity$[ebp], eax

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00045	3b 4d 08	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00048	73 06		 jae	 SHORT $LN2@Grow_to

; 1591 : 			_Capacity = _Count;

  0004a	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  0004d	89 55 fc	 mov	 DWORD PTR __Capacity$[ebp], edx
$LN2@Grow_to:

; 1592 : 		return (_Capacity);

  00050	8b 45 fc	 mov	 eax, DWORD PTR __Capacity$[ebp]

; 1593 : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?_Grow_to@?$vector@_JV?$allocator@_J@std@@@std@@IBEII@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  0000f	50		 push	 eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@_J@std@@PA_J@std@@YAXPA_J0AAU?$_Wrap_alloc@V?$allocator@_J@std@@@0@@Z ; std::_Destroy_range<std::allocator<__int64>,__int64 *>
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1582 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ PROC ; std::vector<__int64,std::allocator<__int64> >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1540 : 		this->_Orphan_all();

  00027	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Orphan_all

; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	50		 push	 eax
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	51		 push	 ecx
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Destroy

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00055	8b f0		 mov	 esi, eax
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0005f	8b 16		 mov	 edx, DWORD PTR [esi]
  00061	89 10		 mov	 DWORD PTR [eax], edx

; 1543 : 		}

  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$vector@_JV?$allocator@_J@std@@@std@@QAEXXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv128 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::erase, COMDAT
; _this$ = ecx

; 1484 : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1485 : 		_Move_unchecked(_VIPTR(_Where) + 1, this->_Mylast(),

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	51		 push	 ecx
  00018	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  0001b	83 c2 08	 add	 edx, 8
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ??$_Move_unchecked@PA_JPA_J@std@@YAPA_JPA_J00@Z ; std::_Move_unchecked<__int64 *,__int64 *>
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	83 e9 08	 sub	 ecx, 8
  0003f	51		 push	 ecx
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Destroy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Destroy

; 1488 : 		--this->_Mylast();

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00050	89 45 f8	 mov	 DWORD PTR tv128[ebp], eax
  00053	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	83 e8 08	 sub	 eax, 8
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR tv128[ebp]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 1489 : 		return (_Make_iter(_Where));

  00060	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00063	52		 push	 edx
  00064	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00067	50		 push	 eax
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z ; std::vector<__int64,std::allocator<__int64> >::_Make_iter
  00070	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1490 : 		}

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
?erase@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QAEXAB_J@Z
_TEXT	SEGMENT
__Idx$1 = -16						; size = 4
tv231 = -12						; size = 4
tv176 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QAEXAB_J@Z PROC ; std::vector<__int64,std::allocator<__int64> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1277 : 		if (_Inside(_STD addressof(_Val)))

  0000a	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$addressof@$$CB_J@std@@YAPB_JAB_J@Z ; std::addressof<__int64 const >
  00013	83 c4 04	 add	 esp, 4
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Inside@?$vector@_JV?$allocator@_J@std@@@std@@IBE_NPB_J@Z ; std::vector<__int64,std::allocator<__int64> >::_Inside
  0001f	0f b6 c8	 movzx	 ecx, al
  00022	85 c9		 test	 ecx, ecx
  00024	0f 84 b7 00 00
	00		 je	 $LN2@push_back

; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

  0002a	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$addressof@$$CB_J@std@@YAPB_JAB_J@Z ; std::addressof<__int64 const >
  00033	83 c4 04	 add	 esp, 4
  00036	8b f0		 mov	 esi, eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$_Unfancy@_J@std@@YAPA_JPA_J@Z ; std::_Unfancy<__int64>
  00048	83 c4 04	 add	 esp, 4
  0004b	2b f0		 sub	 esi, eax
  0004d	c1 fe 03	 sar	 esi, 3
  00050	89 75 f0	 mov	 DWORD PTR __Idx$1[ebp], esi

; 1280 : 			if (this->_Mylast() == this->_Myend())

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0005b	8b f0		 mov	 esi, eax
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  00065	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00067	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00069	75 0a		 jne	 SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

  0006b	6a 01		 push	 1
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Reserve@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::_Reserve
$LN4@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0007d	8b 10		 mov	 edx, DWORD PTR [eax]
  0007f	52		 push	 edx
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	50		 push	 eax
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@_JV?$allocator@_J@std@@@std@@IBEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Orphan_range

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	8b 55 f0	 mov	 edx, DWORD PTR __Idx$1[ebp]
  000a0	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  000a3	50		 push	 eax
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ??$_Unfancy@_J@std@@YAPA_JPA_J@Z ; std::_Unfancy<__int64>
  000b4	83 c4 04	 add	 esp, 4
  000b7	50		 push	 eax
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  000c0	8b c8		 mov	 ecx, eax
  000c2	e8 00 00 00 00	 call	 ??$construct@_JAA_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAA_J@Z ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 &>

; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  000cf	89 45 f8	 mov	 DWORD PTR tv176[ebp], eax
  000d2	8b 55 f8	 mov	 edx, DWORD PTR tv176[ebp]
  000d5	8b 02		 mov	 eax, DWORD PTR [edx]
  000d7	83 c0 08	 add	 eax, 8
  000da	8b 4d f8	 mov	 ecx, DWORD PTR tv176[ebp]
  000dd	89 01		 mov	 DWORD PTR [ecx], eax

; 1286 : 			}
; 1287 : 		else

  000df	eb 7f		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  000e9	8b f0		 mov	 esi, eax
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  000f3	8b 16		 mov	 edx, DWORD PTR [esi]
  000f5	3b 10		 cmp	 edx, DWORD PTR [eax]
  000f7	75 0a		 jne	 SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

  000f9	6a 01		 push	 1
  000fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_Reserve@?$vector@_JV?$allocator@_J@std@@@std@@IAEXI@Z ; std::vector<__int64,std::allocator<__int64> >::_Reserve
$LN5@push_back:

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

  00103	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	50		 push	 eax
  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00116	8b 08		 mov	 ecx, DWORD PTR [eax]
  00118	51		 push	 ecx
  00119	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@_JV?$allocator@_J@std@@@std@@IBEXPA_J0@Z ; std::vector<__int64,std::allocator<__int64> >::_Orphan_range

; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00121	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00124	52		 push	 edx
  00125	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0012d	8b 00		 mov	 eax, DWORD PTR [eax]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ??$_Unfancy@_J@std@@YAPA_JPA_J@Z ; std::_Unfancy<__int64>
  00135	83 c4 04	 add	 esp, 4
  00138	50		 push	 eax
  00139	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  00141	8b c8		 mov	 ecx, eax
  00143	e8 00 00 00 00	 call	 ??$construct@_JAB_J@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JAB_J@Z ; std::_Wrap_alloc<std::allocator<__int64> >::construct<__int64,__int64 const &>

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

  00148	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00150	89 45 f4	 mov	 DWORD PTR tv231[ebp], eax
  00153	8b 4d f4	 mov	 ecx, DWORD PTR tv231[ebp]
  00156	8b 11		 mov	 edx, DWORD PTR [ecx]
  00158	83 c2 08	 add	 edx, 8
  0015b	8b 45 f4	 mov	 eax, DWORD PTR tv231[ebp]
  0015e	89 10		 mov	 DWORD PTR [eax], edx
$LN1@push_back:

; 1295 : 			}
; 1296 : 		}

  00160	5e		 pop	 esi
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c2 04 00	 ret	 4
?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QAEXAB_J@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z PROC ; std::vector<__int64,std::allocator<__int64> >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00014	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 1243 : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$vector@_JV?$allocator@_J@std@@@std@@QAEAA_JI@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC ; std::vector<__int64,std::allocator<__int64> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1185 : 		return (this->_Getal().max_size());

  00009	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<__int64> >::max_size

; 1186 : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?max_size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC	; std::vector<__int64,std::allocator<__int64> >::size, COMDAT
; _this$ = ecx

; 1179 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  00010	8b f0		 mov	 esi, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0001e	c1 f9 03	 sar	 ecx, 3
  00021	8b c1		 mov	 eax, ecx

; 1181 : 		}

  00023	5e		 pop	 esi
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?size@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP	; std::vector<__int64,std::allocator<__int64> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z PROC ; std::vector<__int64,std::allocator<__int64> >::_Make_iter, COMDAT
; _this$ = ecx

; 1077 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1078 : 		return (iterator(_Where._Ptr, &this->_Get_data()));

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
  0000f	50		 push	 eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1079 : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?_Make_iter@?$vector@_JV?$allocator@_J@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@@Z ENDP ; std::vector<__int64,std::allocator<__int64> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ PROC ; std::vector<__int64,std::allocator<__int64> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
  0002e	50		 push	 eax
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@std@@QAE@PA_JPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<__int64> > >
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1059 : 		}

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@_JV?$allocator@_J@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_J@std@@@std@@@2@XZ ENDP ; std::vector<__int64,std::allocator<__int64> >::begin
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC ; std::vector<__int64,std::allocator<__int64> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		{	// micro-optimization for capacity() - size()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  00010	8b f0		 mov	 esi, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0001e	c1 f9 03	 sar	 ecx, 3
  00021	8b c1		 mov	 eax, ecx

; 1049 : 		}

  00023	5e		 pop	 esi
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?_Unused_capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ PROC ; std::vector<__int64,std::allocator<__int64> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
  00010	8b f0		 mov	 esi, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	2b 08		 sub	 ecx, DWORD PTR [eax]
  0001e	c1 f9 03	 sar	 ecx, 3
  00021	8b c1		 mov	 eax, ecx

; 1044 : 		}

  00023	5e		 pop	 esi
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?capacity@?$vector@_JV?$allocator@_J@std@@@std@@QBEIXZ ENDP ; std::vector<__int64,std::allocator<__int64> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ PROC	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 		_Tidy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Tidy@?$vector@_JV?$allocator@_J@std@@@std@@IAEXXZ ; std::vector<__int64,std::allocator<__int64> >::_Tidy

; 977  : 		}

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ENDP	; std::vector<__int64,std::allocator<__int64> >::~vector<__int64,std::allocator<__int64> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ PROC	; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >, COMDAT
; _this$ = ecx

; 707  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 706  : 		: _Mybase()

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >

; 708  : 		}

  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00034	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003b	59		 pop	 ecx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@_JV?$allocator@_J@std@@@std@@QAE@XZ ENDP	; std::vector<__int64,std::allocator<__int64> >::vector<__int64,std::allocator<__int64> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 321  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 316  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 300  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 301  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 296  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@_J@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<__int64> >::_Vector_val<std::_Simple_types<__int64> >, COMDAT
; _this$ = ecx

; 488  : 		{	// initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 485  : 		: _Myfirst(),

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 486  : 		_Mylast(),

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 489  : 		}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@_J@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<__int64> >::_Vector_val<std::_Simple_types<__int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		{	// return const reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 668  : 		return (_Get_data()._Myend);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
  0000f	83 c0 08	 add	 eax, 8

; 669  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 663  : 		return (_Get_data()._Myend);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
  0000f	83 c0 08	 add	 eax, 8

; 664  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		{	// return const reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 658  : 		return (_Get_data()._Mylast);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
  0000f	83 c0 04	 add	 eax, 4

; 659  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
  0000f	83 c0 04	 add	 eax, 4

; 654  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 648  : 		return (_Get_data()._Myfirst);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data

; 649  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABQA_JXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data

; 644  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAPA_JXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 		return (_Mypair._Get_second());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second

; 639  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_second

; 634  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		return (_Mypair._Get_first());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first

; 629  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 623  : 		return (_Mypair._Get_first());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Get_first

; 624  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_J@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 613  : 		_Get_data()._Orphan_all();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_J@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Get_data
  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 614  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >, COMDAT
; _this$ = ecx

; 520  : 		{	// default construct allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 519  : 		: _Mypair(_Zero_then_variadic_args_t())

  00009	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_J@std@@@std@@V?$_Vector_val@U?$_Simple_types@_J@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<__int64> >,std::_Vector_val<std::_Simple_types<__int64> >,1><>

; 521  : 		}

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@_JV?$allocator@_J@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >::_Vector_alloc<std::_Vec_base_types<__int64,std::allocator<__int64> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<__int64> >::max_size, COMDAT
; _this$ = ecx

; 1007 : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@_J@std@@@std@@SAIABV?$allocator@_J@2@@Z ; std::allocator_traits<std::allocator<__int64> >::max_size
  00010	83 c4 04	 add	 esp, 4

; 1009 : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<__int64> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JI@Z PROC ; std::_Wrap_alloc<std::allocator<__int64> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z ; std::allocator<__int64>::deallocate

; 988  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEXPA_JI@Z ENDP ; std::_Wrap_alloc<std::allocator<__int64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEPA_JI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEPA_JI@Z PROC ; std::_Wrap_alloc<std::allocator<__int64> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 		return (_Mybase::allocate(_Count));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?allocate@?$allocator@_J@std@@QAEPA_JI@Z ; std::allocator<__int64>::allocate

; 977  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAEPA_JI@Z ENDP ; std::_Wrap_alloc<std::allocator<__int64> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<__int64> >::_Wrap_alloc<std::allocator<__int64> >, COMDAT
; _this$ = ecx

; 936  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 935  : 		: _Mybase()

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@_J@std@@QAE@XZ ; std::allocator<__int64>::allocator<__int64>

; 937  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@_J@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<__int64> >::_Wrap_alloc<std::allocator<__int64> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_J@std@@@std@@SAIABV?$allocator@_J@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_J@std@@@std@@SAIABV?$allocator@_J@2@@Z PROC ; std::allocator_traits<std::allocator<__int64> >::max_size, COMDAT

; 868  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		return (_Al.max_size());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00006	e8 00 00 00 00	 call	 ?max_size@?$allocator@_J@std@@QBEIXZ ; std::allocator<__int64>::max_size

; 870  : 		}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@_J@std@@@std@@SAIABV?$allocator@_J@2@@Z ENDP ; std::allocator_traits<std::allocator<__int64> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_J@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@_J@std@@QBEIXZ PROC		; std::allocator<__int64>::max_size, COMDAT
; _this$ = ecx

; 748  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00007	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 750  : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?max_size@?$allocator@_J@std@@QBEIXZ ENDP		; std::allocator<__int64>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_J@std@@QAEPA_JI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@_J@std@@QAEPA_JI@Z PROC		; std::allocator<__int64>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00007	6a 01		 push	 1
  00009	6a 08		 push	 8
  0000b	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPAXII_N@Z ; std::_Allocate
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 726  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?allocate@?$allocator@_J@std@@QAEPA_JI@Z ENDP		; std::allocator<__int64>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z PROC	; std::allocator<__int64>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00007	6a 08		 push	 8
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 721  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?deallocate@?$allocator@_J@std@@QAEXPA_JI@Z ENDP	; std::allocator<__int64>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_J@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@_J@std@@QAE@XZ PROC			; std::allocator<__int64>::allocator<__int64>, COMDAT
; _this$ = ecx

; 699  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@_J@std@@QAE@XZ ENDP			; std::allocator<__int64>::allocator<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.h
;	COMDAT ?SetMagicIndex@CGameLogic@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cbMagicIndex$ = 8					; size = 1
?SetMagicIndex@CGameLogic@@QAEXE@Z PROC			; CGameLogic::SetMagicIndex, COMDAT
; _this$ = ecx

; 206  : 	void SetMagicIndex(BYTE cbMagicIndex) { m_cbMagicIndex = cbMagicIndex; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _cbMagicIndex$[ebp]
  0000d	88 48 04	 mov	 BYTE PTR [eax+4], cl
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetMagicIndex@CGameLogic@@QAEXE@Z ENDP			; CGameLogic::SetMagicIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.h
;	COMDAT ?GetCardColor@CGameLogic@@QAEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cbCardData$ = 8					; size = 1
?GetCardColor@CGameLogic@@QAEEE@Z PROC			; CGameLogic::GetCardColor, COMDAT
; _this$ = ecx

; 189  : 	BYTE GetCardColor(BYTE cbCardData) { return cbCardData&MASK_COLOR; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  0000b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?GetCardColor@CGameLogic@@QAEEE@Z ENDP			; CGameLogic::GetCardColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\gamelogic.h
;	COMDAT ?GetCardValue@CGameLogic@@QAEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cbCardData$ = 8					; size = 1
?GetCardValue@CGameLogic@@QAEEE@Z PROC			; CGameLogic::GetCardValue, COMDAT
; _this$ = ecx

; 187  : 	BYTE GetCardValue(BYTE cbCardData) { return cbCardData&MASK_VALUE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _cbCardData$[ebp]
  0000b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?GetCardValue@CGameLogic@@QAEEE@Z ENDP			; CGameLogic::GetCardValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ
text$di	SEGMENT
??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ PROC ; `dynamic initializer for 'ATL::CImage::isCImageStaticInitialized'', COMDAT

; 510  : __declspec(selectany) bool CImage::isCImageStaticInitialized = CImage::CImageStaticInitialize();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?CImageStaticInitialize@CImage@ATL@@CA_NXZ ; ATL::CImage::CImageStaticInitialize
  00008	a2 00 00 00 00	 mov	 BYTE PTR ?isCImageStaticInitialized@CImage@ATL@@0_NA, al ; ATL::CImage::isCImageStaticInitialized
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__E?isCImageStaticInitialized@CImage@ATL@@0_NA@@YAXXZ ENDP ; `dynamic initializer for 'ATL::CImage::isCImageStaticInitialized''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ
text$yd	SEGMENT
??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ PROC ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
  00008	e8 00 00 00 00	 call	 ??1CDCCache@CImage@ATL@@QAE@XZ ; ATL::CImage::CDCCache::~CDCCache
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ ENDP ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ
text$yd	SEGMENT
??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ PROC ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
  00008	e8 00 00 00 00	 call	 ??1CInitGDIPlus@CImage@ATL@@QAE@XZ ; ATL::CImage::CInitGDIPlus::~CInitGDIPlus
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ ENDP ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?CImageStaticInitialize@CImage@ATL@@CA_NXZ
_TEXT	SEGMENT
?CImageStaticInitialize@CImage@ATL@@CA_NXZ PROC		; ATL::CImage::CImageStaticInitialize, COMDAT

; 501  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 502  : 		GetInitGDIPlusInstance();

  00003	e8 00 00 00 00	 call	 ?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ ; ATL::CImage::GetInitGDIPlusInstance

; 503  : 		GetCDCCacheInstance();

  00008	e8 00 00 00 00	 call	 ?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ ; ATL::CImage::GetCDCCacheInstance

; 504  : 		return true;

  0000d	b0 01		 mov	 al, 1

; 505  : 	}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?CImageStaticInitialize@CImage@ATL@@CA_NXZ ENDP		; ATL::CImage::CImageStaticInitialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ
_TEXT	SEGMENT
?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ PROC ; ATL::CImage::GetCDCCacheInstance, COMDAT

; 495  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 496  : 		static CDCCache cache;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00008	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0000f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00017	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0001d	7e 3a		 jle	 SHORT $LN2@GetCDCCach
  0001f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00024	e8 00 00 00 00	 call	 __Init_thread_header
  00029	83 c4 04	 add	 esp, 4
  0002c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA, -1 ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00033	75 24		 jne	 SHORT $LN2@GetCDCCach
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache
  0003a	e8 00 00 00 00	 call	 ??0CDCCache@CImage@ATL@@QAE@XZ ; ATL::CImage::CDCCache::CDCCache
  0003f	68 00 00 00 00	 push	 OFFSET ??__Fcache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ@YAXXZ ; `ATL::CImage::GetCDCCacheInstance'::`2'::`dynamic atexit destructor for 'cache''
  00044	e8 00 00 00 00	 call	 _atexit
  00049	83 c4 04	 add	 esp, 4
  0004c	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tCDCCacheInstance,signed char,ATL::CImage::CDCCache const volatile __based() &,void,int, ?? &>
  00051	e8 00 00 00 00	 call	 __Init_thread_footer
  00056	83 c4 04	 add	 esp, 4
$LN2@GetCDCCach:

; 497  : 		return &cache;

  00059	b8 00 00 00 00	 mov	 eax, OFFSET ?cache@?1??GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@23@XZ@4V423@A ; `ATL::CImage::GetCDCCacheInstance'::`2'::cache

; 498  : 	}

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GetCDCCacheInstance@CImage@ATL@@CAPAVCDCCache@12@XZ ENDP ; ATL::CImage::GetCDCCacheInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ
_TEXT	SEGMENT
?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ PROC ; ATL::CImage::GetInitGDIPlusInstance, COMDAT

; 442  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 		static CInitGDIPlus gdiPlus;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00008	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0000f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00017	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0001d	7e 3a		 jle	 SHORT $LN2@GetInitGDI
  0001f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00024	e8 00 00 00 00	 call	 __Init_thread_header
  00029	83 c4 04	 add	 esp, 4
  0002c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA, -1 ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00033	75 24		 jne	 SHORT $LN2@GetInitGDI
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus
  0003a	e8 00 00 00 00	 call	 ??0CInitGDIPlus@CImage@ATL@@QAE@XZ ; ATL::CImage::CInitGDIPlus::CInitGDIPlus
  0003f	68 00 00 00 00	 push	 OFFSET ??__FgdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ@YAXXZ ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::`dynamic atexit destructor for 'gdiPlus''
  00044	e8 00 00 00 00	 call	 _atexit
  00049	83 c4 04	 add	 esp, 4
  0004c	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4HA ; TSS0<`template-parameter-2',ATL::CImage::tInitGDIPlusInstance,signed char,ATL::CImage::CInitGDIPlus const volatile __based() &,void,int, ?? &>
  00051	e8 00 00 00 00	 call	 __Init_thread_footer
  00056	83 c4 04	 add	 esp, 4
$LN2@GetInitGDI:

; 444  : 		return &gdiPlus;

  00059	b8 00 00 00 00	 mov	 eax, OFFSET ?gdiPlus@?1??GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@23@XZ@4V423@A ; `ATL::CImage::GetInitGDIPlusInstance'::`2'::gdiPlus

; 445  : 	}

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GetInitGDIPlusInstance@CImage@ATL@@CAPAVCInitGDIPlus@12@XZ ENDP ; ATL::CImage::GetInitGDIPlusInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ PROC	; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus, COMDAT
; _this$ = ecx

; 570  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 571  : 	EnterCriticalSection(&m_sect);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 572  : 	if( m_dwToken != 0 )

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0001a	74 0b		 je	 SHORT $LN2@ReleaseGDI

; 573  : 	{
; 574  : 		Gdiplus::GdiplusShutdown( m_dwToken );

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _GdiplusShutdown@4
$LN2@ReleaseGDI:

; 575  : 	}
; 576  : 	m_dwToken = 0;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 577  : 	LeaveCriticalSection(&m_sect);

  00030	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00033	83 c2 04	 add	 edx, 4
  00036	52		 push	 edx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 578  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ ENDP	; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??1CInitGDIPlus@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CInitGDIPlus@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CInitGDIPlus::~CInitGDIPlus, COMDAT
; _this$ = ecx

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 543  : 	ReleaseGDIPlus();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?ReleaseGDIPlus@CInitGDIPlus@CImage@ATL@@QAEXXZ ; ATL::CImage::CInitGDIPlus::ReleaseGDIPlus

; 544  : 	DeleteCriticalSection(&m_sect);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 545  : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1CInitGDIPlus@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CInitGDIPlus::~CInitGDIPlus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??0CInitGDIPlus@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CInitGDIPlus@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CInitGDIPlus::CInitGDIPlus, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 533  : 	m_dwToken( 0 ), m_nCImageObjects( 0 ), m_dwLastError(S_OK)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 535  : 	if (!_AtlInitializeCriticalSectionEx(&m_sect, 0, 0))

  00024	6a 00		 push	 0
  00026	6a 00		 push	 0
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 04	 add	 eax, 4
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	85 c0		 test	 eax, eax
  00039	75 15		 jne	 SHORT $LN1@CInitGDIPl

; 536  : 	{
; 537  : 		m_dwLastError = HRESULT_FROM_WIN32(GetLastError());

  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00047	83 c4 04	 add	 esp, 4
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN1@CInitGDIPl:

; 538  : 	}
; 539  : }

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??0CInitGDIPlus@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CInitGDIPlus::CInitGDIPlus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??1CDCCache@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iDC$ = -4						; size = 4
??1CDCCache@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CDCCache::~CDCCache, COMDAT
; _this$ = ecx

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 607  : 	int iDC;
; 608  : 
; 609  : 	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iDC$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CDCCache
$LN2@CDCCache:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _iDC$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _iDC$[ebp], eax
$LN4@CDCCache:
  0001b	83 7d fc 04	 cmp	 DWORD PTR _iDC$[ebp], 4
  0001f	7d 1e		 jge	 SHORT $LN1@CDCCache

; 610  : 	{
; 611  : 		if( m_ahDCs[iDC] != NULL )

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _iDC$[ebp]
  00024	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00027	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  0002b	74 10		 je	 SHORT $LN5@CDCCache

; 612  : 		{
; 613  : 			::DeleteDC( m_ahDCs[iDC] );

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _iDC$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00036	52		 push	 edx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$LN5@CDCCache:

; 614  : 		}
; 615  : 	}

  0003d	eb d3		 jmp	 SHORT $LN2@CDCCache
$LN1@CDCCache:

; 616  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??1CDCCache@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CDCCache::~CDCCache
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlimage.h
;	COMDAT ??0CDCCache@CImage@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iDC$ = -4						; size = 4
??0CDCCache@CImage@ATL@@QAE@XZ PROC			; ATL::CImage::CDCCache::CDCCache, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 597  : 	int iDC;
; 598  : 
; 599  : 	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iDC$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CDCCache
$LN2@CDCCache:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _iDC$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _iDC$[ebp], eax
$LN4@CDCCache:
  0001b	83 7d fc 04	 cmp	 DWORD PTR _iDC$[ebp], 4
  0001f	7d 0f		 jge	 SHORT $LN1@CDCCache

; 600  : 	{
; 601  : 		m_ahDCs[iDC] = NULL;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _iDC$[ebp]
  00024	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00027	c7 04 8a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx*4], 0

; 602  : 	}

  0002e	eb e2		 jmp	 SHORT $LN2@CDCCache
$LN1@CDCCache:

; 603  : }

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??0CDCCache@CImage@ATL@@QAE@XZ ENDP			; ATL::CImage::CDCCache::CDCCache
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ITableUserAction@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITableUserAction@@QAE@XZ PROC			; ITableUserAction::ITableUserAction, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknownEx@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ITableUserAction@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0ITableUserAction@@QAE@XZ ENDP			; ITableUserAction::ITableUserAction
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ITableFrameSink@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITableFrameSink@@QAE@XZ PROC				; ITableFrameSink::ITableFrameSink, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknownEx@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ITableFrameSink@@6B@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0ITableFrameSink@@QAE@XZ ENDP				; ITableFrameSink::ITableFrameSink
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr_ptr$1 = -16					; size = 4
__User_size$ = -12					; size = 4
__Ptr_container$2 = -8					; size = 4
__Ptr_user$3 = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00006	83 c8 ff	 or	 eax, -1
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  00011	76 06		 jbe	 SHORT $LN2@Deallocate
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	0f af 45 10	 imul	 eax, DWORD PTR __Sz$[ebp]
  00020	89 45 f4	 mov	 DWORD PTR __User_size$[ebp], eax

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00023	81 7d f4 00 10
	00 00		 cmp	 DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  0002a	72 5b		 jb	 SHORT $LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002f	89 4d fc	 mov	 DWORD PTR __Ptr_user$3[ebp], ecx

; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00032	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$3[ebp]
  00035	83 e2 1f	 and	 edx, 31			; 0000001fH
  00038	74 06		 je	 SHORT $LN4@Deallocate
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);

  00040	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_user$3[ebp]
  00043	83 e8 04	 sub	 eax, 4
  00046	89 45 f0	 mov	 DWORD PTR __Ptr_ptr$1[ebp], eax

; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00049	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr_ptr$1[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	89 55 f8	 mov	 DWORD PTR __Ptr_container$2[ebp], edx

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00051	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$2[ebp]
  00054	3b 45 fc	 cmp	 eax, DWORD PTR __Ptr_user$3[ebp]
  00057	72 06		 jb	 SHORT $LN5@Deallocate
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr_user$3[ebp]
  00062	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$2[ebp]
  00065	83 f9 04	 cmp	 ecx, 4
  00068	73 06		 jae	 SHORT $LN6@Deallocate
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00070	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$3[ebp]
  00073	2b 55 f8	 sub	 edx, DWORD PTR __Ptr_container$2[ebp]
  00076	83 fa 23	 cmp	 edx, 35			; 00000023H
  00079	76 06		 jbe	 SHORT $LN7@Deallocate
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00081	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$2[ebp]
  00084	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00087	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00090	83 c4 04	 add	 esp, 4
$LN8@Deallocate:

; 133  : 	}

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Block_size$1 = -16					; size = 4
__Ptr_container$2 = -12					; size = 4
__User_size$ = -8					; size = 4
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 49   : 	void *_Ptr = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 50   : 
; 51   : 	if (_Count == 0)

  0000d	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00011	75 08		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  00013	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	e9 9d 00 00 00	 jmp	 $LN9@Allocate
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0001b	83 c8 ff	 or	 eax, -1
  0001e	33 d2		 xor	 edx, edx
  00020	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00026	73 06		 jae	 SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00031	0f af 45 0c	 imul	 eax, DWORD PTR __Sz$[ebp]
  00035	89 45 f8	 mov	 DWORD PTR __User_size$[ebp], eax

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00038	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Try_aligned_allocation$[ebp]
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 5a		 je	 SHORT $LN4@Allocate
  00040	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR __User_size$[ebp], 4096 ; 00001000H
  00047	72 51		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00049	8b 55 f8	 mov	 edx, DWORD PTR __User_size$[ebp]
  0004c	83 c2 23	 add	 edx, 35			; 00000023H
  0004f	89 55 f0	 mov	 DWORD PTR __Block_size$1[ebp], edx

; 66   : 		if (_Block_size <= _User_size)

  00052	8b 45 f0	 mov	 eax, DWORD PTR __Block_size$1[ebp]
  00055	3b 45 f8	 cmp	 eax, DWORD PTR __User_size$[ebp]
  00058	77 06		 ja	 SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00060	8b 4d f0	 mov	 ecx, DWORD PTR __Block_size$1[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00069	83 c4 04	 add	 esp, 4
  0006c	89 45 f4	 mov	 DWORD PTR __Ptr_container$2[ebp], eax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0006f	83 7d f4 00	 cmp	 DWORD PTR __Ptr_container$2[ebp], 0
  00073	75 06		 jne	 SHORT $LN7@Allocate
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0007b	8b 55 f4	 mov	 edx, DWORD PTR __Ptr_container$2[ebp]
  0007e	83 c2 23	 add	 edx, 35			; 00000023H
  00081	83 e2 e0	 and	 edx, -32		; ffffffe0H
  00084	89 55 fc	 mov	 DWORD PTR __Ptr$[ebp], edx

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00087	b8 04 00 00 00	 mov	 eax, 4
  0008c	6b c8 ff	 imul	 ecx, eax, -1
  0008f	8b 55 fc	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00092	8b 45 f4	 mov	 eax, DWORD PTR __Ptr_container$2[ebp]
  00095	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

  00098	eb 1b		 jmp	 SHORT $LN5@Allocate
$LN4@Allocate:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  0009a	8b 4d f8	 mov	 ecx, DWORD PTR __User_size$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  000a9	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  000ad	75 06		 jne	 SHORT $LN5@Allocate
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);

  000b5	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN9@Allocate:

; 87   : 	}

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 54   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 43   : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\module.h
;	COMDAT ?InterfaceVersionCompare@@YA_NKK@Z
_TEXT	SEGMENT
_dwQueryVer$ = 8					; size = 4
_dwInterfaceVer$ = 12					; size = 4
?InterfaceVersionCompare@@YA_NKK@Z PROC			; InterfaceVersionCompare, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 69   : 	if (GetSubVer(dwQueryVer)>GetSubVer(dwInterfaceVer)) return false;

  00004	8b 45 08	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?GetSubVer@@YAEK@Z	; GetSubVer
  0000d	83 c4 04	 add	 esp, 4
  00010	0f b6 f0	 movzx	 esi, al
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInterfaceVer$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?GetSubVer@@YAEK@Z	; GetSubVer
  0001c	83 c4 04	 add	 esp, 4
  0001f	0f b6 d0	 movzx	 edx, al
  00022	3b f2		 cmp	 esi, edx
  00024	7e 04		 jle	 SHORT $LN2@InterfaceV
  00026	32 c0		 xor	 al, al
  00028	eb 74		 jmp	 SHORT $LN1@InterfaceV
$LN2@InterfaceV:

; 70   : 	if (GetMainVer(dwQueryVer)!=GetMainVer(dwInterfaceVer)) return false;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?GetMainVer@@YAEK@Z	; GetMainVer
  00033	83 c4 04	 add	 esp, 4
  00036	0f b6 f0	 movzx	 esi, al
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInterfaceVer$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ?GetMainVer@@YAEK@Z	; GetMainVer
  00042	83 c4 04	 add	 esp, 4
  00045	0f b6 d0	 movzx	 edx, al
  00048	3b f2		 cmp	 esi, edx
  0004a	74 04		 je	 SHORT $LN3@InterfaceV
  0004c	32 c0		 xor	 al, al
  0004e	eb 4e		 jmp	 SHORT $LN1@InterfaceV
$LN3@InterfaceV:

; 71   : 	if (GetBuildVer(dwQueryVer)!=GetBuildVer(dwInterfaceVer)) return false;

  00050	8b 45 08	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?GetBuildVer@@YAEK@Z	; GetBuildVer
  00059	83 c4 04	 add	 esp, 4
  0005c	0f b6 f0	 movzx	 esi, al
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInterfaceVer$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ?GetBuildVer@@YAEK@Z	; GetBuildVer
  00068	83 c4 04	 add	 esp, 4
  0006b	0f b6 d0	 movzx	 edx, al
  0006e	3b f2		 cmp	 esi, edx
  00070	74 04		 je	 SHORT $LN4@InterfaceV
  00072	32 c0		 xor	 al, al
  00074	eb 28		 jmp	 SHORT $LN1@InterfaceV
$LN4@InterfaceV:

; 72   : 	if (GetProductVer(dwQueryVer)!=GetProductVer(dwInterfaceVer)) return false;

  00076	8b 45 08	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?GetProductVer@@YAEK@Z	; GetProductVer
  0007f	83 c4 04	 add	 esp, 4
  00082	0f b6 f0	 movzx	 esi, al
  00085	8b 4d 0c	 mov	 ecx, DWORD PTR _dwInterfaceVer$[ebp]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 ?GetProductVer@@YAEK@Z	; GetProductVer
  0008e	83 c4 04	 add	 esp, 4
  00091	0f b6 d0	 movzx	 edx, al
  00094	3b f2		 cmp	 esi, edx
  00096	74 04		 je	 SHORT $LN5@InterfaceV
  00098	32 c0		 xor	 al, al
  0009a	eb 02		 jmp	 SHORT $LN1@InterfaceV
$LN5@InterfaceV:

; 73   : 	return true;

  0009c	b0 01		 mov	 al, 1
$LN1@InterfaceV:

; 74   : };

  0009e	5e		 pop	 esi
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?InterfaceVersionCompare@@YA_NKK@Z ENDP			; InterfaceVersionCompare
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\module.h
;	COMDAT ?GetBuildVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetBuildVer@@YAEK@Z PROC				; GetBuildVer, COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	return ((BYTE *)&dwVersion)[0];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	6b c8 00	 imul	 ecx, eax, 0
  0000b	8a 44 0d 08	 mov	 al, BYTE PTR _dwVersion$[ebp+ecx]

; 64   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetBuildVer@@YAEK@Z ENDP				; GetBuildVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\module.h
;	COMDAT ?GetSubVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetSubVer@@YAEK@Z PROC					; GetSubVer, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return ((BYTE *)&dwVersion)[1];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	c1 e0 00	 shl	 eax, 0
  0000b	8a 44 05 08	 mov	 al, BYTE PTR _dwVersion$[ebp+eax]

; 58   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSubVer@@YAEK@Z ENDP					; GetSubVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\module.h
;	COMDAT ?GetMainVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetMainVer@@YAEK@Z PROC				; GetMainVer, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : 	return ((BYTE *)&dwVersion)[2];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	d1 e0		 shl	 eax, 1
  0000a	8a 44 05 08	 mov	 al, BYTE PTR _dwVersion$[ebp+eax]

; 52   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetMainVer@@YAEK@Z ENDP				; GetMainVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\开发库\include\module.h
;	COMDAT ?GetProductVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetProductVer@@YAEK@Z PROC				; GetProductVer, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 	return ((BYTE *)&dwVersion)[3];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	6b c8 03	 imul	 ecx, eax, 3
  0000b	8a 44 0d 08	 mov	 al, BYTE PTR _dwVersion$[ebp+ecx]

; 46   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetProductVer@@YAEK@Z ENDP				; GetProductVer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IUnknownEx@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IUnknownEx@@QAE@XZ PROC				; IUnknownEx::IUnknownEx, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IUnknownEx@@QAE@XZ ENDP				; IUnknownEx::IUnknownEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ
text$di	SEGMENT
??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ PROC	; `dynamic initializer for 'ATL::CAtlStringMgr::isInitialized'', COMDAT

; 165  : __declspec(selectany) bool CAtlStringMgr::isInitialized = CAtlStringMgr::StaticInitialize();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	e8 00 00 00 00	 call	 ?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ ; ATL::CAtlStringMgr::StaticInitialize
  00008	a2 00 00 00 00	 mov	 BYTE PTR ?isInitialized@CAtlStringMgr@ATL@@0_NA, al ; ATL::CAtlStringMgr::isInitialized
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__E?isInitialized@CAtlStringMgr@ATL@@0_NA@@YAXXZ ENDP	; `dynamic initializer for 'ATL::CAtlStringMgr::isInitialized''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_nAlign$ = 12						; size = 4
??$AtlAlignUp@H@ATL@@YGHHK@Z PROC			; ATL::AtlAlignUp<int>, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   : 	return( N( (n+(nAlign-1))&~(N( nAlign )-1) ) );

  00003	8b 45 0c	 mov	 eax, DWORD PTR _nAlign$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00009	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _nAlign$[ebp]
  00010	83 ea 01	 sub	 edx, 1
  00013	f7 d2		 not	 edx
  00015	23 c2		 and	 eax, edx

; 30   : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$AtlAlignUp@H@ATL@@YGHHK@Z ENDP			; ATL::AtlAlignUp<int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ
text$yd	SEGMENT
??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ PROC ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
  00008	e8 00 00 00 00	 call	 ??1CAtlStringMgr@ATL@@UAE@XZ ; ATL::CAtlStringMgr::~CAtlStringMgr
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ENDP ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ
text$yd	SEGMENT
??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ PROC ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
  00008	e8 00 00 00 00	 call	 ??1CWin32Heap@ATL@@UAE@XZ ; ATL::CWin32Heap::~CWin32Heap
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ENDP ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCAtlStringMgr@ATL@@UAEPAXI@Z PROC			; ATL::CAtlStringMgr::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAtlStringMgr@ATL@@UAE@XZ ; ATL::CAtlStringMgr::~CAtlStringMgr
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 1c		 push	 28			; 0000001cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCAtlStringMgr@ATL@@UAEPAXI@Z ENDP			; ATL::CAtlStringMgr::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ
_TEXT	SEGMENT
?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ PROC	; ATL::CAtlStringMgr::StaticInitialize, COMDAT

; 157  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 158  : 		GetInstance();

  00003	e8 00 00 00 00	 call	 ?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::CAtlStringMgr::GetInstance

; 159  : 		return true;

  00008	b0 01		 mov	 al, 1

; 160  : 	}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
?StaticInitialize@CAtlStringMgr@ATL@@CA_NXZ ENDP	; ATL::CAtlStringMgr::StaticInitialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ PROC	; ATL::CAtlStringMgr::Clone, COMDAT
; _this$ = ecx

; 148  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 		return this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 150  : 	}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ ENDP	; ATL::CAtlStringMgr::Clone
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ PROC ; ATL::CAtlStringMgr::GetNilString, COMDAT
; _this$ = ecx

; 143  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 144  : 		m_nil.AddRef();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ?AddRef@CStringData@ATL@@QAEXXZ ; ATL::CStringData::AddRef

; 145  : 		return &m_nil;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 08	 add	 eax, 8

; 146  : 	}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ ENDP ; ATL::CAtlStringMgr::GetNilString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT
_nTotalSize$ = -36					; size = 4
_nDataBytes$ = -32					; size = 4
___atl_condVal$1 = -28					; size = 4
___atl_condVal$2 = -24					; size = 4
_this$ = -20						; size = 4
tv77 = -16						; size = 4
tv65 = -12						; size = 4
_pNewData$ = -8						; size = 4
_nAlignedChars$ = -4					; size = 4
_pData$ = 8						; size = 4
_nChars$ = 12						; size = 4
_nCharSize$ = 16					; size = 4
?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z PROC ; ATL::CAtlStringMgr::Reallocate, COMDAT
; _this$ = ecx

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@Reallocate:

; 113  : 		ATLENSURE_RETURN_VAL( nChars>=0, NULL );

  00009	83 7d 0c 00	 cmp	 DWORD PTR _nChars$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN15@Reallocate
  0000f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00016	eb 07		 jmp	 SHORT $LN16@Reallocate
$LN15@Reallocate:
  00018	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN16@Reallocate:
  0001f	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]
  00022	89 45 e8	 mov	 DWORD PTR ___atl_condVal$2[ebp], eax
  00025	83 7d e8 00	 cmp	 DWORD PTR ___atl_condVal$2[ebp], 0
  00029	75 07		 jne	 SHORT $LN2@Reallocate
  0002b	33 c0		 xor	 eax, eax
  0002d	e9 c4 00 00 00	 jmp	 $LN1@Reallocate
$LN2@Reallocate:
  00032	33 c9		 xor	 ecx, ecx
  00034	75 d3		 jne	 SHORT $LN4@Reallocate

; 114  : 		ATLASSERT( pData->pStringMgr == this );
; 115  : 
; 116  : 		CStringData* pNewData;
; 117  : 		ULONG nTotalSize;
; 118  : 		ULONG nDataBytes;
; 119  : 
; 120  : 		if( FAILED(::ATL::AtlAdd(&nChars, nChars, 1)) )

  00036	6a 01		 push	 1
  00038	8b 55 0c	 mov	 edx, DWORD PTR _nChars$[ebp]
  0003b	52		 push	 edx
  0003c	8d 45 0c	 lea	 eax, DWORD PTR _nChars$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$AtlAdd@H@ATL@@YAJPAHHH@Z ; ATL::AtlAdd<int>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	85 c0		 test	 eax, eax
  0004a	7d 07		 jge	 SHORT $LN9@Reallocate

; 121  : 		{
; 122  : 			return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 a3 00 00 00	 jmp	 $LN1@Reallocate
$LN9@Reallocate:

; 123  : 		}
; 124  : 
; 125  : 		int nAlignedChars = ::ATL::AtlAlignUp( nChars, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

  00053	6a 08		 push	 8
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$AtlAlignUp@H@ATL@@YGHHK@Z ; ATL::AtlAlignUp<int>
  0005e	89 45 fc	 mov	 DWORD PTR _nAlignedChars$[ebp], eax
$LN7@Reallocate:

; 126  : 		ATLENSURE_RETURN_VAL( nChars<=nAlignedChars, NULL );

  00061	8b 55 0c	 mov	 edx, DWORD PTR _nChars$[ebp]
  00064	3b 55 fc	 cmp	 edx, DWORD PTR _nAlignedChars$[ebp]
  00067	7f 09		 jg	 SHORT $LN17@Reallocate
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN18@Reallocate
$LN17@Reallocate:
  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN18@Reallocate:
  00079	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0007c	89 45 e4	 mov	 DWORD PTR ___atl_condVal$1[ebp], eax
  0007f	83 7d e4 00	 cmp	 DWORD PTR ___atl_condVal$1[ebp], 0
  00083	75 04		 jne	 SHORT $LN5@Reallocate
  00085	33 c0		 xor	 eax, eax
  00087	eb 6d		 jmp	 SHORT $LN1@Reallocate
$LN5@Reallocate:
  00089	33 c9		 xor	 ecx, ecx
  0008b	75 d4		 jne	 SHORT $LN7@Reallocate

; 127  : 
; 128  : 		if(	FAILED(::ATL::AtlMultiply(&nDataBytes, static_cast<ULONG>(nAlignedChars), static_cast<ULONG>(nCharSize))) ||

  0008d	8b 55 10	 mov	 edx, DWORD PTR _nCharSize$[ebp]
  00090	52		 push	 edx
  00091	8b 45 fc	 mov	 eax, DWORD PTR _nAlignedChars$[ebp]
  00094	50		 push	 eax
  00095	8d 4d e0	 lea	 ecx, DWORD PTR _nDataBytes$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ??$AtlMultiply@K@ATL@@YAJPAKKK@Z ; ATL::AtlMultiply<unsigned long>
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	85 c0		 test	 eax, eax
  000a3	7c 16		 jl	 SHORT $LN12@Reallocate
  000a5	8b 55 e0	 mov	 edx, DWORD PTR _nDataBytes$[ebp]
  000a8	52		 push	 edx
  000a9	6a 10		 push	 16			; 00000010H
  000ab	8d 45 dc	 lea	 eax, DWORD PTR _nTotalSize$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??$AtlAdd@K@ATL@@YAJPAKKK@Z ; ATL::AtlAdd<unsigned long>
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	85 c0		 test	 eax, eax
  000b9	7d 04		 jge	 SHORT $LN11@Reallocate
$LN12@Reallocate:

; 129  : 			FAILED(::ATL::AtlAdd(&nTotalSize, static_cast<ULONG>(sizeof( CStringData )), nDataBytes)))
; 130  : 		{
; 131  : 			return NULL;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 37		 jmp	 SHORT $LN1@Reallocate
$LN11@Reallocate:

; 132  : 		}
; 133  : 		pNewData = static_cast< CStringData* >( m_pMemMgr->Reallocate( pData, nTotalSize ) );

  000bf	8b 4d dc	 mov	 ecx, DWORD PTR _nTotalSize$[ebp]
  000c2	51		 push	 ecx
  000c3	8b 55 08	 mov	 edx, DWORD PTR _pData$[ebp]
  000c6	52		 push	 edx
  000c7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000d0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d2	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000d5	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000d8	ff d2		 call	 edx
  000da	89 45 f8	 mov	 DWORD PTR _pNewData$[ebp], eax

; 134  : 		if( pNewData == NULL )

  000dd	83 7d f8 00	 cmp	 DWORD PTR _pNewData$[ebp], 0
  000e1	75 04		 jne	 SHORT $LN13@Reallocate

; 135  : 		{
; 136  : 			return NULL;

  000e3	33 c0		 xor	 eax, eax
  000e5	eb 0f		 jmp	 SHORT $LN1@Reallocate
$LN13@Reallocate:

; 137  : 		}
; 138  : 		pNewData->nAllocLength = nAlignedChars - 1;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _nAlignedChars$[ebp]
  000ea	83 e8 01	 sub	 eax, 1
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  000f0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 139  : 
; 140  : 		return pNewData;

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _pNewData$[ebp]
$LN1@Reallocate:

; 141  : 	}

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z ENDP ; ATL::CAtlStringMgr::Reallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pData$ = 8						; size = 4
?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z PROC	; ATL::CAtlStringMgr::Free, COMDAT
; _this$ = ecx

; 102  : 	{		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Free:

; 103  : 		ATLASSUME(pData != NULL);

  00007	33 c0		 xor	 eax, eax
  00009	75 fc		 jne	 SHORT $LN2@Free

; 104  : 		ATLASSERT(pData->pStringMgr == this);
; 105  : 			
; 106  : 		m_pMemMgr->Free( pData );

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00020	ff d0		 call	 eax

; 107  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z ENDP	; ATL::CAtlStringMgr::Free
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT
_nTotalSize$ = -36					; size = 4
_nDataBytes$ = -32					; size = 4
___atl_condVal$1 = -28					; size = 4
___atl_condVal$2 = -24					; size = 4
tv77 = -20						; size = 4
tv65 = -16						; size = 4
_nAlignedChars$ = -12					; size = 4
_this$ = -8						; size = 4
_pData$ = -4						; size = 4
_nChars$ = 8						; size = 4
_nCharSize$ = 12					; size = 4
?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z PROC ; ATL::CAtlStringMgr::Allocate, COMDAT
; _this$ = ecx

; 69   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@Allocate:

; 70   : 		ATLENSURE_RETURN_VAL( nChars>=0, NULL );

  00009	83 7d 08 00	 cmp	 DWORD PTR _nChars$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN15@Allocate
  0000f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00016	eb 07		 jmp	 SHORT $LN16@Allocate
$LN15@Allocate:
  00018	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN16@Allocate:
  0001f	8b 45 f0	 mov	 eax, DWORD PTR tv65[ebp]
  00022	89 45 e8	 mov	 DWORD PTR ___atl_condVal$2[ebp], eax
  00025	83 7d e8 00	 cmp	 DWORD PTR ___atl_condVal$2[ebp], 0
  00029	75 07		 jne	 SHORT $LN2@Allocate
  0002b	33 c0		 xor	 eax, eax
  0002d	e9 de 00 00 00	 jmp	 $LN1@Allocate
$LN2@Allocate:
  00032	33 c9		 xor	 ecx, ecx
  00034	75 d3		 jne	 SHORT $LN4@Allocate

; 71   : 
; 72   : 		size_t nTotalSize;
; 73   : 		CStringData* pData;
; 74   : 		size_t nDataBytes;
; 75   : 
; 76   : 		if( FAILED(::ATL::AtlAdd(&nChars, nChars, 1)) )

  00036	6a 01		 push	 1
  00038	8b 55 08	 mov	 edx, DWORD PTR _nChars$[ebp]
  0003b	52		 push	 edx
  0003c	8d 45 08	 lea	 eax, DWORD PTR _nChars$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$AtlAdd@H@ATL@@YAJPAHHH@Z ; ATL::AtlAdd<int>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	85 c0		 test	 eax, eax
  0004a	7d 07		 jge	 SHORT $LN9@Allocate

; 77   : 		{
; 78   : 			return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 bd 00 00 00	 jmp	 $LN1@Allocate
$LN9@Allocate:

; 79   : 		}
; 80   : 
; 81   : 		int nAlignedChars = ::ATL::AtlAlignUp( nChars, 8 );  // Prevent excessive reallocation.  The heap will usually round up anyway.

  00053	6a 08		 push	 8
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _nChars$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$AtlAlignUp@H@ATL@@YGHHK@Z ; ATL::AtlAlignUp<int>
  0005e	89 45 f4	 mov	 DWORD PTR _nAlignedChars$[ebp], eax
$LN7@Allocate:

; 82   : 		ATLENSURE_RETURN_VAL( nChars<=nAlignedChars, NULL );

  00061	8b 55 08	 mov	 edx, DWORD PTR _nChars$[ebp]
  00064	3b 55 f4	 cmp	 edx, DWORD PTR _nAlignedChars$[ebp]
  00067	7f 09		 jg	 SHORT $LN17@Allocate
  00069	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN18@Allocate
$LN17@Allocate:
  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN18@Allocate:
  00079	8b 45 ec	 mov	 eax, DWORD PTR tv77[ebp]
  0007c	89 45 e4	 mov	 DWORD PTR ___atl_condVal$1[ebp], eax
  0007f	83 7d e4 00	 cmp	 DWORD PTR ___atl_condVal$1[ebp], 0
  00083	75 07		 jne	 SHORT $LN5@Allocate
  00085	33 c0		 xor	 eax, eax
  00087	e9 84 00 00 00	 jmp	 $LN1@Allocate
$LN5@Allocate:
  0008c	33 c9		 xor	 ecx, ecx
  0008e	75 d1		 jne	 SHORT $LN7@Allocate

; 83   : 
; 84   : 		if(	FAILED(::ATL::AtlMultiply(&nDataBytes, static_cast<size_t>(nAlignedChars), static_cast<size_t>(nCharSize))) ||

  00090	8b 55 0c	 mov	 edx, DWORD PTR _nCharSize$[ebp]
  00093	52		 push	 edx
  00094	8b 45 f4	 mov	 eax, DWORD PTR _nAlignedChars$[ebp]
  00097	50		 push	 eax
  00098	8d 4d e0	 lea	 ecx, DWORD PTR _nDataBytes$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	85 c0		 test	 eax, eax
  000a6	7c 16		 jl	 SHORT $LN12@Allocate
  000a8	8b 55 e0	 mov	 edx, DWORD PTR _nDataBytes$[ebp]
  000ab	52		 push	 edx
  000ac	6a 10		 push	 16			; 00000010H
  000ae	8d 45 dc	 lea	 eax, DWORD PTR _nTotalSize$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??$AtlAdd@I@ATL@@YAJPAIII@Z ; ATL::AtlAdd<unsigned int>
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	85 c0		 test	 eax, eax
  000bc	7d 04		 jge	 SHORT $LN11@Allocate
$LN12@Allocate:

; 85   : 			FAILED(::ATL::AtlAdd(&nTotalSize, static_cast<size_t>(sizeof( CStringData )), nDataBytes)))
; 86   : 		{
; 87   : 			return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	eb 4e		 jmp	 SHORT $LN1@Allocate
$LN11@Allocate:

; 88   : 		}
; 89   : 		pData = static_cast< CStringData* >( m_pMemMgr->Allocate( nTotalSize ) );

  000c2	8b 4d dc	 mov	 ecx, DWORD PTR _nTotalSize$[ebp]
  000c5	51		 push	 ecx
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	8b 10		 mov	 edx, DWORD PTR [eax]
  000d1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000d4	8b 02		 mov	 eax, DWORD PTR [edx]
  000d6	ff d0		 call	 eax
  000d8	89 45 fc	 mov	 DWORD PTR _pData$[ebp], eax

; 90   : 		if( pData == NULL )

  000db	83 7d fc 00	 cmp	 DWORD PTR _pData$[ebp], 0
  000df	75 04		 jne	 SHORT $LN13@Allocate

; 91   : 		{
; 92   : 			return( NULL );

  000e1	33 c0		 xor	 eax, eax
  000e3	eb 2b		 jmp	 SHORT $LN1@Allocate
$LN13@Allocate:

; 93   : 		}
; 94   : 		pData->pStringMgr = this;

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _pData$[ebp]
  000e8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	89 11		 mov	 DWORD PTR [ecx], edx

; 95   : 		pData->nRefs = 1;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  000f0	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 96   : 		pData->nAllocLength = nAlignedChars - 1;

  000f7	8b 4d f4	 mov	 ecx, DWORD PTR _nAlignedChars$[ebp]
  000fa	83 e9 01	 sub	 ecx, 1
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _pData$[ebp]
  00100	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 97   : 		pData->nDataLength = 0;

  00103	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
  00106	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 98   : 
; 99   : 		return( pData );

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _pData$[ebp]
$LN1@Allocate:

; 100  : 	}

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 08 00	 ret	 8
?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z ENDP ; ATL::CAtlStringMgr::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ PROC ; ATL::CAtlStringMgr::GetInstance, COMDAT

; 55   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : #pragma warning(push)
; 57   : #pragma warning(disable: 4640)
; 58   : 		static CWin32Heap strHeap( ::GetProcessHeap() );

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00008	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0000f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00017	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0001d	7e 41		 jle	 SHORT $LN2@GetInstanc
  0001f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00024	e8 00 00 00 00	 call	 __Init_thread_header
  00029	83 c4 04	 add	 esp, 4
  0002c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA, -1 ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00033	75 2b		 jne	 SHORT $LN2@GetInstanc
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0003b	50		 push	 eax
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
  00041	e8 00 00 00 00	 call	 ??0CWin32Heap@ATL@@QAE@PAX@Z ; ATL::CWin32Heap::CWin32Heap
  00046	68 00 00 00 00	 push	 OFFSET ??__FstrHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strHeap''
  0004b	e8 00 00 00 00	 call	 _atexit
  00050	83 c4 04	 add	 esp, 4
  00053	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS0<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00058	e8 00 00 00 00	 call	 __Init_thread_footer
  0005d	83 c4 04	 add	 esp, 4
$LN2@GetInstanc:

; 59   : 		static CAtlStringMgr strMgr(&strHeap);

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  00066	64 8b 15 00 00
	00 00		 mov	 edx, DWORD PTR fs:__tls_array
  0006d	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00076	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  0007c	7e 3f		 jle	 SHORT $LN3@GetInstanc
  0007e	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00083	e8 00 00 00 00	 call	 __Init_thread_header
  00088	83 c4 04	 add	 esp, 4
  0008b	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA, -1 ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  00092	75 29		 jne	 SHORT $LN3@GetInstanc
  00094	68 00 00 00 00	 push	 OFFSET ?strHeap@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4VCWin32Heap@3@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strHeap
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr
  0009e	e8 00 00 00 00	 call	 ??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z ; ATL::CAtlStringMgr::CAtlStringMgr
  000a3	68 00 00 00 00	 push	 OFFSET ??__FstrMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ@YAXXZ ; `ATL::CAtlStringMgr::GetInstance'::`2'::`dynamic atexit destructor for 'strMgr''
  000a8	e8 00 00 00 00	 call	 _atexit
  000ad	83 c4 04	 add	 esp, 4
  000b0	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4HA ; TSS1<`template-parameter-2',ATL::CAtlStringMgr::tInstance,ATL::IAtlStringMgr * * const volatile,void,int, ?? &>
  000b5	e8 00 00 00 00	 call	 __Init_thread_footer
  000ba	83 c4 04	 add	 esp, 4
$LN3@GetInstanc:

; 60   : #pragma warning(pop)
; 61   : 
; 62   : 		return &strMgr;

  000bd	b8 00 00 00 00	 mov	 eax, OFFSET ?strMgr@?1??GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@3@XZ@4V23@A ; `ATL::CAtlStringMgr::GetInstance'::`2'::strMgr

; 63   : 	}

  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?GetInstance@CAtlStringMgr@ATL@@SAPAUIAtlStringMgr@2@XZ ENDP ; ATL::CAtlStringMgr::GetInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CAtlStringMgr@ATL@@UAE@XZ PROC			; ATL::CAtlStringMgr::~CAtlStringMgr, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAtlStringMgr@ATL@@6B@

; 45   : 		isInitialized = false;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?isInitialized@CAtlStringMgr@ATL@@0_NA, 0 ; ATL::CAtlStringMgr::isInitialized

; 46   : 	}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1CAtlStringMgr@ATL@@UAE@XZ ENDP			; ATL::CAtlStringMgr::~CAtlStringMgr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlstr.h
;	COMDAT ??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pMemMgr$ = 8						; size = 4
??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z PROC	; ATL::CAtlStringMgr::CAtlStringMgr, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAtlStringMgr@ATL@@6B@

; 39   : 		m_pMemMgr( pMemMgr )

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _pMemMgr$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 40   : 	{

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	e8 00 00 00 00	 call	 ??0CNilStringData@ATL@@QAE@XZ ; ATL::CNilStringData::CNilStringData

; 41   : 		m_nil.SetManager( this );

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	83 c1 08	 add	 ecx, 8
  0002e	e8 00 00 00 00	 call	 ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z ; ATL::CNilStringData::SetManager

; 42   : 	}

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??0CAtlStringMgr@ATL@@QAE@PAUIAtlMemMgr@1@@Z ENDP	; ATL::CAtlStringMgr::CAtlStringMgr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00008	e8 00 00 00 00	 call	 ??1CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::~CAtlWinModule
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2815 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00008	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  0000d	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2799 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2800 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A ; ATL::_AtlBaseModule
  0000c	e8 00 00 00 00	 call	 ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
  00011	50		 push	 eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2801 : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2794 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2795 : 		Term();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Term@CAtlWinModule@ATL@@QAEXXZ ; ATL::CAtlWinModule::Term

; 2796 : 	}

  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2780 : 	CAtlWinModule()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2781 : 	{

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2782 : 		cbSize = sizeof(_ATL_WIN_MODULE);

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 2c 00 00
	00		 mov	 DWORD PTR [eax], 44	; 0000002cH

; 2783 : 		HRESULT hr = AtlWinModuleInit(this);

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
  00023	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2784 : 		if (FAILED(hr))

  00026	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002a	7d 10		 jge	 SHORT $LN1@CAtlWinMod

; 2785 : 		{
; 2786 : 			ATLASSERT(0);
; 2787 : 			CAtlBaseModule::m_bInitFailed = true;

  0002c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2788 : 			cbSize = 0;

  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN1@CAtlWinMod:

; 2789 : 			return;
; 2790 : 		}
; 2791 : 	}

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00008	e8 00 00 00 00	 call	 ??1CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::~CAtlComModule
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2559 : __declspec(selectany) CAtlComModule _AtlComModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00008	e8 00 00 00 00	 call	 ??0CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::CAtlComModule
  0000d	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_factory$1 = -16					; size = 4
_pCache$2 = -12						; size = 4
_this$ = -8						; size = 4
_ppEntry$3 = -4						; size = 4
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2456 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2457 : 		if (cbSize == 0)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 02		 jne	 SHORT $LN5@Term

; 2458 : 			return;

  00011	eb 76		 jmp	 SHORT $LN1@Term
$LN5@Term:

; 2459 : 
; 2460 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	89 55 fc	 mov	 DWORD PTR _ppEntry$3[ebp], edx
  0001c	eb 09		 jmp	 SHORT $LN4@Term
$LN2@Term:
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _ppEntry$3[ebp]
  00021	83 c0 04	 add	 eax, 4
  00024	89 45 fc	 mov	 DWORD PTR _ppEntry$3[ebp], eax
$LN4@Term:
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _ppEntry$3[ebp]
  0002d	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00030	73 43		 jae	 SHORT $LN3@Term

; 2461 : 		{
; 2462 : 			if (*ppEntry != NULL)

  00032	8b 45 fc	 mov	 eax, DWORD PTR _ppEntry$3[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 39		 je	 SHORT $LN6@Term

; 2463 : 			{
; 2464 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _ppEntry$3[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00042	89 45 f4	 mov	 DWORD PTR _pCache$2[ebp], eax

; 2465 : 				
; 2466 : 				if (pCache->pCF != NULL)

  00045	8b 4d f4	 mov	 ecx, DWORD PTR _pCache$2[ebp]
  00048	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0004b	74 26		 je	 SHORT $LN6@Term

; 2467 : 				{
; 2468 : 					// Decode factory pointer if it's not null
; 2469 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  0004d	8b 55 f4	 mov	 edx, DWORD PTR _pCache$2[ebp]
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	50		 push	 eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4
  00059	89 45 f0	 mov	 DWORD PTR _factory$1[ebp], eax

; 2470 : 					_Analysis_assume_(factory != nullptr);
; 2471 : 					factory->Release();					

  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _factory$1[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	8b 45 f0	 mov	 eax, DWORD PTR _factory$1[ebp]
  00064	50		 push	 eax
  00065	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00068	ff d1		 call	 ecx

; 2472 : 					pCache->pCF = NULL;

  0006a	8b 55 f4	 mov	 edx, DWORD PTR _pCache$2[ebp]
  0006d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN6@Term:

; 2473 : 				}				
; 2474 : 			}
; 2475 : 		}

  00073	eb a9		 jmp	 SHORT $LN2@Term
$LN3@Term:

; 2476 : 		m_csObjMap.Term();

  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	83 c1 10	 add	 ecx, 16			; 00000010H
  0007b	e8 00 00 00 00	 call	 ?Term@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Term

; 2477 : 		// Set to 0 to indicate that this function has been called
; 2478 : 		// At this point no one should be concerned about cbsize
; 2479 : 		// having the correct value
; 2480 : 		cbSize = 0;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Term:

; 2481 : 	}

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2450 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlComModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2451 : 		Term();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term

; 2452 : 	}

  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2429 : 	CAtlComModule() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2430 : 	{

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_ATL_COM_MODULE70@ATL@@QAE@XZ

; 2431 : 		cbSize = 0;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2432 : 
; 2433 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ___ImageBase

; 2434 : 
; 2435 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 08 04 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET ___pobjMapEntryFirst+4

; 2436 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ___pobjMapEntryLast

; 2437 : 
; 2438 : 		if (FAILED(m_csObjMap.Init()))

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 10	 add	 ecx, 16			; 00000010H
  0003c	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  00041	85 c0		 test	 eax, eax
  00043	7d 09		 jge	 SHORT $LN2@CAtlComMod

; 2439 : 		{
; 2440 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2441 : 			ATLASSERT(0);
; 2442 : 			CAtlBaseModule::m_bInitFailed = true;

  00045	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2443 : 			return;

  0004c	eb 09		 jmp	 SHORT $LN1@CAtlComMod
$LN2@CAtlComMod:

; 2444 : 		}
; 2445 : 		// Set cbSize on success.
; 2446 : 		cbSize = sizeof(_ATL_COM_MODULE);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	c7 01 28 00 00
	00		 mov	 DWORD PTR [ecx], 40	; 00000028H
$LN1@CAtlComMod:

; 2447 : 	}

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7650 : 	if (pWinModule == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00008	75 07		 jne	 SHORT $LN5@AtlWinModu

; 7651 : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0000f	eb 7d		 jmp	 SHORT $LN1@AtlWinModu
$LN5@AtlWinModu:

; 7652 : 	if (pWinModule->cbSize == 0)

  00011	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	75 04		 jne	 SHORT $LN6@AtlWinModu

; 7653 : 		return S_OK;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 71		 jmp	 SHORT $LN1@AtlWinModu
$LN6@AtlWinModu:

; 7654 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00020	83 39 2c	 cmp	 DWORD PTR [ecx], 44	; 0000002cH
  00023	74 07		 je	 SHORT $LN7@AtlWinModu

; 7655 : 		return E_INVALIDARG;

  00025	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0002a	eb 62		 jmp	 SHORT $LN1@AtlWinModu
$LN7@AtlWinModu:

; 7656 : 
; 7657 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00033	eb 09		 jmp	 SHORT $LN4@AtlWinModu
$LN2@AtlWinModu:
  00035	8b 55 fc	 mov	 edx, DWORD PTR _i$1[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 fc	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@AtlWinModu:
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00041	83 c1 20	 add	 ecx, 32			; 00000020H
  00044	e8 00 00 00 00	 call	 ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
  00049	39 45 fc	 cmp	 DWORD PTR _i$1[ebp], eax
  0004c	7d 1f		 jge	 SHORT $LN3@AtlWinModu

; 7658 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _hInst$[ebp]
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00055	51		 push	 ecx
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00059	83 c1 20	 add	 ecx, 32			; 00000020H
  0005c	e8 00 00 00 00	 call	 ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
  00061	0f b7 10	 movzx	 edx, WORD PTR [eax]
  00064	52		 push	 edx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassW@8
  0006b	eb c8		 jmp	 SHORT $LN2@AtlWinModu
$LN3@AtlWinModu:

; 7659 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00070	83 c1 20	 add	 ecx, 32			; 00000020H
  00073	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 7660 : 	pWinModule->m_csWindowCreate.Term();

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0007b	83 c1 04	 add	 ecx, 4
  0007e	e8 00 00 00 00	 call	 ?Term@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Term

; 7661 : 	pWinModule->cbSize = 0;

  00083	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 7662 : 	return S_OK;

  0008c	33 c0		 xor	 eax, eax
$LN1@AtlWinModu:

; 7663 : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8394 : 	if (pWinModule == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _pWinModule$[ebp], 0
  00008	75 07		 jne	 SHORT $LN2@AtlWinModu

; 8395 : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0000f	eb 2a		 jmp	 SHORT $LN1@AtlWinModu
$LN2@AtlWinModu:

; 8396 : 
; 8397 : 	// check only in the DLL
; 8398 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00011	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00014	83 38 2c	 cmp	 DWORD PTR [eax], 44	; 0000002cH
  00017	74 07		 je	 SHORT $LN3@AtlWinModu

; 8399 : 		return E_INVALIDARG;

  00019	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001e	eb 1b		 jmp	 SHORT $LN1@AtlWinModu
$LN3@AtlWinModu:

; 8400 : 
; 8401 : 	pWinModule->m_pCreateWndList = NULL;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00023	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 8402 : 
; 8403 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  0002d	83 c1 04	 add	 ecx, 4
  00030	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  00035	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 8404 : 	if (FAILED(hr))
; 8405 : 	{
; 8406 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
; 8407 : 		ATLASSERT(0);
; 8408 : 	}
; 8409 : 	return hr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$LN1@AtlWinModu:

; 8410 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	e8 00 00 00 00	 call	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 04	 add	 ecx, 4
  0002c	e8 00 00 00 00	 call	 ??0CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::CComCriticalSection
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 20	 add	 ecx, 32			; 00000020H
  0003e	e8 00 00 00 00	 call	 ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
  00043	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 0b		 jl	 SHORT $LN3@operator
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00016	7c 0c		 jl	 SHORT $LN2@operator
$LN3@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 01		 push	 1
  0001a	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0001f	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN2@operator:

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0002c	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
$LN4@operator:

; 243  : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 216  : 		if(m_aT != NULL)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 37		 je	 SHORT $LN5@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)

  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00018	eb 09		 jmp	 SHORT $LN4@RemoveAll
$LN2@RemoveAll:
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0001d	83 c1 01	 add	 ecx, 1
  00020	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00029	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0002c	7d 02		 jge	 SHORT $LN3@RemoveAll

; 219  : 				m_aT[i].~T();

  0002e	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN3@RemoveAll:

; 220  : 			free(m_aT);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	52		 push	 edx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN5@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 224  : 		m_nAllocSize = 0;

  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 225  :     }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 160  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 		return m_nSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 162  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 311  : 	RemoveAll();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 312  : }

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 120  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 121  : 	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??1CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::~CComCriticalSection
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 10	 add	 ecx, 16			; 00000010H
  0000d	e8 00 00 00 00	 call	 ??0CComCriticalSection@ATL@@QAE@XZ ; ATL::CComCriticalSection::CComCriticalSection
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\afx.inl
;	COMDAT ?_AfxInitManaged@@YAHXZ
_TEXT	SEGMENT
?_AfxInitManaged@@YAHXZ PROC				; _AfxInitManaged, COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : 	return 0;

  00003	33 c0		 xor	 eax, eax

; 78   : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
?_AfxInitManaged@@YAHXZ ENDP				; _AfxInitManaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pMgr$ = 8						; size = 4
?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z PROC ; ATL::CNilStringData::SetManager, COMDAT
; _this$ = ecx

; 123  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 		ATLASSERT( pStringMgr == NULL );
; 125  : 		pStringMgr = pMgr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pMgr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 126  : 	}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z ENDP ; ATL::CNilStringData::SetManager
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpstr.h
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CNilStringData@ATL@@QAE@XZ PROC			; ATL::CNilStringData::CNilStringData, COMDAT
; _this$ = ecx

; 112  : 	CNilStringData() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	{
; 114  : 		pStringMgr = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 115  : 		nRefs = 2;  // Never gets freed by IAtlStringMgr

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 0c 02 00
	00 00		 mov	 DWORD PTR [ecx+12], 2

; 116  : 		nDataLength = 0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 117  : 		nAllocLength = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 118  : 		achNil[0] = 0;

  0002e	b9 02 00 00 00	 mov	 ecx, 2
  00033	6b d1 00	 imul	 edx, ecx, 0
  00036	33 c0		 xor	 eax, eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	66 89 44 11 10	 mov	 WORD PTR [ecx+edx+16], ax

; 119  : 		achNil[1] = 0;

  00040	ba 02 00 00 00	 mov	 edx, 2
  00045	c1 e2 00	 shl	 edx, 0
  00048	33 c0		 xor	 eax, eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	66 89 44 11 10	 mov	 WORD PTR [ecx+edx+16], ax

; 120  : 	}

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??0CNilStringData@ATL@@QAE@XZ ENDP			; ATL::CNilStringData::CNilStringData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpstr.h
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AddRef@CStringData@ATL@@QAEXXZ PROC			; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 63   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 		ATLASSERT(nRefs > 0);
; 65   : 		_InterlockedIncrement(&nRefs);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0000d	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 66   : 	}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@H@ATL@@YAJPAHHH@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@H@ATL@@YAJPAHHH@Z PROC			; ATL::AtlAdd<int>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00008	2b 45 0c	 sub	 eax, DWORD PTR _tLeft$[ebp]
  0000b	3b 45 10	 cmp	 eax, DWORD PTR _tRight$[ebp]
  0000e	7d 0f		 jge	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00010	68 16 02 00 00	 push	 534			; 00000216H
  00015	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  0001a	83 c4 04	 add	 esp, 4
  0001d	eb 0d		 jmp	 SHORT $LN1@AtlAdd
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00022	03 4d 10	 add	 ecx, DWORD PTR _tRight$[ebp]
  00025	8b 55 08	 mov	 edx, DWORD PTR _ptResult$[ebp]
  00028	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 	return S_OK;

  0002a	33 c0		 xor	 eax, eax
$LN1@AtlAdd:

; 106  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$AtlAdd@H@ATL@@YAJPAHHH@Z ENDP			; ATL::AtlAdd<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlAdd<unsigned int>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	83 c8 ff	 or	 eax, -1
  00006	2b 45 0c	 sub	 eax, DWORD PTR _tLeft$[ebp]
  00009	3b 45 10	 cmp	 eax, DWORD PTR _tRight$[ebp]
  0000c	73 0f		 jae	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0000e	68 16 02 00 00	 push	 534			; 00000216H
  00013	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00018	83 c4 04	 add	 esp, 4
  0001b	eb 0d		 jmp	 SHORT $LN1@AtlAdd
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00020	03 4d 10	 add	 ecx, DWORD PTR _tRight$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR _ptResult$[ebp]
  00026	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 	return S_OK;

  00028	33 c0		 xor	 eax, eax
$LN1@AtlAdd:

; 106  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$AtlAdd@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlAdd<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCWin32Heap@ATL@@UAEPAXI@Z PROC			; ATL::CWin32Heap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CWin32Heap@ATL@@UAE@XZ ; ATL::CWin32Heap::~CWin32Heap
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCWin32Heap@ATL@@UAEPAXI@Z ENDP			; ATL::CWin32Heap::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?GetSize@CWin32Heap@ATL@@UAEIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?GetSize@CWin32Heap@ATL@@UAEIPAX@Z PROC			; ATL::CWin32Heap::GetSize, COMDAT
; _this$ = ecx

; 175  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  : 		return( ::HeapSize( m_hHeap, 0, p ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapSize@12

; 177  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?GetSize@CWin32Heap@ATL@@UAEIPAX@Z ENDP			; ATL::CWin32Heap::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_nBytes$ = 12						; size = 4
?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z PROC		; ATL::CWin32Heap::Reallocate, COMDAT
; _this$ = ecx

; 160  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 		if( p == NULL )

  00007	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  0000b	75 12		 jne	 SHORT $LN2@Reallocate

; 162  : 		{
; 163  : 			return( Allocate( nBytes ) );

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 02		 mov	 eax, DWORD PTR [edx]
  0001b	ff d0		 call	 eax
  0001d	eb 32		 jmp	 SHORT $LN1@Reallocate
$LN2@Reallocate:

; 164  : 		}
; 165  : 
; 166  : 		if (nBytes==0)

  0001f	83 7d 0c 00	 cmp	 DWORD PTR _nBytes$[ebp], 0
  00023	75 15		 jne	 SHORT $LN3@Reallocate

; 167  : 		{
; 168  : 			  Free(p);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00034	ff d2		 call	 edx

; 169  : 			  return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 17		 jmp	 SHORT $LN1@Reallocate
$LN3@Reallocate:

; 170  : 		}
; 171  : 
; 172  : 		return( ::HeapReAlloc( m_hHeap, 0, p, nBytes ) );

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00041	51		 push	 ecx
  00042	6a 00		 push	 0
  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapReAlloc@16
$LN1@Reallocate:

; 173  : 	}

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z ENDP		; ATL::CWin32Heap::Reallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?Free@CWin32Heap@ATL@@UAEXPAX@Z
_TEXT	SEGMENT
_bSuccess$1 = -8					; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?Free@CWin32Heap@ATL@@UAEXPAX@Z PROC			; ATL::CWin32Heap::Free, COMDAT
; _this$ = ecx

; 148  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 		if( p != NULL )

  00009	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  0000d	74 16		 je	 SHORT $LN1@Free

; 150  : 		{
; 151  : 			BOOL bSuccess;
; 152  : 
; 153  : 			bSuccess = ::HeapFree( m_hHeap, 0, p );

  0000f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	52		 push	 edx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
  00022	89 45 f8	 mov	 DWORD PTR _bSuccess$1[ebp], eax
$LN1@Free:

; 154  : 			ATLASSERT( bSuccess );
; 155  : 		}
; 156  : 	}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Free@CWin32Heap@ATL@@UAEXPAX@Z ENDP			; ATL::CWin32Heap::Free
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ?Allocate@CWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?Allocate@CWin32Heap@ATL@@UAEPAXI@Z PROC		; ATL::CWin32Heap::Allocate, COMDAT
; _this$ = ecx

; 144  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  : 		return( ::HeapAlloc( m_hHeap, 0, nBytes ) );

  00007	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	52		 push	 edx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12

; 146  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?Allocate@CWin32Heap@ATL@@UAEPAXI@Z ENDP		; ATL::CWin32Heap::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ??1CWin32Heap@ATL@@UAE@XZ
_TEXT	SEGMENT
_bSuccess$1 = -8					; size = 4
_this$ = -4						; size = 4
??1CWin32Heap@ATL@@UAE@XZ PROC				; ATL::CWin32Heap::~CWin32Heap, COMDAT
; _this$ = ecx

; 109  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWin32Heap@ATL@@6B@

; 110  : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 111  : 		if( m_bOwnHeap && (m_hHeap != NULL) )

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00019	85 d2		 test	 edx, edx
  0001b	74 19		 je	 SHORT $LN1@CWin32Heap
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00024	74 10		 je	 SHORT $LN1@CWin32Heap

; 112  : 		{
; 113  : 			BOOL bSuccess;
; 114  : 
; 115  : 			bSuccess = ::HeapDestroy( m_hHeap );

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002c	52		 push	 edx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapDestroy@4
  00033	89 45 f8	 mov	 DWORD PTR _bSuccess$1[ebp], eax
$LN1@CWin32Heap:

; 116  : 			ATLASSERT( bSuccess );
; 117  : 		}
; 118  : #endif
; 119  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??1CWin32Heap@ATL@@UAE@XZ ENDP				; ATL::CWin32Heap::~CWin32Heap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlmem.h
;	COMDAT ??0CWin32Heap@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hHeap$ = 8						; size = 4
??0CWin32Heap@ATL@@QAE@PAX@Z PROC			; ATL::CWin32Heap::CWin32Heap, COMDAT
; _this$ = ecx

; 89   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWin32Heap@ATL@@6B@

; 87   : 		m_hHeap( hHeap ),

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _hHeap$[ebp]
  00016	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 88   : 		m_bOwnHeap( false )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 90   : 		ATLASSERT( hHeap != NULL );
; 91   : 	}

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0CWin32Heap@ATL@@QAE@PAX@Z ENDP			; ATL::CWin32Heap::CWin32Heap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 274  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 		return m_hInst;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 276  : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 		DeleteCriticalSection(&m_sec);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 141  : 		return S_OK;

  00011	33 c0		 xor	 eax, eax

; 142  : 	}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hRes$ = -4						; size = 4
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 128  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 129  : 		HRESULT hRes = S_OK;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hRes$[ebp], 0

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	85 c0		 test	 eax, eax
  00022	75 12		 jne	 SHORT $LN2@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00030	83 c4 04	 add	 esp, 4
  00033	89 45 fc	 mov	 DWORD PTR _hRes$[ebp], eax
$LN2@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _hRes$[ebp]

; 136  : 	}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00007	6a 18		 push	 24			; 00000018H
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 	}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);
; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwSpinCount$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _lpCriticalSection$[ebp]
  0000a	51		 push	 ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 736  : #endif
; 737  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	8b 45 0c	 mov	 eax, DWORD PTR _dwExceptionFlags$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwExceptionCode$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 32   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceISAPI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceISAPI@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceISAPI'', COMDAT

; 119  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceISAPI> atlTraceISAPI(_T("atlTraceISAPI"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60887
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceISAPI@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceISAPI''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSync@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSync@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSync'', COMDAT

; 118  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSync> atlTraceSync(_T("atlTraceSync"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60840
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceSync@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSync''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSecurity@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSecurity@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSecurity'', COMDAT

; 117  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSecurity> atlTraceSecurity(_T("atlTraceSecurity"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60793
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceSecurity@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSecurity''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceUtil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceUtil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceUtil'', COMDAT

; 116  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceUtil> atlTraceUtil(_T("atlTraceUtil"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60746
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceUtil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceUtil''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceMap@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceMap@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceMap'', COMDAT

; 115  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceMap> atlTraceMap(_T("atlTraceMap"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60741
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceMap@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceMap''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceString@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceString@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceString'', COMDAT

; 114  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceString> atlTraceString(_T("atlTraceString"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60694
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceString@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceString''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceStencil@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceStencil@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceStencil'', COMDAT

; 113  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceStencil> atlTraceStencil(_T("atlTraceStencil"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60647
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceStencil@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceStencil''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCache@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCache@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCache'', COMDAT

; 112  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCache> atlTraceCache(_T("atlTraceCache"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60600
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceCache@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCache''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceTime@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceTime@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceTime'', COMDAT

; 111  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceTime> atlTraceTime(_T("atlTraceTime"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60553
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceTime@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceTime''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60506
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceAllocation@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceAllocation@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceAllocation'', COMDAT

; 109  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceAllocation> atlTraceAllocation(_T("atlTraceAllocation"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60459
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceAllocation@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceAllocation''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceNotImpl@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceNotImpl@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceNotImpl'', COMDAT

; 108  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceNotImpl> atlTraceNotImpl(_T("atlTraceNotImpl"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60412
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceNotImpl@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceNotImpl''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceSnapin@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceSnapin@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceSnapin'', COMDAT

; 107  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceSnapin> atlTraceSnapin(_T("atlTraceSnapin"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60365
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceSnapin@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceSnapin''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBProvider@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBProvider@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBProvider'', COMDAT

; 106  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBProvider> atlTraceDBProvider(_T("atlTraceDBProvider"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60318
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceDBProvider@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBProvider''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceDBClient@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceDBClient@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceDBClient'', COMDAT

; 105  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceDBClient> atlTraceDBClient(_T("atlTraceDBClient"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60271
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceDBClient@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceDBClient''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceHosting@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceHosting@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceHosting'', COMDAT

; 104  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceHosting> atlTraceHosting(_T("atlTraceHosting"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60224
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceHosting@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceHosting''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceControls@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceControls@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceControls'', COMDAT

; 103  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceControls> atlTraceControls(_T("atlTraceControls"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60177
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceControls@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceControls''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceWindowing@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceWindowing@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceWindowing'', COMDAT

; 102  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceWindowing> atlTraceWindowing(_T("atlTraceWindowing"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60130
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceWindowing@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceWindowing''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRefcount@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRefcount@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRefcount'', COMDAT

; 101  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRefcount> atlTraceRefcount(_T("atlTraceRefcount"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60083
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceRefcount@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRefcount''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceRegistrar@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceRegistrar@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceRegistrar'', COMDAT

; 100  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceRegistrar> atlTraceRegistrar(_T("atlTraceRegistrar"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG60036
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceRegistrar@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceRegistrar''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceQI@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceQI@ATL@@YAXXZ PROC				; ATL::`dynamic initializer for 'atlTraceQI'', COMDAT

; 99   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceQI> atlTraceQI(_T("atlTraceQI"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG59989
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceQI@ATL@@YAXXZ ENDP				; ATL::`dynamic initializer for 'atlTraceQI''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceCOM@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceCOM@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceCOM'', COMDAT

; 98   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceCom> atlTraceCOM(_T("atlTraceCOM"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG59942
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceCOM@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceCOM''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceGeneral@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceGeneral@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceGeneral'', COMDAT

; 97   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceGeneral> atlTraceGeneral(_T("atlTraceGeneral"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG59871
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
  0000d	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??__EatlTraceGeneral@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceGeneral''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlAdd<unsigned long>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	83 c8 ff	 or	 eax, -1
  00006	2b 45 0c	 sub	 eax, DWORD PTR _tLeft$[ebp]
  00009	3b 45 10	 cmp	 eax, DWORD PTR _tRight$[ebp]
  0000c	73 0f		 jae	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0000e	68 16 02 00 00	 push	 534			; 00000216H
  00013	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00018	83 c4 04	 add	 esp, 4
  0001b	eb 0d		 jmp	 SHORT $LN1@AtlAdd
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00020	03 4d 10	 add	 ecx, DWORD PTR _tRight$[ebp]
  00023	8b 55 08	 mov	 edx, DWORD PTR _ptResult$[ebp]
  00026	89 0a		 mov	 DWORD PTR [edx], ecx

; 105  : 	return S_OK;

  00028	33 c0		 xor	 eax, eax
$LN1@AtlAdd:

; 106  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$AtlAdd@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlAdd<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_i64Result$ = -8					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlMultiply<unsigned long>, COMDAT

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 181  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00009	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _i64Result$[ebp], eax
  0000f	89 55 fc	 mov	 DWORD PTR _i64Result$[ebp+4], edx

; 182  : 	if(i64Result>ULONG_MAX)

  00012	83 7d fc 00	 cmp	 DWORD PTR _i64Result$[ebp+4], 0
  00016	77 06		 ja	 SHORT $LN4@AtlMultipl
  00018	83 7d f8 ff	 cmp	 DWORD PTR _i64Result$[ebp], -1
  0001c	76 0f		 jbe	 SHORT $LN2@AtlMultipl
$LN4@AtlMultipl:

; 183  : 	{
; 184  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001e	68 16 02 00 00	 push	 534			; 00000216H
  00023	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00028	83 c4 04	 add	 esp, 4
  0002b	eb 0a		 jmp	 SHORT $LN1@AtlMultipl
$LN2@AtlMultipl:

; 185  : 	}
; 186  : 	*piResult=static_cast<unsigned long _ATL_W64>(i64Result);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i64Result$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 187  : 	return S_OK;

  00035	33 c0		 xor	 eax, eax
$LN1@AtlMultipl:

; 188  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$AtlMultiply@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlMultiply<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_i64Result$ = -8					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00009	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _i64Result$[ebp], eax
  0000f	89 55 fc	 mov	 DWORD PTR _i64Result$[ebp+4], edx

; 152  : 	if(i64Result>UINT_MAX)

  00012	83 7d fc 00	 cmp	 DWORD PTR _i64Result$[ebp+4], 0
  00016	77 06		 ja	 SHORT $LN4@AtlMultipl
  00018	83 7d f8 ff	 cmp	 DWORD PTR _i64Result$[ebp], -1
  0001c	76 0f		 jbe	 SHORT $LN2@AtlMultipl
$LN4@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001e	68 16 02 00 00	 push	 534			; 00000216H
  00023	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00028	83 c4 04	 add	 esp, 4
  0002b	eb 0a		 jmp	 SHORT $LN1@AtlMultipl
$LN2@AtlMultipl:

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i64Result$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 157  : 	return S_OK;

  00035	33 c0		 xor	 eax, eax
$LN1@AtlMultipl:

; 158  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 535  :             return _time64(_Time);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  0000d	83 c4 04	 add	 esp, 4

; 536  :         }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -4						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00008	7f 08		 jg	 SHORT $LN3@HRESULT_FR
  0000a	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR tv68[ebp], eax
  00010	eb 18		 jmp	 SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00015	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001b	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  00021	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00027	89 4d fc	 mov	 DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
tv68 = -4						; size = 4
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _IsEqualGUID
  00011	83 c4 08	 add	 esp, 8
  00014	85 c0		 test	 eax, eax
  00016	74 09		 je	 SHORT $LN3@
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@
$LN3@:
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@:
  00028	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 195  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_==	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
tv69 = -4						; size = 4
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00004	6a 10		 push	 16			; 00000010H
  00006	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _memcmp
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN3@IsEqualGUI
  0001a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00021	eb 07		 jmp	 SHORT $LN4@IsEqualGUI
$LN3@IsEqualGUI:
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@IsEqualGUI:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]

; 162  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_IsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\qijianban\laok\服务端\游戏组件\老k子游戏\红中麻将\服务器组件\tableframesink.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00013	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00017	76 11		 jbe	 SHORT $LN1@vector
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001c	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001f	8b 55 08	 mov	 edx, DWORD PTR ___t$[ebp]
  00022	03 55 0c	 add	 edx, DWORD PTR ___s$[ebp]
  00025	89 55 08	 mov	 DWORD PTR ___t$[ebp], edx
  00028	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
